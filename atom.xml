<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Cothrax</title>
  <subtitle>I don&#39;t need a subtitle.</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="https://cothrax.github.io/"/>
  <updated>2016-12-04T02:06:13.165Z</updated>
  <id>https://cothrax.github.io/</id>
  
  <author>
    <name>Cothrax</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>bzoj-3653 谈笑风生</title>
    <link href="https://cothrax.github.io/2016/12/03/bzoj-3653/"/>
    <id>https://cothrax.github.io/2016/12/03/bzoj-3653/</id>
    <published>2016-12-03T15:56:19.000Z</published>
    <updated>2016-12-04T02:06:13.165Z</updated>
    
    <content type="html"><![CDATA[<h2 id="大意"><a href="#大意" class="headerlink" title="大意"></a>大意</h2><p>给定一个n个节点的树，有m次查询<br>查询(a,k)为：点b与点a距离不超过k，且a和b均为c的祖先的无序对(a,b,c)的个数<br>n,m&lt;=300000<br><a id="more"></a></p>
<h2 id="链接"><a href="#链接" class="headerlink" title="链接"></a>链接</h2><p><a href="http://hzwer.com/5444.html" target="_blank" rel="external">hzwer</a><br><a href="/2016/12/03/bzoj-3653/3653.cpp" title="3653.cpp">3653.cpp</a></p>
<h2 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h2><p>siz[u]为u的子树大小，dep[u]为u的深度（dep[1]=0)<br>对(a,b,c)分类讨论：</p>
<ol>
<li>若b在a的子树外，则c可以为a的子树内的任意点，答案为$(siz[a]-1)*min(dep[a],k)$</li>
<li>若b在a的子树中，则c必须在b的子树中，此时答案就是$\sum_{b\in a}{siz[b]-1}$，<br>求出dfs序，用主席树维护siz和即可</li>
</ol>
<h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><figure class="highlight c++"><figcaption><span>3653.cpp</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="comment">//#define DEBUG</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N=<span class="number">250010</span>,M=<span class="number">250010</span>;</span><br><span class="line"><span class="keyword">struct</span> edge&#123;<span class="keyword">int</span> v,nxt;&#125; g[N*<span class="number">2</span>];</span><br><span class="line"><span class="keyword">int</span> head[N],d[N]=&#123;<span class="number">-1</span>&#125;,siz[N],loc[N],bit[N],par[N];</span><br><span class="line"><span class="keyword">int</span> n,m,sz=<span class="number">0</span>,k=<span class="number">0</span>;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">add</span><span class="params">(<span class="keyword">int</span> u,<span class="keyword">int</span> v)</span></span><br><span class="line"></span>&#123;g[++sz]=&#123;v,head[u]&#125;;head[u]=sz;&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">upd</span><span class="params">(<span class="keyword">int</span> x,<span class="keyword">int</span> k)</span></span><br><span class="line"></span>&#123;<span class="keyword">while</span>(x&amp;&amp;x&lt;=n)bit[x]+=k,x+=x&amp;(-x);&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">sum</span><span class="params">(<span class="keyword">int</span> x)</span></span><br><span class="line"></span>&#123;<span class="keyword">int</span> ret=<span class="number">0</span>;<span class="keyword">while</span>(x)ret+=bit[x],x-=x&amp;(-x);<span class="keyword">return</span> ret;&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">dfs</span><span class="params">(<span class="keyword">int</span> u,<span class="keyword">int</span> p)</span></span>&#123;</span><br><span class="line">    loc[u]=++k;d[u]=d[p]+<span class="number">1</span>;siz[u]=<span class="number">1</span>;par[u]=p;<span class="keyword">int</span> v;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=head[u];i;i=g[i].nxt)</span><br><span class="line">        <span class="keyword">if</span>((v=g[i].v)!=p)dfs(v,u),siz[u]+=siz[v];</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="comment">/*freopen("in","r",stdin);</span><br><span class="line">    freopen("out","w",stdout);*/</span></span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">"%d\n"</span>,&amp;n);</span><br><span class="line">    <span class="keyword">int</span> u,v,cnt=<span class="number">0</span>;<span class="keyword">char</span> c;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;n<span class="number">-1</span>;i++)</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">"%d %d\n"</span>,&amp;u,&amp;v),add(u,v),add(v,u);</span><br><span class="line">    dfs(<span class="number">1</span>,<span class="number">0</span>);<span class="built_in">scanf</span>(<span class="string">"%d"</span>,&amp;m);</span><br><span class="line">    <span class="keyword">while</span>(cnt&lt;m)&#123;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">"%c "</span>,&amp;c);</span><br><span class="line">        <span class="keyword">switch</span>(c)&#123;</span><br><span class="line">            <span class="keyword">case</span> <span class="string">'W'</span>:&#123;</span><br><span class="line">                <span class="built_in">scanf</span>(<span class="string">"%d\n"</span>,&amp;u);cnt++;</span><br><span class="line">                <span class="built_in">printf</span>(<span class="string">"%d\n"</span>,d[u]-sum(loc[u]));</span><br><span class="line">            &#125;;<span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">case</span> <span class="string">'A'</span>:&#123;</span><br><span class="line">                <span class="built_in">scanf</span>(<span class="string">"%d %d\n"</span>,&amp;u,&amp;v);</span><br><span class="line">                <span class="keyword">if</span>(par[u]==v)swap(u,v);</span><br><span class="line">                upd(loc[v],<span class="number">1</span>);upd(loc[v]+siz[v],<span class="number">-1</span>);</span><br><span class="line">            &#125;;<span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;大意&quot;&gt;&lt;a href=&quot;#大意&quot; class=&quot;headerlink&quot; title=&quot;大意&quot;&gt;&lt;/a&gt;大意&lt;/h2&gt;&lt;p&gt;给定一个n个节点的树，有m次查询&lt;br&gt;查询(a,k)为：点b与点a距离不超过k，且a和b均为c的祖先的无序对(a,b,c)的个数&lt;br&gt;n,m&amp;lt;=300000&lt;br&gt;
    
    </summary>
    
      <category term="Problem Set" scheme="https://cothrax.github.io/categories/Problem-Set/"/>
    
    
      <category term="OI" scheme="https://cothrax.github.io/tags/OI/"/>
    
      <category term="数据结构" scheme="https://cothrax.github.io/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"/>
    
      <category term="DFS序" scheme="https://cothrax.github.io/tags/DFS%E5%BA%8F/"/>
    
      <category term="主席树" scheme="https://cothrax.github.io/tags/%E4%B8%BB%E5%B8%AD%E6%A0%91/"/>
    
  </entry>
  
  <entry>
    <title>bzoj-1103 [POI2007]大都市</title>
    <link href="https://cothrax.github.io/2016/12/03/bzoj-1103/"/>
    <id>https://cothrax.github.io/2016/12/03/bzoj-1103/</id>
    <published>2016-12-03T15:51:52.000Z</published>
    <updated>2016-12-03T16:05:03.056Z</updated>
    
    <content type="html"><![CDATA[<h2 id="大意"><a href="#大意" class="headerlink" title="大意"></a>大意</h2><p>给定n个节点的树，有m次查询，其间有修改操作</p>
<ol>
<li>修改操作：标记某一条边</li>
<li>查询操作：点u到点1的路径上未标记的点数</li>
</ol>
<p>n,m≤300000</p>
<a id="more"></a>
<h2 id="链接"><a href="#链接" class="headerlink" title="链接"></a>链接</h2><p><a href="http://www.lydsy.com/JudgeOnline/problem.php?id=1103" target="_blank" rel="external">bzoj-1013</a><br><a href="/2016/12/03/bzoj-1103/1103.cpp" title="1103.cpp">1103.cpp</a></p>
<h2 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h2><p>考虑修改p对查询q有影响，当且仅当q的p的子树中<br>用树状数组维护dfs序，差分修改即可</p>
<h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><figure class="highlight c++"><figcaption><span>1103.cpp</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="comment">//#define DEBUG</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N=<span class="number">250010</span>,M=<span class="number">250010</span>;</span><br><span class="line"><span class="keyword">struct</span> edge&#123;<span class="keyword">int</span> v,nxt;&#125; g[N*<span class="number">2</span>];</span><br><span class="line"><span class="keyword">int</span> head[N],d[N]=&#123;<span class="number">-1</span>&#125;,siz[N],loc[N],bit[N],par[N];</span><br><span class="line"><span class="keyword">int</span> n,m,sz=<span class="number">0</span>,k=<span class="number">0</span>;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">add</span><span class="params">(<span class="keyword">int</span> u,<span class="keyword">int</span> v)</span></span><br><span class="line"></span>&#123;g[++sz]=&#123;v,head[u]&#125;;head[u]=sz;&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">upd</span><span class="params">(<span class="keyword">int</span> x,<span class="keyword">int</span> k)</span></span><br><span class="line"></span>&#123;<span class="keyword">while</span>(x&amp;&amp;x&lt;=n)bit[x]+=k,x+=x&amp;(-x);&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">sum</span><span class="params">(<span class="keyword">int</span> x)</span></span><br><span class="line"></span>&#123;<span class="keyword">int</span> ret=<span class="number">0</span>;<span class="keyword">while</span>(x)ret+=bit[x],x-=x&amp;(-x);<span class="keyword">return</span> ret;&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">dfs</span><span class="params">(<span class="keyword">int</span> u,<span class="keyword">int</span> p)</span></span>&#123;</span><br><span class="line">    loc[u]=++k;d[u]=d[p]+<span class="number">1</span>;siz[u]=<span class="number">1</span>;par[u]=p;<span class="keyword">int</span> v;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=head[u];i;i=g[i].nxt)</span><br><span class="line">        <span class="keyword">if</span>((v=g[i].v)!=p)dfs(v,u),siz[u]+=siz[v];</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="comment">/*freopen("in","r",stdin);</span><br><span class="line">    freopen("out","w",stdout);*/</span></span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">"%d\n"</span>,&amp;n);</span><br><span class="line">    <span class="keyword">int</span> u,v,cnt=<span class="number">0</span>;<span class="keyword">char</span> c;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;n<span class="number">-1</span>;i++)</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">"%d %d\n"</span>,&amp;u,&amp;v),add(u,v),add(v,u);</span><br><span class="line">    dfs(<span class="number">1</span>,<span class="number">0</span>);<span class="built_in">scanf</span>(<span class="string">"%d"</span>,&amp;m);</span><br><span class="line">    <span class="keyword">while</span>(cnt&lt;m)&#123;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">"%c "</span>,&amp;c);</span><br><span class="line">        <span class="keyword">switch</span>(c)&#123;</span><br><span class="line">            <span class="keyword">case</span> <span class="string">'W'</span>:&#123;</span><br><span class="line">                <span class="built_in">scanf</span>(<span class="string">"%d\n"</span>,&amp;u);cnt++;</span><br><span class="line">                <span class="built_in">printf</span>(<span class="string">"%d\n"</span>,d[u]-sum(loc[u]));</span><br><span class="line">            &#125;;<span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">case</span> <span class="string">'A'</span>:&#123;</span><br><span class="line">                <span class="built_in">scanf</span>(<span class="string">"%d %d\n"</span>,&amp;u,&amp;v);</span><br><span class="line">                <span class="keyword">if</span>(par[u]==v)swap(u,v);</span><br><span class="line">                upd(loc[v],<span class="number">1</span>);upd(loc[v]+siz[v],<span class="number">-1</span>);</span><br><span class="line">            &#125;;<span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;大意&quot;&gt;&lt;a href=&quot;#大意&quot; class=&quot;headerlink&quot; title=&quot;大意&quot;&gt;&lt;/a&gt;大意&lt;/h2&gt;&lt;p&gt;给定n个节点的树，有m次查询，其间有修改操作&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;修改操作：标记某一条边&lt;/li&gt;
&lt;li&gt;查询操作：点u到点1的路径上未标记的点数&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;n,m≤300000&lt;/p&gt;
    
    </summary>
    
      <category term="Problem Set" scheme="https://cothrax.github.io/categories/Problem-Set/"/>
    
    
      <category term="OI" scheme="https://cothrax.github.io/tags/OI/"/>
    
      <category term="数据结构" scheme="https://cothrax.github.io/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"/>
    
      <category term="树状数组" scheme="https://cothrax.github.io/tags/%E6%A0%91%E7%8A%B6%E6%95%B0%E7%BB%84/"/>
    
      <category term="DFS序" scheme="https://cothrax.github.io/tags/DFS%E5%BA%8F/"/>
    
      <category term="POI" scheme="https://cothrax.github.io/tags/POI/"/>
    
  </entry>
  
  <entry>
    <title>bzoj-1087 [SCOI2005]互不侵犯King</title>
    <link href="https://cothrax.github.io/2016/12/03/bzoj-1087/"/>
    <id>https://cothrax.github.io/2016/12/03/bzoj-1087/</id>
    <published>2016-12-03T15:47:42.000Z</published>
    <updated>2016-12-03T16:02:16.266Z</updated>
    
    <content type="html"><![CDATA[<h2 id="描述"><a href="#描述" class="headerlink" title="描述"></a>描述</h2><p>在N×N的棋盘里面放K个国王，使他们互不攻击，共有多少种摆放方案。国王能攻击到它上下左右，以及左上<br>左下右上右下八个方向上附近的各一个格子，共8个格子。<br>1 &lt;=N&lt;=9,0&lt;=K&lt;=N*N</p>
<a id="more"></a>
<h2 id="链接"><a href="#链接" class="headerlink" title="链接"></a>链接</h2><p><a href="http://www.lydsy.com/JudgeOnline/problem.php?id=1087" target="_blank" rel="external">bzoj-1013</a><br><a href="/2016/12/03/bzoj-1087/1087.cpp" title="1087.cpp">1087.cpp</a></p>
<h2 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h2><p>逐行做状压dp<br>f[i,j,s]为第i行状态为s，当前已放j个国王的方案数<br>预处理有效状态和有效转移</p>
<h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><figure class="highlight c++"><figcaption><span>1087.cpp</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> ll long long</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N=<span class="number">10</span>,M=<span class="number">1</span>&lt;&lt;N;</span><br><span class="line"><span class="keyword">int</span> n,m,k,cnt[M];</span><br><span class="line">ll f[N][N*N][M];</span><br><span class="line"><span class="keyword">bool</span> flg[M],mat[M][M];</span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">jud</span><span class="params">(<span class="keyword">int</span> x,<span class="keyword">int</span> y)</span></span><br><span class="line"></span>&#123;<span class="keyword">return</span> ((x&lt;&lt;<span class="number">1</span>|x|x&gt;&gt;<span class="number">1</span>)&amp;y)==<span class="number">0</span>;&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="comment">//freopen("in","r",stdin);</span></span><br><span class="line">    <span class="comment">//freopen("out","w",stdout);</span></span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">"%d %d\n"</span>,&amp;n,&amp;k);m=<span class="number">1</span>&lt;&lt;n;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;m;i++)cnt[i]=cnt[i&amp;(i<span class="number">-1</span>)]+<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;m;i++)</span><br><span class="line">        <span class="keyword">if</span>(!(i&amp;(i&gt;&gt;<span class="number">1</span>)))flg[i]=<span class="literal">true</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;m;i++)<span class="keyword">if</span>(flg[i])</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">0</span>;j&lt;m;j++)<span class="keyword">if</span>(flg[j])mat[i][j]=jud(i,j);</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;m;i++)<span class="keyword">if</span>(flg[i])f[<span class="number">1</span>][cnt[i]][i]=<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;n;i++)</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> p=<span class="number">0</span>;p&lt;m;p++)<span class="keyword">if</span>(flg[p])</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> q=<span class="number">0</span>;q&lt;m;q++)<span class="keyword">if</span>(flg[q]&amp;&amp;mat[p][q])</span><br><span class="line">                <span class="keyword">for</span>(<span class="keyword">int</span> j=cnt[p];j+cnt[q]&lt;=k;j++)</span><br><span class="line">                    f[i+<span class="number">1</span>][j+cnt[q]][q]+=f[i][j][p];</span><br><span class="line">    ll ans=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">0</span>;j&lt;m;j++)ans+=f[n][k][j];</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"%lld"</span>,ans);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;描述&quot;&gt;&lt;a href=&quot;#描述&quot; class=&quot;headerlink&quot; title=&quot;描述&quot;&gt;&lt;/a&gt;描述&lt;/h2&gt;&lt;p&gt;在N×N的棋盘里面放K个国王，使他们互不攻击，共有多少种摆放方案。国王能攻击到它上下左右，以及左上&lt;br&gt;左下右上右下八个方向上附近的各一个格子，共8个格子。&lt;br&gt;1 &amp;lt;=N&amp;lt;=9,0&amp;lt;=K&amp;lt;=N*N&lt;/p&gt;
    
    </summary>
    
      <category term="Problem Set" scheme="https://cothrax.github.io/categories/Problem-Set/"/>
    
    
      <category term="OI" scheme="https://cothrax.github.io/tags/OI/"/>
    
      <category term="DP" scheme="https://cothrax.github.io/tags/DP/"/>
    
      <category term="位运算" scheme="https://cothrax.github.io/tags/%E4%BD%8D%E8%BF%90%E7%AE%97/"/>
    
      <category term="状压DP" scheme="https://cothrax.github.io/tags/%E7%8A%B6%E5%8E%8BDP/"/>
    
      <category term="SCOI" scheme="https://cothrax.github.io/tags/SCOI/"/>
    
  </entry>
  
  <entry>
    <title>bzoj-1012 [JSOI2008]最大数</title>
    <link href="https://cothrax.github.io/2016/12/03/bzoj-1012/"/>
    <id>https://cothrax.github.io/2016/12/03/bzoj-1012/</id>
    <published>2016-12-03T15:41:10.000Z</published>
    <updated>2016-12-03T16:02:31.879Z</updated>
    
    <content type="html"><![CDATA[<h2 id="大意"><a href="#大意" class="headerlink" title="大意"></a>大意</h2><p>维护一个数列，支持：</p>
<ol>
<li>向末尾插入一个数</li>
<li>查询长l的后缀的最大值<a id="more"></a>
</li>
</ol>
<h2 id="链接"><a href="#链接" class="headerlink" title="链接"></a>链接</h2><p><a href="http://www.lydsy.com/JudgeOnline/problem.php?id=1013" target="_blank" rel="external">bzoj-1012</a><br><a href="/2016/12/03/bzoj-1012/1012.cpp" title="1012.cpp">1012.cpp</a></p>
<h2 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h2><p>维护后缀最大值的序列，注意到这个序列是单调增的，用一个单调栈维护即可<br>查询时可以以编号为索引二分，或者用并查集维护</p>
<h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><figure class="highlight c++"><figcaption><span>1012.cpp</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N=<span class="number">200010</span>;</span><br><span class="line"><span class="keyword">int</span> stk[N],idx[N],n,m,t;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">ins</span><span class="params">(<span class="keyword">int</span> x,<span class="keyword">int</span> k)</span></span>&#123;</span><br><span class="line">    <span class="keyword">while</span>(t&gt;<span class="number">0</span>&amp;&amp;stk[t]&lt;k)t--;</span><br><span class="line">    stk[++t]=k;idx[t]=x;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">bin</span><span class="params">(<span class="keyword">int</span> x)</span></span>&#123; <span class="comment">//max_i&#123;idx[i]&gt;=x&#125;</span></span><br><span class="line">    <span class="keyword">int</span> l=<span class="number">1</span>,r=t,ans=t;</span><br><span class="line">    <span class="keyword">while</span>(l&lt;=r)&#123;</span><br><span class="line">        <span class="keyword">int</span> mid=(l+r)/<span class="number">2</span>;</span><br><span class="line">        <span class="keyword">if</span>(idx[mid]&gt;=x)ans=mid,r=mid<span class="number">-1</span>;</span><br><span class="line">        <span class="keyword">else</span> l=mid+<span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> stk[ans];</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="comment">//freopen("in","r",stdin);freopen("out","w",stdout);</span></span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">"%d %d\n"</span>,&amp;n,&amp;m);</span><br><span class="line">    <span class="keyword">int</span> lst=<span class="number">0</span>,sz=<span class="number">0</span>;t=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;n;i++)&#123;</span><br><span class="line">        <span class="keyword">int</span> x;<span class="keyword">char</span> c;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">"%c %d\n"</span>,&amp;c,&amp;x);</span><br><span class="line">        <span class="keyword">switch</span>(c)&#123;</span><br><span class="line">            <span class="keyword">case</span> <span class="string">'A'</span>:ins(++sz,(x+lst)%m);<span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">case</span> <span class="string">'Q'</span>:<span class="built_in">printf</span>(<span class="string">"%d\n"</span>,lst=bin(sz-x+<span class="number">1</span>));<span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;大意&quot;&gt;&lt;a href=&quot;#大意&quot; class=&quot;headerlink&quot; title=&quot;大意&quot;&gt;&lt;/a&gt;大意&lt;/h2&gt;&lt;p&gt;维护一个数列，支持：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;向末尾插入一个数&lt;/li&gt;
&lt;li&gt;查询长l的后缀的最大值
    
    </summary>
    
      <category term="Problem Set" scheme="https://cothrax.github.io/categories/Problem-Set/"/>
    
    
      <category term="OI" scheme="https://cothrax.github.io/tags/OI/"/>
    
      <category term="数据结构" scheme="https://cothrax.github.io/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"/>
    
      <category term="JSOI" scheme="https://cothrax.github.io/tags/JSOI/"/>
    
      <category term="二分答案" scheme="https://cothrax.github.io/tags/%E4%BA%8C%E5%88%86%E7%AD%94%E6%A1%88/"/>
    
      <category term="单调栈" scheme="https://cothrax.github.io/tags/%E5%8D%95%E8%B0%83%E6%A0%88/"/>
    
  </entry>
  
  <entry>
    <title>bzoj-1013 [JSOI2008]球形空间产生器</title>
    <link href="https://cothrax.github.io/2016/12/03/bzoj-1013/"/>
    <id>https://cothrax.github.io/2016/12/03/bzoj-1013/</id>
    <published>2016-12-03T15:35:36.000Z</published>
    <updated>2016-12-03T16:03:28.577Z</updated>
    
    <content type="html"><![CDATA[<h2 id="大意"><a href="#大意" class="headerlink" title="大意"></a>大意</h2><p>给定n维空间内的n+1个坐标，求这些坐标确定的球的球心<br>n≤10<br><a id="more"></a></p>
<h2 id="链接"><a href="#链接" class="headerlink" title="链接"></a>链接</h2><p><a href="http://www.lydsy.com/JudgeOnline/problem.php?id=1013" target="_blank" rel="external">bzoj-1013</a><br><a href="/2016/12/03/bzoj-1013/1013.cpp" title="1013.cpp">1013.cpp</a></p>
<h2 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h2><p>列方程组，然后高斯消元即可<br>如相邻两个方程：<br>$\sum{(x_i-a_i)^2}=r^2$<br>$\sum{(x_i-b_i)^2}=r^2$<br>相减得到<br>$\sum{2(a_i-b_i)x_i}=\sum{a_i^2}-\sum{b_i^2}$</p>
<h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><figure class="highlight c++"><figcaption><span>1013.cpp#include<algorithm></algorithm></span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cmath&gt;</span></span></span><br><span class="line"><span class="comment">//#define D</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N=<span class="number">15</span>;<span class="keyword">const</span> <span class="keyword">double</span> EPS=<span class="number">10E-4</span>;</span><br><span class="line"><span class="keyword">int</span> n;<span class="keyword">double</span> a[N][N];</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">solv</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;i++)&#123;</span><br><span class="line">        <span class="keyword">int</span> p=i;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j=i+<span class="number">1</span>;j&lt;=n;j++)</span><br><span class="line">            <span class="keyword">if</span>(a[p][i]&lt;a[j][i])p=j;</span><br><span class="line">        swap(a[p],a[i]);</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j=i+<span class="number">1</span>;j&lt;=n+<span class="number">1</span>;j++)a[i][j]/=a[i][i];</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">1</span>;j&lt;=n;j++)<span class="keyword">if</span>(j!=i)</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> k=i+<span class="number">1</span>;k&lt;=n+<span class="number">1</span>;k++)</span><br><span class="line">                a[j][k]-=a[j][i]*a[i][k];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    freopen(<span class="string">"in"</span>,<span class="string">"r"</span>,<span class="built_in">stdin</span>);</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">"%d\n"</span>,&amp;n);</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n+<span class="number">1</span>;i++)</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">1</span>;j&lt;=n;j++)&#123;</span><br><span class="line">            <span class="built_in">scanf</span>(<span class="string">"%lf"</span>,&amp;a[i][j]);</span><br><span class="line">            a[i][n+<span class="number">1</span>]+=a[i][j]*a[i][j];</span><br><span class="line">            a[i][j]*=<span class="number">2</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;i++)</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">1</span>;j&lt;=n+<span class="number">1</span>;j++)</span><br><span class="line">            a[i][j]-=a[i+<span class="number">1</span>][j];</span><br><span class="line">    solv();</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;i++)&#123;</span><br><span class="line">        <span class="keyword">double</span> x=a[i][n+<span class="number">1</span>];</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"%0.3lf"</span>,(<span class="built_in">abs</span>(x)&lt;EPS)?<span class="number">0</span>:x);</span><br><span class="line">        <span class="keyword">if</span>(i&lt;n)<span class="built_in">printf</span>(<span class="string">" "</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;大意&quot;&gt;&lt;a href=&quot;#大意&quot; class=&quot;headerlink&quot; title=&quot;大意&quot;&gt;&lt;/a&gt;大意&lt;/h2&gt;&lt;p&gt;给定n维空间内的n+1个坐标，求这些坐标确定的球的球心&lt;br&gt;n≤10&lt;br&gt;
    
    </summary>
    
      <category term="Problem Set" scheme="https://cothrax.github.io/categories/Problem-Set/"/>
    
    
      <category term="OI" scheme="https://cothrax.github.io/tags/OI/"/>
    
      <category term="高斯消元" scheme="https://cothrax.github.io/tags/%E9%AB%98%E6%96%AF%E6%B6%88%E5%85%83/"/>
    
  </entry>
  
  <entry>
    <title>bzoj-1001 狼抓兔子</title>
    <link href="https://cothrax.github.io/2016/12/03/bzoj-1001/"/>
    <id>https://cothrax.github.io/2016/12/03/bzoj-1001/</id>
    <published>2016-12-03T15:24:04.000Z</published>
    <updated>2016-12-03T16:02:41.088Z</updated>
    
    <content type="html"><![CDATA[<h2 id="大意"><a href="#大意" class="headerlink" title="大意"></a>大意</h2><p>给定一个n*m的网格状带权图，求从(1,1)到(n,m)的最小割<br>n,m≤1000<br><a id="more"></a></p>
<h2 id="链接"><a href="#链接" class="headerlink" title="链接"></a>链接</h2><p><a href="http://www.lydsy.com/JudgeOnline/problem.php?id=1001" target="_blank" rel="external">bzoj-1001</a><br><a href="/2016/12/03/bzoj-1001/1001.cpp" title="1001.cpp">1001.cpp</a><br><a href="/2016/12/03/bzoj-1001/1001_spf.cpp" title="1001_spf.cpp">1001_spf.cpp</a></p>
<h2 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h2><p>果断跑dinic，然后tle<br>由于网格是平面图，平面图上的最小割可以转化为对偶图上的最小环<br>由于给定起点和终点，可以连接起终点得到一条边，计算不穿过这条边的对偶图的最短路即可。<br>详见：<a href="/2016/12/03/bzoj-1001/冬令营论文演示文稿.ppt" title="周冬《两极相通——浅析最大—最小定理在信息学竞赛中的应用》">周冬《两极相通——浅析最大—最小定理在信息学竞赛中的应用》</a></p>
<h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><p>dinic<br><figure class="highlight c++"><figcaption><span>1001.cpp</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="comment">//#define DEBUG</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N=<span class="number">1010</span>,INF=<span class="number">10e7</span>;</span><br><span class="line"><span class="keyword">struct</span> edge&#123;<span class="keyword">int</span> v,nxt,c;&#125; g[N*N*<span class="number">12</span>];</span><br><span class="line"><span class="keyword">int</span> n,m,sz,head[N*N],q[N*N],dep[N*N];</span><br><span class="line"><span class="keyword">inline</span> <span class="keyword">void</span> _add(<span class="keyword">int</span> u,<span class="keyword">int</span> v,<span class="keyword">int</span> c)</span><br><span class="line">&#123;g[++sz]=&#123;v,head[u],c&#125;;head[u]=sz;&#125;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">add</span><span class="params">(<span class="keyword">int</span> u,<span class="keyword">int</span> v,<span class="keyword">int</span> c)</span></span><br><span class="line"></span>&#123;_add(u,v,c);_add(v,u,<span class="number">0</span>);_add(v,u,c);_add(u,v,<span class="number">0</span>);&#125;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">int</span> <span class="title">p</span><span class="params">(<span class="keyword">int</span> x,<span class="keyword">int</span> y)</span></span>&#123;<span class="keyword">return</span> x*m+y;&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">bfs</span><span class="params">(<span class="keyword">int</span> s,<span class="keyword">int</span> t0)</span></span>&#123;</span><br><span class="line">    <span class="built_in">memset</span>(dep,<span class="number">-1</span>,<span class="keyword">sizeof</span>(dep));</span><br><span class="line">    <span class="keyword">int</span> u,v;q[<span class="number">0</span>]=s;dep[s]=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> h=<span class="number">0</span>,t=<span class="number">1</span>;h&lt;t;h++)</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=head[u=q[h]];i;i=g[i].nxt)</span><br><span class="line">            <span class="keyword">if</span>(dep[v=g[i].v]==<span class="number">-1</span>&amp;&amp;g[i].c)</span><br><span class="line">                q[t++]=v,dep[v]=dep[u]+<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">return</span> dep[t0]!=<span class="number">-1</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">dfs</span><span class="params">(<span class="keyword">int</span> u,<span class="keyword">int</span> t,<span class="keyword">int</span> f)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(u==t)<span class="keyword">return</span> f;</span><br><span class="line">    <span class="keyword">int</span> ret=<span class="number">0</span>,v;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=head[u];i;i=g[i].nxt)</span><br><span class="line">        <span class="keyword">if</span>(dep[v=g[i].v]==dep[u]+<span class="number">1</span>)&#123;</span><br><span class="line">            <span class="keyword">int</span> tmp=dfs(v,t,min(f-ret,g[i].c));</span><br><span class="line">            g[i].c-=tmp;g[i^<span class="number">1</span>].c+=tmp;ret+=tmp;</span><br><span class="line">            <span class="keyword">if</span>(ret==f)<span class="keyword">return</span> ret;</span><br><span class="line">        &#125;</span><br><span class="line">    <span class="keyword">return</span> ret;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">maxflow</span><span class="params">(<span class="keyword">int</span> s,<span class="keyword">int</span> t)</span></span><br><span class="line"></span>&#123;<span class="keyword">int</span> ret=<span class="number">0</span>;<span class="keyword">while</span>(bfs(s,t))ret+=dfs(s,t,INF);<span class="keyword">return</span> ret;&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="comment">//freopen("1001.in","r",stdin);</span></span><br><span class="line">    <span class="comment">//freopen("1001.ans","w",stdout);</span></span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">"%d%d"</span>,&amp;n,&amp;m);sz=<span class="number">1</span>;<span class="keyword">int</span> w;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;n;i++)</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">0</span>;j&lt;m<span class="number">-1</span>;j++)</span><br><span class="line">            <span class="built_in">scanf</span>(<span class="string">"%d"</span>,&amp;w),add(p(i,j),p(i,j+<span class="number">1</span>),w);</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;n<span class="number">-1</span>;i++)</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">0</span>;j&lt;m;j++)</span><br><span class="line">            <span class="built_in">scanf</span>(<span class="string">"%d"</span>,&amp;w),add(p(i,j),p(i+<span class="number">1</span>,j),w);</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;n<span class="number">-1</span>;i++)</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">0</span>;j&lt;m<span class="number">-1</span>;j++)</span><br><span class="line">            <span class="built_in">scanf</span>(<span class="string">"%d"</span>,&amp;w),add(p(i,j),p(i+<span class="number">1</span>,j+<span class="number">1</span>),w);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"%d"</span>,maxflow(p(<span class="number">0</span>,<span class="number">0</span>),p(n<span class="number">-1</span>,m<span class="number">-1</span>)));</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>最短路<br><figure class="highlight c++"><figcaption><span>1001_spf.cpp</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N=<span class="number">1000</span>*<span class="number">1000</span>*<span class="number">2</span>,INF=<span class="number">1000000000</span>;</span><br><span class="line"><span class="keyword">struct</span> edge&#123;<span class="keyword">int</span> v,w,nxt;&#125; g[N*<span class="number">3</span>];</span><br><span class="line"><span class="keyword">int</span> n,m,S,T,sz=<span class="number">0</span>,head[N],q[N],d[N];</span><br><span class="line"><span class="keyword">bool</span> inq[N]=&#123;<span class="literal">false</span>&#125;;</span><br><span class="line"><span class="keyword">inline</span> <span class="keyword">void</span> _add(<span class="keyword">int</span> u,<span class="keyword">int</span> v,<span class="keyword">int</span> w)</span><br><span class="line">&#123;g[++sz]=&#123;v,w,head[u]&#125;;head[u]=sz;&#125;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">add</span><span class="params">(<span class="keyword">int</span> u,<span class="keyword">int</span> v,<span class="keyword">int</span> w)</span></span><br><span class="line"></span>&#123;_add(u,v,w);_add(v,u,w);&#125;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">int</span> <span class="title">p</span><span class="params">(<span class="keyword">int</span> x,<span class="keyword">int</span> y,<span class="keyword">int</span> z)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(x&lt;<span class="number">0</span>||y&gt;m<span class="number">-2</span>)<span class="keyword">return</span> S;</span><br><span class="line">    <span class="keyword">if</span>(x&gt;n<span class="number">-2</span>||y&lt;<span class="number">0</span>)<span class="keyword">return</span> T;</span><br><span class="line">    <span class="keyword">return</span> x*m*<span class="number">2</span>+y*<span class="number">2</span>+z;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">spfa</span><span class="params">()</span></span>&#123;</span><br><span class="line">    fill(d,d+N,INF);<span class="keyword">int</span> u,v;q[<span class="number">0</span>]=S;inq[S]=<span class="literal">true</span>;d[S]=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> h=<span class="number">0</span>,t=<span class="number">1</span>;h!=t;inq[q[h]]=<span class="literal">false</span>,h=(h+<span class="number">1</span>)%N)</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=head[u=q[h]];i;i=g[i].nxt)</span><br><span class="line">            <span class="keyword">if</span>(d[v=g[i].v]&gt;d[u]+g[i].w)&#123;</span><br><span class="line">                d[v]=d[u]+g[i].w;</span><br><span class="line">                <span class="keyword">if</span>(!inq[v])&#123;q[t++]=v;t%=N;inq[v]=<span class="literal">true</span>;&#125;</span><br><span class="line">            &#125;</span><br><span class="line">    <span class="keyword">return</span> d[T];</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="comment">//freopen("1001.in","r",stdin);</span></span><br><span class="line">    <span class="comment">//freopen("1001.out","w",stdout);</span></span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">"%d%d"</span>,&amp;n,&amp;m);</span><br><span class="line">    <span class="keyword">int</span> w;S=n*m*<span class="number">2</span>,T=n*m*<span class="number">2</span>+<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;n;i++)</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">0</span>;j&lt;m<span class="number">-1</span>;j++)</span><br><span class="line">            <span class="built_in">scanf</span>(<span class="string">"%d"</span>,&amp;w),add(p(i<span class="number">-1</span>,j,<span class="number">1</span>),p(i,j,<span class="number">0</span>),w);</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;n<span class="number">-1</span>;i++)</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">0</span>;j&lt;m;j++)</span><br><span class="line">            <span class="built_in">scanf</span>(<span class="string">"%d"</span>,&amp;w),add(p(i,j<span class="number">-1</span>,<span class="number">0</span>),p(i,j,<span class="number">1</span>),w);</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;n<span class="number">-1</span>;i++)</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">0</span>;j&lt;m<span class="number">-1</span>;j++)</span><br><span class="line">            <span class="built_in">scanf</span>(<span class="string">"%d"</span>,&amp;w),add(p(i,j,<span class="number">0</span>),p(i,j,<span class="number">1</span>),w);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"%d"</span>,spfa());</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;大意&quot;&gt;&lt;a href=&quot;#大意&quot; class=&quot;headerlink&quot; title=&quot;大意&quot;&gt;&lt;/a&gt;大意&lt;/h2&gt;&lt;p&gt;给定一个n*m的网格状带权图，求从(1,1)到(n,m)的最小割&lt;br&gt;n,m≤1000&lt;br&gt;
    
    </summary>
    
      <category term="Problem Set" scheme="https://cothrax.github.io/categories/Problem-Set/"/>
    
    
      <category term="OI" scheme="https://cothrax.github.io/tags/OI/"/>
    
      <category term="图论" scheme="https://cothrax.github.io/tags/%E5%9B%BE%E8%AE%BA/"/>
    
      <category term="最短路" scheme="https://cothrax.github.io/tags/%E6%9C%80%E7%9F%AD%E8%B7%AF/"/>
    
      <category term="网络流" scheme="https://cothrax.github.io/tags/%E7%BD%91%E7%BB%9C%E6%B5%81/"/>
    
      <category term="平面图" scheme="https://cothrax.github.io/tags/%E5%B9%B3%E9%9D%A2%E5%9B%BE/"/>
    
      <category term="最小割" scheme="https://cothrax.github.io/tags/%E6%9C%80%E5%B0%8F%E5%89%B2/"/>
    
  </entry>
  
  <entry>
    <title>NOIP2016 填坑</title>
    <link href="https://cothrax.github.io/2016/11/24/noip-2016/"/>
    <id>https://cothrax.github.io/2016/11/24/noip-2016/</id>
    <published>2016-11-24T14:55:08.000Z</published>
    <updated>2016-11-27T08:43:14.549Z</updated>
    
    <content type="html"><![CDATA[<p>第一次也是倒数第二次noip就这么跪了，也是第一次站在一定高度上正视自己的平庸<br>首先，考前有两道概率题没订正，默默地立了个flag：noip不考期望，结果d1t3方程没调出来、暴力都没来得及写。<br>其次，以一个蒟蒻的思维能力偏偏碰上了一场难度偏高的noip，考前还在复习树剖、主席树模板，各种数据结构学傻，然而没有融入自己的思考。<br>最后，作为第一次noip，暴力分没有拿满也是很遗憾的<br>虽说是afo了，但善始善终，把坑填完。<br><a id="more"></a></p>
<h1 id="链接"><a href="#链接" class="headerlink" title="链接"></a>链接</h1><ul>
<li><a href="/2016/11/24/noip-2016/toy.pas" title="toy.pas">toy.pas</a></li>
<li><a href="/2016/11/24/noip-2016/running.pas" title="running.pas">running.pas</a></li>
<li><a href="/2016/11/24/noip-2016/classroom.pas" title="classroom.pas">classroom.pas</a></li>
<li><a href="/2016/11/24/noip-2016/problem.pas" title="problem.pas">problem.pas</a></li>
<li><a href="/2016/11/24/noip-2016/earthworm.pas" title="earthworm.pas">earthworm.pas</a></li>
<li>angrybirds<ul>
<li><a href="/2016/11/24/noip-2016/angrybirds.pas" title="angrybirds.pas">angrybirds.pas</a></li>
<li><a href="/2016/11/24/noip-2016/angrybirds.cpp" title="angrybirds.cpp">angrybirds.cpp</a>
</li>
</ul>
</li>
</ul>
<h1 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h1><p>两个T1是原来的，其余都是订正后的</p>
<h2 id="D1T1-玩具谜题"><a href="#D1T1-玩具谜题" class="headerlink" title="D1T1 玩具谜题"></a>D1T1 玩具谜题</h2><p>没什么好说的</p>
<blockquote>
<p>mogician/mengbier比较亮，noip药丸的征兆</p>
</blockquote>
<figure class="highlight delphi"><figcaption><span>toy.pas</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> int=longint;</span><br><span class="line"><span class="keyword">var</span></span><br><span class="line">    n,m,i,j,k,cur:int;</span><br><span class="line">    s:ansistring;</span><br><span class="line">    dir:<span class="keyword">array</span>[<span class="number">0</span>..<span class="number">100010</span>] <span class="keyword">of</span> int;</span><br><span class="line">    a:<span class="keyword">array</span>[<span class="number">0</span>..<span class="number">100010</span>] <span class="keyword">of</span> ansistring;</span><br><span class="line"></span><br><span class="line"><span class="keyword">begin</span></span><br><span class="line">    <span class="comment">//assign(input,'toy.in');reset(input);</span></span><br><span class="line">    <span class="comment">//assign(output,'toy.out');rewrite(output);</span></span><br><span class="line">    readln(n,m);</span><br><span class="line">    <span class="keyword">for</span> i:=<span class="number">0</span> <span class="keyword">to</span> n-<span class="number">1</span> <span class="keyword">do</span> <span class="keyword">begin</span></span><br><span class="line">        readln(s);j:=pos(<span class="string">' '</span>,s);</span><br><span class="line">        val(copy(s,<span class="number">1</span>,j-<span class="number">1</span>),dir[i]);<span class="comment">//d=0 inside;d=1 outside</span></span><br><span class="line">        a[i]:=copy(s,j+<span class="number">1</span>,length(s)-j);</span><br><span class="line">    <span class="keyword">end</span>;</span><br><span class="line">    cur:=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> i:=<span class="number">1</span> <span class="keyword">to</span> m <span class="keyword">do</span> <span class="keyword">begin</span></span><br><span class="line">        <span class="keyword">read</span>(j,k); <span class="comment">//j=0 left;j=1 right</span></span><br><span class="line">        <span class="keyword">if</span> (j=<span class="number">0</span>)xor(dir[cur]=<span class="number">0</span>) <span class="keyword">then</span> cur:=(cur+k)<span class="keyword">mod</span> n</span><br><span class="line">        <span class="keyword">else</span> cur:=((cur-k)<span class="keyword">mod</span> n+n)<span class="keyword">mod</span> n;</span><br><span class="line">    <span class="keyword">end</span>;</span><br><span class="line">    <span class="keyword">write</span>(a[cur]);</span><br><span class="line">    <span class="comment">//close(input);close(output);</span></span><br><span class="line"><span class="keyword">end</span>.</span><br></pre></td></tr></table></figure>
<h2 id="D1T2-天天爱跑步"><a href="#D1T2-天天爱跑步" class="headerlink" title="D1T2 天天爱跑步"></a>D1T2 天天爱跑步</h2><p>可以树剖做，也有线性的做法<br>把一条路径s-&gt;t从lca拆成两半，记tim=dep[s]-dep[lca]</p>
<ol>
<li>前一半上的点u要被观察到，需满足w[u]=tim-(dep[u]-dep[lca])，即w[u]+dep[u]为定值=dep[s]</li>
<li>后一半，同理s[u]-dep[u]为定值=dep[s]-dep[lca]*2</li>
</ol>
<p>树剖之后，考虑前一半，差分处理所有询问，即在s处标记插入权值dep[s]，在lca[s]处删除dep[s]（这个可以用链表实现），然后顺序遍历树链上的点u，遍历过程中用cnt[x]记录权值x的计数，检查u处的标记来更新cnt，再cnt[w[u]+dep[u]加到u的答案中即可<br>后一半同理</p>
<p>线性做法可以用dfs序+子树和实现，离线处理询问<br>还可以直接在树上做，合并权值线段树</p>
<figure class="highlight delphi"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span></span><br><span class="line">    int=longint;</span><br><span class="line">    edge=<span class="keyword">record</span> v,nxt:int <span class="keyword">end</span>;</span><br><span class="line">    node=<span class="keyword">record</span> v,k,nxt:int <span class="keyword">end</span>;</span><br><span class="line">    arr=<span class="keyword">array</span>[<span class="number">0</span>..<span class="number">300010</span>] <span class="keyword">of</span> int;</span><br><span class="line"><span class="keyword">var</span></span><br><span class="line">    g:<span class="keyword">array</span>[<span class="number">0</span>..<span class="number">600010</span>] <span class="keyword">of</span> edge;</span><br><span class="line">    lnk:<span class="keyword">array</span>[<span class="number">0</span>..<span class="number">2400010</span>] <span class="keyword">of</span> node;</span><br><span class="line">    head,w,lca,par,s,t,_s,_t,ans,</span><br><span class="line">    pre,dep,loc,seg,son,top,siz:arr;</span><br><span class="line">    cnt:<span class="keyword">array</span>[-<span class="number">900010</span>..<span class="number">900010</span>] <span class="keyword">of</span> int;</span><br><span class="line">    n,m,k,sz,sl,i,u,v:int;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">procedure</span> <span class="title">add</span><span class="params">(u,v:int)</span>;</span></span><br><span class="line"><span class="keyword">begin</span></span><br><span class="line">    inc(sz);g[sz].v:=v;</span><br><span class="line">    g[sz].nxt:=head[u];head[u]:=sz;</span><br><span class="line"><span class="keyword">end</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">find</span><span class="params">(x:int)</span>:</span>int;</span><br><span class="line"><span class="keyword">begin</span></span><br><span class="line">    <span class="keyword">if</span> par[x]=x <span class="keyword">then</span> find:=x</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">begin</span></span><br><span class="line">        par[x]:=find(par[x]);</span><br><span class="line">        find:=par[x];</span><br><span class="line">    <span class="keyword">end</span>;</span><br><span class="line"><span class="keyword">end</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">procedure</span> <span class="title">union</span><span class="params">(x,y:int)</span>;</span></span><br><span class="line"><span class="keyword">begin</span></span><br><span class="line">    x:=find(x);y:=find(y);</span><br><span class="line">    par[x]:=y;</span><br><span class="line"><span class="keyword">end</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">procedure</span> <span class="title">ins</span><span class="params">(<span class="keyword">var</span> ptr:arr;u,v,k:int)</span>;</span></span><br><span class="line"><span class="keyword">begin</span></span><br><span class="line">    inc(sl);lnk[sl].v:=v;lnk[sl].k:=k;</span><br><span class="line">    lnk[sl].nxt:=ptr[u];ptr[u]:=sl;</span><br><span class="line"><span class="keyword">end</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">procedure</span> <span class="title">calc</span><span class="params">(<span class="keyword">var</span> ptr:arr;u:int)</span>;</span></span><br><span class="line"><span class="keyword">var</span> i,v:int;</span><br><span class="line"><span class="keyword">begin</span></span><br><span class="line">    i:=ptr[u];</span><br><span class="line">    <span class="keyword">while</span> i&lt;&gt;<span class="number">0</span> <span class="keyword">do</span> <span class="keyword">begin</span></span><br><span class="line">        v:=lnk[i].v;</span><br><span class="line">        <span class="keyword">if</span> dep[v]&lt;&gt;<span class="number">0</span> <span class="keyword">then</span> lca[lnk[i].k]:=find(v);</span><br><span class="line">        i:=lnk[i].nxt;</span><br><span class="line">    <span class="keyword">end</span>;</span><br><span class="line"><span class="keyword">end</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">procedure</span> <span class="title">dfs1</span><span class="params">(u,p:int)</span>;</span></span><br><span class="line"><span class="keyword">var</span> v,i:int;</span><br><span class="line"><span class="keyword">begin</span></span><br><span class="line">    pre[u]:=p;dep[u]:=dep[p]+<span class="number">1</span>;siz[u]:=<span class="number">1</span>;son[u]:=<span class="number">0</span>;</span><br><span class="line">    i:=head[u];</span><br><span class="line">    <span class="keyword">while</span> i&lt;&gt;<span class="number">0</span> <span class="keyword">do</span> <span class="keyword">begin</span></span><br><span class="line">        v:=g[i].v;</span><br><span class="line">        <span class="keyword">if</span> dep[v]=<span class="number">0</span> <span class="keyword">then</span> <span class="keyword">begin</span></span><br><span class="line">            dfs1(v,u);</span><br><span class="line">            <span class="keyword">if</span> siz[v]&gt;siz[son[u]] <span class="keyword">then</span> son[u]:=v;</span><br><span class="line">            inc(siz[u],siz[v]);</span><br><span class="line">        <span class="keyword">end</span>;</span><br><span class="line">        i:=g[i].nxt;</span><br><span class="line">    <span class="keyword">end</span>;</span><br><span class="line">    calc(s,u);calc(t,u);<span class="keyword">if</span> p&lt;&gt;<span class="number">0</span> <span class="keyword">then</span> union(u,p);</span><br><span class="line"><span class="keyword">end</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">procedure</span> <span class="title">dfs2</span><span class="params">(u:int)</span>;</span></span><br><span class="line"><span class="keyword">var</span> i,v:int;</span><br><span class="line"><span class="keyword">begin</span></span><br><span class="line">    inc(k);loc[u]:=k;seg[k]:=u;</span><br><span class="line">    <span class="keyword">if</span> u=son[pre[u]] <span class="keyword">then</span> top[u]:=top[pre[u]] <span class="keyword">else</span> top[u]:=u;</span><br><span class="line">    <span class="keyword">if</span> son[u]&lt;&gt;<span class="number">0</span> <span class="keyword">then</span> dfs2(son[u]);</span><br><span class="line">    i:=head[u];</span><br><span class="line">    <span class="keyword">while</span> i&lt;&gt;<span class="number">0</span> <span class="keyword">do</span> <span class="keyword">begin</span></span><br><span class="line">        v:=g[i].v;</span><br><span class="line">        <span class="keyword">if</span> (v&lt;&gt;son[u])<span class="keyword">and</span>(v&lt;&gt;pre[u]) <span class="keyword">then</span> dfs2(v);</span><br><span class="line">        i:=g[i].nxt;</span><br><span class="line">    <span class="keyword">end</span>;</span><br><span class="line"><span class="keyword">end</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">procedure</span> <span class="title">swap</span><span class="params">(<span class="keyword">var</span> a,b:int)</span>;</span></span><br><span class="line"><span class="keyword">var</span> tmp:int;</span><br><span class="line"><span class="keyword">begin</span> tmp:=a;a:=b;b:=tmp <span class="keyword">end</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">procedure</span> <span class="title">modify</span><span class="params">(u,v,x:int)</span>;</span></span><br><span class="line"><span class="keyword">var</span> p:^int;</span><br><span class="line"><span class="keyword">begin</span></span><br><span class="line">    <span class="keyword">while</span> true <span class="keyword">do</span> <span class="keyword">begin</span></span><br><span class="line">        <span class="keyword">if</span> dep[u]&lt;dep[v] <span class="keyword">then</span> swap(u,v);</span><br><span class="line">        <span class="keyword">if</span> top[u]=top[v] <span class="keyword">then</span> <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">if</span> dep[top[u]]&gt;dep[top[v]] <span class="keyword">then</span> p:=@u <span class="keyword">else</span> p:=@v;</span><br><span class="line">        ins(_t,loc[p^]+<span class="number">1</span>,<span class="number">0</span>,x);</span><br><span class="line">        ins(_s,loc[top[p^]],<span class="number">0</span>,x);</span><br><span class="line">        p^:=pre[top[p^]];</span><br><span class="line">    <span class="keyword">end</span>;</span><br><span class="line">    ins(_s,loc[v],<span class="number">0</span>,x);ins(_t,loc[u]+<span class="number">1</span>,<span class="number">0</span>,x);</span><br><span class="line"><span class="keyword">end</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">procedure</span> <span class="title">solv</span><span class="params">(<span class="keyword">var</span> ptr:arr;x:int)</span>;</span></span><br><span class="line"><span class="keyword">var</span> u,v,i,j,tmp:int;</span><br><span class="line"><span class="keyword">begin</span></span><br><span class="line">    <span class="keyword">for</span> u:=<span class="number">1</span> <span class="keyword">to</span> n <span class="keyword">do</span> <span class="keyword">begin</span></span><br><span class="line">        i:=ptr[u];<span class="keyword">if</span> x=<span class="number">0</span> <span class="keyword">then</span> tmp:=dep[u];</span><br><span class="line">        <span class="keyword">while</span> i&lt;&gt;<span class="number">0</span> <span class="keyword">do</span> <span class="keyword">begin</span></span><br><span class="line">            <span class="keyword">if</span> x=<span class="number">1</span> <span class="keyword">then</span> <span class="keyword">begin</span></span><br><span class="line">                v:=lca[lnk[i].k];tmp:=dep[lnk[i].v]-<span class="number">2</span>*dep[v];</span><br><span class="line">                <span class="keyword">if</span> tmp=w[v] <span class="keyword">then</span> dec(ans[v]);</span><br><span class="line">            <span class="keyword">end</span>;</span><br><span class="line">            modify(u,lca[lnk[i].k],tmp);</span><br><span class="line">            i:=lnk[i].nxt;</span><br><span class="line">        <span class="keyword">end</span>;</span><br><span class="line">    <span class="keyword">end</span>;</span><br><span class="line">    <span class="keyword">for</span> i:=<span class="number">1</span> <span class="keyword">to</span> n <span class="keyword">do</span> <span class="keyword">begin</span></span><br><span class="line">        j:=_s[i];</span><br><span class="line">        <span class="keyword">while</span> j&lt;&gt;<span class="number">0</span> <span class="keyword">do</span> <span class="keyword">begin</span></span><br><span class="line">            inc(cnt[lnk[j].k]);j:=lnk[j].nxt;</span><br><span class="line">        <span class="keyword">end</span>;</span><br><span class="line">        j:=_t[i];</span><br><span class="line">        <span class="keyword">while</span> j&lt;&gt;<span class="number">0</span> <span class="keyword">do</span> <span class="keyword">begin</span></span><br><span class="line">            dec(cnt[lnk[j].k]);j:=lnk[j].nxt;</span><br><span class="line">        <span class="keyword">end</span>;</span><br><span class="line">        inc(ans[seg[i]],cnt[w[seg[i]]]);</span><br><span class="line">    <span class="keyword">end</span>;</span><br><span class="line"><span class="keyword">end</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">begin</span></span><br><span class="line">    <span class="keyword">read</span>(n,m);sz:=<span class="number">0</span>;sl:=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> i:=<span class="number">1</span> <span class="keyword">to</span> n-<span class="number">1</span> <span class="keyword">do</span> <span class="keyword">begin</span></span><br><span class="line">        <span class="keyword">read</span>(u,v);add(u,v);add(v,u);</span><br><span class="line">    <span class="keyword">end</span>;</span><br><span class="line">    <span class="keyword">for</span> i:=<span class="number">1</span> <span class="keyword">to</span> n <span class="keyword">do</span> <span class="keyword">read</span>(w[i]);</span><br><span class="line">    <span class="keyword">for</span> i:=<span class="number">1</span> <span class="keyword">to</span> m <span class="keyword">do</span> <span class="keyword">begin</span></span><br><span class="line">        <span class="keyword">read</span>(u,v);ins(s,u,v,i);ins(t,v,u,i);</span><br><span class="line">    <span class="keyword">end</span>;</span><br><span class="line">    <span class="keyword">for</span> i:=<span class="number">1</span> <span class="keyword">to</span> n <span class="keyword">do</span> par[i]:=i;</span><br><span class="line">    dfs1(<span class="number">1</span>,<span class="number">0</span>);k:=<span class="number">0</span>;dfs2(<span class="number">1</span>);</span><br><span class="line">    <span class="keyword">for</span> i:=<span class="number">1</span> <span class="keyword">to</span> n <span class="keyword">do</span> inc(w[i],dep[i]);</span><br><span class="line">    solv(s,<span class="number">0</span>);</span><br><span class="line">    fillchar(_s,sizeof(_s),<span class="number">0</span>);</span><br><span class="line">    fillchar(_t,sizeof(_t),<span class="number">0</span>);</span><br><span class="line">    fillchar(cnt,sizeof(cnt),<span class="number">0</span>);</span><br><span class="line">    <span class="keyword">for</span> i:=<span class="number">1</span> <span class="keyword">to</span> n <span class="keyword">do</span> dec(w[i],dep[i]*<span class="number">2</span>);</span><br><span class="line">    solv(t,<span class="number">1</span>);</span><br><span class="line">    <span class="keyword">for</span> i:=<span class="number">1</span> <span class="keyword">to</span> n <span class="keyword">do</span> <span class="keyword">write</span>(ans[i],<span class="string">' '</span>);</span><br><span class="line"><span class="keyword">end</span>.</span><br></pre></td></tr></table></figure>
<h2 id="D1T3-换教室"><a href="#D1T3-换教室" class="headerlink" title="D1T3 换教室"></a>D1T3 换教室</h2><p>先floyd $O(N^3)$求最短路，然后dp就好了<br>记f[i,j,0/1] 1..i的教室申请j次，第i次有没有申请（0/1）的最小期望值<br>然后分4类讨论转移即可</p>
<blockquote>
<p>对期望的线性性质理解很肤浅，转移写错</p>
</blockquote>
<figure class="highlight delphi"><figcaption><span>classroom.pas</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">uses</span> math;</span><br><span class="line"><span class="keyword">type</span> int=longint;</span><br><span class="line"><span class="keyword">const</span> inf=<span class="number">1000000000</span>;</span><br><span class="line"><span class="keyword">var</span></span><br><span class="line">    g:<span class="keyword">array</span>[<span class="number">0</span>..<span class="number">310</span>,<span class="number">0</span>..<span class="number">310</span>] <span class="keyword">of</span> int;</span><br><span class="line">    c,d:<span class="keyword">array</span>[<span class="number">0</span>..<span class="number">2010</span>] <span class="keyword">of</span> int;</span><br><span class="line">    a:<span class="keyword">array</span>[<span class="number">0</span>..<span class="number">2010</span>] <span class="keyword">of</span> double;</span><br><span class="line">    f:<span class="keyword">array</span>[<span class="number">0</span>..<span class="number">2010</span>,<span class="number">0</span>..<span class="number">2010</span>,<span class="number">0</span>..<span class="number">1</span>] <span class="keyword">of</span> double;</span><br><span class="line">    n,m,p,q,u,v,w,i,j,k:int;x,y,z,ans:double;</span><br><span class="line"></span><br><span class="line"><span class="keyword">begin</span></span><br><span class="line">    <span class="comment">//assign(input,'classroom.in');reset(input);</span></span><br><span class="line">    <span class="comment">//assign(output,'classroom.out');rewrite(output);</span></span><br><span class="line">    <span class="keyword">read</span>(n,m,p,q);</span><br><span class="line">    filldword(g,sizeof(g)<span class="keyword">shr</span> <span class="number">2</span>,inf);</span><br><span class="line">    <span class="keyword">for</span> i:=<span class="number">1</span> <span class="keyword">to</span> n <span class="keyword">do</span> <span class="keyword">read</span>(c[i]);</span><br><span class="line">    <span class="keyword">for</span> i:=<span class="number">1</span> <span class="keyword">to</span> n <span class="keyword">do</span> <span class="keyword">read</span>(d[i]);</span><br><span class="line">    <span class="keyword">for</span> i:=<span class="number">1</span> <span class="keyword">to</span> n <span class="keyword">do</span> <span class="keyword">read</span>(a[i]);</span><br><span class="line">    <span class="keyword">for</span> i:=<span class="number">1</span> <span class="keyword">to</span> q <span class="keyword">do</span> <span class="keyword">begin</span></span><br><span class="line">        <span class="keyword">read</span>(u,v,w);</span><br><span class="line">        g[u,v]:=min(g[u,v],w);g[v,u]:=g[u,v];</span><br><span class="line">    <span class="keyword">end</span>;</span><br><span class="line">    <span class="keyword">for</span> k:=<span class="number">1</span> <span class="keyword">to</span> p <span class="keyword">do</span></span><br><span class="line">        <span class="keyword">for</span> i:=<span class="number">1</span> <span class="keyword">to</span> p <span class="keyword">do</span></span><br><span class="line">            <span class="keyword">for</span> j:=<span class="number">1</span> <span class="keyword">to</span> p <span class="keyword">do</span></span><br><span class="line">                g[i,j]:=min(g[i,j],g[i,k]+g[k,j]);</span><br><span class="line">    <span class="keyword">for</span> i:=<span class="number">1</span> <span class="keyword">to</span> p <span class="keyword">do</span> g[i,i]:=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> i:=<span class="number">1</span> <span class="keyword">to</span> p <span class="keyword">do</span> g[<span class="number">0</span>,i]:=<span class="number">0</span>;</span><br><span class="line">    f[<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>]:=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> i:=<span class="number">1</span> <span class="keyword">to</span> n <span class="keyword">do</span></span><br><span class="line">        <span class="keyword">for</span> j:=i+<span class="number">1</span> <span class="keyword">to</span> m <span class="keyword">do</span></span><br><span class="line">            <span class="keyword">begin</span> f[i,j,<span class="number">0</span>]:=inf;f[i,j,<span class="number">1</span>]:=inf <span class="keyword">end</span>;</span><br><span class="line">    <span class="keyword">for</span> i:=<span class="number">1</span> <span class="keyword">to</span> n <span class="keyword">do</span> <span class="keyword">begin</span></span><br><span class="line">        x:=a[i-<span class="number">1</span>]*g[d[i-<span class="number">1</span>],c[i]]+(<span class="number">1</span>-a[i-<span class="number">1</span>])*g[c[i-<span class="number">1</span>],c[i]];</span><br><span class="line">        y:=a[i]*g[c[i-<span class="number">1</span>],d[i]]+(<span class="number">1</span>-a[i])*g[c[i-<span class="number">1</span>],c[i]];</span><br><span class="line">        z:=a[i]*(a[i-<span class="number">1</span>]*g[d[i-<span class="number">1</span>],d[i]]+(<span class="number">1</span>-a[i-<span class="number">1</span>])*g[c[i-<span class="number">1</span>],d[i]])+(<span class="number">1</span>-a[i])*x;</span><br><span class="line">        f[i,<span class="number">0</span>,<span class="number">0</span>]:=f[i-<span class="number">1</span>,<span class="number">0</span>,<span class="number">0</span>]+g[c[i-<span class="number">1</span>],c[i]];</span><br><span class="line">        <span class="comment">//writeln(i,'::',x:0:3,' ',y:0:3,' ',z:0:3);</span></span><br><span class="line">        f[i,<span class="number">0</span>,<span class="number">1</span>]:=inf;</span><br><span class="line">        <span class="keyword">for</span> j:=<span class="number">1</span> <span class="keyword">to</span> min(i,m) <span class="keyword">do</span> <span class="keyword">begin</span></span><br><span class="line">            f[i,j,<span class="number">0</span>]:=min(f[i-<span class="number">1</span>,j,<span class="number">0</span>]+g[c[i-<span class="number">1</span>],c[i]],f[i-<span class="number">1</span>,j,<span class="number">1</span>]+x);</span><br><span class="line">            f[i,j,<span class="number">1</span>]:=min(f[i-<span class="number">1</span>,j-<span class="number">1</span>,<span class="number">0</span>]+y,f[i-<span class="number">1</span>,j-<span class="number">1</span>,<span class="number">1</span>]+z);</span><br><span class="line">        <span class="keyword">end</span>;</span><br><span class="line">    <span class="keyword">end</span>;</span><br><span class="line">    ans:=inf;</span><br><span class="line">    <span class="keyword">for</span> i:=<span class="number">0</span> <span class="keyword">to</span> min(n,m) <span class="keyword">do</span> ans:=min(ans,min(f[n,i,<span class="number">0</span>],f[n,i,<span class="number">1</span>]));</span><br><span class="line">    <span class="keyword">write</span>(ans:<span class="number">0</span>:<span class="number">2</span>);</span><br><span class="line"><span class="keyword">end</span>.</span><br></pre></td></tr></table></figure>
<h2 id="D2T1-组合数问题"><a href="#D2T1-组合数问题" class="headerlink" title="D2T1 组合数问题"></a>D2T1 组合数问题</h2><p>k是全局的<br>$O(N^2)$求出模k下的所有组合数，然后二维前缀和即可</p>
<blockquote>
<p>还好</p>
</blockquote>
<figure class="highlight delphi"><figcaption><span>problem.pas</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">uses</span> math;</span><br><span class="line"><span class="keyword">type</span> int=longint;</span><br><span class="line"><span class="keyword">var</span></span><br><span class="line">    t,k,mxn,mxm,ans,i,j:int;</span><br><span class="line">    q:<span class="keyword">array</span>[<span class="number">0</span>..<span class="number">10010</span>,<span class="number">0</span>..<span class="number">1</span>] <span class="keyword">of</span> int;</span><br><span class="line">    c,f:<span class="keyword">array</span>[-<span class="number">1</span>..<span class="number">2010</span>,-<span class="number">1</span>..<span class="number">2010</span>] <span class="keyword">of</span> int;</span><br><span class="line"><span class="keyword">begin</span></span><br><span class="line">    <span class="comment">//assign(input,'problem.in');reset(input);</span></span><br><span class="line">    <span class="comment">//assign(output,'problem.out');rewrite(output);</span></span><br><span class="line">    <span class="keyword">read</span>(t,k);mxn:=<span class="number">0</span>;mxm:=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> i:=<span class="number">1</span> <span class="keyword">to</span> t <span class="keyword">do</span> <span class="keyword">begin</span></span><br><span class="line">        <span class="keyword">read</span>(q[i,<span class="number">0</span>],q[i,<span class="number">1</span>]);</span><br><span class="line">        mxn:=max(mxn,q[i,<span class="number">0</span>]);mxm:=max(mxm,q[i,<span class="number">1</span>]);</span><br><span class="line">    <span class="keyword">end</span>;</span><br><span class="line">    c[<span class="number">0</span>,<span class="number">0</span>]:=<span class="number">1</span>;<span class="keyword">if</span> k=<span class="number">1</span> <span class="keyword">then</span> f[<span class="number">0</span>,<span class="number">0</span>]:=<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span> i:=<span class="number">1</span> <span class="keyword">to</span> mxn <span class="keyword">do</span></span><br><span class="line">        <span class="keyword">for</span> j:=<span class="number">0</span> <span class="keyword">to</span> min(mxm,i) <span class="keyword">do</span> <span class="keyword">begin</span></span><br><span class="line">            c[i,j]:=(c[i-<span class="number">1</span>,j]+c[i-<span class="number">1</span>,j-<span class="number">1</span>])<span class="keyword">mod</span> k;</span><br><span class="line">            <span class="keyword">if</span> c[i,j]=<span class="number">0</span> <span class="keyword">then</span> f[i,j]:=<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">end</span>;</span><br><span class="line">    <span class="keyword">for</span> i:=<span class="number">0</span> <span class="keyword">to</span> mxn <span class="keyword">do</span></span><br><span class="line">        <span class="keyword">for</span> j:=<span class="number">1</span> <span class="keyword">to</span> mxm <span class="keyword">do</span></span><br><span class="line">            f[i,j]:=f[i,j]+f[i,j-<span class="number">1</span>];</span><br><span class="line">    <span class="keyword">for</span> i:=<span class="number">1</span> <span class="keyword">to</span> t <span class="keyword">do</span> <span class="keyword">begin</span></span><br><span class="line">        ans:=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> j:=<span class="number">0</span> <span class="keyword">to</span> q[i,<span class="number">0</span>] <span class="keyword">do</span></span><br><span class="line">            ans:=ans+f[j,q[i,<span class="number">1</span>]];</span><br><span class="line">        writeln(ans);</span><br><span class="line">    <span class="keyword">end</span>;</span><br><span class="line">    <span class="comment">//close(input);close(output);</span></span><br><span class="line"><span class="keyword">end</span>.</span><br></pre></td></tr></table></figure>
<h2 id="D2T2-蚯蚓"><a href="#D2T2-蚯蚓" class="headerlink" title="D2T2 蚯蚓"></a>D2T2 蚯蚓</h2><p>注意到存在增量q，意味着第i次切下来的新蚯蚓一定不会比当前第i-1次切出的长<br>三个队列维护即可</p>
<blockquote>
<p>没多想，手写堆+全局表示<br>我直接p=u/v然后用p算，ccf千万别卡精度。。好慌</p>
</blockquote>
<figure class="highlight delphi"><figcaption><span>earthworm.pas</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">uses</span> math;</span><br><span class="line"><span class="keyword">type</span> int=longint;ll=int64;</span><br><span class="line"><span class="keyword">var</span></span><br><span class="line">    q:<span class="keyword">array</span>[<span class="number">0</span>..<span class="number">2</span>,<span class="number">0</span>..<span class="number">7500010</span>] <span class="keyword">of</span> ll;</span><br><span class="line">    h,t:<span class="keyword">array</span>[<span class="number">0</span>..<span class="number">2</span>] <span class="keyword">of</span> int;</span><br><span class="line">    n,m,t0,i:int;u,v,q0,dt,tmp,x,y:ll;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">ext</span><span class="params">()</span>:</span>ll;</span><br><span class="line"><span class="keyword">var</span> i,j:int;</span><br><span class="line"><span class="keyword">begin</span></span><br><span class="line">    j:=-<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span> i:=<span class="number">0</span> <span class="keyword">to</span> <span class="number">2</span> <span class="keyword">do</span></span><br><span class="line">        <span class="keyword">if</span> (h[i]&lt;=t[i])<span class="keyword">and</span>((j=-<span class="number">1</span>)</span><br><span class="line">            <span class="keyword">or</span>(q[j,h[j]]&lt;q[i,h[i]])) <span class="keyword">then</span> j:=i;</span><br><span class="line">    ext:=q[j,h[j]];inc(h[j]);<span class="comment">//writeln(j,'::',ext);</span></span><br><span class="line"><span class="keyword">end</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">procedure</span> <span class="title">qsort</span><span class="params">(l,r:int)</span>;</span></span><br><span class="line"><span class="keyword">var</span> i,j:int;x,tmp:ll;</span><br><span class="line"><span class="keyword">begin</span></span><br><span class="line">    i:=l;j:=r;x:=q[<span class="number">0</span>,random(r-l)+l];</span><br><span class="line">    <span class="keyword">repeat</span></span><br><span class="line">        <span class="keyword">while</span> q[<span class="number">0</span>,i]&gt;x <span class="keyword">do</span> inc(i);</span><br><span class="line">        <span class="keyword">while</span> q[<span class="number">0</span>,j]&lt;x <span class="keyword">do</span> dec(j);</span><br><span class="line">        <span class="keyword">if</span> i&lt;=j <span class="keyword">then</span> <span class="keyword">begin</span></span><br><span class="line">            tmp:=q[<span class="number">0</span>,i];q[<span class="number">0</span>,i]:=q[<span class="number">0</span>,j];q[<span class="number">0</span>,j]:=tmp;</span><br><span class="line">            inc(i);dec(j);</span><br><span class="line">        <span class="keyword">end</span>;</span><br><span class="line">    <span class="keyword">until</span> i&gt;j;</span><br><span class="line">    <span class="keyword">if</span> i&lt;r <span class="keyword">then</span> qsort(i,r);</span><br><span class="line">    <span class="keyword">if</span> l&lt;j <span class="keyword">then</span> qsort(l,j);</span><br><span class="line"><span class="keyword">end</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">begin</span></span><br><span class="line">    <span class="comment">//assign(input,'earthworm.in');reset(input);</span></span><br><span class="line">    <span class="comment">//assign(output,'earthworm.out');rewrite(output);</span></span><br><span class="line">    <span class="keyword">read</span>(n,m,q0,u,v,t0);</span><br><span class="line">    <span class="keyword">for</span> i:=<span class="number">1</span> <span class="keyword">to</span> n <span class="keyword">do</span> <span class="keyword">read</span>(q[<span class="number">0</span>,i]);</span><br><span class="line">    qsort(<span class="number">1</span>,n);</span><br><span class="line">    <span class="comment">//for i:=1 to n do write(q[0,i],' ');writeln;</span></span><br><span class="line">    h[<span class="number">0</span>]:=<span class="number">1</span>;h[<span class="number">1</span>]:=<span class="number">1</span>;h[<span class="number">2</span>]:=<span class="number">1</span>;t[<span class="number">0</span>]:=n;dt:=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> i:=<span class="number">1</span> <span class="keyword">to</span> m <span class="keyword">do</span> <span class="keyword">begin</span></span><br><span class="line">        tmp:=ext()+dt;x:=trunc(tmp*u/v);y:=tmp-x;inc(dt,q0);</span><br><span class="line">        <span class="comment">//writeln(tmp,' ',x,' ',y,'&gt;&gt;',dt);</span></span><br><span class="line">        inc(t[<span class="number">1</span>]);inc(t[<span class="number">2</span>]);q[<span class="number">1</span>,t[<span class="number">1</span>]]:=x-dt;q[<span class="number">2</span>,t[<span class="number">2</span>]]:=y-dt;</span><br><span class="line">        <span class="keyword">if</span> i <span class="keyword">mod</span> t0=<span class="number">0</span> <span class="keyword">then</span> <span class="keyword">write</span>(tmp,<span class="string">' '</span>);</span><br><span class="line">    <span class="keyword">end</span>;</span><br><span class="line">    writeln;</span><br><span class="line">    <span class="keyword">for</span> i:=<span class="number">1</span> <span class="keyword">to</span> n+m <span class="keyword">do</span> <span class="keyword">begin</span></span><br><span class="line">        tmp:=ext()+dt;</span><br><span class="line">        <span class="keyword">if</span> i <span class="keyword">mod</span> t0=<span class="number">0</span> <span class="keyword">then</span> <span class="keyword">write</span>(tmp,<span class="string">' '</span>);</span><br><span class="line">    <span class="keyword">end</span>;</span><br><span class="line">    <span class="comment">//close(input);close(output);</span></span><br><span class="line"><span class="keyword">end</span>.</span><br></pre></td></tr></table></figure>
<h2 id="D2T3-愤怒的小鸟"><a href="#D2T3-愤怒的小鸟" class="headerlink" title="D2T3 愤怒的小鸟"></a>D2T3 愤怒的小鸟</h2><p>状压DP<br>记s[i,j]为以第i个和第j个猪确定的抛物线能消灭的猪的集合<br>然后$O(2^n)$做DP，每次转移是$O(N^2)$的</p>
<blockquote>
<p>d1之后，知乎上有一个dalao立了个flag:d2t3是搜索。<br>然后我想都没想直接搜然后还写错了。。</p>
</blockquote>
<figure class="highlight delphi"><figcaption><span>angrybirds.pas</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">uses</span> math;</span><br><span class="line"><span class="keyword">type</span> int=longint;</span><br><span class="line"><span class="keyword">const</span> eps=<span class="number">0.000001</span>;</span><br><span class="line"><span class="keyword">var</span> </span><br><span class="line">    t,n,m,i,j,k:int;</span><br><span class="line">    x,y:<span class="keyword">array</span>[<span class="number">0</span>..<span class="number">20</span>] <span class="keyword">of</span> double;</span><br><span class="line">    s:<span class="keyword">array</span>[<span class="number">0</span>..<span class="number">20</span>,<span class="number">0</span>..<span class="number">20</span>] <span class="keyword">of</span> int;</span><br><span class="line">    f:<span class="keyword">array</span>[<span class="number">0</span>..<span class="number">1</span> <span class="keyword">shl</span> <span class="number">18</span>+<span class="number">10</span>] <span class="keyword">of</span> int;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">calc</span><span class="params">(u,v:int)</span>:</span>int;</span><br><span class="line"><span class="keyword">var</span> a,b,p:double;i:int;</span><br><span class="line"><span class="keyword">begin</span></span><br><span class="line">    p:=x[u]/x[v];</span><br><span class="line">    <span class="keyword">if</span> abs(x[u]-x[v])&lt;eps <span class="keyword">then</span> <span class="keyword">exit</span>(<span class="number">0</span>);</span><br><span class="line">    a:=(y[u]-y[v]*p)/(sqr(x[u])-sqr(x[v])*p);</span><br><span class="line">    b:=(y[u]-a*sqr(x[u]))/x[u];</span><br><span class="line">    <span class="keyword">if</span> (a&gt;<span class="number">0</span>)<span class="keyword">or</span>(abs(a)&lt;eps) <span class="keyword">then</span> <span class="keyword">exit</span>(<span class="number">0</span>);</span><br><span class="line">    calc:=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> i:=<span class="number">0</span> <span class="keyword">to</span> n-<span class="number">1</span> <span class="keyword">do</span></span><br><span class="line">        <span class="keyword">if</span> abs(y[i]-(a*sqr(x[i])+b*x[i]))&lt;eps <span class="keyword">then</span></span><br><span class="line">            calc:=calc <span class="keyword">or</span> (<span class="number">1</span> <span class="keyword">shl</span> i);</span><br><span class="line"><span class="keyword">end</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">begin</span></span><br><span class="line">    <span class="comment">//assign(input,'angrybirds.in');reset(input);</span></span><br><span class="line">    <span class="comment">//assign(output,'angrybirds.out');rewrite(output);</span></span><br><span class="line">    <span class="keyword">read</span>(t);</span><br><span class="line">    <span class="keyword">repeat</span></span><br><span class="line">        <span class="keyword">read</span>(n,m);m:=<span class="number">1</span> <span class="keyword">shl</span> n-<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span> i:=<span class="number">0</span> <span class="keyword">to</span> n-<span class="number">1</span> <span class="keyword">do</span> <span class="keyword">read</span>(x[i],y[i]);</span><br><span class="line">        <span class="keyword">for</span> i:=<span class="number">0</span> <span class="keyword">to</span> n-<span class="number">1</span> <span class="keyword">do</span></span><br><span class="line">            <span class="keyword">for</span> j:=i+<span class="number">1</span> <span class="keyword">to</span> n-<span class="number">1</span> <span class="keyword">do</span> s[i,j]:=calc(i,j);</span><br><span class="line">        <span class="keyword">for</span> i:=<span class="number">0</span> <span class="keyword">to</span> n-<span class="number">1</span> <span class="keyword">do</span> s[i,i]:=<span class="number">1</span> <span class="keyword">shl</span> i</span><br><span class="line">        f[<span class="number">0</span>]:=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> i:=<span class="number">1</span> <span class="keyword">to</span> m <span class="keyword">do</span> <span class="keyword">begin</span></span><br><span class="line">            j:=i;f[i]:=maxlongint;</span><br><span class="line">            <span class="keyword">for</span> j:=<span class="number">0</span> <span class="keyword">to</span> n-<span class="number">1</span> <span class="keyword">do</span> <span class="keyword">if</span> i <span class="keyword">and</span>(<span class="number">1</span> <span class="keyword">shl</span> j)&gt;<span class="number">0</span> <span class="keyword">then</span></span><br><span class="line">                <span class="keyword">for</span> k:=j <span class="keyword">to</span> n-<span class="number">1</span> <span class="keyword">do</span> <span class="keyword">if</span> i <span class="keyword">and</span>(<span class="number">1</span> <span class="keyword">shl</span> k)&gt;<span class="number">0</span> <span class="keyword">then</span></span><br><span class="line">                    f[i]:=min(f[i],f[i xor(i <span class="keyword">and</span> s[j,k])]+<span class="number">1</span>);</span><br><span class="line">        <span class="keyword">end</span>;</span><br><span class="line">        writeln(f[m]);</span><br><span class="line">        dec(t);</span><br><span class="line">    <span class="keyword">until</span> t=<span class="number">0</span>;</span><br><span class="line">    <span class="comment">//close(input);close(output);</span></span><br><span class="line"><span class="keyword">end</span>.</span><br></pre></td></tr></table></figure>
<p>还有$O(N2^N)$的做法，因为编号最小的猪一定要被删掉，枚举包含该猪的集合转移<br><figure class="highlight cpp"><figcaption><span>angrybirds.cpp</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cmath&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N=<span class="number">20</span>,M=<span class="number">1</span>&lt;&lt;<span class="number">20</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">double</span> eps=<span class="number">0.000001</span>;</span><br><span class="line"><span class="keyword">int</span> n,m,t,h[N*N],s[N][N*N],f[M]=&#123;<span class="number">0</span>&#125;;</span><br><span class="line"><span class="keyword">double</span> x[N],y[N];</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">calc</span><span class="params">(<span class="keyword">int</span> u,<span class="keyword">int</span> v)</span></span>&#123;</span><br><span class="line">    <span class="keyword">double</span> a,b,p;</span><br><span class="line">    p=x[u]/x[v];</span><br><span class="line">    <span class="keyword">if</span>(<span class="built_in">abs</span>(x[u]-x[v])&lt;eps)<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    a=(y[u]-y[v]*p)/(x[u]*x[u]-x[v]*x[v]*p);</span><br><span class="line">    b=(y[u]-a*x[u]*x[u])/x[u];</span><br><span class="line">    <span class="keyword">if</span>(a&gt;-eps)<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span> ret=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;n;i++)</span><br><span class="line">        <span class="keyword">if</span>(<span class="built_in">abs</span>(y[i]-(a*x[i]*x[i]+b*x[i]))&lt;eps)ret|=<span class="number">1</span>&lt;&lt;i;</span><br><span class="line">    <span class="keyword">return</span> ret;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="comment">//freopen("angrybirds.in","r",stdin);</span></span><br><span class="line">    <span class="comment">//freopen("angrybirds.out","w",stdout);</span></span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">"%d"</span>,&amp;t);</span><br><span class="line">    <span class="keyword">while</span>(t--)&#123;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">"%d%d"</span>,&amp;n,&amp;m);m=(<span class="number">1</span>&lt;&lt;n)<span class="number">-1</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;n;i++)<span class="built_in">scanf</span>(<span class="string">"%lf%lf"</span>,&amp;x[i],&amp;y[i]);</span><br><span class="line">        <span class="keyword">int</span> k=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;n;i++)</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j=i+<span class="number">1</span>;j&lt;n;j++)h[k++]=calc(i,j);</span><br><span class="line">        sort(h,h+k);<span class="keyword">int</span> lst=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;k;i++)</span><br><span class="line">            <span class="keyword">if</span>(h[i]==<span class="number">0</span>)<span class="keyword">continue</span>;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> (lst==<span class="number">0</span>||h[i]!=h[lst<span class="number">-1</span>])h[lst++]=h[i];</span><br><span class="line">        <span class="keyword">int</span> cnt[N]=&#123;<span class="number">0</span>&#125;;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;lst;i++)</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j=h[i];j&gt;<span class="number">0</span>;j=j&amp;(j<span class="number">-1</span>))&#123;</span><br><span class="line">                <span class="keyword">int</span> p=round(<span class="built_in">log</span>(j&amp;(-j))/<span class="built_in">log</span>(<span class="number">2</span>));</span><br><span class="line">                s[p][cnt[p]++]=h[i];</span><br><span class="line">            &#125;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=m;i++)&#123;</span><br><span class="line">            <span class="keyword">int</span> p=round(<span class="built_in">log</span>(i&amp;(-i))/<span class="built_in">log</span>(<span class="number">2</span>));</span><br><span class="line">            f[i]=f[i^(<span class="number">1</span>&lt;&lt;p)]+<span class="number">1</span>;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">0</span>;j&lt;cnt[p];j++)</span><br><span class="line">                f[i]=min(f[i],f[i^(i&amp;s[p][j])]+<span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"%d\n"</span>,f[m]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//fclose(stdin);fclose(stdout);</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h1 id="写在后面"><a href="#写在后面" class="headerlink" title="写在后面"></a>写在后面</h1><p>以上即一个智障选手的noip<br>还有3天分数就出来了<br>要结束了<br>我的青春</p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;第一次也是倒数第二次noip就这么跪了，也是第一次站在一定高度上正视自己的平庸&lt;br&gt;首先，考前有两道概率题没订正，默默地立了个flag：noip不考期望，结果d1t3方程没调出来、暴力都没来得及写。&lt;br&gt;其次，以一个蒟蒻的思维能力偏偏碰上了一场难度偏高的noip，考前还在复习树剖、主席树模板，各种数据结构学傻，然而没有融入自己的思考。&lt;br&gt;最后，作为第一次noip，暴力分没有拿满也是很遗憾的&lt;br&gt;虽说是afo了，但善始善终，把坑填完。&lt;br&gt;
    
    </summary>
    
      <category term="Problem Set" scheme="https://cothrax.github.io/categories/Problem-Set/"/>
    
    
      <category term="数据结构" scheme="https://cothrax.github.io/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"/>
    
      <category term="DP" scheme="https://cothrax.github.io/tags/DP/"/>
    
      <category term="图论" scheme="https://cothrax.github.io/tags/%E5%9B%BE%E8%AE%BA/"/>
    
      <category term="最短路" scheme="https://cothrax.github.io/tags/%E6%9C%80%E7%9F%AD%E8%B7%AF/"/>
    
      <category term="概率期望" scheme="https://cothrax.github.io/tags/%E6%A6%82%E7%8E%87%E6%9C%9F%E6%9C%9B/"/>
    
      <category term="NOIP" scheme="https://cothrax.github.io/tags/NOIP/"/>
    
      <category term="背包" scheme="https://cothrax.github.io/tags/%E8%83%8C%E5%8C%85/"/>
    
      <category term="状压DP" scheme="https://cothrax.github.io/tags/%E7%8A%B6%E5%8E%8BDP/"/>
    
      <category term="数学" scheme="https://cothrax.github.io/tags/%E6%95%B0%E5%AD%A6/"/>
    
      <category term="队列" scheme="https://cothrax.github.io/tags/%E9%98%9F%E5%88%97/"/>
    
  </entry>
  
  <entry>
    <title>XJOI NOIP2016提高组冲剌题1</title>
    <link href="https://cothrax.github.io/2016/11/12/xjoi-noip-2016-test1/"/>
    <id>https://cothrax.github.io/2016/11/12/xjoi-noip-2016-test1/</id>
    <published>2016-11-12T13:20:18.000Z</published>
    <updated>2016-11-12T23:53:26.441Z</updated>
    
    <content type="html"><![CDATA[<p>在大学军的OJ上找点题练手，出题人果然比BZOJ的十连测良心。。</p>
<h1 id="T1-挖金矿"><a href="#T1-挖金矿" class="headerlink" title="T1 挖金矿"></a>T1 挖金矿</h1><p>大意：给定n×m的矩阵，在每一行选长为$k(1\leq k\leq m)$的前缀，要最大化所选数的平均值<br>$n\times m\leq 10^5,1\leq a[i,j]\leq 10^9$<br><a id="more"></a></p>
<h2 id="链接"><a href="#链接" class="headerlink" title="链接"></a>链接</h2><p><a href="http://www.hzxjhs.com:83/contest/622/problem/1" target="_blank" rel="external">XJOI</a><br><a href="/2016/11/12/xjoi-noip-2016-test1/gold.pas" title="gold.pas">gold.pas</a></p>
<h2 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h2><p>关于平均值的题目：</p>
<ol>
<li>二分统计逆序对：<a href="/2016/10/09/lydsy-noip-2016-test3/" title="十连测Test3-T1">十连测Test3-T1</a></li>
<li>二分判负环：<a href="/2016/08/30/雅礼中学2015模拟赛-Day3/" title="雅礼2015-T2">雅礼2015-T2</a></li>
</ol>
<p>考虑二分答案$x\in [0,\sum a[i,j]]$</p>
<p>将矩阵中的所有数减去x后，将每一列前缀和的最大值加起来</p>
<p>即$sum=\sum_{i=1}^n max_{1\leq k\leq h}(\sum_{j=1}^k a[i,j])$</p>
<p>如果$sum\geq 0$，那么x合法</p>
<p>细节：题中没有给出n,m的范围，用链表处理</p>
<h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><figure class="highlight delphi"><figcaption><span>gold.pas</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">uses</span> math;</span><br><span class="line"><span class="keyword">type</span> int=longint;node=<span class="keyword">record</span> w,nxt:int <span class="keyword">end</span>;</span><br><span class="line"><span class="keyword">const</span> eps=<span class="number">0.000001</span>;inf:double=<span class="number">100000000000</span>;</span><br><span class="line"><span class="keyword">var</span> </span><br><span class="line">    lnk:<span class="keyword">array</span>[<span class="number">0</span>..<span class="number">100010</span>] <span class="keyword">of</span> node;</span><br><span class="line">    head,tail:<span class="keyword">array</span>[<span class="number">0</span>..<span class="number">100010</span>] <span class="keyword">of</span> int;</span><br><span class="line">    n,m,sz,i,j,x:int;l,r,mid,ans:double;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">procedure</span> <span class="title">insert</span><span class="params">(i,x:int)</span>;</span></span><br><span class="line"><span class="keyword">begin</span></span><br><span class="line">    inc(sz);lnk[sz].w:=x;</span><br><span class="line">    <span class="keyword">if</span> head[i]=<span class="number">0</span> <span class="keyword">then</span> <span class="keyword">begin</span> head[i]:=sz;tail[i]:=sz <span class="keyword">end</span></span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">begin</span> lnk[tail[i]].nxt:=sz;tail[i]:=sz <span class="keyword">end</span>;</span><br><span class="line"><span class="keyword">end</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">jud</span><span class="params">(x:double)</span>:</span>boolean;</span><br><span class="line"><span class="keyword">var</span> sum,cur,ans:double;i,j:int;</span><br><span class="line"><span class="keyword">begin</span></span><br><span class="line">    sum:=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> i:=<span class="number">1</span> <span class="keyword">to</span> n <span class="keyword">do</span> <span class="keyword">begin</span></span><br><span class="line">        j:=head[i];cur:=<span class="number">0</span>;ans:=-inf;</span><br><span class="line">        <span class="keyword">while</span> j&lt;&gt;<span class="number">0</span> <span class="keyword">do</span> <span class="keyword">begin</span></span><br><span class="line">            cur:=cur+int64(lnk[j].w)-x;</span><br><span class="line">            ans:=max(ans,cur);</span><br><span class="line">            j:=lnk[j].nxt;</span><br><span class="line">        <span class="keyword">end</span>;</span><br><span class="line">        sum:=sum+ans;</span><br><span class="line">    <span class="keyword">end</span>;</span><br><span class="line">    jud:=sum&gt;=<span class="number">0</span>;</span><br><span class="line"><span class="keyword">end</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">begin</span></span><br><span class="line">    <span class="comment">//assign(input,'gold.in');reset(input);</span></span><br><span class="line">    <span class="comment">//assign(output,'gold.out');rewrite(output);</span></span><br><span class="line">    <span class="keyword">read</span>(n,m);sz:=<span class="number">0</span>;</span><br><span class="line">    l:=<span class="number">0</span>;r:=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> i:=<span class="number">1</span> <span class="keyword">to</span> n <span class="keyword">do</span></span><br><span class="line">        <span class="keyword">for</span> j:=<span class="number">1</span> <span class="keyword">to</span> m <span class="keyword">do</span> <span class="keyword">begin</span></span><br><span class="line">            <span class="keyword">read</span>(x);insert(i,x);r:=r+x;</span><br><span class="line">        <span class="keyword">end</span>;</span><br><span class="line">    <span class="keyword">while</span> r-l&gt;eps <span class="keyword">do</span> <span class="keyword">begin</span></span><br><span class="line">        mid:=(l+r)/<span class="number">2</span>;</span><br><span class="line">        <span class="keyword">if</span> jud(mid) <span class="keyword">then</span> <span class="keyword">begin</span> ans:=mid;l:=mid <span class="keyword">end</span></span><br><span class="line">        <span class="keyword">else</span> r:=mid;</span><br><span class="line">    <span class="keyword">end</span>;</span><br><span class="line">    <span class="keyword">write</span>(ans:<span class="number">0</span>:<span class="number">4</span>);</span><br><span class="line">    <span class="comment">//close(input);close(output);</span></span><br><span class="line"><span class="keyword">end</span>.</span><br></pre></td></tr></table></figure>
<h1 id="T2-道路规划"><a href="#T2-道路规划" class="headerlink" title="T2 道路规划"></a>T2 道路规划</h1><p>大意：给定1..n的两个全排列a和b，一上一下排成一行，把a和b中对应的数字用直线连起来，定义点集S：该集合中的任意两个数对应的连线相交。求S的最大规模<br>如图：<br><img src="/2016/11/12/xjoi-noip-2016-test1/g.png" alt="g.png" title=""></p>
<h2 id="链接-1"><a href="#链接-1" class="headerlink" title="链接"></a>链接</h2><p><a href="http://www.hzxjhs.com:83/contest/622/problem/2" target="_blank" rel="external">XJOI</a><br><a href="/2016/11/12/xjoi-noip-2016-test1/road.pas" title="road.pas">road.pas</a></p>
<h2 id="题解-1"><a href="#题解-1" class="headerlink" title="题解"></a>题解</h2><p>记la[i]为i在a中的下标，lb[i]为i在b中的下标<br>因为如果i和j的线相交，那么必然有$(la[i]-la[j])(lb[i]-lb[j])&lt;0$<br>以lb[a[i]]作为i的权值，就规约为了LDS<br>可以二分或用树状数组优化到$O(NlogN)$</p>
<h2 id="代码-1"><a href="#代码-1" class="headerlink" title="代码"></a>代码</h2><figure class="highlight delphi"><figcaption><span>road.pas</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">uses</span> math;</span><br><span class="line"><span class="keyword">type</span> int=longint;</span><br><span class="line"><span class="keyword">var</span> </span><br><span class="line">    n,i,j:int;</span><br><span class="line">    a,b,f,bit:<span class="keyword">array</span>[<span class="number">0</span>..<span class="number">100010</span>] <span class="keyword">of</span> int;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">procedure</span> <span class="title">add</span><span class="params">(x,k:int)</span>;</span></span><br><span class="line"><span class="keyword">begin</span></span><br><span class="line">    <span class="keyword">while</span> x&lt;=n <span class="keyword">do</span> <span class="keyword">begin</span></span><br><span class="line">        bit[x]:=max(bit[x],k);</span><br><span class="line">        x:=x+x <span class="keyword">and</span> (-x);</span><br><span class="line">    <span class="keyword">end</span>;</span><br><span class="line"><span class="keyword">end</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">query</span><span class="params">(x:int)</span>:</span>int;</span><br><span class="line"><span class="keyword">begin</span></span><br><span class="line">    query:=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span> x&gt;<span class="number">0</span> <span class="keyword">do</span> <span class="keyword">begin</span></span><br><span class="line">        query:=max(query,bit[x]);</span><br><span class="line">        x:=x <span class="keyword">and</span> (x-<span class="number">1</span>);</span><br><span class="line">    <span class="keyword">end</span>;</span><br><span class="line"><span class="keyword">end</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">begin</span></span><br><span class="line">    <span class="comment">//assign(input,'road.in');reset(input);</span></span><br><span class="line">    <span class="comment">//assign(output,'road.out');rewrite(output);</span></span><br><span class="line">    <span class="keyword">read</span>(n);</span><br><span class="line">    <span class="keyword">for</span> i:=<span class="number">1</span> <span class="keyword">to</span> n <span class="keyword">do</span> <span class="keyword">begin</span> <span class="keyword">read</span>(j);a[j]:=i <span class="keyword">end</span>;</span><br><span class="line">    <span class="keyword">for</span> i:=<span class="number">1</span> <span class="keyword">to</span> n <span class="keyword">do</span> <span class="keyword">begin</span> <span class="keyword">read</span>(j);b[a[j]]:=i <span class="keyword">end</span>;</span><br><span class="line">    <span class="keyword">for</span> i:=<span class="number">1</span> <span class="keyword">to</span> n <span class="keyword">do</span> <span class="keyword">begin</span></span><br><span class="line">        f[i]:=query(n-b[i]+<span class="number">1</span>)+<span class="number">1</span>;  <span class="comment">//i-&gt;n-i+1</span></span><br><span class="line">        add(n-b[i]+<span class="number">1</span>,f[i]);</span><br><span class="line">    <span class="keyword">end</span>;</span><br><span class="line">    <span class="keyword">for</span> i:=<span class="number">2</span> <span class="keyword">to</span> n <span class="keyword">do</span> f[i]:=max(f[i],f[i-<span class="number">1</span>]);</span><br><span class="line">    <span class="keyword">write</span>(f[n]);</span><br><span class="line">    <span class="comment">//close(input);close(output);</span></span><br><span class="line"><span class="keyword">end</span>.</span><br></pre></td></tr></table></figure>
<h1 id="T3-排队"><a href="#T3-排队" class="headerlink" title="T3 排队"></a>T3 排队</h1><p>题意很崎岖，自己去看链接吧</p>
<h2 id="链接-2"><a href="#链接-2" class="headerlink" title="链接"></a>链接</h2><p><a href="http://www.hzxjhs.com:83/contest/622/problem/3" target="_blank" rel="external">XJOI</a><br><a href="/2016/11/12/xjoi-noip-2016-test1/queue.pas" title="queue.pas">queue.pas</a><br><a href="/2016/11/12/xjoi-noip-2016-test1/queue_tmp.pas" title="queue_tmp.pas">queue_tmp.pas</a></p>
<h2 id="题解-2"><a href="#题解-2" class="headerlink" title="题解"></a>题解</h2><p>可以先按儿子升序的顺序dfs整棵树，其<strong>post-dfs序</strong>就是所有点的优先级，记一个点u在post-dfs序中的下标为f[u]，即一个人进来一定会选取可用点集中f值最小的点。<br>可以用一个<strong>小根堆</strong>维护可用的（空的）(f[u],u)的值对<br>这样对于操作1，直接暴力从堆中取x个最优值即可，输出值即最后一次取出的值。<br>然后对于操作2，先说说标算的方法吧<br>显然取出点x只会对x到根的路径上的点产生影响，而路径上被占用的点一定是连续的一段，影响就是将这一段下移一格，记这一段最上面的点为u，u就会空出，将它插入堆中即可。输出值为dep[x]-dep[u]，dep表示深度<br>至于怎么找u，<strong>倍增</strong>处理即可</p>
<p>然而由于没有考虑到占用的点是连续的这个性质，身为一个蒟蒻写了180+的<strong>dfs序+树状数组+线段树</strong></p>
<blockquote>
<p>Too young too naive</p>
</blockquote>
<p>bug:注意堆中值对的顺序</p>
<h2 id="代码-2"><a href="#代码-2" class="headerlink" title="代码"></a>代码</h2><p>标算解法<br><figure class="highlight delphi"><figcaption><span>queue.pas</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> int=longint;edge=<span class="keyword">record</span> v,nxt:int <span class="keyword">end</span>;</span><br><span class="line"><span class="keyword">var</span></span><br><span class="line">    g:<span class="keyword">array</span>[<span class="number">0</span>..<span class="number">200010</span>] <span class="keyword">of</span> edge;</span><br><span class="line">    head,stk,f,dep:<span class="keyword">array</span>[<span class="number">0</span>..<span class="number">100010</span>] <span class="keyword">of</span> int;</span><br><span class="line">    par:<span class="keyword">array</span>[<span class="number">0</span>..<span class="number">100010</span>,<span class="number">0</span>..<span class="number">20</span>] <span class="keyword">of</span> int;</span><br><span class="line">    hp:<span class="keyword">array</span>[<span class="number">0</span>..<span class="number">150010</span>,<span class="number">0</span>..<span class="number">1</span>] <span class="keyword">of</span> int;</span><br><span class="line">    flg:<span class="keyword">array</span>[<span class="number">0</span>..<span class="number">100010</span>] <span class="keyword">of</span> boolean;</span><br><span class="line">    n,m,sz,hs,k,lg,op,i,j,u,v,t:int;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">procedure</span> <span class="title">add</span><span class="params">(u,v:int)</span>;</span></span><br><span class="line"><span class="keyword">begin</span></span><br><span class="line">    inc(sz);g[sz].v:=v;</span><br><span class="line">    g[sz].nxt:=head[u];head[u]:=sz;</span><br><span class="line"><span class="keyword">end</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">procedure</span> <span class="title">qsort</span><span class="params">(l,r:int)</span>;</span></span><br><span class="line"><span class="keyword">var</span> i,j,x,tmp:int;</span><br><span class="line"><span class="keyword">begin</span></span><br><span class="line">    <span class="keyword">if</span> l&gt;=r <span class="keyword">then</span> <span class="keyword">exit</span>;</span><br><span class="line">    i:=l;j:=r;x:=stk[random(r-l)+l];</span><br><span class="line">    <span class="keyword">repeat</span></span><br><span class="line">        <span class="keyword">while</span> stk[i]&lt;x <span class="keyword">do</span> inc(i);</span><br><span class="line">        <span class="keyword">while</span> stk[j]&gt;x <span class="keyword">do</span> dec(j);</span><br><span class="line">        <span class="keyword">if</span> i&lt;=j <span class="keyword">then</span> <span class="keyword">begin</span></span><br><span class="line">            tmp:=stk[i];stk[i]:=stk[j];stk[j]:=tmp;</span><br><span class="line">            inc(i);dec(j);</span><br><span class="line">        <span class="keyword">end</span>;</span><br><span class="line">    <span class="keyword">until</span> i&gt;j;</span><br><span class="line">    <span class="keyword">if</span> i&lt;r <span class="keyword">then</span> qsort(i,r);</span><br><span class="line">    <span class="keyword">if</span> l&lt;j <span class="keyword">then</span> qsort(l,j);</span><br><span class="line"><span class="keyword">end</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">procedure</span> <span class="title">dfs</span><span class="params">(u,p:int)</span>;</span></span><br><span class="line"><span class="keyword">var</span> i,v,h:int;</span><br><span class="line"><span class="keyword">begin</span></span><br><span class="line">    par[u,<span class="number">0</span>]:=p;dep[u]:=dep[p]+<span class="number">1</span>;</span><br><span class="line">    i:=head[u];h:=t+<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">while</span> i&lt;&gt;<span class="number">0</span> <span class="keyword">do</span> <span class="keyword">begin</span></span><br><span class="line">        v:=g[i].v;</span><br><span class="line">        <span class="keyword">if</span> v&lt;&gt;p <span class="keyword">then</span> <span class="keyword">begin</span> inc(t);stk[t]:=v <span class="keyword">end</span>;</span><br><span class="line">        i:=g[i].nxt;</span><br><span class="line">    <span class="keyword">end</span>;</span><br><span class="line">    qsort(h,t);</span><br><span class="line">    <span class="keyword">for</span> i:=h <span class="keyword">to</span> t <span class="keyword">do</span> dfs(stk[i],u);</span><br><span class="line">    inc(k);f[u]:=k;t:=h-<span class="number">1</span>;</span><br><span class="line"><span class="keyword">end</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">//begin heap</span></span><br><span class="line"><span class="function"><span class="keyword">procedure</span> <span class="title">hfy</span><span class="params">(i:int)</span>;</span></span><br><span class="line"><span class="keyword">var</span> l,r,s:int;tmp:<span class="keyword">array</span>[<span class="number">0</span>..<span class="number">1</span>] <span class="keyword">of</span> int;</span><br><span class="line"><span class="keyword">begin</span></span><br><span class="line">    l:=i <span class="keyword">shl</span> <span class="number">1</span>;r:=l <span class="keyword">or</span> <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">if</span> (l&lt;=hs) <span class="keyword">and</span> (hp[l,<span class="number">0</span>]&lt;hp[i,<span class="number">0</span>]) <span class="keyword">then</span> s:=l <span class="keyword">else</span> s:=i;</span><br><span class="line">    <span class="keyword">if</span> (r&lt;=hs) <span class="keyword">and</span> (hp[r,<span class="number">0</span>]&lt;hp[s,<span class="number">0</span>]) <span class="keyword">then</span> s:=r;</span><br><span class="line">    <span class="keyword">if</span> s&lt;&gt;i <span class="keyword">then</span> <span class="keyword">begin</span></span><br><span class="line">        tmp:=hp[s];hp[s]:=hp[i];hp[i]:=tmp;hfy(s);</span><br><span class="line">    <span class="keyword">end</span>;</span><br><span class="line"><span class="keyword">end</span>;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">ext</span><span class="params">()</span>:</span>int;</span><br><span class="line"><span class="keyword">begin</span></span><br><span class="line">    ext:=hp[<span class="number">1</span>,<span class="number">1</span>];hp[<span class="number">1</span>]:=hp[hs];dec(hs);hfy(<span class="number">1</span>);</span><br><span class="line"><span class="keyword">end</span>;</span><br><span class="line"><span class="function"><span class="keyword">procedure</span> <span class="title">ins</span><span class="params">(w,k:int)</span>;</span></span><br><span class="line"><span class="keyword">var</span> i:int;tmp:<span class="keyword">array</span>[<span class="number">0</span>..<span class="number">1</span>] <span class="keyword">of</span> int;</span><br><span class="line"><span class="keyword">begin</span></span><br><span class="line">    inc(hs);hp[hs,<span class="number">0</span>]:=w;hp[hs,<span class="number">1</span>]:=k;i:=hs;</span><br><span class="line">    <span class="keyword">while</span> (i&gt;<span class="number">1</span>) <span class="keyword">and</span> (hp[i,<span class="number">0</span>]&lt;hp[i <span class="keyword">shr</span> <span class="number">1</span>,<span class="number">0</span>]) <span class="keyword">do</span> <span class="keyword">begin</span></span><br><span class="line">        tmp:=hp[i];hp[i]:=hp[i <span class="keyword">shr</span> <span class="number">1</span>];hp[i <span class="keyword">shr</span> <span class="number">1</span>]:=tmp;</span><br><span class="line">        i:=i <span class="keyword">shr</span> <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">end</span>;</span><br><span class="line"><span class="keyword">end</span>;</span><br><span class="line"><span class="comment">//end heap</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">procedure</span> <span class="title">op1</span><span class="params">(x:int)</span>;</span></span><br><span class="line"><span class="keyword">var</span> i:int;</span><br><span class="line"><span class="keyword">begin</span></span><br><span class="line">    <span class="keyword">for</span> i:=<span class="number">1</span> <span class="keyword">to</span> x <span class="keyword">do</span> <span class="keyword">begin</span></span><br><span class="line">        u:=ext();flg[u]:=true;</span><br><span class="line">    <span class="keyword">end</span>;</span><br><span class="line">    writeln(u);</span><br><span class="line"><span class="keyword">end</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">procedure</span> <span class="title">op2</span><span class="params">(u:int)</span>;</span></span><br><span class="line"><span class="keyword">var</span> i,v:int;</span><br><span class="line"><span class="keyword">begin</span></span><br><span class="line">    v:=u;</span><br><span class="line">    <span class="keyword">for</span> i:=lg <span class="keyword">downto</span> <span class="number">0</span> <span class="keyword">do</span></span><br><span class="line">        <span class="keyword">if</span> flg[par[v,i]] <span class="keyword">then</span> v:=par[v,i];</span><br><span class="line">    flg[v]:=false;ins(f[v],v);</span><br><span class="line">    writeln(dep[u]-dep[v]);</span><br><span class="line"><span class="keyword">end</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">begin</span></span><br><span class="line">    <span class="keyword">read</span>(n,m);sz:=<span class="number">0</span>;lg:=trunc(ln(n)/ln(<span class="number">2</span>));</span><br><span class="line">    <span class="keyword">for</span> i:=<span class="number">1</span> <span class="keyword">to</span> n-<span class="number">1</span> <span class="keyword">do</span> <span class="keyword">begin</span></span><br><span class="line">        <span class="keyword">read</span>(u,v);add(u,v);add(v,u);</span><br><span class="line">    <span class="keyword">end</span>;</span><br><span class="line">    k:=<span class="number">0</span>;t:=<span class="number">0</span>;dfs(<span class="number">1</span>,<span class="number">1</span>);</span><br><span class="line">    <span class="keyword">for</span> i:=<span class="number">1</span> <span class="keyword">to</span> lg <span class="keyword">do</span></span><br><span class="line">        <span class="keyword">for</span> j:=<span class="number">1</span> <span class="keyword">to</span> n <span class="keyword">do</span> par[j,i]:=par[par[j,i-<span class="number">1</span>],i-<span class="number">1</span>];</span><br><span class="line">    hs:=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> i:=<span class="number">1</span> <span class="keyword">to</span> n <span class="keyword">do</span> ins(f[i],i);</span><br><span class="line">    fillchar(flg,sizeof(flg),false);</span><br><span class="line">    <span class="keyword">for</span> i:=<span class="number">1</span> <span class="keyword">to</span> m <span class="keyword">do</span> <span class="keyword">begin</span></span><br><span class="line">        <span class="keyword">read</span>(op,u);</span><br><span class="line">        <span class="keyword">case</span> op <span class="keyword">of</span> <span class="number">1</span>:op1(u);<span class="number">2</span>:op2(u) <span class="keyword">end</span>;</span><br><span class="line">    <span class="keyword">end</span>;</span><br><span class="line"><span class="keyword">end</span>.</span><br></pre></td></tr></table></figure></p>
<p>巨长的sb解法<br><figure class="highlight delphi"><figcaption><span>queue.pas</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> int=longint;edge=<span class="keyword">record</span> v,nxt:int <span class="keyword">end</span>;</span><br><span class="line"><span class="keyword">var</span></span><br><span class="line">    g:<span class="keyword">array</span>[<span class="number">0</span>..<span class="number">200010</span>] <span class="keyword">of</span> edge;</span><br><span class="line">    head,stk,f,bit,lp,rp,par:<span class="keyword">array</span>[<span class="number">0</span>..<span class="number">100010</span>] <span class="keyword">of</span> int;</span><br><span class="line">    seg,tag:<span class="keyword">array</span>[<span class="number">0</span>..<span class="number">400010</span>] <span class="keyword">of</span> int;</span><br><span class="line">    hp:<span class="keyword">array</span>[<span class="number">0</span>..<span class="number">150010</span>,<span class="number">0</span>..<span class="number">1</span>] <span class="keyword">of</span> int;</span><br><span class="line">    n,m,sz,hs,k,cnt,op,i,u,v,t:int;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">procedure</span> <span class="title">add</span><span class="params">(u,v:int)</span>;</span></span><br><span class="line"><span class="keyword">begin</span></span><br><span class="line">    inc(sz);g[sz].v:=v;</span><br><span class="line">    g[sz].nxt:=head[u];head[u]:=sz;</span><br><span class="line"><span class="keyword">end</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">procedure</span> <span class="title">swap</span><span class="params">(<span class="keyword">var</span> a,b:int)</span>;</span></span><br><span class="line"><span class="keyword">var</span> tmp:int;</span><br><span class="line"><span class="keyword">begin</span> tmp:=a;a:=b;b:=tmp <span class="keyword">end</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">procedure</span> <span class="title">qsort</span><span class="params">(l,r:int)</span>;</span></span><br><span class="line"><span class="keyword">var</span> i,j,x:int;</span><br><span class="line"><span class="keyword">begin</span></span><br><span class="line">    <span class="keyword">if</span> l&gt;=r <span class="keyword">then</span> <span class="keyword">exit</span>;</span><br><span class="line">    i:=l;j:=r;x:=stk[random(r-l)+l];</span><br><span class="line">    <span class="keyword">repeat</span></span><br><span class="line">        <span class="keyword">while</span> stk[i]&lt;x <span class="keyword">do</span> inc(i);</span><br><span class="line">        <span class="keyword">while</span> stk[j]&gt;x <span class="keyword">do</span> dec(j);</span><br><span class="line">        <span class="keyword">if</span> i&lt;=j <span class="keyword">then</span> <span class="keyword">begin</span></span><br><span class="line">            swap(stk[i],stk[j]);inc(i);dec(j);</span><br><span class="line">        <span class="keyword">end</span>;</span><br><span class="line">    <span class="keyword">until</span> i&gt;j;</span><br><span class="line">    <span class="keyword">if</span> i&lt;r <span class="keyword">then</span> qsort(i,r);</span><br><span class="line">    <span class="keyword">if</span> l&lt;j <span class="keyword">then</span> qsort(l,j);</span><br><span class="line"><span class="keyword">end</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">procedure</span> <span class="title">dfs</span><span class="params">(u,p:int)</span>;</span></span><br><span class="line"><span class="keyword">var</span> i,v,h:int;</span><br><span class="line"><span class="keyword">begin</span></span><br><span class="line">    par[u]:=p;i:=head[u];h:=t+<span class="number">1</span>;inc(cnt);lp[u]:=cnt;</span><br><span class="line">    <span class="keyword">while</span> i&lt;&gt;<span class="number">0</span> <span class="keyword">do</span> <span class="keyword">begin</span></span><br><span class="line">        v:=g[i].v;</span><br><span class="line">        <span class="keyword">if</span> v&lt;&gt;p <span class="keyword">then</span> <span class="keyword">begin</span> inc(t);stk[t]:=v <span class="keyword">end</span>;</span><br><span class="line">        i:=g[i].nxt;</span><br><span class="line">    <span class="keyword">end</span>;</span><br><span class="line">    qsort(h,t);</span><br><span class="line">    <span class="keyword">for</span> i:=h <span class="keyword">to</span> t <span class="keyword">do</span> dfs(stk[i],u);</span><br><span class="line">    inc(k);f[u]:=k;t:=h-<span class="number">1</span>;rp[u]:=cnt;</span><br><span class="line"><span class="keyword">end</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">//begin heap</span></span><br><span class="line"><span class="function"><span class="keyword">procedure</span> <span class="title">hfy</span><span class="params">(i:int)</span>;</span></span><br><span class="line"><span class="keyword">var</span> l,r,s:int;</span><br><span class="line"><span class="keyword">begin</span></span><br><span class="line">    l:=i <span class="keyword">shl</span> <span class="number">1</span>;r:=l <span class="keyword">or</span> <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">if</span> (l&lt;=hs) <span class="keyword">and</span> (hp[l,<span class="number">0</span>]&lt;hp[i,<span class="number">0</span>]) <span class="keyword">then</span> s:=l <span class="keyword">else</span> s:=i;</span><br><span class="line">    <span class="keyword">if</span> (r&lt;=hs) <span class="keyword">and</span> (hp[r,<span class="number">0</span>]&lt;hp[s,<span class="number">0</span>]) <span class="keyword">then</span> s:=r;</span><br><span class="line">    <span class="keyword">if</span> s&lt;&gt;i <span class="keyword">then</span> <span class="keyword">begin</span></span><br><span class="line">        swap(hp[s,<span class="number">0</span>],hp[i,<span class="number">0</span>]);swap(hp[s,<span class="number">1</span>],hp[i,<span class="number">1</span>]);</span><br><span class="line">        hfy(s);</span><br><span class="line">    <span class="keyword">end</span>;</span><br><span class="line"><span class="keyword">end</span>;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">ext</span><span class="params">()</span>:</span>int;</span><br><span class="line"><span class="keyword">begin</span></span><br><span class="line">    ext:=hp[<span class="number">1</span>,<span class="number">1</span>];hp[<span class="number">1</span>]:=hp[hs];dec(hs);hfy(<span class="number">1</span>);</span><br><span class="line"><span class="keyword">end</span>;</span><br><span class="line"><span class="function"><span class="keyword">procedure</span> <span class="title">ins</span><span class="params">(w,k:int)</span>;</span></span><br><span class="line"><span class="keyword">var</span> i,p:int;</span><br><span class="line"><span class="keyword">begin</span></span><br><span class="line">    inc(hs);hp[hs,<span class="number">0</span>]:=w;hp[hs,<span class="number">1</span>]:=k;</span><br><span class="line">    i:=hs;p:=i <span class="keyword">shr</span> <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">while</span> (i&gt;<span class="number">1</span>) <span class="keyword">and</span> (hp[i,<span class="number">0</span>]&lt;hp[p,<span class="number">0</span>]) <span class="keyword">do</span> <span class="keyword">begin</span></span><br><span class="line">        swap(hp[i,<span class="number">0</span>],hp[p,<span class="number">0</span>]);swap(hp[i,<span class="number">1</span>],hp[p,<span class="number">1</span>]);</span><br><span class="line">        i:=p;p:=p <span class="keyword">shr</span> <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">end</span>;</span><br><span class="line"><span class="keyword">end</span>;</span><br><span class="line"><span class="comment">//end heap</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//begin bit</span></span><br><span class="line"><span class="function"><span class="keyword">procedure</span> _<span class="title">add</span><span class="params">(x,k:int)</span>;</span></span><br><span class="line"><span class="keyword">begin</span></span><br><span class="line">    <span class="keyword">if</span> x=<span class="number">0</span> <span class="keyword">then</span> <span class="keyword">exit</span>;</span><br><span class="line">    <span class="keyword">while</span> x&lt;=n <span class="keyword">do</span> <span class="keyword">begin</span></span><br><span class="line">        inc(bit[x],k);inc(x,x <span class="keyword">and</span> (-x));</span><br><span class="line">    <span class="keyword">end</span>;</span><br><span class="line"><span class="keyword">end</span>;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">ask</span><span class="params">(x:int)</span>:</span>int;</span><br><span class="line"><span class="keyword">begin</span></span><br><span class="line">    ask:=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span> x&gt;<span class="number">0</span> <span class="keyword">do</span> <span class="keyword">begin</span></span><br><span class="line">        inc(ask,bit[x]);x:=x <span class="keyword">and</span> (x-<span class="number">1</span>);</span><br><span class="line">    <span class="keyword">end</span>;</span><br><span class="line"><span class="keyword">end</span>;</span><br><span class="line"><span class="comment">//end bit</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//seg-tree begin</span></span><br><span class="line"><span class="function"><span class="keyword">procedure</span> <span class="title">pushdown</span><span class="params">(i,b,e:int)</span>;</span></span><br><span class="line"><span class="keyword">begin</span></span><br><span class="line">    <span class="keyword">if</span> b&lt;e <span class="keyword">then</span> <span class="keyword">begin</span> </span><br><span class="line">        seg[i <span class="keyword">shl</span> <span class="number">1</span>]:=tag[i];tag[i <span class="keyword">shl</span> <span class="number">1</span>]:=tag[i];</span><br><span class="line">        seg[i <span class="keyword">shl</span> <span class="number">1</span> <span class="keyword">or</span> <span class="number">1</span>]:=tag[i];tag[i <span class="keyword">shl</span> <span class="number">1</span> <span class="keyword">or</span> <span class="number">1</span>]:=tag[i];</span><br><span class="line">    <span class="keyword">end</span>;</span><br><span class="line">    tag[i]:=-<span class="number">1</span>;</span><br><span class="line"><span class="keyword">end</span>;</span><br><span class="line"><span class="function"><span class="keyword">procedure</span> <span class="title">modify</span><span class="params">(i,b,e,l,r,k:int)</span>;</span></span><br><span class="line"><span class="keyword">var</span> mid:int;</span><br><span class="line"><span class="keyword">begin</span></span><br><span class="line">    <span class="keyword">if</span> (b&gt;e) <span class="keyword">or</span> (e&lt;l) <span class="keyword">or</span> (r&lt;b) <span class="keyword">then</span> <span class="keyword">exit</span>;</span><br><span class="line">    <span class="keyword">if</span> (l&lt;=b) <span class="keyword">and</span> (e&lt;=r) <span class="keyword">then</span> <span class="keyword">begin</span></span><br><span class="line">        seg[i]:=k;tag[i]:=k;<span class="keyword">exit</span>;</span><br><span class="line">    <span class="keyword">end</span>;</span><br><span class="line">    <span class="keyword">if</span> tag[i]&lt;&gt;-<span class="number">1</span> <span class="keyword">then</span> pushdown(i,b,e);</span><br><span class="line">    mid:=(b+e) <span class="keyword">shr</span> <span class="number">1</span>;seg[i]:=k;</span><br><span class="line">    modify(i <span class="keyword">shl</span> <span class="number">1</span>,b,mid,l,r,k);</span><br><span class="line">    modify(i <span class="keyword">shl</span> <span class="number">1</span> <span class="keyword">or</span> <span class="number">1</span>,mid+<span class="number">1</span>,e,l,r,k);</span><br><span class="line"><span class="keyword">end</span>;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">query</span><span class="params">(i,b,e,x:int)</span>:</span>int;</span><br><span class="line"><span class="keyword">var</span> mid:int;</span><br><span class="line"><span class="keyword">begin</span></span><br><span class="line">    <span class="keyword">if</span> b=e <span class="keyword">then</span> <span class="keyword">exit</span>(seg[i]);</span><br><span class="line">    <span class="keyword">if</span> tag[i]&lt;&gt;-<span class="number">1</span> <span class="keyword">then</span> pushdown(i,b,e);</span><br><span class="line">    mid:=(b+e) <span class="keyword">shr</span> <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">if</span> x&lt;=mid <span class="keyword">then</span> query:=query(i <span class="keyword">shl</span> <span class="number">1</span>,b,mid,x)</span><br><span class="line">    <span class="keyword">else</span> query:=query(i <span class="keyword">shl</span> <span class="number">1</span> <span class="keyword">or</span> <span class="number">1</span>,mid+<span class="number">1</span>,e,x);</span><br><span class="line"><span class="keyword">end</span>;</span><br><span class="line"><span class="comment">//seg-tree end</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//op begin</span></span><br><span class="line"><span class="function"><span class="keyword">procedure</span> <span class="title">op1</span><span class="params">(x:int)</span>;</span></span><br><span class="line"><span class="keyword">var</span> i,u:int;</span><br><span class="line"><span class="keyword">begin</span></span><br><span class="line">    <span class="keyword">for</span> i:=<span class="number">1</span> <span class="keyword">to</span> x <span class="keyword">do</span> <span class="keyword">begin</span></span><br><span class="line">        u:=ext();</span><br><span class="line">        _add(lp[u],<span class="number">1</span>);_add(rp[u]+<span class="number">1</span>,-<span class="number">1</span>);</span><br><span class="line">        modify(<span class="number">1</span>,<span class="number">1</span>,n,lp[u],rp[u],u);</span><br><span class="line">    <span class="keyword">end</span>;</span><br><span class="line">    writeln(u);</span><br><span class="line"><span class="keyword">end</span>;</span><br><span class="line"><span class="function"><span class="keyword">procedure</span> <span class="title">op2</span><span class="params">(x:int)</span>;</span></span><br><span class="line"><span class="keyword">var</span> u,v,i:int;</span><br><span class="line"><span class="keyword">begin</span></span><br><span class="line">    writeln(ask(lp[x])-<span class="number">1</span>); <span class="comment">//<span class="doctag">bug:</span> 这写在前面</span></span><br><span class="line">    u:=query(<span class="number">1</span>,<span class="number">1</span>,n,lp[x]);ins(f[u],u); <span class="comment">//<span class="doctag">bug:</span> 记得ins</span></span><br><span class="line">    _add(lp[u],-<span class="number">1</span>);_add(rp[u]+<span class="number">1</span>,<span class="number">1</span>);</span><br><span class="line">    i:=head[u];</span><br><span class="line">    <span class="keyword">while</span> i&lt;&gt;<span class="number">0</span> <span class="keyword">do</span> <span class="keyword">begin</span></span><br><span class="line">        v:=g[i].v;</span><br><span class="line">        <span class="keyword">if</span> v&lt;&gt;par[u] <span class="keyword">then</span> modify(<span class="number">1</span>,<span class="number">1</span>,n,lp[v],rp[v],v);</span><br><span class="line">        i:=g[i].nxt;</span><br><span class="line">    <span class="keyword">end</span>;</span><br><span class="line"><span class="keyword">end</span>;</span><br><span class="line"><span class="comment">//op end</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">begin</span></span><br><span class="line">    <span class="keyword">read</span>(n,m);sz:=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> i:=<span class="number">1</span> <span class="keyword">to</span> n-<span class="number">1</span> <span class="keyword">do</span> <span class="keyword">begin</span></span><br><span class="line">        <span class="keyword">read</span>(u,v);add(u,v);add(v,u);</span><br><span class="line">    <span class="keyword">end</span>;</span><br><span class="line">    cnt:=<span class="number">0</span>;k:=<span class="number">0</span>;t:=<span class="number">0</span>;dfs(<span class="number">1</span>,<span class="number">0</span>);hs:=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> i:=<span class="number">1</span> <span class="keyword">to</span> n <span class="keyword">do</span> ins(f[i],i);</span><br><span class="line">    fillchar(tag,sizeof(tag),<span class="number">255</span>);</span><br><span class="line">    <span class="keyword">for</span> i:=<span class="number">1</span> <span class="keyword">to</span> m <span class="keyword">do</span> <span class="keyword">begin</span></span><br><span class="line">        <span class="keyword">read</span>(op,u);</span><br><span class="line">        <span class="keyword">case</span> op <span class="keyword">of</span> <span class="number">1</span>:op1(u);<span class="number">2</span>:op2(u) <span class="keyword">end</span>;</span><br><span class="line">    <span class="keyword">end</span>;</span><br><span class="line"><span class="keyword">end</span>.</span><br></pre></td></tr></table></figure></p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;在大学军的OJ上找点题练手，出题人果然比BZOJ的十连测良心。。&lt;/p&gt;
&lt;h1 id=&quot;T1-挖金矿&quot;&gt;&lt;a href=&quot;#T1-挖金矿&quot; class=&quot;headerlink&quot; title=&quot;T1 挖金矿&quot;&gt;&lt;/a&gt;T1 挖金矿&lt;/h1&gt;&lt;p&gt;大意：给定n×m的矩阵，在每一行选长为$k(1\leq k\leq m)$的前缀，要最大化所选数的平均值&lt;br&gt;$n\times m\leq 10^5,1\leq a[i,j]\leq 10^9$&lt;br&gt;
    
    </summary>
    
      <category term="Problem Set" scheme="https://cothrax.github.io/categories/Problem-Set/"/>
    
    
      <category term="OI" scheme="https://cothrax.github.io/tags/OI/"/>
    
      <category term="数据结构" scheme="https://cothrax.github.io/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"/>
    
      <category term="DP" scheme="https://cothrax.github.io/tags/DP/"/>
    
      <category term="二分答案" scheme="https://cothrax.github.io/tags/%E4%BA%8C%E5%88%86%E7%AD%94%E6%A1%88/"/>
    
      <category term="堆" scheme="https://cothrax.github.io/tags/%E5%A0%86/"/>
    
      <category term="倍增" scheme="https://cothrax.github.io/tags/%E5%80%8D%E5%A2%9E/"/>
    
      <category term="线段树" scheme="https://cothrax.github.io/tags/%E7%BA%BF%E6%AE%B5%E6%A0%91/"/>
    
      <category term="线性DP" scheme="https://cothrax.github.io/tags/%E7%BA%BF%E6%80%A7DP/"/>
    
      <category term="树状数组" scheme="https://cothrax.github.io/tags/%E6%A0%91%E7%8A%B6%E6%95%B0%E7%BB%84/"/>
    
      <category term="DFS序" scheme="https://cothrax.github.io/tags/DFS%E5%BA%8F/"/>
    
  </entry>
  
  <entry>
    <title>NOIP2016 模板整理和复习</title>
    <link href="https://cothrax.github.io/2016/11/11/noip-2016-review-template/"/>
    <id>https://cothrax.github.io/2016/11/11/noip-2016-review-template/</id>
    <published>2016-11-11T14:27:34.000Z</published>
    <updated>2016-11-18T01:45:10.281Z</updated>
    
    <content type="html"><![CDATA[<p>noip前复习一些不熟悉的模板<br>在历时4个月的刷题过程中，有些算法一带而过，之写过一两次或者年代久远或者理解肤浅，需要在考前复习。<br><a id="more"></a></p>
<h2 id="Todo-List"><a href="#Todo-List" class="headerlink" title="Todo List"></a>Todo List</h2><ol>
<li><del>字符串类</del><ol>
<li><del>KMP</del></li>
<li><del>BKDRhash等</del></li>
<li><del>双Hash、rabin-karp</del></li>
</ol>
</li>
<li><del>高斯消元</del></li>
<li><del>dp类</del><ol>
<li><del>斜率优化</del></li>
<li><del>单调队列优化多重背包</del></li>
</ol>
</li>
<li><del>图论类</del><ol>
<li><del>Dinic流、二分图最大匹配</del></li>
<li><del>差分约束</del></li>
<li><del>非递归拓扑排序</del></li>
<li><del>割点/边、点双连通、边双连通</del></li>
<li><del>tarjan求lca</del></li>
<li><del>树剖</del></li>
</ol>
</li>
<li><del>数据结构类</del><ol>
<li><del>莫队</del></li>
<li><del>分块</del></li>
<li><del>Treap</del></li>
</ol>
</li>
<li>博弈论：SG函数</li>
<li>双向BFS</li>
<li><del>康托展开</del> 全排列相关</li>
</ol>
<h2 id="字符串类"><a href="#字符串类" class="headerlink" title="字符串类"></a>字符串类</h2><h3 id="KMP"><a href="#KMP" class="headerlink" title="KMP"></a>KMP</h3><p>前缀匹配后缀，参见matrix67的讲解<br><figure class="highlight delphi"><figcaption><span>kmp.pas</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> int=longint;</span><br><span class="line"><span class="function"><span class="keyword">procedure</span> <span class="title">kmp</span><span class="params">(<span class="keyword">var</span> a,b:ansistring)</span>;</span></span><br><span class="line"><span class="keyword">var</span> </span><br><span class="line">    i,j,n,m:int;</span><br><span class="line">    p:<span class="keyword">array</span>[<span class="number">0</span>..<span class="number">100010</span>] <span class="keyword">of</span> int;</span><br><span class="line"><span class="keyword">begin</span></span><br><span class="line">    n:=length(a);m:=length(b);</span><br><span class="line">    j:=<span class="number">0</span>;p[<span class="number">1</span>]:=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> i:=<span class="number">2</span> <span class="keyword">to</span> m <span class="keyword">do</span> <span class="keyword">begin</span></span><br><span class="line">        <span class="keyword">while</span> (j&gt;<span class="number">0</span>) <span class="keyword">and</span> (b[i]&lt;&gt;b[j+<span class="number">1</span>]) <span class="keyword">do</span> j:=p[j];</span><br><span class="line">        <span class="keyword">if</span> b[i]=b[j+<span class="number">1</span>] <span class="keyword">then</span> inc(j);</span><br><span class="line">        p[i]:=j;</span><br><span class="line">    <span class="keyword">end</span>;</span><br><span class="line">    j:=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> i:=<span class="number">1</span> <span class="keyword">to</span> n <span class="keyword">do</span> <span class="keyword">begin</span></span><br><span class="line">        <span class="keyword">while</span> (j&gt;<span class="number">0</span>) <span class="keyword">and</span> (a[i]&lt;&gt;b[j+<span class="number">1</span>]) <span class="keyword">do</span> j:=p[j];</span><br><span class="line">        <span class="keyword">if</span> a[i]=b[j+<span class="number">1</span>] <span class="keyword">then</span> inc(j);</span><br><span class="line">        <span class="keyword">if</span> j=m <span class="keyword">then</span> <span class="keyword">begin</span></span><br><span class="line">            writeln(i-m+<span class="number">1</span>); <span class="comment">//match</span></span><br><span class="line">            j:=p[j];</span><br><span class="line">        <span class="keyword">end</span>;</span><br><span class="line">    <span class="keyword">end</span>;</span><br><span class="line"><span class="keyword">end</span>;</span><br></pre></td></tr></table></figure></p>
<p>相关神题：</p>
<ol>
<li>应用匹配思想的dp：<a href="/2016/08/28/雅礼中学2015模拟赛-prefix/" title="雅礼2015 prefix">雅礼2015 prefix</a></li>
<li>广义匹配：<a href="/2016/08/28/JSOI2016-提高1班-Day3-message/" title="josi2016 message">josi2016 message</a></li>
</ol>
<h3 id="字符串Hash"><a href="#字符串Hash" class="headerlink" title="字符串Hash"></a>字符串Hash</h3><h4 id="Rabin-Karp类Hash"><a href="#Rabin-Karp类Hash" class="headerlink" title="Rabin-Karp类Hash"></a>Rabin-Karp类Hash</h4><p>通过进制展开得到Hash</p>
<p>$h(s)=\sum_{i=1}^{len(s)}p^{n-i}*s[i]$</p>
<p>化成递推式就是：$h(s[1,i])=h(s[1,i-1])*p+s[i]$</p>
<p>$O(N)$处理出s的前缀hash值，可以$O(1)$得到任意一段区间的hash值</p>
<p>$h(s[l,r])=h(s[1,r)-h(s[1,l-1])*p^{r-l+1}$</p>
<p>一道双hash题：<a href="/2016/08/17/JSOI2016-提高1班-Day2/" title="josi t2 drunk">josi t2 drunk</a><br>这里贴片段<br><figure class="highlight delphi"><figcaption><span>drunk.pas</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> int=longint;</span><br><span class="line"><span class="keyword">const</span></span><br><span class="line">    q:<span class="keyword">array</span>[<span class="number">0</span>..<span class="number">1</span>] <span class="keyword">of</span> int=(<span class="number">1000019</span>,<span class="number">100000007</span>);</span><br><span class="line">    p:<span class="keyword">array</span>[<span class="number">0</span>..<span class="number">1</span>] <span class="keyword">of</span> int=(<span class="number">1009</span>,<span class="number">133</span>);</span><br><span class="line"><span class="keyword">var</span></span><br><span class="line">    s:ansistring;</span><br><span class="line">    pn,f:<span class="keyword">array</span>[<span class="number">0</span>..<span class="number">1</span>,<span class="number">0</span>..<span class="number">100010</span>] <span class="keyword">of</span> int64;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">hash</span><span class="params">(l,r,j:int)</span>:</span>int64; <span class="comment">//[l,r]的hash</span></span><br><span class="line"><span class="keyword">begin</span></span><br><span class="line">    hash:=((f[j,r]-f[j,l-<span class="number">1</span>]*pn[j,r-l+<span class="number">1</span>])<span class="keyword">mod</span> q[j]+q[j])<span class="keyword">mod</span> q[j];</span><br><span class="line"><span class="keyword">end</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">procedure</span> <span class="title">init</span><span class="params">()</span>;</span> <span class="comment">//预处理前缀hash</span></span><br><span class="line"><span class="keyword">var</span> i,j,n:int;</span><br><span class="line"><span class="keyword">begin</span></span><br><span class="line">    n:=length(s);</span><br><span class="line">    <span class="keyword">for</span> i:=<span class="number">0</span> <span class="keyword">to</span> <span class="number">1</span> <span class="keyword">do</span> <span class="keyword">begin</span> f[i,<span class="number">0</span>]:=<span class="number">0</span>;pn[i,<span class="number">0</span>]:=<span class="number">1</span> <span class="keyword">end</span>;</span><br><span class="line">    <span class="keyword">for</span> i:=<span class="number">1</span> <span class="keyword">to</span> n <span class="keyword">do</span></span><br><span class="line">        <span class="keyword">for</span> j:=<span class="number">0</span> <span class="keyword">to</span> <span class="number">1</span> <span class="keyword">do</span> <span class="keyword">begin</span></span><br><span class="line">            pn[j,i]:=pn[j,i-<span class="number">1</span>]*p[j] <span class="keyword">mod</span> q[i];</span><br><span class="line">            f[j,i]:=(f[j,i-<span class="number">1</span>]*p[j]+ord(s[i])) <span class="keyword">mod</span> q[i];</span><br><span class="line">        <span class="keyword">end</span>;</span><br><span class="line"><span class="keyword">end</span>;</span><br></pre></td></tr></table></figure></p>
<h4 id="BKDRhash"><a href="#BKDRhash" class="headerlink" title="BKDRhash"></a>BKDRhash</h4><figure class="highlight delphi"><figcaption><span>string_hash</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">bkdr</span><span class="params">(<span class="keyword">var</span> s:<span class="keyword">string</span>)</span>:</span>dword;</span><br><span class="line"><span class="keyword">var</span> i:int;</span><br><span class="line"><span class="keyword">begin</span></span><br><span class="line">    bkdr:=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> i:=<span class="number">1</span> <span class="keyword">to</span> length(s) <span class="keyword">do</span></span><br><span class="line">        bkdr:=(bkdr*p+ord(s[i])) <span class="keyword">and</span> <span class="keyword">not</span> (<span class="number">15</span> <span class="keyword">shl</span> <span class="number">7</span>);</span><br><span class="line"><span class="keyword">end</span>;</span><br></pre></td></tr></table></figure>
<h2 id="DP类"><a href="#DP类" class="headerlink" title="DP类"></a>DP类</h2><h3 id="单调队列优化多重背包"><a href="#单调队列优化多重背包" class="headerlink" title="单调队列优化多重背包"></a>单调队列优化多重背包</h3><p>原来的方程：$f[i,j]=max(f[i-1,j-k*c[i]+k*v[i])$</p>
<p>记$j=b+a*v[i]$，代入得：</p>
<p>$f[i,j]=max(f[i-1,b+(a-k)*c[i]]-(a-k)*v[i]+a*v[i])$</p>
<p>即分离出具有单调性的部分，记$k=a-k$：</p>
<p>$f[i,j]=max(f[i-1,b+k*c[i]]-k*v[i])+a*v[i],a-k\leq a[i]$</p>
<p>然后可以根据剩余系b分别做单调队列<br>题目见此：<a href="/2016/08/20/JSOI2016-提高2班-单调队列及动规优化/" title="t2 war">t2 war</a><br><figure class="highlight delphi"><figcaption><span>war.pas</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">d:=<span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span> i:=<span class="number">1</span> <span class="keyword">to</span> n <span class="keyword">do</span> <span class="keyword">begin</span></span><br><span class="line">    d:=min(m,d+c[i]*a[i]); <span class="comment">//当前最大总体积</span></span><br><span class="line">    <span class="keyword">for</span> j:=<span class="number">0</span> <span class="keyword">to</span> c[i]-<span class="number">1</span> <span class="keyword">do</span> <span class="keyword">begin</span> <span class="comment">//枚举剩余系b</span></span><br><span class="line">        h:=<span class="number">1</span>;t:=<span class="number">0</span>;k:=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span> j+c[i]*k&lt;=d <span class="keyword">do</span> <span class="keyword">begin</span> <span class="comment">//枚举系数</span></span><br><span class="line">            <span class="keyword">while</span> (h&lt;=t) <span class="keyword">and</span> (q[t,<span class="number">0</span>]&lt;=f[j+c[i]*k]-v[i]*k) <span class="keyword">do</span> dec(t);</span><br><span class="line">            inc(t);q[t,<span class="number">1</span>]:=k;q[t,<span class="number">0</span>]:=f[j+c[i]*k]-v[i]*k; <span class="comment">//max()中维护的值入队</span></span><br><span class="line">            <span class="keyword">while</span> (h&lt;=t) <span class="keyword">and</span> (k-q[h,<span class="number">1</span>]&gt;a[i]) <span class="keyword">do</span> inc(h); <span class="comment">//超出数量限制出队</span></span><br><span class="line">            f[j+c[i]*k]:=max(f[j+c[i]*k],q[h,<span class="number">0</span>]+k*v[i]);</span><br><span class="line">            inc(k);</span><br><span class="line">        <span class="keyword">end</span>;</span><br><span class="line">    <span class="keyword">end</span>;</span><br><span class="line"><span class="keyword">end</span>;</span><br></pre></td></tr></table></figure></p>
<h3 id="斜率优化"><a href="#斜率优化" class="headerlink" title="斜率优化"></a>斜率优化</h3><p>具体题目，以及推<del>倒</del>导细节见：<a href="/2016/08/29/JSOI2016-提高1班-Day3-separate/" title="[JSOI2016] 提高1班 Day3 separate">[JSOI2016] 提高1班 Day3 separate</a></p>
<p><strong>简要的思路：</strong><br>原方程：$f[i,j]=min(f[i-1,k-1]+(a[k]-a[j])^2)$</p>
<p>记：$x[i]=a[i],y[i]=f[i-1,j-1]+a[i]^2$</p>
<p>推得：$g(k,t)\leq 2a[j],k&gt;t$(*)，则k优于t</p>
<p><strong>新的认识：</strong></p>
<ol>
<li>根据式(*)，若$t=q[h],k=q[h+1]$，则从头出队，因为此时$g(k,t)$已经小于$a[i]$，<strong>a是单调递增的</strong>，k不可能再成为最优解</li>
<li>然后是从尾出队，这个单调队列维护的实际上是一个<strong>上凸的凸包</strong>，因为根据式(*)，我们希望<strong>斜率尽量小</strong><br>那么记$k=q[t-1],t=q[t],l$为新插入的点，如果$g(k,t)&gt;g(t,l)$，那么此时直接将l接到队尾<strong>破坏了上凸的性质</strong>，因此t出队。也可以理解成由于g(t,l)一定优于g(k,t)，那么t不再可能成为最优解</li>
</ol>
<p><strong>核心代码</strong>：（出入队条件很长很丑，可以写成函数但会增大常数）</p>
<figure class="highlight delphi"><figcaption><span>glope.pas</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> i:=<span class="number">1</span> <span class="keyword">to</span> n <span class="keyword">do</span> f[<span class="number">1</span>,i]:=sqr(a[i]);</span><br><span class="line"><span class="keyword">for</span> i:=<span class="number">2</span> <span class="keyword">to</span> m <span class="keyword">do</span> <span class="keyword">begin</span></span><br><span class="line">    h:=<span class="number">0</span>;t:=<span class="number">0</span>;q[h]:=i-<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span> j:=i <span class="keyword">to</span> n <span class="keyword">do</span> <span class="keyword">begin</span> <span class="comment">//f[i,j]当j&lt;i时不合法</span></span><br><span class="line">        x[j]:=a[j];</span><br><span class="line">        y[j]:=f[i-<span class="number">1</span>,j-<span class="number">1</span>]+sqr(a[j]);</span><br><span class="line">        <span class="comment">//g(j,q[t])&lt;=g(q[t],q[t-1])</span></span><br><span class="line">        <span class="keyword">while</span> (h&lt;t) <span class="keyword">and</span> ((y[j]-y[q[t]])*(x[q[t]]-x[q[t]-<span class="number">1</span>])</span><br><span class="line">            &lt;=(y[q[t]]-y[q[t]-<span class="number">1</span>])*(x[j]-x[q[t]])) <span class="keyword">do</span> dec(t);</span><br><span class="line">        inc(t);q[t]:=j;</span><br><span class="line">        <span class="comment">//g(q[h],q[h+1])&lt;=2*a[i]</span></span><br><span class="line">        <span class="keyword">while</span> (h&lt;t) <span class="keyword">and</span> ((y[q[h]]-y[q[h+<span class="number">1</span>]])</span><br><span class="line">            &lt;=<span class="number">2</span>*a[i]*(x[q[h]]-x[q[h+<span class="number">1</span>]])) <span class="keyword">do</span> inc(h);</span><br><span class="line">        f[i,j]:=f[i-<span class="number">1</span>,q[h]-<span class="number">1</span>]+sqr(a[q[h]]-a[j]);</span><br><span class="line">    <span class="keyword">end</span>;</span><br><span class="line"><span class="keyword">end</span>;</span><br></pre></td></tr></table></figure>
<h2 id="图论类"><a href="#图论类" class="headerlink" title="图论类"></a>图论类</h2><h3 id="Dinic最大流"><a href="#Dinic最大流" class="headerlink" title="Dinic最大流"></a>Dinic最大流</h3><p>这玩意noip不考吧，费用流到现在还不会orz<br>注意点</p>
<ol>
<li>邻接表从下标2开始存，这样的话方便用<code>i xor 1</code>找到反向边</li>
<li>这种dinic写法应用了一个优化：一次dfs找出多条增广路，因此不需要iter数组</li>
</ol>
<figure class="highlight delphi"><figcaption><span>dinic.pas</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">uses</span> math;</span><br><span class="line"><span class="keyword">const</span> mxn=<span class="number">100010</span>;mxm=<span class="number">100010</span>;inf=maxlongint;</span><br><span class="line"><span class="keyword">type</span></span><br><span class="line">    int=longint;</span><br><span class="line">    edge=<span class="keyword">record</span> v,w,nxt:int <span class="keyword">end</span>;</span><br><span class="line"><span class="keyword">var</span></span><br><span class="line">    g:<span class="keyword">array</span>[<span class="number">0</span>..mxm*<span class="number">2</span>] <span class="keyword">of</span> edge;</span><br><span class="line">    head,d:<span class="keyword">array</span>[<span class="number">0</span>..mxn] <span class="keyword">of</span> int;</span><br><span class="line">    n,m,sz:int;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">procedure</span> <span class="title">add</span><span class="params">(u,v,w:int)</span>;</span></span><br><span class="line"><span class="keyword">begin</span></span><br><span class="line">    inc(sz);g[sz].v:=v;</span><br><span class="line">    g[sz].nxt:=head[u];head[u]:=sz;</span><br><span class="line"><span class="keyword">end</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">bfs</span><span class="params">(s,t0:int)</span>:</span>boolean;</span><br><span class="line"><span class="keyword">var</span></span><br><span class="line">    q:<span class="keyword">array</span>[<span class="number">0</span>..mxn] <span class="keyword">of</span> int;</span><br><span class="line">    h,t,i,u,v:int;</span><br><span class="line"><span class="keyword">begin</span></span><br><span class="line">    fillchar(d,sizeof(d),<span class="number">255</span>);</span><br><span class="line">    h:=<span class="number">1</span>;t:=<span class="number">2</span>;q[h]:=s;d[s]:=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span> h&lt;&gt;t <span class="keyword">do</span> <span class="keyword">begin</span></span><br><span class="line">        u:=q[h];inc(h);i:=head[u];</span><br><span class="line">        <span class="keyword">while</span> i&lt;&gt;<span class="number">0</span> <span class="keyword">do</span> <span class="keyword">begin</span></span><br><span class="line">            v:=g[i].v;</span><br><span class="line">            <span class="keyword">if</span> (g[i].w&gt;<span class="number">0</span>)<span class="keyword">and</span>(d[v]=-<span class="number">1</span>) <span class="keyword">then</span></span><br><span class="line">                <span class="keyword">begin</span> d[v]:=d[u]+<span class="number">1</span>;q[t]:=v;inc(t) <span class="keyword">end</span>;</span><br><span class="line">            i:=g[i].nxt;</span><br><span class="line">        <span class="keyword">end</span>;</span><br><span class="line">    <span class="keyword">end</span>;</span><br><span class="line">    bfs:=d[t0]&lt;&gt;-<span class="number">1</span>;</span><br><span class="line"><span class="keyword">end</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">dfs</span><span class="params">(u,t,f:int)</span>:</span>int;</span><br><span class="line"><span class="keyword">var</span> tmp,v,i:int;</span><br><span class="line"><span class="keyword">begin</span></span><br><span class="line">    <span class="keyword">if</span> u=t <span class="keyword">then</span> <span class="keyword">exit</span>(f);</span><br><span class="line">    i:=head[u];dfs:=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span> i&lt;&gt;<span class="number">0</span> <span class="keyword">do</span> <span class="keyword">begin</span></span><br><span class="line">        v:=g[i].v;</span><br><span class="line">        <span class="keyword">if</span> (g[i].w&gt;<span class="number">0</span>)<span class="keyword">and</span>(d[v]=d[u]+<span class="number">1</span>) <span class="keyword">then</span> <span class="keyword">begin</span> <span class="comment">//&gt;0的条件不要忘</span></span><br><span class="line">            tmp:=dfs(v,t,min(g[i].w,f-dfs));</span><br><span class="line">            dec(g[i].w,tmp);inc(g[i xor <span class="number">1</span>].w,tmp);inc(dfs,tmp);</span><br><span class="line">            <span class="keyword">if</span> dfs=f <span class="keyword">then</span> <span class="keyword">exit</span>(f);</span><br><span class="line">        <span class="keyword">end</span>;</span><br><span class="line">        i:=g[i].nxt;</span><br><span class="line">    <span class="keyword">end</span>;</span><br><span class="line">    <span class="keyword">if</span> dfs=<span class="number">0</span> <span class="keyword">then</span> d[u]:=-<span class="number">1</span>;</span><br><span class="line"><span class="keyword">end</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">maxflow</span><span class="params">(s,t:int)</span>:</span>int;</span><br><span class="line"><span class="keyword">begin</span></span><br><span class="line">    maxflow:=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span> bfs(s,t) <span class="keyword">do</span> inc(maxflow,dfs(s,t,inf));</span><br><span class="line"><span class="keyword">end</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">begin</span> <span class="keyword">end</span>.</span><br></pre></td></tr></table></figure>
<h3 id="非递归拓扑排序"><a href="#非递归拓扑排序" class="headerlink" title="非递归拓扑排序"></a>非递归拓扑排序</h3><p>topo返回值表示是否是dag</p>
<figure class="highlight delphi"><figcaption><span>topo.pas</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">topo</span><span class="params">()</span>:</span>boolean;</span><br><span class="line"><span class="keyword">var</span> </span><br><span class="line">    i,v,u,h,t:int;</span><br><span class="line">    deg,q:<span class="keyword">array</span>[<span class="number">0</span>..mxn] <span class="keyword">of</span> int;</span><br><span class="line"><span class="keyword">begin</span></span><br><span class="line">    fillchar(deg,sizeof(deg),<span class="number">0</span>);</span><br><span class="line">    <span class="keyword">for</span> i:=<span class="number">1</span> <span class="keyword">to</span> sz <span class="keyword">do</span> inc(deg[g[i].v]);</span><br><span class="line">    h:=<span class="number">1</span>;t:=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> i:=<span class="number">1</span> <span class="keyword">to</span> n <span class="keyword">do</span></span><br><span class="line">        <span class="keyword">if</span> deg[i]=<span class="number">0</span> <span class="keyword">then</span> <span class="keyword">begin</span> inc(t);q[t]:=i <span class="keyword">end</span>;</span><br><span class="line">    <span class="keyword">while</span> h&lt;=t <span class="keyword">do</span> <span class="keyword">begin</span></span><br><span class="line">        u:=q[h];inc(h);i:=head[u];</span><br><span class="line">        <span class="keyword">while</span> i&lt;&gt;<span class="number">0</span> <span class="keyword">do</span> <span class="keyword">begin</span></span><br><span class="line">            v:=g[i].v;dec(deg[v]);</span><br><span class="line">            <span class="keyword">if</span> deg[v]=<span class="number">0</span> <span class="keyword">then</span> <span class="keyword">begin</span> inc(t);q[t]:=v <span class="keyword">end</span>;</span><br><span class="line">            i:=g[i].nxt;</span><br><span class="line">        <span class="keyword">end</span>;</span><br><span class="line">    <span class="keyword">end</span>;</span><br><span class="line">    topo:=t=n;</span><br><span class="line"><span class="keyword">end</span>;</span><br></pre></td></tr></table></figure>
<h3 id="差分约束"><a href="#差分约束" class="headerlink" title="差分约束"></a>差分约束</h3><p>规约为最短路即可，可以先想最短路：从u-&gt;v有权为w的边，那么$d[v]\geq d[u]+w$<br>然后将所有不等式变形成这个形式，建图即可。<br>如果求某两个变量差的最小值，则要用最长路解决<br>这类题目做的很少，<a href="/2016/07/25/Luogu-P1993-小K的农场/" title="[Luogu] P1993 小K的农场">[Luogu] P1993 小K的农场</a></p>
<blockquote>
<p>留一个坑：<a href="http://www.cppblog.com/menjitianya/archive/2015/11/19/212292.html" target="_blank" rel="external">http://www.cppblog.com/menjitianya/archive/2015/11/19/212292.html</a></p>
</blockquote>
<h3 id="tarjan-lca"><a href="#tarjan-lca" class="headerlink" title="tarjan-lca"></a>tarjan-lca</h3><p>离线+链表+并查集+dfs<br>链接：<a href="http://begin.lydsy.com/JudgeOnline/problem.php?id=1939" target="_blank" rel="external">1939: [usaco2008 Oct]Pasture Walking 牧场旅行</a><br>当然这题完全可以在线倍增/树剖<br><figure class="highlight delphi"><figcaption><span>1939.pas</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span></span><br><span class="line">    int=longint;</span><br><span class="line">    edge=<span class="keyword">record</span> v,w,nxt:int <span class="keyword">end</span>;</span><br><span class="line">    node=<span class="keyword">record</span> k,v,nxt:int <span class="keyword">end</span>;</span><br><span class="line"><span class="keyword">var</span></span><br><span class="line">    g:<span class="keyword">array</span>[<span class="number">0</span>..<span class="number">2010</span>] <span class="keyword">of</span> edge;</span><br><span class="line">    lnk:<span class="keyword">array</span>[<span class="number">0</span>..<span class="number">2010</span>] <span class="keyword">of</span> node;</span><br><span class="line">    head,ptr,d,par,ans:<span class="keyword">array</span>[<span class="number">0</span>..<span class="number">1010</span>] <span class="keyword">of</span> int;</span><br><span class="line">    q:<span class="keyword">array</span>[<span class="number">0</span>..<span class="number">1010</span>,<span class="number">0</span>..<span class="number">1</span>] <span class="keyword">of</span> int;</span><br><span class="line">    vis:<span class="keyword">array</span>[<span class="number">0</span>..<span class="number">1010</span>] <span class="keyword">of</span> boolean;</span><br><span class="line">    n,m,sz,sl,i,u,v,w:int;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">procedure</span> <span class="title">add</span><span class="params">(u,v,w:int)</span>;</span></span><br><span class="line"><span class="keyword">begin</span></span><br><span class="line">    inc(sz);g[sz].v:=v;g[sz].w:=w;</span><br><span class="line">    g[sz].nxt:=head[u];head[u]:=sz;</span><br><span class="line"><span class="keyword">end</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">procedure</span> <span class="title">ins</span><span class="params">(k,u,v:int)</span>;</span></span><br><span class="line"><span class="keyword">begin</span></span><br><span class="line">    inc(sl);lnk[sl].k:=k;lnk[sl].v:=v;</span><br><span class="line">    lnk[sl].nxt:=ptr[u];ptr[u]:=sl;</span><br><span class="line"><span class="keyword">end</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">find</span><span class="params">(x:int)</span>:</span>int;</span><br><span class="line"><span class="keyword">begin</span></span><br><span class="line">    <span class="keyword">if</span> par[x]=x <span class="keyword">then</span> find:=x</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">begin</span></span><br><span class="line">        par[x]:=find(par[x]);</span><br><span class="line">        find:=par[x];</span><br><span class="line">    <span class="keyword">end</span>;</span><br><span class="line"><span class="keyword">end</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">procedure</span> <span class="title">union</span><span class="params">(x,y:int)</span>;</span></span><br><span class="line"><span class="keyword">begin</span></span><br><span class="line">    x:=find(x);y:=find(y);par[y]:=x;</span><br><span class="line"><span class="keyword">end</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">procedure</span> <span class="title">dfs</span><span class="params">(u,p:int)</span>;</span></span><br><span class="line"><span class="keyword">var</span> i,v,lca:int;</span><br><span class="line"><span class="keyword">begin</span></span><br><span class="line">    vis[u]:=true;i:=head[u];</span><br><span class="line">    <span class="keyword">while</span> i&lt;&gt;<span class="number">0</span> <span class="keyword">do</span> <span class="keyword">begin</span></span><br><span class="line">        v:=g[i].v;</span><br><span class="line">        <span class="keyword">if</span> v&lt;&gt;p <span class="keyword">then</span> <span class="keyword">begin</span></span><br><span class="line">            d[v]:=d[u]+g[i].w;dfs(v,u);union(u,v);</span><br><span class="line">        <span class="keyword">end</span>;</span><br><span class="line">        i:=g[i].nxt;</span><br><span class="line">    <span class="keyword">end</span>;</span><br><span class="line">    i:=ptr[u];</span><br><span class="line">    <span class="keyword">while</span> i&lt;&gt;<span class="number">0</span> <span class="keyword">do</span> <span class="keyword">begin</span></span><br><span class="line">        v:=lnk[i].v;</span><br><span class="line">        <span class="keyword">if</span> vis[v] <span class="keyword">then</span> <span class="keyword">begin</span></span><br><span class="line">            lca:=find(v);</span><br><span class="line">            ans[lnk[i].k]:=d[v]+d[u]-<span class="number">2</span>*d[lca];</span><br><span class="line">        <span class="keyword">end</span>;</span><br><span class="line">        i:=lnk[i].nxt;</span><br><span class="line">    <span class="keyword">end</span>;</span><br><span class="line"><span class="keyword">end</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">begin</span></span><br><span class="line">    <span class="keyword">read</span>(n,m);sz:=<span class="number">0</span>;sl:=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> i:=<span class="number">1</span> <span class="keyword">to</span> n-<span class="number">1</span> <span class="keyword">do</span> <span class="keyword">begin</span></span><br><span class="line">        <span class="keyword">read</span>(u,v,w);add(u,v,w);add(v,u,w);</span><br><span class="line">    <span class="keyword">end</span>;</span><br><span class="line">    <span class="keyword">for</span> i:=<span class="number">1</span> <span class="keyword">to</span> m <span class="keyword">do</span> <span class="keyword">begin</span></span><br><span class="line">        <span class="keyword">read</span>(q[i,<span class="number">0</span>],q[i,<span class="number">1</span>]);</span><br><span class="line">        ins(i,q[i,<span class="number">0</span>],q[i,<span class="number">1</span>]);ins(i,q[i,<span class="number">1</span>],q[i,<span class="number">0</span>]);</span><br><span class="line">    <span class="keyword">end</span>;</span><br><span class="line">    <span class="keyword">for</span> i:=<span class="number">1</span> <span class="keyword">to</span> n <span class="keyword">do</span> par[i]:=i;</span><br><span class="line">    dfs(<span class="number">1</span>,<span class="number">0</span>);</span><br><span class="line">    <span class="keyword">for</span> i:=<span class="number">1</span> <span class="keyword">to</span> m <span class="keyword">do</span> writeln(ans[i]);</span><br><span class="line"><span class="keyword">end</span>.</span><br></pre></td></tr></table></figure></p>
<h3 id="tarjan-连通分量"><a href="#tarjan-连通分量" class="headerlink" title="tarjan-连通分量"></a>tarjan-连通分量</h3><p><strong>强连通分量</strong><br><figure class="highlight delphi"><figcaption><span>scc.pas</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">procedure</span> <span class="title">tarjan</span><span class="params">(u:int)</span>;</span></span><br><span class="line"><span class="keyword">var</span> i,v:int;</span><br><span class="line"><span class="keyword">begin</span></span><br><span class="line">    inc(tim);dfn[u]:=tim;low[u]:=tim;</span><br><span class="line">    inc(t);stk[t]:=u;ins[u]:=true;</span><br><span class="line">    i:=head[u];</span><br><span class="line">    <span class="keyword">while</span> i&lt;&gt;<span class="number">0</span> <span class="keyword">do</span> <span class="keyword">begin</span></span><br><span class="line">        v:=g[i].v;</span><br><span class="line">        <span class="keyword">if</span> dfn[v]=<span class="number">0</span> <span class="keyword">then</span> <span class="keyword">begin</span></span><br><span class="line">            tarjan(v);low[u]:=min(low[u],low[v])</span><br><span class="line">        <span class="keyword">end</span> <span class="keyword">else</span> <span class="keyword">if</span> ins[v] <span class="keyword">then</span></span><br><span class="line">            low[u]:=min(low[u],dfn[v]);</span><br><span class="line">        i:=g[i].nxt;</span><br><span class="line">    <span class="keyword">end</span>;</span><br><span class="line">    <span class="keyword">if</span> dfn[u]=low[u] <span class="keyword">then</span> <span class="keyword">begin</span></span><br><span class="line">        inc(cc);</span><br><span class="line">        <span class="keyword">while</span> stk[t+<span class="number">1</span>]&lt;&gt;u <span class="keyword">do</span> <span class="keyword">begin</span></span><br><span class="line">            scc[stk[t]]:=cc;ins[stk[t]]:=false;dec(t); <span class="comment">//<span class="doctag">bug:</span>记得标记ins</span></span><br><span class="line">        <span class="keyword">end</span>;</span><br><span class="line">    <span class="keyword">end</span>;</span><br><span class="line"><span class="keyword">end</span>;</span><br></pre></td></tr></table></figure></p>
<p><strong>边双连通分量</strong>：与scc一致<br><strong>点双连通分量</strong>：由于一个点可能被包含在多个分量中，因此在<code>tarjan(v)</code>后如果<code>low[v]&gt;=dfn[u]</code>，立刻处理v这个分量，注意u也包含在该分量内，但不能退栈。见<a href="/2016/08/16/POJ-P2942/" title="[POJ] P2942 Knights of the Round Table">[POJ] P2942 Knights of the Round Table</a></p>
<h2 id="数据结构类"><a href="#数据结构类" class="headerlink" title="数据结构类"></a>数据结构类</h2><h3 id="莫队"><a href="#莫队" class="headerlink" title="莫队"></a>莫队</h3><p>这其实不算数据结构吧，只是一类数据结构题的一种偷懒的解法罢了<br>写过一次：<a href="/2016/09/08/NOIP模拟赛-2014-7-18/" title="p1-harem">p1-harem</a></p>
<p>其核心思想是离线处理区间统计问题，要求统计量具有这种性质：<br>能在$O(1)$内由区间$[l,r]$的答案得到$[l\pm 1,r\pm 1]$的答案</p>
<p>区间的排序方法是：按$\sqrt{n}$分块，第一关键字为所在块编号，第二关键字为右端点<br>复杂度：</p>
<ul>
<li>同一块内<ol>
<li>由于按块编号排序，左端点每次变化$O(\sqrt{N})$，则总复杂度$O(N\sqrt{N})$</li>
<li>右端点顺序排列，因此为$O(N)$，而总共$\sqrt{N}$块，总复杂度$O(N\sqrt{N})$。</li>
</ol>
</li>
<li>跨块的复杂度也类似，是同阶的</li>
</ul>
<p>注意点：区间初始为$l=1,r=0$，注意端点</p>
<p>上面那题的核心代码</p>
<figure class="highlight delphi"><figcaption><span>mo.pas</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> int=longint;</span><br><span class="line"><span class="keyword">var</span></span><br><span class="line">    n,m,k:int;</span><br><span class="line">    q:<span class="keyword">array</span>[<span class="number">0</span>..<span class="number">100010</span>,<span class="number">0</span>..<span class="number">3</span>] <span class="keyword">of</span> int; <span class="comment">//[编号,l,r,所在块]</span></span><br><span class="line">    ans,a:<span class="keyword">array</span>[<span class="number">0</span>..<span class="number">100010</span>] <span class="keyword">of</span> int;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">com</span><span class="params">(i,j:int)</span>:</span>boolean; <span class="comment">//i&lt;j</span></span><br><span class="line"><span class="keyword">begin</span></span><br><span class="line">    com:=(q[i,<span class="number">3</span>]&lt;q[j,<span class="number">3</span>]) <span class="keyword">or</span> ((q[i,<span class="number">3</span>]=q[j,<span class="number">3</span>]) <span class="keyword">and</span> (q[i,<span class="number">2</span>]&lt;q[j,<span class="number">2</span>]));</span><br><span class="line"><span class="keyword">end</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">procedure</span> <span class="title">qsort</span><span class="params">(l,r:int)</span>;</span> <span class="comment">//用com函数排序，略</span></span><br><span class="line"><span class="function"><span class="keyword">procedure</span> <span class="title">update</span><span class="params">(x,i:int)</span>;</span> <span class="comment">//相关更新操作，略</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">procedure</span> <span class="title">init</span><span class="params">()</span>;</span></span><br><span class="line"><span class="keyword">var</span> i:int;</span><br><span class="line"><span class="keyword">begin</span></span><br><span class="line">    <span class="comment">&#123;...data input&#125;</span></span><br><span class="line">    <span class="keyword">read</span>(n);k:=trunc(sqrt(n)); <span class="comment">//n=询问数,k=块的大小</span></span><br><span class="line">    <span class="keyword">for</span> i:=<span class="number">1</span> <span class="keyword">to</span> n <span class="keyword">do</span> <span class="keyword">begin</span></span><br><span class="line">        <span class="keyword">read</span>(q[i,<span class="number">1</span>],q[i,<span class="number">2</span>]);q[i,<span class="number">0</span>]:=i;</span><br><span class="line">        q[i,<span class="number">3</span>]:=(q[i,<span class="number">1</span>]-<span class="number">1</span>)<span class="keyword">div</span> k+<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">end</span>;</span><br><span class="line">    qsort(<span class="number">1</span>,n);</span><br><span class="line"><span class="keyword">end</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">procedure</span> <span class="title">mo</span><span class="params">()</span>;</span></span><br><span class="line"><span class="keyword">var</span> i,j,l,r,cnt:int;</span><br><span class="line"><span class="keyword">begin</span></span><br><span class="line">    l:=<span class="number">1</span>;r:=<span class="number">0</span>;cnt:=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> i:=<span class="number">1</span> <span class="keyword">to</span> n <span class="keyword">do</span> <span class="keyword">begin</span></span><br><span class="line">        <span class="keyword">for</span> j:=r+<span class="number">1</span> <span class="keyword">to</span> q[i,<span class="number">2</span>] <span class="keyword">do</span> update(a[j],<span class="number">1</span>);</span><br><span class="line">        <span class="keyword">for</span> j:=r <span class="keyword">downto</span> q[i,<span class="number">2</span>]+<span class="number">1</span> <span class="keyword">do</span> update(a[j],-<span class="number">1</span>);</span><br><span class="line">        <span class="keyword">for</span> j:=l <span class="keyword">to</span> q[i,<span class="number">1</span>]-<span class="number">1</span> <span class="keyword">do</span> update(a[j],-<span class="number">1</span>);</span><br><span class="line">        <span class="keyword">for</span> j:=l-<span class="number">1</span> <span class="keyword">downto</span> q[i,<span class="number">1</span>] <span class="keyword">do</span> update(a[j],<span class="number">1</span>);</span><br><span class="line">        l:=q[i,<span class="number">1</span>];r:=q[i,<span class="number">2</span>];ans[q[i,<span class="number">0</span>]]:=cnt;</span><br><span class="line">    <span class="keyword">end</span>;</span><br><span class="line">    <span class="keyword">for</span> i:=<span class="number">1</span> <span class="keyword">to</span> n <span class="keyword">do</span> writeln(ans[i]);</span><br><span class="line"><span class="keyword">end</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">begin</span> <span class="keyword">end</span>.</span><br></pre></td></tr></table></figure>
<h3 id="分块（块状数组）"><a href="#分块（块状数组）" class="headerlink" title="分块（块状数组）"></a>分块（块状数组）</h3><p>只写过一次分块题：<a href="/2016/09/06/NOIP模拟赛-教主的魔法/" title="NOIP模拟赛 教主的魔法">NOIP模拟赛 教主的魔法</a><br>注意点：</p>
<ol>
<li>不要混淆块编号和元素编号</li>
<li>在下面的模型中，tag维护块的懒标记，再暴力首尾两块时不必重新处理，因为尽管块内元素的顺序有变化，但总的增量是不变的</li>
</ol>
<p>带修改，区间中统计不小于k的元素个数<br><figure class="highlight delphi"><figcaption><span>block.pas</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">uses</span> math;</span><br><span class="line"><span class="keyword">const</span> mxn=<span class="number">100010</span>;</span><br><span class="line"><span class="keyword">type</span> int=longint;</span><br><span class="line"><span class="keyword">var</span></span><br><span class="line">    a,b,blk,tag:<span class="keyword">array</span>[<span class="number">0</span>..mxn] <span class="keyword">of</span> int;</span><br><span class="line">    n,k:int;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">bin</span><span class="params">(i,x:int)</span>:</span>int; <span class="comment">//省略</span></span><br><span class="line"><span class="function"><span class="keyword">procedure</span> <span class="title">qsort</span><span class="params">(l,r:int)</span>;</span> <span class="comment">//省略</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">procedure</span> <span class="title">sort</span><span class="params">(x:int)</span>;</span></span><br><span class="line"><span class="keyword">var</span> i,l,r:int;</span><br><span class="line"><span class="keyword">begin</span></span><br><span class="line">    l:=(x-<span class="number">1</span>)*k+<span class="number">1</span>;r:=min(n,x*k); <span class="comment">//<span class="doctag">bug:</span> x是块编号</span></span><br><span class="line">    <span class="keyword">for</span> i:=l <span class="keyword">to</span> r <span class="keyword">do</span> b[i]:=a[i]<span class="comment">&#123;+tag[x]&#125;</span>;</span><br><span class="line">    <span class="comment">&#123;tag[x]:=0;&#125;</span>qsort(l,r);</span><br><span class="line"><span class="keyword">end</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">procedure</span> <span class="title">modify</span><span class="params">(l,r,x:int)</span>;</span></span><br><span class="line"><span class="keyword">var</span> i:int;</span><br><span class="line"><span class="keyword">begin</span></span><br><span class="line">    <span class="keyword">for</span> i:=l <span class="keyword">to</span> min(r,blk[l]*k) <span class="keyword">do</span> inc(a[i],x); <span class="comment">//<span class="doctag">bug:</span>起始为l</span></span><br><span class="line">    sort(blk[l]);</span><br><span class="line">    <span class="keyword">if</span> blk[l]=blk[r] <span class="keyword">then</span> <span class="keyword">exit</span>;</span><br><span class="line">    <span class="keyword">for</span> i:=(blk[r]-<span class="number">1</span>)*k+<span class="number">1</span> <span class="keyword">to</span> r <span class="keyword">do</span> inc(a[i],x); <span class="comment">//<span class="doctag">bug:</span>结束为r</span></span><br><span class="line">    sort(blk[r]);</span><br><span class="line">    <span class="keyword">for</span> i:=blk[l]+<span class="number">1</span> <span class="keyword">to</span> blk[r]-<span class="number">1</span> <span class="keyword">do</span> inc(tag[i],x);</span><br><span class="line"><span class="keyword">end</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">query</span><span class="params">(l,r,x:int)</span>:</span>int;</span><br><span class="line"><span class="keyword">var</span> i:int;</span><br><span class="line"><span class="keyword">begin</span></span><br><span class="line">    query:=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> i:=l <span class="keyword">to</span> min(r,blk[l]*k) <span class="keyword">do</span></span><br><span class="line">        <span class="keyword">if</span> a[i]+tag[blk[l]]&gt;=x <span class="keyword">then</span> inc(query); <span class="comment">//tag下标是块编号</span></span><br><span class="line">    <span class="keyword">if</span> blk[l]=blk[r] <span class="keyword">then</span> <span class="keyword">exit</span>(query);</span><br><span class="line">    <span class="keyword">for</span> i:=(blk[r]-<span class="number">1</span>)*k+<span class="number">1</span> <span class="keyword">to</span> r <span class="keyword">do</span></span><br><span class="line">        <span class="keyword">if</span> a[i]+tag[blk[r]]&gt;=x <span class="keyword">then</span> inc(query);</span><br><span class="line">    <span class="keyword">for</span> i:=blk[l]+<span class="number">1</span> <span class="keyword">to</span> blk[r]-<span class="number">1</span> <span class="keyword">do</span> inc(query,min(i*k,n)-bin(i,x));</span><br><span class="line">    <span class="comment">//bin(i,x): max_j&#123;b[j]+tag[i]&lt;x,j in i&#125;</span></span><br><span class="line"><span class="keyword">end</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">procedure</span> <span class="title">init</span><span class="params">()</span>;</span></span><br><span class="line"><span class="keyword">var</span> i:int;</span><br><span class="line"><span class="keyword">begin</span></span><br><span class="line">    k:=trunc(sqrt(n));</span><br><span class="line">    <span class="keyword">for</span> i:=<span class="number">1</span> <span class="keyword">to</span> n <span class="keyword">do</span> blk[i]:=(i-<span class="number">1</span>)<span class="keyword">div</span> k+<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span> i:=<span class="number">1</span> <span class="keyword">to</span> blk[n] <span class="keyword">do</span> sort(i);</span><br><span class="line"><span class="keyword">end</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">begin</span> <span class="keyword">end</span>.</span><br></pre></td></tr></table></figure></p>
<h3 id="Treap"><a href="#Treap" class="headerlink" title="Treap"></a>Treap</h3><p>模板题见此：<a href="/2016/11/05/bzoj-3224/" title="BZOJ-3224 普通平衡树">BZOJ-3224 普通平衡树</a></p>
<h3 id="树剖"><a href="#树剖" class="headerlink" title="树剖"></a>树剖</h3><p>想了想还是放在数据结构里吧</p>
<blockquote>
<p>线段树不能虚！注意pushdown<br>线段树不能虚！注意pushdown<br>线段树不能虚！注意pushdown</p>
</blockquote>
<p>模板题见：<a href="/2016/11/05/luogu-3384/" title="luogu-3384 【模板】树链剖分">luogu-3384 【模板】树链剖分</a></p>
<h2 id="其他"><a href="#其他" class="headerlink" title="其他"></a>其他</h2><h3 id="高斯消元"><a href="#高斯消元" class="headerlink" title="高斯消元"></a>高斯消元</h3><p>解线性方程组，做一道物理题：<a href="/2016/08/29/JSOI2016-提高1班-Day3-resistor/" title="jsoi2016 resistor">jsoi2016 resistor</a></p>
<figure class="highlight delphi"><figcaption><span>gs.pas</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> mxn=<span class="number">110</span>;eps=<span class="number">0.000000001</span>;</span><br><span class="line"><span class="keyword">type</span></span><br><span class="line">    int=longint;</span><br><span class="line">    mat=<span class="keyword">array</span>[<span class="number">0</span>..mxn,<span class="number">0</span>..mxn] <span class="keyword">of</span> double;</span><br><span class="line"><span class="function"><span class="keyword">procedure</span> <span class="title">gauss</span><span class="params">(<span class="keyword">var</span> a:mat;n:int)</span>;</span></span><br><span class="line"><span class="keyword">var</span></span><br><span class="line">    i,j,k,p:int;</span><br><span class="line">    tmp:<span class="keyword">array</span>[<span class="number">0</span>..mxn] <span class="keyword">of</span> double;</span><br><span class="line"><span class="keyword">begin</span></span><br><span class="line">    <span class="keyword">for</span> i:=<span class="number">1</span> <span class="keyword">to</span> n <span class="keyword">do</span> <span class="keyword">begin</span></span><br><span class="line">        p:=i; <span class="comment">//换主元</span></span><br><span class="line">        <span class="keyword">for</span> j:=i+<span class="number">1</span> <span class="keyword">to</span> n <span class="keyword">do</span> <span class="keyword">if</span> a[j,i]&gt;a[p,i] <span class="keyword">then</span> p:=j;</span><br><span class="line">        <span class="keyword">if</span> abs(a[p,i])&lt;eps <span class="keyword">then</span> <span class="keyword">exit</span>; <span class="comment">//无解</span></span><br><span class="line">        tmp:=a[i];a[i]:=a[p];a[p]:=tmp;</span><br><span class="line">        <span class="keyword">for</span> j:=i+<span class="number">1</span> <span class="keyword">to</span> n+<span class="number">1</span> <span class="keyword">do</span> a[i,j]:=a[i,j]/a[i,i]; <span class="comment">//处理主元所在行</span></span><br><span class="line">        <span class="keyword">for</span> j:=<span class="number">1</span> <span class="keyword">to</span> n <span class="keyword">do</span> <span class="keyword">if</span> i&lt;&gt;j <span class="keyword">then</span> <span class="comment">//处理余下行</span></span><br><span class="line">            <span class="keyword">for</span> k:=i+<span class="number">1</span> <span class="keyword">to</span> n+<span class="number">1</span> <span class="keyword">do</span> a[j,k]:=a[j,k]-a[j,i]*a[i,k];</span><br><span class="line">    <span class="keyword">end</span>;</span><br><span class="line">    <span class="keyword">for</span> i:=<span class="number">1</span> <span class="keyword">to</span> n <span class="keyword">do</span> writeln(<span class="string">'x'</span>,i,<span class="string">'='</span>,a[i,n+<span class="number">1</span>]:<span class="number">0</span>:<span class="number">3</span>);</span><br><span class="line"><span class="keyword">end</span>;</span><br></pre></td></tr></table></figure>
<h3 id="康托展开"><a href="#康托展开" class="headerlink" title="康托展开"></a>康托展开</h3><p>即全排列hash值，如0..8的全排列：<br>$h=\sum_{i=0}^8k(8-i)!,k=\sum_{j=i+1}^8[a[i]&gt;a[j]]$<br><figure class="highlight delphi"><figcaption><span>kt.pas</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">ct</span><span class="params">(<span class="keyword">var</span> a:arr)</span>:</span>int;</span><br><span class="line"><span class="keyword">var</span> i,j,cnt:int;</span><br><span class="line"><span class="keyword">begin</span></span><br><span class="line">    ct:=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> i:=<span class="number">0</span> <span class="keyword">to</span> <span class="number">8</span> <span class="keyword">do</span> <span class="keyword">begin</span></span><br><span class="line">        cnt:=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> j:=i+<span class="number">1</span> <span class="keyword">to</span> <span class="number">8</span> <span class="keyword">do</span></span><br><span class="line">            <span class="keyword">if</span> a[i]&gt;a[j] <span class="keyword">then</span> inc(cnt);</span><br><span class="line">        inc(ct,cnt*fac[<span class="number">8</span>-i]);</span><br><span class="line">    <span class="keyword">end</span>;</span><br><span class="line"><span class="keyword">end</span>;</span><br></pre></td></tr></table></figure></p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;noip前复习一些不熟悉的模板&lt;br&gt;在历时4个月的刷题过程中，有些算法一带而过，之写过一两次或者年代久远或者理解肤浅，需要在考前复习。&lt;br&gt;
    
    </summary>
    
      <category term="Algorithm Note" scheme="https://cothrax.github.io/categories/Algorithm-Note/"/>
    
    
  </entry>
  
  <entry>
    <title>NOIP2016十连测总结</title>
    <link href="https://cothrax.github.io/2016/11/10/lydsy-noip-2016-summary/"/>
    <id>https://cothrax.github.io/2016/11/10/lydsy-noip-2016-summary/</id>
    <published>2016-11-10T15:08:22.000Z</published>
    <updated>2016-11-11T16:08:56.080Z</updated>
    
    <content type="html"><![CDATA[<p>NOIP2016十连测在12天前已经完结，除了几个神坑没有填之外，基本订正完毕。<br>从一个蒟蒻的noiper的角度看，除了god出的前两场，其余均为NOIplus难度。</p>
<blockquote>
<p>I good vegetable.</p>
</blockquote>
<a id="more"></a>
<h2 id="挖坑"><a href="#挖坑" class="headerlink" title="挖坑"></a>挖坑</h2><ol>
<li><a href="/2016/10/03/lydsy-noip-2016-test2/" title="Test2 T3 speed">Test2 T3 speed</a>：好吧题解都看不懂</li>
<li><a href="/2016/10/28/lydsy-noip-2016-test9/" title="Test9 T3 mst">Test9 T3 mst</a>：过于noip的计算几何题</li>
<li><a href="/2016/11/04/lydsy-noip-2016-test7/" title="Test7 T3 tournament">Test7 T3 tournament</a>和<a href="/2016/10/16/lydsy-noip-2016-test6/" title="Test6 T2 goodbye">Test6 T2 goodbye</a>：概率期望的知识要补</li>
<li><a href="/2016/10/28/lydsy-noip-2016-test5/" title="Test5 T3 travel">Test5 T3 travel</a>：题解好长，想法题，先留着吧</li>
<li>一些不明白的地方<ol>
<li><a href="/2016/10/10/lydsy-noip-2016-test4/" title="Test4 T3 ra">Test4 T3 ra</a>的部分分解法和复杂度的分析</li>
<li><a href="/2016/11/04/lydsy-noip-2016-test7/" title="Test7 T2 password">Test7 T2 password</a>的方程个数的期望</li>
</ol>
</li>
</ol>
<h2 id="简单题"><a href="#简单题" class="headerlink" title="简单题"></a>简单题</h2><ol>
<li><a href="/2016/10/02/lydsy-noip-2016-test1/" title="Test1 T1 master">Test1 T1 master</a>：字符串dp</li>
<li><a href="/2016/10/03/lydsy-noip-2016-test2/" title="Test2 T1 div">Test2 T1 div</a>：乱搞</li>
<li><a href="/2016/10/10/lydsy-noip-2016-test4/" title="Test4 T1 orisis">Test4 T1 orisis</a>：水</li>
<li><a href="/2016/10/30/lydsy-noip-2016-test8/" title="Test9 T1 2048">Test9 T1 2048</a>：模拟</li>
<li><a href="/2016/10/16/lydsy-noip-2016-test6/" title="Test6 T1 fantasy">Test6 T1 fantasy</a>：观察+乱搞（被卡常）</li>
</ol>
<h2 id="新知"><a href="#新知" class="headerlink" title="新知"></a>新知</h2><ol>
<li>数论<ol>
<li>裴蜀定理：<a href="/2016/10/28/lydsy-noip-2016-test5/" title="Test5 T1 simple">Test5 T1 simple</a></li>
<li>杜教筛？：<a href="/2016/10/10/lydsy-noip-2016-test4/" title="Test4 T3 ra">Test4 T3 ra</a></li>
</ol>
</li>
<li>dfs序：<a href="/2016/10/28/lydsy-noip-2016-test9/" title="Test10 T3 lca">Test10 T3 lca</a><ul>
<li>“贡献”的思想，还有<a href="/2016/10/09/lydsy-noip-2016-test3/" title="Test3 T3 seq">Test3 T3 seq</a></li>
</ul>
</li>
<li>容斥dp：<a href="/2016/10/10/lydsy-noip-2016-test4/" title="Test4 T2 obelisk">Test4 T2 obelisk</a></li>
</ol>
<h2 id="长见识"><a href="#长见识" class="headerlink" title="长见识"></a>长见识</h2><ol>
<li>dp类<ol>
<li>强行单调后二分：<a href="/2016/10/03/lydsy-noip-2016-test2/" title="Test2 T2 market">Test2 T2 market</a></li>
<li>数据结构优化lis：<a href="/2016/10/30/lydsy-noip-2016-test8/" title="Test8 T2 hamon">Test8 T2 hamon</a></li>
<li>广义矩阵乘法+快速幂：<a href="/2016/10/28/lydsy-noip-2016-test9/" title="Test10 T1 lis">Test10 T1 lis</a></li>
<li>最短路处理dp（woc这是图论题）：<a href="/2016/10/28/lydsy-noip-2016-test9/" title="Test10 T2 bag">Test10 T2 bag</a></li>
</ol>
</li>
<li>位运算求交集：<a href="/2016/10/02/lydsy-noip-2016-test1/" title="Test1 T2 tour">Test1 T2 tour</a></li>
<li>图论<ol>
<li>增点：<a href="/2016/10/02/lydsy-noip-2016-test1/" title="Test1 T3 walk">Test1 T3 walk</a></li>
<li>拆点+路径求交+破环成链+dag上dp：<a href="/2016/10/16/lydsy-noip-2016-test6/" title="Test6 T3 reality">Test6 T3 reality</a></li>
</ol>
</li>
</ol>
<h2 id="脑洞"><a href="#脑洞" class="headerlink" title="脑洞"></a>脑洞</h2><ol>
<li>神奇二分，化最优解为统计问题：<a href="/2016/10/09/lydsy-noip-2016-test3/" title="Test3 T1 ave">Test3 T1 ave</a></li>
<li><a href="/2016/10/28/lydsy-noip-2016-test5/" title="Test5 T2 walk">Test5 T2 walk</a>
<ol>
<li>如何处理常数：链表、栈</li>
<li>如何处理gcd：按倍数枚举</li>
</ol>
</li>
<li>自己看吧：<a href="/2016/10/30/lydsy-noip-2016-test8/" title="Test8 T3 raviel">Test8 T3 raviel</a></li>
<li><a href="/2016/10/30/lydsy-noip-2016-test8/" title="Test9 T2 seq">Test9 T2 seq</a>
<ol>
<li>40分可以dp，noip难度类似2015的子串</li>
<li>结论</li>
</ol>
</li>
<li>可以乱搞：<a href="/2016/10/28/lydsy-noip-2016-test9/" title="Test10 T1 lis">Test10 T1 lis</a></li>
</ol>
<h2 id="知识强化"><a href="#知识强化" class="headerlink" title="知识强化"></a>知识强化</h2><ol>
<li>主席树二维数点：<a href="/2016/10/09/lydsy-noip-2016-test3/" title="Test3 T3 seq">Test3 T3 seq</a></li>
<li>好像没有了</li>
</ol>
<h2 id="数学啊数学"><a href="#数学啊数学" class="headerlink" title="数学啊数学"></a>数学啊数学</h2><ol>
<li>恶心的组合数学dp：<a href="/2016/10/09/lydsy-noip-2016-test3/" title="Test3 T2 color">Test3 T2 color</a></li>
<li>坑爹数论：<a href="/2016/10/30/lydsy-noip-2016-test8/" title="Test8 T1 uria">Test8 T1 uria</a></li>
<li>递推解约瑟夫+<strong>打表</strong>：<a href="/2016/11/04/lydsy-noip-2016-test7/" title="Test7 T1 joseph">Test7 T1 joseph</a></li>
<li>同余方程组+带权并查集：<a href="/2016/11/04/lydsy-noip-2016-test7/" title="Test7 T2 password">Test7 T2 password</a></li>
</ol>
<h2 id="写在后面"><a href="#写在后面" class="headerlink" title="写在后面"></a>写在后面</h2><p>可以说这次十连测暴露出了大量的知识盲区，题目的思维深度超出了一个蒟蒻的能力范围。<br>在算法能力方面，这次测试给了我很大的提升，但完全没有达到训练应试能力/代码能力的效果<del>（因为看完题面连暴力都懒得打了orz）</del></p>
<blockquote>
<p>while true do inc(rp);</p>
</blockquote>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;NOIP2016十连测在12天前已经完结，除了几个神坑没有填之外，基本订正完毕。&lt;br&gt;从一个蒟蒻的noiper的角度看，除了god出的前两场，其余均为NOIplus难度。&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;I good vegetable.&lt;/p&gt;
&lt;/blockquote&gt;
    
    </summary>
    
      <category term="Algorithm Note" scheme="https://cothrax.github.io/categories/Algorithm-Note/"/>
    
    
  </entry>
  
  <entry>
    <title>luogu-3384 【模板】树链剖分</title>
    <link href="https://cothrax.github.io/2016/11/05/luogu-3384/"/>
    <id>https://cothrax.github.io/2016/11/05/luogu-3384/</id>
    <published>2016-11-05T15:48:50.000Z</published>
    <updated>2016-11-24T14:54:53.126Z</updated>
    
    <content type="html"><![CDATA[<h2 id="大意"><a href="#大意" class="headerlink" title="大意"></a>大意</h2><p>一颗根为r、有n个节点的树，点上有权值，要求支持如下操作：</p>
<ol>
<li>操作1：<code>1 x y z</code> x到y的路径上所有点权加z</li>
<li>操作2：格式： <code>2 x y</code> 求x到y路径上的点权和</li>
<li>操作3： 格式： <code>3 x z</code> x子树中所有点权加z</li>
<li>操作4： 格式： <code>4 x</code> 求x子树点权和</li>
</ol>
<a id="more"></a>
<h2 id="链接"><a href="#链接" class="headerlink" title="链接"></a>链接</h2><p><a href="https://www.luogu.org/problem/show?pid=3384#sub" target="_blank" rel="external">luogu-3384</a><br><a href="/2016/11/05/luogu-3384/tree.pas" title="tree.pas">tree.pas</a></p>
<h2 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h2><p>树剖模板题<br>尽管是树剖，遍历方式依然是dfs，所得序列满足dfs序的性质，操作3/4可以轻松解决<br>md线段树调了好久。。。<strong>pushdown要小心不能虚</strong></p>
<h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><figure class="highlight delphi"><figcaption><span>tree.pas</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> int=longint;edge=<span class="keyword">record</span> v,nxt:int <span class="keyword">end</span>;</span><br><span class="line"><span class="keyword">var</span></span><br><span class="line">    g:<span class="keyword">array</span>[<span class="number">0</span>..<span class="number">200010</span>] <span class="keyword">of</span> edge;</span><br><span class="line">    head,siz,dep,par,son,top,w,loc,a:<span class="keyword">array</span>[<span class="number">0</span>..<span class="number">100010</span>] <span class="keyword">of</span> int;</span><br><span class="line">    seg,tag:<span class="keyword">array</span>[<span class="number">0</span>..<span class="number">400010</span>] <span class="keyword">of</span> int;</span><br><span class="line">    n,m,k,sz,rt,md,u,v,i,x,y,z,op:int;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">procedure</span> <span class="title">add</span><span class="params">(u,v:int)</span>;</span></span><br><span class="line"><span class="keyword">begin</span></span><br><span class="line">    inc(sz);g[sz].v:=v;</span><br><span class="line">    g[sz].nxt:=head[u];head[u]:=sz;</span><br><span class="line"><span class="keyword">end</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">procedure</span> <span class="title">dfs1</span><span class="params">(u,p:int)</span>;</span></span><br><span class="line"><span class="keyword">var</span> i,v:int;</span><br><span class="line"><span class="keyword">begin</span></span><br><span class="line">    par[u]:=p;dep[u]:=dep[p]+<span class="number">1</span>;</span><br><span class="line">    siz[u]:=<span class="number">1</span>;son[u]:=<span class="number">0</span>;i:=head[u];</span><br><span class="line">    <span class="keyword">while</span> i&lt;&gt;<span class="number">0</span> <span class="keyword">do</span> <span class="keyword">begin</span></span><br><span class="line">        v:=g[i].v;</span><br><span class="line">        <span class="keyword">if</span> v&lt;&gt;p <span class="keyword">then</span> <span class="keyword">begin</span></span><br><span class="line">            dfs1(v,u);</span><br><span class="line">            <span class="keyword">if</span> siz[v]&gt;siz[son[u]] <span class="keyword">then</span> son[u]:=v;</span><br><span class="line">            inc(siz[u],siz[v]);</span><br><span class="line">        <span class="keyword">end</span>;</span><br><span class="line">        i:=g[i].nxt;</span><br><span class="line">    <span class="keyword">end</span>;</span><br><span class="line"><span class="keyword">end</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">procedure</span> <span class="title">dfs2</span><span class="params">(u:int)</span>;</span></span><br><span class="line"><span class="keyword">var</span> i,v:int;</span><br><span class="line"><span class="keyword">begin</span></span><br><span class="line">    <span class="keyword">if</span> u=<span class="number">0</span> <span class="keyword">then</span> <span class="keyword">exit</span>;</span><br><span class="line">    <span class="keyword">if</span> u=son[par[u]] <span class="keyword">then</span> top[u]:=top[par[u]] <span class="keyword">else</span> top[u]:=u;</span><br><span class="line">    inc(k);loc[u]:=k;a[k]:=u;dfs2(son[u]);</span><br><span class="line">    i:=head[u];</span><br><span class="line">    <span class="keyword">while</span> i&lt;&gt;<span class="number">0</span> <span class="keyword">do</span> <span class="keyword">begin</span></span><br><span class="line">        v:=g[i].v;</span><br><span class="line">        <span class="keyword">if</span> (v&lt;&gt;par[u])<span class="keyword">and</span>(v&lt;&gt;son[u]) <span class="keyword">then</span> dfs2(v);</span><br><span class="line">        i:=g[i].nxt;</span><br><span class="line">    <span class="keyword">end</span>;</span><br><span class="line"><span class="keyword">end</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// seg-tree begin</span></span><br><span class="line"><span class="function"><span class="keyword">procedure</span> <span class="title">pushdown</span><span class="params">(i,b,e:int)</span>;</span></span><br><span class="line"><span class="keyword">var</span> l,r,mid:int;</span><br><span class="line"><span class="keyword">begin</span></span><br><span class="line">    l:=i <span class="keyword">shl</span> <span class="number">1</span>;r:=l <span class="keyword">or</span> <span class="number">1</span>;mid:=(b+e)<span class="keyword">shr</span> <span class="number">1</span>;</span><br><span class="line">    seg[l]:=(seg[l]+tag[i]*(mid-b+<span class="number">1</span>))<span class="keyword">mod</span> md;</span><br><span class="line">    seg[r]:=(seg[r]+tag[i]*(e-mid))<span class="keyword">mod</span> md;</span><br><span class="line">    tag[l]:=(tag[l]+tag[i])<span class="keyword">mod</span> md;</span><br><span class="line">    tag[r]:=(tag[r]+tag[i])<span class="keyword">mod</span> md;</span><br><span class="line">    tag[i]:=<span class="number">0</span>;</span><br><span class="line"><span class="keyword">end</span>;</span><br><span class="line"><span class="function"><span class="keyword">procedure</span> <span class="title">build</span><span class="params">(i,b,e:int)</span>;</span></span><br><span class="line"><span class="keyword">var</span> mid:int;</span><br><span class="line"><span class="keyword">begin</span></span><br><span class="line">    <span class="keyword">if</span> b=e <span class="keyword">then</span> <span class="keyword">begin</span> seg[i]:=w[a[b]];<span class="keyword">exit</span> <span class="keyword">end</span>;</span><br><span class="line">    mid:=(b+e) <span class="keyword">shr</span> <span class="number">1</span>;</span><br><span class="line">    build(i <span class="keyword">shl</span> <span class="number">1</span>,b,mid);build(i <span class="keyword">shl</span> <span class="number">1</span> <span class="keyword">or</span> <span class="number">1</span>,mid+<span class="number">1</span>,e);</span><br><span class="line">    seg[i]:=(seg[i <span class="keyword">shl</span> <span class="number">1</span>]+seg[i <span class="keyword">shl</span> <span class="number">1</span> <span class="keyword">or</span> <span class="number">1</span>])<span class="keyword">mod</span> md;</span><br><span class="line"><span class="keyword">end</span>;</span><br><span class="line"><span class="function"><span class="keyword">procedure</span> <span class="title">modify</span><span class="params">(i,b,e,l,r,k:int)</span>;</span></span><br><span class="line"><span class="keyword">var</span> mid:int;</span><br><span class="line"><span class="keyword">begin</span></span><br><span class="line">    <span class="keyword">if</span> (e&lt;l) <span class="keyword">or</span> (r&lt;b) <span class="keyword">then</span> <span class="keyword">exit</span>;</span><br><span class="line">    <span class="keyword">if</span> (l&lt;=b) <span class="keyword">and</span> (e&lt;=r) <span class="keyword">then</span> <span class="keyword">begin</span></span><br><span class="line">        seg[i]:=(seg[i]+k*(e-b+<span class="number">1</span>))<span class="keyword">mod</span> md;</span><br><span class="line">        tag[i]:=(tag[i]+k)<span class="keyword">mod</span> md;</span><br><span class="line">        <span class="keyword">exit</span>;</span><br><span class="line">    <span class="keyword">end</span>;</span><br><span class="line">    <span class="keyword">if</span> tag[i]&lt;&gt;<span class="number">0</span> <span class="keyword">then</span> pushdown(i,b,e);</span><br><span class="line">    mid:=(b+e) <span class="keyword">shr</span> <span class="number">1</span>;</span><br><span class="line">    modify(i <span class="keyword">shl</span> <span class="number">1</span>,b,mid,l,r,k);</span><br><span class="line">    modify(i <span class="keyword">shl</span> <span class="number">1</span> <span class="keyword">or</span> <span class="number">1</span>,mid+<span class="number">1</span>,e,l,r,k);</span><br><span class="line">    seg[i]:=(seg[i <span class="keyword">shl</span> <span class="number">1</span>]+seg[i <span class="keyword">shl</span> <span class="number">1</span> <span class="keyword">or</span> <span class="number">1</span>])<span class="keyword">mod</span> md;</span><br><span class="line"><span class="keyword">end</span>;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">query</span><span class="params">(i,b,e,l,r:int)</span>:</span>int;</span><br><span class="line"><span class="keyword">var</span> mid:int;</span><br><span class="line"><span class="keyword">begin</span></span><br><span class="line">    <span class="keyword">if</span> (e&lt;l) <span class="keyword">or</span> (r&lt;b) <span class="keyword">then</span> <span class="keyword">exit</span>(<span class="number">0</span>);</span><br><span class="line">    <span class="keyword">if</span> (l&lt;=b) <span class="keyword">and</span> (e&lt;=r) <span class="keyword">then</span> <span class="keyword">exit</span>(seg[i]);</span><br><span class="line">    <span class="keyword">if</span> tag[i]&lt;&gt;<span class="number">0</span> <span class="keyword">then</span> pushdown(i,b,e);</span><br><span class="line">    mid:=(b+e) <span class="keyword">shr</span> <span class="number">1</span>;</span><br><span class="line">    query:=(query(i <span class="keyword">shl</span> <span class="number">1</span>,b,mid,l,r)+</span><br><span class="line">        query(i <span class="keyword">shl</span> <span class="number">1</span> <span class="keyword">or</span> <span class="number">1</span>,mid+<span class="number">1</span>,e,l,r))<span class="keyword">mod</span> md;</span><br><span class="line"><span class="keyword">end</span>;</span><br><span class="line"><span class="comment">//seg-tree end</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">procedure</span> <span class="title">swap</span><span class="params">(<span class="keyword">var</span> a,b:int)</span>;</span></span><br><span class="line"><span class="keyword">var</span> tmp:int;</span><br><span class="line"><span class="keyword">begin</span> tmp:=a;a:=b;b:=tmp <span class="keyword">end</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">lca</span><span class="params">(u,v:int)</span>:</span>int;</span><br><span class="line"><span class="keyword">begin</span></span><br><span class="line">    <span class="keyword">while</span> true <span class="keyword">do</span> <span class="keyword">begin</span></span><br><span class="line">        <span class="keyword">if</span> dep[u]&gt;dep[v] <span class="keyword">then</span> swap(u,v);</span><br><span class="line">        <span class="keyword">if</span> top[u]=top[v] <span class="keyword">then</span> <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">if</span> dep[top[u]]&lt;dep[top[v]] <span class="keyword">then</span> v:=par[top[v]]</span><br><span class="line">        <span class="keyword">else</span> u:=par[top[u]];</span><br><span class="line">    <span class="keyword">end</span>;</span><br><span class="line">    lca:=u;</span><br><span class="line"><span class="keyword">end</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">procedure</span> <span class="title">mfylnk</span><span class="params">(u,v,k:int)</span>;</span></span><br><span class="line"><span class="keyword">begin</span></span><br><span class="line">    <span class="keyword">while</span> true <span class="keyword">do</span> <span class="keyword">begin</span></span><br><span class="line">        <span class="keyword">if</span> dep[u]&gt;dep[v] <span class="keyword">then</span> swap(u,v);</span><br><span class="line">        <span class="keyword">if</span> top[u]=top[v] <span class="keyword">then</span> <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">if</span> dep[top[u]]&lt;dep[top[v]] <span class="keyword">then</span> <span class="keyword">begin</span></span><br><span class="line">            modify(<span class="number">1</span>,<span class="number">1</span>,n,loc[top[v]],loc[v],k);</span><br><span class="line">            v:=par[top[v]];</span><br><span class="line">        <span class="keyword">end</span> <span class="keyword">else</span> <span class="keyword">begin</span></span><br><span class="line">            modify(<span class="number">1</span>,<span class="number">1</span>,n,loc[top[u]],loc[u],k);</span><br><span class="line">            u:=par[top[u]];</span><br><span class="line">        <span class="keyword">end</span>;</span><br><span class="line">    <span class="keyword">end</span>;</span><br><span class="line">    modify(<span class="number">1</span>,<span class="number">1</span>,n,loc[u],loc[v],k);</span><br><span class="line"><span class="keyword">end</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">asklnk</span><span class="params">(u,v:int)</span>:</span>int;</span><br><span class="line"><span class="keyword">begin</span></span><br><span class="line">    asklnk:=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span> true <span class="keyword">do</span> <span class="keyword">begin</span></span><br><span class="line">        <span class="keyword">if</span> dep[u]&gt;dep[v] <span class="keyword">then</span> swap(u,v);</span><br><span class="line">        <span class="keyword">if</span> top[u]=top[v] <span class="keyword">then</span> <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">if</span> dep[top[u]]&lt;dep[top[v]] <span class="keyword">then</span> <span class="keyword">begin</span></span><br><span class="line">            asklnk:=(asklnk+query(<span class="number">1</span>,<span class="number">1</span>,n,loc[top[v]],loc[v]))<span class="keyword">mod</span> md;</span><br><span class="line">            v:=par[top[v]];</span><br><span class="line">        <span class="keyword">end</span> <span class="keyword">else</span> <span class="keyword">begin</span></span><br><span class="line">            asklnk:=(asklnk+query(<span class="number">1</span>,<span class="number">1</span>,n,loc[top[u]],loc[u]))<span class="keyword">mod</span> md;</span><br><span class="line">            u:=par[top[u]];</span><br><span class="line">        <span class="keyword">end</span>;</span><br><span class="line">    <span class="keyword">end</span>;</span><br><span class="line">    asklnk:=(asklnk+query(<span class="number">1</span>,<span class="number">1</span>,n,loc[u],loc[v]))<span class="keyword">mod</span> md;</span><br><span class="line"><span class="keyword">end</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">procedure</span> <span class="title">mfysbt</span><span class="params">(u,k:int)</span>;</span></span><br><span class="line"><span class="keyword">begin</span> modify(<span class="number">1</span>,<span class="number">1</span>,n,loc[u],loc[u]+siz[u]-<span class="number">1</span>,k) <span class="keyword">end</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">asksbt</span><span class="params">(u:int)</span>:</span>int;</span><br><span class="line"><span class="keyword">begin</span> asksbt:=query(<span class="number">1</span>,<span class="number">1</span>,n,loc[u],loc[u]+siz[u]-<span class="number">1</span>) <span class="keyword">end</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">procedure</span> <span class="title">walk</span><span class="params">(i,b,e,d:int)</span>;</span></span><br><span class="line"><span class="keyword">var</span> mid,j:int;</span><br><span class="line"><span class="keyword">begin</span></span><br><span class="line">    mid:=(b+e) <span class="keyword">shr</span> <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">if</span> b&lt;e <span class="keyword">then</span> walk(i*<span class="number">2</span>,b,mid,d+<span class="number">1</span>);</span><br><span class="line">    <span class="keyword">for</span> j:=<span class="number">1</span> <span class="keyword">to</span> d*<span class="number">5</span> <span class="keyword">do</span> <span class="keyword">write</span>(<span class="string">' '</span>);</span><br><span class="line">    writeln(i,<span class="string">':['</span>,b,<span class="string">','</span>,e,<span class="string">']='</span>,seg[i],<span class="string">':'</span>,tag[i]);</span><br><span class="line">    <span class="keyword">if</span> b&lt;e <span class="keyword">then</span> walk(i*<span class="number">2</span>+<span class="number">1</span>,mid+<span class="number">1</span>,e,d+<span class="number">1</span>);</span><br><span class="line"><span class="keyword">end</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">begin</span></span><br><span class="line">    <span class="keyword">read</span>(n,m,rt,md);k:=<span class="number">0</span>;sz:=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> i:=<span class="number">1</span> <span class="keyword">to</span> n <span class="keyword">do</span> <span class="keyword">read</span>(w[i]);</span><br><span class="line">    <span class="keyword">for</span> i:=<span class="number">1</span> <span class="keyword">to</span> n-<span class="number">1</span> <span class="keyword">do</span> <span class="keyword">begin</span></span><br><span class="line">        <span class="keyword">read</span>(u,v);add(u,v);add(v,u);</span><br><span class="line">    <span class="keyword">end</span>;</span><br><span class="line">    dfs1(rt,<span class="number">0</span>);dfs2(rt);build(<span class="number">1</span>,<span class="number">1</span>,n);</span><br><span class="line">    <span class="keyword">for</span> i:=<span class="number">1</span> <span class="keyword">to</span> m <span class="keyword">do</span> <span class="keyword">begin</span></span><br><span class="line">        <span class="keyword">read</span>(op);</span><br><span class="line">        <span class="keyword">case</span> op <span class="keyword">of</span></span><br><span class="line">            <span class="number">1</span>:<span class="keyword">begin</span> <span class="keyword">read</span>(x,y,z);mfylnk(x,y,z) <span class="keyword">end</span>;</span><br><span class="line">            <span class="number">2</span>:<span class="keyword">begin</span> <span class="keyword">read</span>(x,y);writeln(asklnk(x,y)) <span class="keyword">end</span>;</span><br><span class="line">            <span class="number">3</span>:<span class="keyword">begin</span> <span class="keyword">read</span>(x,z);mfysbt(x,z) <span class="keyword">end</span>;</span><br><span class="line">            <span class="number">4</span>:<span class="keyword">begin</span> <span class="keyword">read</span>(x);writeln(asksbt(x)) <span class="keyword">end</span>;</span><br><span class="line">        <span class="keyword">end</span>;</span><br><span class="line">    <span class="keyword">end</span>;</span><br><span class="line"><span class="keyword">end</span>.</span><br></pre></td></tr></table></figure>
]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;大意&quot;&gt;&lt;a href=&quot;#大意&quot; class=&quot;headerlink&quot; title=&quot;大意&quot;&gt;&lt;/a&gt;大意&lt;/h2&gt;&lt;p&gt;一颗根为r、有n个节点的树，点上有权值，要求支持如下操作：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;操作1：&lt;code&gt;1 x y z&lt;/code&gt; x到y的路径上所有点权加z&lt;/li&gt;
&lt;li&gt;操作2：格式： &lt;code&gt;2 x y&lt;/code&gt; 求x到y路径上的点权和&lt;/li&gt;
&lt;li&gt;操作3： 格式： &lt;code&gt;3 x z&lt;/code&gt; x子树中所有点权加z&lt;/li&gt;
&lt;li&gt;操作4： 格式： &lt;code&gt;4 x&lt;/code&gt; 求x子树点权和&lt;/li&gt;
&lt;/ol&gt;
    
    </summary>
    
      <category term="Problem Set" scheme="https://cothrax.github.io/categories/Problem-Set/"/>
    
    
      <category term="OI" scheme="https://cothrax.github.io/tags/OI/"/>
    
      <category term="数据结构" scheme="https://cothrax.github.io/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"/>
    
      <category term="线段树" scheme="https://cothrax.github.io/tags/%E7%BA%BF%E6%AE%B5%E6%A0%91/"/>
    
      <category term="树链剖分" scheme="https://cothrax.github.io/tags/%E6%A0%91%E9%93%BE%E5%89%96%E5%88%86/"/>
    
  </entry>
  
  <entry>
    <title>BZOJ-3224 普通平衡树</title>
    <link href="https://cothrax.github.io/2016/11/05/bzoj-3224/"/>
    <id>https://cothrax.github.io/2016/11/05/bzoj-3224/</id>
    <published>2016-11-05T02:07:18.000Z</published>
    <updated>2016-11-24T14:54:52.035Z</updated>
    
    <content type="html"><![CDATA[<h2 id="大意"><a href="#大意" class="headerlink" title="大意"></a>大意</h2><p>实现一系列操作维护一个数集：插入、删除、查询数x的排名、查询排名为x的数、求前驱和后驱</p>
<a id="more"></a>
<h2 id="链接"><a href="#链接" class="headerlink" title="链接"></a>链接</h2><p><a href="http://www.lydsy.com/JudgeOnline/problem.php?id=3224" target="_blank" rel="external">BZOJ-3224</a><br><a href="https://www.luogu.org/problem/show?pid=3369#sub" target="_blank" rel="external">luogu-3369</a><br><a href="/2016/11/05/bzoj-3224/treap.pas" title="treap.pas">treap.pas</a></p>
<h2 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h2><p>treap模板题，本蒟蒻第一次写平衡树</p>
<h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><figure class="highlight delphi"><figcaption><span>treap.pas</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">uses</span> math;</span><br><span class="line"><span class="keyword">type</span> </span><br><span class="line">    int=longint;</span><br><span class="line">    node=<span class="keyword">record</span> l,r,w,s,cnt,rnd:int <span class="keyword">end</span>;</span><br><span class="line"><span class="keyword">const</span> inf=maxlongint;</span><br><span class="line"><span class="keyword">var</span></span><br><span class="line">    tp:<span class="keyword">array</span>[<span class="number">0</span>..<span class="number">100010</span>] <span class="keyword">of</span> node;</span><br><span class="line">    sz,rt,i,n,op,x:int;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">procedure</span> <span class="title">upd</span><span class="params">(k:int)</span>;</span> <span class="comment">//更新tp[k].s即子树规模</span></span><br><span class="line"><span class="keyword">begin</span> tp[k].s:=tp[tp[k].l].s+tp[tp[k].r].s+tp[k].cnt <span class="keyword">end</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">procedure</span> <span class="title">lturn</span><span class="params">(<span class="keyword">var</span> k:int)</span>;</span> <span class="comment">//左旋</span></span><br><span class="line"><span class="keyword">var</span> t:int;</span><br><span class="line"><span class="keyword">begin</span></span><br><span class="line">    t:=tp[k].r;tp[k].r:=tp[t].l;tp[t].l:=k;</span><br><span class="line">    tp[t].s:=tp[k].s;upd(k);k:=t;</span><br><span class="line"><span class="keyword">end</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">procedure</span> <span class="title">rturn</span><span class="params">(<span class="keyword">var</span> k:int)</span>;</span> <span class="comment">//右旋</span></span><br><span class="line"><span class="keyword">var</span> t:int;</span><br><span class="line"><span class="keyword">begin</span></span><br><span class="line">    t:=tp[k].l;tp[k].l:=tp[t].r;tp[t].r:=k;</span><br><span class="line">    tp[t].s:=tp[k].s;upd(k);k:=t;</span><br><span class="line"><span class="keyword">end</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">procedure</span> <span class="title">ins</span><span class="params">(<span class="keyword">var</span> k:int;x:int)</span>;</span> <span class="comment">//插入</span></span><br><span class="line"><span class="keyword">begin</span></span><br><span class="line">    <span class="keyword">if</span> k=<span class="number">0</span> <span class="keyword">then</span> <span class="keyword">begin</span></span><br><span class="line">        inc(sz);k:=sz;tp[sz].w:=x;tp[sz].cnt:=<span class="number">1</span>;</span><br><span class="line">        tp[k].s:=<span class="number">1</span>;tp[sz].rnd:=random(inf);<span class="keyword">exit</span>;</span><br><span class="line">    <span class="keyword">end</span>;</span><br><span class="line">    <span class="keyword">if</span> x=tp[k].w <span class="keyword">then</span> <span class="keyword">begin</span> inc(tp[k].cnt);upd(k) <span class="keyword">end</span> <span class="comment">//<span class="doctag">bug:</span>缺upd(k)</span></span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> x&lt;tp[k].w <span class="keyword">then</span> <span class="keyword">begin</span></span><br><span class="line">        ins(tp[k].l,x);upd(k);</span><br><span class="line">        <span class="keyword">if</span> tp[k].rnd&lt;tp[tp[k].l].rnd <span class="keyword">then</span> rturn(k);</span><br><span class="line">    <span class="keyword">end</span> <span class="keyword">else</span> <span class="keyword">begin</span></span><br><span class="line">        ins(tp[k].r,x);upd(k);</span><br><span class="line">        <span class="keyword">if</span> tp[k].rnd&lt;tp[tp[k].r].rnd <span class="keyword">then</span> lturn(k);</span><br><span class="line">    <span class="keyword">end</span>;</span><br><span class="line"><span class="keyword">end</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">procedure</span> <span class="title">del</span><span class="params">(<span class="keyword">var</span> k:int;x:int)</span>;</span> <span class="comment">//堆式删除</span></span><br><span class="line"><span class="keyword">begin</span></span><br><span class="line">    <span class="keyword">if</span> k=<span class="number">0</span> <span class="keyword">then</span> <span class="keyword">exit</span>;</span><br><span class="line">    <span class="keyword">if</span> x&lt;tp[k].w <span class="keyword">then</span> del(tp[k].l,x)</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> x&gt;tp[k].w <span class="keyword">then</span> del(tp[k].r,x)</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">begin</span></span><br><span class="line">        <span class="keyword">if</span> tp[k].cnt&gt;<span class="number">1</span> <span class="keyword">then</span> dec(tp[k].cnt)</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> tp[k].l*tp[k].r=<span class="number">0</span> <span class="keyword">then</span> k:=max(tp[k].l,tp[k].r)</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> tp[tp[k].l].rnd&lt;tp[tp[k].r].rnd <span class="keyword">then</span></span><br><span class="line">            <span class="keyword">begin</span> lturn(k);del(tp[k].l,x) <span class="keyword">end</span></span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">begin</span> rturn(k);del(tp[k].r,x) <span class="keyword">end</span>;</span><br><span class="line">    <span class="keyword">end</span>;</span><br><span class="line">    <span class="keyword">if</span> k&lt;&gt;<span class="number">0</span> <span class="keyword">then</span> upd(k);</span><br><span class="line"><span class="keyword">end</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">low</span><span class="params">(k,x:int)</span>:</span>int; <span class="comment">//查询比x小的数的个数</span></span><br><span class="line"><span class="keyword">begin</span></span><br><span class="line">    <span class="keyword">if</span> k=<span class="number">0</span> <span class="keyword">then</span> <span class="keyword">exit</span>(<span class="number">0</span>)</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> x=tp[k].w <span class="keyword">then</span> <span class="keyword">exit</span>(tp[tp[k].l].s)</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> x&lt;tp[k].w <span class="keyword">then</span> <span class="keyword">exit</span>(low(tp[k].l,x))</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">exit</span>(tp[tp[k].l].s+tp[k].cnt+low(tp[k].r,x)); <span class="comment">//考虑cnt</span></span><br><span class="line"><span class="keyword">end</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">kth</span><span class="params">(k,x:int)</span>:</span>int; <span class="comment">//查询第k个树</span></span><br><span class="line"><span class="keyword">begin</span></span><br><span class="line">    <span class="keyword">if</span> k=<span class="number">0</span> <span class="keyword">then</span> <span class="keyword">exit</span>(<span class="number">0</span>)</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> tp[tp[k].l].s+tp[k].cnt&lt;x <span class="keyword">then</span></span><br><span class="line">        <span class="keyword">exit</span>(kth(tp[k].r,x-tp[tp[k].l].s-tp[k].cnt))</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> tp[tp[k].l].s&gt;=x <span class="keyword">then</span> <span class="keyword">exit</span>(kth(tp[k].l,x))</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">exit</span>(tp[k].w);</span><br><span class="line"><span class="keyword">end</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> _<span class="title">min</span><span class="params">(k:int)</span>:</span>int; <span class="comment">//查询子树k中的最小值</span></span><br><span class="line"><span class="keyword">begin</span></span><br><span class="line">    <span class="keyword">if</span> k=<span class="number">0</span> <span class="keyword">then</span> <span class="keyword">exit</span>(inf)</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> tp[k].l=<span class="number">0</span> <span class="keyword">then</span> <span class="keyword">exit</span>(tp[k].w)</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">exit</span>(_min(tp[k].l));</span><br><span class="line"><span class="keyword">end</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> _<span class="title">max</span><span class="params">(k:int)</span>:</span>int; <span class="comment">//查询子树k中的最大值</span></span><br><span class="line"><span class="keyword">begin</span></span><br><span class="line">    <span class="keyword">if</span> k=<span class="number">0</span> <span class="keyword">then</span> <span class="keyword">exit</span>(-inf)</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> tp[k].r=<span class="number">0</span> <span class="keyword">then</span> <span class="keyword">exit</span>(tp[k].w)</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">exit</span>(_max(tp[k].r));</span><br><span class="line"><span class="keyword">end</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">pvs</span><span class="params">(k,x:int)</span>:</span>int; <span class="comment">//求树中比x小的最大的数</span></span><br><span class="line"><span class="keyword">var</span> tmp:int;</span><br><span class="line"><span class="keyword">begin</span></span><br><span class="line">    tmp:=_min(tp[k].r);</span><br><span class="line">    <span class="keyword">if</span> tp[k].w&gt;=x <span class="keyword">then</span> <span class="keyword">exit</span>(pvs(tp[k].l,x))</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> tmp&gt;=x <span class="keyword">then</span> <span class="keyword">exit</span>(tp[k].w)</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">exit</span>(pvs(tp[k].r,x));</span><br><span class="line"><span class="keyword">end</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">nxt</span><span class="params">(k,x:int)</span>:</span>int; <span class="comment">//求树中比x大的最小的数</span></span><br><span class="line"><span class="keyword">var</span> tmp:int;</span><br><span class="line"><span class="keyword">begin</span></span><br><span class="line">    tmp:=_max(tp[k].l);</span><br><span class="line">    <span class="keyword">if</span> tp[k].w&lt;=x <span class="keyword">then</span> <span class="keyword">exit</span>(nxt(tp[k].r,x))</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> tmp&lt;=x <span class="keyword">then</span> <span class="keyword">exit</span>(tp[k].w)</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">exit</span>(nxt(tp[k].l,x));</span><br><span class="line"><span class="keyword">end</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">procedure</span> <span class="title">walk</span><span class="params">(k,d:int)</span>;</span> <span class="comment">//debug-output</span></span><br><span class="line"><span class="keyword">var</span> i:int;</span><br><span class="line"><span class="keyword">begin</span></span><br><span class="line">    <span class="keyword">if</span> k=<span class="number">0</span> <span class="keyword">then</span> <span class="keyword">exit</span>;</span><br><span class="line">    walk(tp[k].l,d+<span class="number">1</span>);</span><br><span class="line">    <span class="keyword">for</span> i:=<span class="number">1</span> <span class="keyword">to</span> d*<span class="number">7</span> <span class="keyword">do</span> <span class="keyword">write</span>(<span class="string">' '</span>);</span><br><span class="line">    writeln(tp[k].w,<span class="string">':'</span>,tp[k].cnt,<span class="string">':'</span>,tp[k].s);</span><br><span class="line">    walk(tp[k].r,d+<span class="number">1</span>);</span><br><span class="line"><span class="keyword">end</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">begin</span></span><br><span class="line">    randomize;<span class="keyword">read</span>(n);sz:=<span class="number">0</span>;rt:=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> i:=<span class="number">1</span> <span class="keyword">to</span> n <span class="keyword">do</span> <span class="keyword">begin</span></span><br><span class="line">        <span class="keyword">read</span>(op,x);</span><br><span class="line">        <span class="keyword">case</span> op <span class="keyword">of</span> </span><br><span class="line">            <span class="number">1</span>:ins(rt,x);</span><br><span class="line">            <span class="number">2</span>:del(rt,x);</span><br><span class="line">            <span class="number">3</span>:writeln(low(rt,x)+<span class="number">1</span>);</span><br><span class="line">            <span class="number">4</span>:writeln(kth(rt,x));</span><br><span class="line">            <span class="number">5</span>:writeln(pvs(rt,x));</span><br><span class="line">            <span class="number">6</span>:writeln(nxt(rt,x));</span><br><span class="line">        <span class="keyword">end</span>;</span><br><span class="line">        <span class="comment">//walk(rt,1);</span></span><br><span class="line">    <span class="keyword">end</span>;</span><br><span class="line"><span class="keyword">end</span>.</span><br></pre></td></tr></table></figure>
<p></p>
]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;大意&quot;&gt;&lt;a href=&quot;#大意&quot; class=&quot;headerlink&quot; title=&quot;大意&quot;&gt;&lt;/a&gt;大意&lt;/h2&gt;&lt;p&gt;实现一系列操作维护一个数集：插入、删除、查询数x的排名、查询排名为x的数、求前驱和后驱&lt;/p&gt;
    
    </summary>
    
      <category term="Problem Set" scheme="https://cothrax.github.io/categories/Problem-Set/"/>
    
    
      <category term="OI" scheme="https://cothrax.github.io/tags/OI/"/>
    
      <category term="数据结构" scheme="https://cothrax.github.io/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"/>
    
      <category term="平衡树" scheme="https://cothrax.github.io/tags/%E5%B9%B3%E8%A1%A1%E6%A0%91/"/>
    
      <category term="Treap" scheme="https://cothrax.github.io/tags/Treap/"/>
    
  </entry>
  
  <entry>
    <title>NOIP2016十连测 Day 10</title>
    <link href="https://cothrax.github.io/2016/11/04/lydsy-noip-2016-test10/"/>
    <id>https://cothrax.github.io/2016/11/04/lydsy-noip-2016-test10/</id>
    <published>2016-11-04T13:55:20.000Z</published>
    <updated>2016-11-08T14:47:42.991Z</updated>
    
    <content type="html"><![CDATA[<blockquote>
<p>订正进度(3/3)</p>
</blockquote>
<h1 id="P1-lis"><a href="#P1-lis" class="headerlink" title="P1 lis"></a>P1 lis</h1><p>大意：<br>给定长度n和参数$t_0,A,B,C,D$，定义数列$a_n$：<br>$n=1,a[n]=t_0$<br>$n\geq 2,a[n]=(A\times a_{n-1}^2+B\times a_{n-1}+C)\% D$</p>
<p>求$a_n$的最长不下降子序列<br>$0\leq t_0,A,B,C\leq150,1\leq D\leq150, 1\leq n\leq10^{12}$<br><a id="more"></a></p>
<h2 id="解法一"><a href="#解法一" class="headerlink" title="解法一"></a>解法一</h2><p>复杂度：$O(D^3logN)$<br>根据鸽巢原理，该数列一定有循环节$T\leq D$，该数列为<span>$\{l+m*T+r\}$</span><!-- Has MathJax -->，l为前面不属于循环节的部分，r为末尾剩余的不完整循环<br>考虑纯循环数列的lis<br>记f[n,i,j]为以a[i]开头，a[nT+j]结尾的lis<br>那么$f[n,i,j]=max_{1\leq k\leq T,a[i]\leq a[j]\leq a[k]}(f[n-1,i,k]+f[1,k,j]-1)$</p>
<p>这里定义矩阵$C=A\times B$：$$C[i,j]=max_{k=1}^n(A[i,k]+B[k,j]-1)$$</p>
<p>可以证明该乘法满足结合律，那么可以用矩阵快速幂求解f[n]：<br>$f[n]=f[n-1]\times f[1]=f[1]^n$<br>要求$a[i]\leq a[j]$，则不合法的g[i,j]标记为$-\infty$<br>单位矩阵的对角线上为0，其余为$-\infty$<br>初始矩阵f[1]直接dp求即可</p>
<p>记l[i]为<span>$\{l\}$</span><!-- Has MathJax -->中满足上界为T[i]的lis<br>记r[i]为<span>$\{r\}$</span><!-- Has MathJax -->中满足下界为T[i]的lis<br>这两个用直接dp求得</p>
<p>然后枚举中间部分的左右端点<br>$ans=max_{1\leq i,j\leq T}(l[i]+r[i]+g[m-1,i,j])$</p>
<p>细节：</p>
<ol>
<li>两个特判<ol>
<li>$n\leq l+T$，此时暴力求</li>
<li>循环节长为1时特判</li>
</ol>
</li>
<li>初始化矩阵时，枚举i,j求i..T+j的lis值，注意必须要以i开头、T+j结尾</li>
<li>快速幂的指数为m-1</li>
<li>不要让$-\infty$参与运算，防止出现诡异的错误</li>
</ol>
<div><br><div class="copy"><br>    <a href="/2016/11/04/lydsy-noip-2016-test10/lis_.pas" title="{plain text}">{plain text}</a><br></div><br><div><br><figure class="highlight delphi"><figcaption><span>_lis.pas</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">uses</span> math;</span><br><span class="line"><span class="keyword">const</span> inf=<span class="number">1000000000</span>;</span><br><span class="line"><span class="keyword">type</span> </span><br><span class="line">    int=longint;</span><br><span class="line">    mat=<span class="keyword">array</span>[<span class="number">0</span>..<span class="number">155</span>,<span class="number">0</span>..<span class="number">155</span>] <span class="keyword">of</span> int64;</span><br><span class="line"><span class="keyword">var</span> </span><br><span class="line">    a,b,c,d,k,i,j,x,til,len,rst:int;</span><br><span class="line">    l,r,f,s,loc:<span class="keyword">array</span>[<span class="number">0</span>..<span class="number">2240</span>] <span class="keyword">of</span> int;</span><br><span class="line">    g:mat;n,m,ans:int64;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">bin</span><span class="params">(x,n:int)</span>:</span>int;</span><br><span class="line"><span class="keyword">var</span> l,r,mid:int;</span><br><span class="line"><span class="keyword">begin</span></span><br><span class="line">    <span class="comment">//max_j&#123;f[j]&lt;=x&#125;</span></span><br><span class="line">    l:=<span class="number">1</span>;r:=n;bin:=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span> l&lt;=r <span class="keyword">do</span> <span class="keyword">begin</span></span><br><span class="line">        mid:=(l+r) <span class="keyword">shr</span> <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">if</span> f[mid]&lt;=x <span class="keyword">then</span> <span class="keyword">begin</span> bin:=mid;l:=mid+<span class="number">1</span> <span class="keyword">end</span></span><br><span class="line">        <span class="keyword">else</span> r:=mid-<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">end</span>;</span><br><span class="line"><span class="keyword">end</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">lis</span><span class="params">(dn,up,n,b:int)</span>:</span>int;</span><br><span class="line"><span class="keyword">var</span> i,j:int;</span><br><span class="line"><span class="keyword">begin</span></span><br><span class="line">    <span class="keyword">for</span> i:=<span class="number">1</span> <span class="keyword">to</span> n <span class="keyword">do</span> f[i]:=inf;</span><br><span class="line">    lis:=<span class="number">0</span>;f[<span class="number">0</span>]:=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> i:=<span class="number">1</span> <span class="keyword">to</span> n <span class="keyword">do</span> <span class="keyword">begin</span></span><br><span class="line">        <span class="keyword">if</span> (s[b+i]&lt;dn)<span class="keyword">or</span>(s[b+i]&gt;up) <span class="keyword">then</span> <span class="keyword">continue</span>;</span><br><span class="line">        j:=bin(s[b+i],lis);</span><br><span class="line">        f[j+<span class="number">1</span>]:=min(f[j+<span class="number">1</span>],s[b+i]);</span><br><span class="line">        <span class="keyword">if</span> j=lis <span class="keyword">then</span> inc(lis);</span><br><span class="line">    <span class="keyword">end</span>;</span><br><span class="line"><span class="keyword">end</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> _<span class="title">lis</span><span class="params">(n,b:int)</span>:</span>int;</span><br><span class="line"><span class="keyword">var</span> i,j,len:int;</span><br><span class="line"><span class="keyword">begin</span></span><br><span class="line">    <span class="keyword">for</span> i:=<span class="number">1</span> <span class="keyword">to</span> n <span class="keyword">do</span> f[i]:=inf;</span><br><span class="line">    f[<span class="number">1</span>]:=s[b+<span class="number">1</span>];len:=<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span> i:=<span class="number">2</span> <span class="keyword">to</span> n <span class="keyword">do</span> <span class="keyword">begin</span></span><br><span class="line">        j:=bin(s[b+i],len);</span><br><span class="line">        <span class="keyword">if</span> j&gt;<span class="number">0</span> <span class="keyword">then</span> f[j+<span class="number">1</span>]:=min(f[j+<span class="number">1</span>],s[b+i]);</span><br><span class="line">        <span class="keyword">if</span> j=len <span class="keyword">then</span> inc(len);</span><br><span class="line">    <span class="keyword">end</span>;</span><br><span class="line">    _lis:=j+<span class="number">1</span>;</span><br><span class="line"><span class="keyword">end</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">mul</span><span class="params">(<span class="keyword">var</span> a,b:mat)</span>:</span>mat;</span><br><span class="line"><span class="keyword">var</span> i,j,k:int;</span><br><span class="line"><span class="keyword">begin</span></span><br><span class="line">    fillchar(mul,sizeof(mul),<span class="number">224</span>);</span><br><span class="line">    <span class="keyword">for</span> i:=<span class="number">1</span> <span class="keyword">to</span> len <span class="keyword">do</span></span><br><span class="line">        <span class="keyword">for</span> j:=<span class="number">1</span> <span class="keyword">to</span> len <span class="keyword">do</span></span><br><span class="line">            <span class="keyword">for</span> k:=<span class="number">1</span> <span class="keyword">to</span> len <span class="keyword">do</span> <span class="keyword">if</span> min(a[i,k],b[k,j])&gt;=<span class="number">0</span> <span class="keyword">then</span></span><br><span class="line">                mul[i,j]:=max(mul[i,j],a[i,k]+b[k,j]-<span class="number">1</span>);</span><br><span class="line"><span class="keyword">end</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">mpow</span><span class="params">(<span class="keyword">var</span> a:mat;p:int64)</span>:</span>mat;</span><br><span class="line"><span class="keyword">var</span> i:int;</span><br><span class="line"><span class="keyword">begin</span></span><br><span class="line">    fillchar(mpow,sizeof(mpow),<span class="number">224</span>);</span><br><span class="line">    <span class="keyword">for</span> i:=<span class="number">1</span> <span class="keyword">to</span> len <span class="keyword">do</span> mpow[i,i]:=<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">while</span> p&gt;<span class="number">0</span> <span class="keyword">do</span> <span class="keyword">begin</span></span><br><span class="line">        <span class="keyword">if</span> p <span class="keyword">and</span> <span class="number">1</span>=<span class="number">1</span> <span class="keyword">then</span> mpow:=mul(mpow,a);</span><br><span class="line">        a:=mul(a,a);</span><br><span class="line">        p:=p <span class="keyword">shr</span> <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">end</span>;</span><br><span class="line"><span class="keyword">end</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">begin</span></span><br><span class="line">    assign(input,<span class="string">'lis.in'</span>);reset(input);</span><br><span class="line">    assign(output,<span class="string">'lis.out'</span>);rewrite(output);</span><br><span class="line">    <span class="keyword">read</span>(n,s[<span class="number">1</span>],a,b,c,d);k:=<span class="number">1</span>;</span><br><span class="line">    <span class="comment">//找循环节</span></span><br><span class="line">    <span class="keyword">while</span> true <span class="keyword">do</span> <span class="keyword">begin</span></span><br><span class="line">        x:=(a*sqr(s[k])+b*s[k]+c)<span class="keyword">mod</span> d;</span><br><span class="line">        <span class="keyword">if</span> loc[x]&gt;<span class="number">0</span> <span class="keyword">then</span> <span class="keyword">break</span>;</span><br><span class="line">        inc(k);s[k]:=x;loc[x]:=k;</span><br><span class="line">    <span class="keyword">end</span>;</span><br><span class="line">    til:=loc[x]-<span class="number">1</span>;len:=k-loc[x]+<span class="number">1</span>;</span><br><span class="line">    rst:=(n-til)<span class="keyword">mod</span> len;m:=(n-til)<span class="keyword">div</span> len;</span><br><span class="line">    <span class="keyword">if</span> n&lt;=k <span class="keyword">then</span> <span class="comment">//不足一个周期特判</span></span><br><span class="line">        <span class="keyword">begin</span> <span class="keyword">write</span>(lis(-<span class="number">1</span>,d,n,<span class="number">0</span>));halt <span class="keyword">end</span>;</span><br><span class="line">    <span class="keyword">if</span> len=<span class="number">1</span> <span class="keyword">then</span> <span class="comment">//周期为1特判</span></span><br><span class="line">        <span class="keyword">begin</span> <span class="keyword">write</span>(m+lis(-<span class="number">1</span>,s[til+<span class="number">1</span>],til,<span class="number">0</span>));halt <span class="keyword">end</span>;</span><br><span class="line">    <span class="keyword">for</span> i:=k+<span class="number">1</span> <span class="keyword">to</span> k+len <span class="keyword">do</span> s[i]:=s[i-len];</span><br><span class="line">    <span class="comment">//预处理</span></span><br><span class="line">    <span class="keyword">for</span> i:=<span class="number">1</span> <span class="keyword">to</span> len <span class="keyword">do</span> <span class="keyword">begin</span></span><br><span class="line">        l[i]:=lis(-<span class="number">1</span>,s[til+i],til,<span class="number">0</span>);</span><br><span class="line">        r[i]:=lis(s[til+i],d,rst,til);</span><br><span class="line">    <span class="keyword">end</span>;</span><br><span class="line">    <span class="comment">//矩阵快速幂</span></span><br><span class="line">    <span class="comment">//g[n,i,j]=max(g[n-1,i,j]+g[1,j,k]) a[i]&lt;=a[j]&lt;=a[k]</span></span><br><span class="line">    <span class="keyword">for</span> i:=<span class="number">1</span> <span class="keyword">to</span> len <span class="keyword">do</span></span><br><span class="line">        <span class="keyword">for</span> j:=<span class="number">1</span> <span class="keyword">to</span> len <span class="keyword">do</span></span><br><span class="line">            <span class="keyword">if</span> s[til+i]&gt;s[til+j] <span class="keyword">then</span> g[i,j]:=-inf</span><br><span class="line">            <span class="keyword">else</span> g[i,j]:=_lis(len-i+j+<span class="number">1</span>,til-<span class="number">1</span>+i);</span><br><span class="line">    g:=mpow(g,m-<span class="number">1</span>);ans:=<span class="number">0</span>;</span><br><span class="line">    <span class="comment">//统计答案</span></span><br><span class="line">    <span class="keyword">for</span> i:=<span class="number">1</span> <span class="keyword">to</span> len <span class="keyword">do</span></span><br><span class="line">        <span class="keyword">for</span> j:=<span class="number">1</span> <span class="keyword">to</span> len <span class="keyword">do</span></span><br><span class="line">            ans:=max(ans,l[i]+r[j]+g[i,j]);</span><br><span class="line">    <span class="keyword">write</span>(ans);</span><br><span class="line">    close(input);close(output);</span><br><span class="line"><span class="keyword">end</span>.</span><br></pre></td></tr></table></figure><br><br></div></div>

<h2 id="解法二"><a href="#解法二" class="headerlink" title="解法二"></a>解法二</h2><p>复杂度：$O(D^2logN)$<br>其实这题可以乱搞：<br>在n比较小时，可以直接暴力生成$O(NlogN)$求LIS<br>而当n足够大时，有如下解法：<br>为叙述方便，记$LIS(dn,up,seq)$为求在数列seq中$seq[i]\in[dn,up]$的LIS值<br>枚举一个循环节中的数T[i]，记$dt=l^2$<br>用<span>$LIS(-\infty,T[i],\{l+dt*T\})+(m-2*l)+LIS(T[i],+\infty,\{dt*T+r\})$</span><!-- Has MathJax --><br>简单来说，就是求l并上$l^2$个T的lis、$l^2$个T并上r的lis，中间部分的lis=循环节数<br>正确性显然<br>细节：注意端点</p>
<div><br><div class="copy"><br>    <a href="/2016/11/04/lydsy-noip-2016-test10/lis.pas" title="{plain text}">{plain text}</a><br></div><br><div><br><figure class="highlight delphi"><figcaption><span>lis.pas</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">uses</span> math;</span><br><span class="line"><span class="keyword">type</span> int=longint;ll=int64;</span><br><span class="line"><span class="keyword">const</span> inf=<span class="number">1000000</span>;mx=<span class="number">100000</span>;</span><br><span class="line"><span class="keyword">var</span> </span><br><span class="line">    loc:<span class="keyword">array</span>[<span class="number">0</span>..<span class="number">155</span>] <span class="keyword">of</span> int;</span><br><span class="line">    seq,f:<span class="keyword">array</span>[<span class="number">0</span>..mx+<span class="number">10</span>] <span class="keyword">of</span> int;</span><br><span class="line">    a,b,c,d,k,x,i:int;n:int64;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">bin</span><span class="params">(x,n:int)</span>:</span>int;</span><br><span class="line"><span class="keyword">var</span> l,r,mid:int;</span><br><span class="line"><span class="keyword">begin</span></span><br><span class="line">    l:=<span class="number">0</span>;r:=n;bin:=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span> l&lt;=r <span class="keyword">do</span> <span class="keyword">begin</span></span><br><span class="line">        mid:=(l+r) <span class="keyword">shr</span> <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">if</span> f[mid]&lt;=x <span class="keyword">then</span> <span class="keyword">begin</span> bin:=mid;l:=mid+<span class="number">1</span> <span class="keyword">end</span></span><br><span class="line">        <span class="keyword">else</span> r:=mid-<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">end</span>;</span><br><span class="line"><span class="keyword">end</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">lis</span><span class="params">(dn,up,n,b:int)</span>:</span>int;</span><br><span class="line"><span class="keyword">var</span> i,j:int;</span><br><span class="line"><span class="keyword">begin</span></span><br><span class="line">    <span class="keyword">for</span> i:=<span class="number">1</span> <span class="keyword">to</span> n <span class="keyword">do</span> f[i]:=inf;</span><br><span class="line">    f[<span class="number">0</span>]:=<span class="number">0</span>;lis:=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> i:=<span class="number">1</span> <span class="keyword">to</span> n <span class="keyword">do</span> <span class="keyword">begin</span></span><br><span class="line">        <span class="keyword">if</span> (seq[b+i]&lt;dn)<span class="keyword">or</span>(seq[b+i]&gt;up) <span class="keyword">then</span> <span class="keyword">continue</span>;</span><br><span class="line">        j:=bin(seq[b+i],lis);</span><br><span class="line">        f[j+<span class="number">1</span>]:=min(f[j+<span class="number">1</span>],seq[b+i]);</span><br><span class="line">        <span class="keyword">if</span> j=lis <span class="keyword">then</span> inc(lis);</span><br><span class="line">    <span class="keyword">end</span>;</span><br><span class="line"><span class="keyword">end</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">procedure</span> <span class="title">solv</span><span class="params">()</span>;</span></span><br><span class="line"><span class="keyword">var</span> b,r,l,i,dt:int;ans,m:int64;</span><br><span class="line"><span class="keyword">begin</span></span><br><span class="line">    b:=loc[x];l:=k-loc[x]+<span class="number">1</span>;</span><br><span class="line">    m:=(n-b+<span class="number">1</span>)<span class="keyword">div</span> l;r:=(n-b+<span class="number">1</span>)<span class="keyword">mod</span> l;</span><br><span class="line">    dt:=l*l;</span><br><span class="line">    <span class="keyword">for</span> i:=k+<span class="number">1</span> <span class="keyword">to</span> k+dt <span class="keyword">do</span> seq[i]:=seq[i-l];</span><br><span class="line">    ans:=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> i:=b <span class="keyword">to</span> k <span class="keyword">do</span></span><br><span class="line">        ans:=max(ans,ll(lis(-<span class="number">1</span>,seq[i],b-<span class="number">1</span>+dt,<span class="number">0</span>))+</span><br><span class="line">            ll(lis(seq[i],d,r+dt,b-<span class="number">1</span>))+m-<span class="number">2</span>*l);</span><br><span class="line">    <span class="keyword">write</span>(ans);</span><br><span class="line"><span class="keyword">end</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">begin</span></span><br><span class="line">    assign(input,<span class="string">'lis.in'</span>);reset(input);</span><br><span class="line">    assign(output,<span class="string">'lis.out'</span>);rewrite(output);</span><br><span class="line">    <span class="keyword">read</span>(n,seq[<span class="number">1</span>],a,b,c,d);</span><br><span class="line">    <span class="keyword">if</span> n&lt;=mx <span class="keyword">then</span> <span class="keyword">begin</span></span><br><span class="line">        <span class="keyword">for</span> i:=<span class="number">2</span> <span class="keyword">to</span> n <span class="keyword">do</span></span><br><span class="line">            seq[i]:=(a*sqr(seq[i-<span class="number">1</span>])+b*seq[i-<span class="number">1</span>]+c) <span class="keyword">mod</span> d;</span><br><span class="line">        <span class="keyword">write</span>(lis(-<span class="number">1</span>,d,n,<span class="number">0</span>));halt;</span><br><span class="line">    <span class="keyword">end</span>;</span><br><span class="line">    loc[seq[<span class="number">1</span>]]:=<span class="number">1</span>;k:=<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">while</span> true <span class="keyword">do</span> <span class="keyword">begin</span></span><br><span class="line">        x:=(a*sqr(seq[k])+b*seq[k]+c) <span class="keyword">mod</span> d;</span><br><span class="line">        <span class="keyword">if</span> loc[x]&lt;&gt;<span class="number">0</span> <span class="keyword">then</span> <span class="keyword">break</span>;</span><br><span class="line">        inc(k);seq[k]:=x;loc[x]:=k;</span><br><span class="line">    <span class="keyword">end</span>;</span><br><span class="line">    solv();</span><br><span class="line">    close(input);close(output);</span><br><span class="line"><span class="keyword">end</span>.</span><br></pre></td></tr></table></figure><br><br></div></div>

<h1 id="P2-bag"><a href="#P2-bag" class="headerlink" title="P2 bag"></a>P2 bag</h1><p>大意：给定n种物品，第i种体积为$v_i$，其中体积不小于l的物品总数不能超过c件，其他个数无限。有m次询问，第i次给定容量$w_i$的背包，问是否存在恰好装满的方案<br>$n\leq 50;m\leq 10^5;v_i,l\leq 10^4;$<br>$c\leq 30,w_i\leq 10^{18}$</p>
<h2 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h2><p>最短路处理dp<br>记最小的物品体积为v0，分类讨论</p>
<ul>
<li>$v0&gt;l$</li>
</ul>
<p>这种情况下体积有上限cV<br>于是直接dp：<br>f[i,j,k] 1..i种物品，大物品有j件，总体积为k的方案是否存在<br>转移：$f[i,j,k]=f[i-1,j,k]\ or\ f[i,j-1,k-v[i]]$<br>对于一个w，答案是f[n,0..c,w]<br>可以用bitset优化，但pascal没有所以不讨论</p>
<ul>
<li>$v0\leq l$</li>
</ul>
<p>如果存在体积为w的方案，那么一定存在体积为w+v0的方案<br>答案具有一定的单调性，也就是说可以表示为w=p*v0+k的方案可以归为一类<br>记s=f[i,j,k] 1..i种物品，大物品限制j件，当$s\% v0=k$时s的最小值<br>转移：<br>$v[i]&gt;v0$,$f[i,j,k]=min(f[i-1,j,k],f[i,j-1,(k-v[i])\% v0]+v[i])$<br>$v[i]\leq v0$,$f[i,j,k]=min(f[i-1,j,k],f[i,j,(k-v[i])\% v0]+v[i])$</p>
<p>第一种直接for循环即可<br>第二种的转移是存在环的，用节点建图，就规约为最短路的求解<br>记原点s，从s向f[i,j,k]连权为f[i-1,j,k]的边<br>从f[i,j,k]向f[i,j,(k+v[i])%v0]连权为v[i]的边<br>然后spfa</p>
<p>其实图是不用存的，转移时处理即可</p>
<p>bug</p>
<ol>
<li>记得检查输出格式，换行</li>
<li>状态f[i,j,k]的含义是 大物品件数=j时的解，最后要用前缀最小值f[n,0..j,k]</li>
<li>up和lim不可混用</li>
<li>数据范围！$w\leq 10^{18}$</li>
</ol>
<div><br><div class="copy"><br>    <a href="/2016/11/04/lydsy-noip-2016-test10/bag.pas" title="{plain text}">{plain text}</a><br></div><br><div><br><figure class="highlight delphi"><figcaption><span>bag.pas</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">uses</span> math;</span><br><span class="line"><span class="keyword">type</span> int=longint;</span><br><span class="line"><span class="keyword">var</span> </span><br><span class="line">    n,m,mn,mx,up,lim,i:int;</span><br><span class="line">    v:<span class="keyword">array</span>[<span class="number">0</span>..<span class="number">55</span>] <span class="keyword">of</span> int;</span><br><span class="line">    f:<span class="keyword">array</span>[<span class="number">0</span>..<span class="number">35</span>,<span class="number">0</span>..<span class="number">300010</span>] <span class="keyword">of</span> int64;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">procedure</span> <span class="title">solv1</span><span class="params">()</span>;</span></span><br><span class="line"><span class="keyword">var</span> </span><br><span class="line">    f:<span class="keyword">array</span>[<span class="number">0</span>..<span class="number">35</span>,<span class="number">0</span>..<span class="number">300010</span>] <span class="keyword">of</span> boolean;</span><br><span class="line">    i,j,k:int;w:int64;</span><br><span class="line"><span class="keyword">begin</span></span><br><span class="line">    fillchar(f,sizeof(f),false);</span><br><span class="line">    f[<span class="number">0</span>,<span class="number">0</span>]:=true;mx:=mx*n;</span><br><span class="line">    <span class="keyword">for</span> i:=<span class="number">1</span> <span class="keyword">to</span> n <span class="keyword">do</span></span><br><span class="line">        <span class="keyword">for</span> j:=<span class="number">1</span> <span class="keyword">to</span> lim <span class="keyword">do</span></span><br><span class="line">            <span class="keyword">for</span> k:=v[i] <span class="keyword">to</span> mx <span class="keyword">do</span></span><br><span class="line">                f[j,k]:=f[j,k] <span class="keyword">or</span> f[j-<span class="number">1</span>,k-v[i]];</span><br><span class="line">    <span class="keyword">for</span> i:=<span class="number">1</span> <span class="keyword">to</span> m <span class="keyword">do</span> <span class="keyword">begin</span></span><br><span class="line">        <span class="keyword">read</span>(w);</span><br><span class="line">        <span class="keyword">if</span> (w&lt;=mx) <span class="keyword">and</span> f[lim,w] <span class="keyword">then</span> writeln(<span class="string">'Yes'</span>) </span><br><span class="line">        <span class="keyword">else</span> writeln(<span class="string">'No'</span>);</span><br><span class="line">    <span class="keyword">end</span>;</span><br><span class="line"><span class="keyword">end</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">procedure</span> <span class="title">solv2</span><span class="params">()</span>;</span></span><br><span class="line"><span class="keyword">var</span> </span><br><span class="line">    q:<span class="keyword">array</span>[<span class="number">0</span>..<span class="number">10010</span>] <span class="keyword">of</span> int;</span><br><span class="line">    inq:<span class="keyword">array</span>[<span class="number">0</span>..<span class="number">10010</span>] <span class="keyword">of</span> boolean;</span><br><span class="line">    i,j,k:int;w:int64;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">procedure</span> <span class="title">spfa</span><span class="params">(x:int64)</span>;</span></span><br><span class="line">    <span class="keyword">var</span> i,v,u,h,t:int;</span><br><span class="line">    <span class="keyword">begin</span></span><br><span class="line">        h:=<span class="number">0</span>;t:=mn;</span><br><span class="line">        <span class="keyword">for</span> i:=<span class="number">0</span> <span class="keyword">to</span> mn-<span class="number">1</span> <span class="keyword">do</span> q[i]:=i;</span><br><span class="line">        fillchar(inq,sizeof(inq),true);</span><br><span class="line">        <span class="keyword">while</span> h&lt;&gt;t <span class="keyword">do</span> <span class="keyword">begin</span></span><br><span class="line">            u:=q[h];v:=(u+x)<span class="keyword">mod</span> mn;</span><br><span class="line">            <span class="keyword">if</span> f[j,v]&gt;f[j,u]+x <span class="keyword">then</span> <span class="keyword">begin</span></span><br><span class="line">                f[j,v]:=f[j,u]+x;</span><br><span class="line">                <span class="keyword">if</span> <span class="keyword">not</span> inq[v] <span class="keyword">then</span> <span class="keyword">begin</span></span><br><span class="line">                    q[t]:=v;inq[v]:=true;</span><br><span class="line">                    inc(t);<span class="keyword">if</span> t&gt;<span class="number">10010</span> <span class="keyword">then</span> t:=<span class="number">0</span>;</span><br><span class="line">                <span class="keyword">end</span>;</span><br><span class="line">            <span class="keyword">end</span>;</span><br><span class="line">            inq[u]:=false;inc(h);<span class="keyword">if</span> h&gt;<span class="number">10010</span> <span class="keyword">then</span> h:=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">end</span>;</span><br><span class="line">    <span class="keyword">end</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">begin</span></span><br><span class="line">    fillchar(f,sizeof(f),<span class="number">31</span>);</span><br><span class="line">    f[<span class="number">0</span>,<span class="number">0</span>]:=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> i:=<span class="number">1</span> <span class="keyword">to</span> n <span class="keyword">do</span> <span class="keyword">begin</span></span><br><span class="line">        <span class="keyword">if</span> v[i]&gt;=up <span class="keyword">then</span> <span class="keyword">for</span> j:=<span class="number">1</span> <span class="keyword">to</span> lim <span class="keyword">do</span> <span class="keyword">for</span> k:=<span class="number">0</span> <span class="keyword">to</span> mn-<span class="number">1</span> <span class="keyword">do</span></span><br><span class="line">            f[j,k]:=min(f[j,k],f[j-<span class="number">1</span>,((k-v[i])<span class="keyword">mod</span> mn+mn)<span class="keyword">mod</span> mn]+v[i])</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">for</span> j:=<span class="number">0</span> <span class="keyword">to</span> lim <span class="keyword">do</span> spfa(v[i]);</span><br><span class="line">    <span class="keyword">end</span>;</span><br><span class="line">    <span class="keyword">for</span> k:=<span class="number">0</span> <span class="keyword">to</span> mn-<span class="number">1</span> <span class="keyword">do</span></span><br><span class="line">        <span class="keyword">for</span> j:=<span class="number">0</span> <span class="keyword">to</span> lim-<span class="number">1</span> <span class="keyword">do</span> f[lim,k]:=min(f[lim,k],f[j,k]);</span><br><span class="line">    <span class="keyword">for</span> i:=<span class="number">1</span> <span class="keyword">to</span> m <span class="keyword">do</span> <span class="keyword">begin</span></span><br><span class="line">        <span class="keyword">read</span>(w);</span><br><span class="line">        <span class="keyword">if</span> f[lim,w <span class="keyword">mod</span> mn]&lt;=w <span class="keyword">then</span> writeln(<span class="string">'Yes'</span>)</span><br><span class="line">        <span class="keyword">else</span> writeln(<span class="string">'No'</span>);</span><br><span class="line">    <span class="keyword">end</span>;</span><br><span class="line"><span class="keyword">end</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">begin</span></span><br><span class="line">    assign(input,<span class="string">'bag_sample3.in'</span>);reset(input);</span><br><span class="line">    assign(output,<span class="string">'bag.out'</span>);rewrite(output);</span><br><span class="line">    <span class="keyword">read</span>(n,m);mn:=maxlongint;</span><br><span class="line">    <span class="keyword">for</span> i:=<span class="number">1</span> <span class="keyword">to</span> n <span class="keyword">do</span> <span class="keyword">begin</span> </span><br><span class="line">        <span class="keyword">read</span>(v[i]);mn:=min(mn,v[i]);mx:=max(mx,v[i]) </span><br><span class="line">    <span class="keyword">end</span>;</span><br><span class="line">    <span class="keyword">read</span>(up,lim);</span><br><span class="line">    <span class="keyword">if</span> mn&gt;=up <span class="keyword">then</span> solv1() <span class="keyword">else</span> solv2();</span><br><span class="line">    close(input);close(output);</span><br><span class="line"><span class="keyword">end</span>.</span><br></pre></td></tr></table></figure><br><br></div></div>

<h1 id="P2-lca"><a href="#P2-lca" class="headerlink" title="P2 lca"></a>P2 lca</h1><p>大意：给定n个节点的树，点上有权值，开始所有点是白色的<br>共有m次操作，分为两种：</p>
<ol>
<li><code>Modify v</code> 把v改成黑色</li>
<li><code>Query v</code> 求lca(v,一个黑色节点)的权值的最大值</li>
</ol>
<p>$n\leq 10^5,m\leq 2*10^5$</p>
<h2 id="题解-1"><a href="#题解-1" class="headerlink" title="题解"></a>题解</h2><p>dfs序+线段树<br>考虑一个点u的权值对查询v的贡献，显然只有当v在u的子树中时才会产生贡献<br>于是对于每次修改u，遍历u到根的路径，对于路径上的每个点v，更新v的子树的答案，排除u所在的那颗子树<br>这样只要先求出dfs序，然后用线段树维护最大值即可<br>此外，如果一个点w之前被遍历过，那么其父节点p一定被以相同的方式处理过，因此更新完w后break即可</p>
<p>线段树注意点：</p>
<ol>
<li>pushdown下移标记时不是简单赋值</li>
<li>处理区间时，分清当前区间[b,e]和操作区间[l,r]，mid=(b+e) shr 1</li>
<li>其实本题只有单点查值，没有pushdown的必要</li>
</ol>
<div><br><div class="copy"><br>    <a href="/2016/11/04/lydsy-noip-2016-test10/lca.pas" title="{plain text}">{plain text}</a><br></div><br><div><br><figure class="highlight delphi"><figcaption><span>lca.pas</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">uses</span> math;</span><br><span class="line"><span class="keyword">type</span> int=longint;edge=<span class="keyword">record</span> v,nxt:int <span class="keyword">end</span>;</span><br><span class="line"><span class="keyword">var</span> </span><br><span class="line">    g:<span class="keyword">array</span>[<span class="number">0</span>..<span class="number">200010</span>] <span class="keyword">of</span> edge;</span><br><span class="line">    seg:<span class="keyword">array</span>[<span class="number">0</span>..<span class="number">400010</span>] <span class="keyword">of</span> int;</span><br><span class="line">    w,l,r,head,par:<span class="keyword">array</span>[<span class="number">0</span>..<span class="number">100010</span>] <span class="keyword">of</span> int;</span><br><span class="line">    flg:<span class="keyword">array</span>[<span class="number">0</span>..<span class="number">100010</span>] <span class="keyword">of</span> boolean;</span><br><span class="line">    n,m,sz,i,k,u,v:int;s:<span class="keyword">string</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">procedure</span> <span class="title">add</span><span class="params">(u,v:int)</span>;</span></span><br><span class="line"><span class="keyword">begin</span></span><br><span class="line">    inc(sz);g[sz].v:=v;</span><br><span class="line">    g[sz].nxt:=head[u];head[u]:=sz;</span><br><span class="line"><span class="keyword">end</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">procedure</span> <span class="title">dfs</span><span class="params">(u:int)</span>;</span></span><br><span class="line"><span class="keyword">var</span> i,v:int;</span><br><span class="line"><span class="keyword">begin</span></span><br><span class="line">    inc(k);l[u]:=k;i:=head[u];</span><br><span class="line">    <span class="keyword">while</span> i&lt;&gt;<span class="number">0</span> <span class="keyword">do</span> <span class="keyword">begin</span></span><br><span class="line">        v:=g[i].v;</span><br><span class="line">        <span class="keyword">if</span> l[v]=<span class="number">0</span> <span class="keyword">then</span> <span class="keyword">begin</span> par[v]:=u;dfs(v) <span class="keyword">end</span>;</span><br><span class="line">        i:=g[i].nxt;</span><br><span class="line">    <span class="keyword">end</span>;</span><br><span class="line">    r[u]:=k;</span><br><span class="line"><span class="keyword">end</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">procedure</span> _<span class="title">modify</span><span class="params">(i,b,e,l,r,k:int)</span>;</span></span><br><span class="line"><span class="keyword">var</span> mid:int;</span><br><span class="line"><span class="keyword">begin</span></span><br><span class="line">    <span class="keyword">if</span> (l&gt;r) <span class="keyword">or</span> (e&lt;l) <span class="keyword">or</span> (b&gt;r) <span class="keyword">then</span> <span class="keyword">exit</span>;</span><br><span class="line">    <span class="keyword">if</span> (l&lt;=b) <span class="keyword">and</span> (e&lt;=r) <span class="keyword">then</span> <span class="keyword">begin</span></span><br><span class="line">        seg[i]:=max(seg[i],k);</span><br><span class="line">        <span class="keyword">exit</span>;</span><br><span class="line">    <span class="keyword">end</span>;</span><br><span class="line">    mid:=(b+e) <span class="keyword">shr</span> <span class="number">1</span>;</span><br><span class="line">    _modify(i <span class="keyword">shl</span> <span class="number">1</span>,b,mid,l,r,k);</span><br><span class="line">    _modify(i <span class="keyword">shl</span> <span class="number">1</span> <span class="keyword">or</span> <span class="number">1</span>,mid+<span class="number">1</span>,e,l,r,k);</span><br><span class="line"><span class="keyword">end</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> _<span class="title">query</span><span class="params">(i,b,e,x:int)</span>:</span>int;</span><br><span class="line"><span class="keyword">var</span> mid:int;</span><br><span class="line"><span class="keyword">begin</span></span><br><span class="line">    <span class="keyword">if</span> b=e <span class="keyword">then</span> <span class="keyword">exit</span>(seg[i]);</span><br><span class="line">    mid:=(b+e) <span class="keyword">shr</span> <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">if</span> x&lt;=mid <span class="keyword">then</span> _query:=max(seg[i],_query(i <span class="keyword">shl</span> <span class="number">1</span>,b,mid,x))</span><br><span class="line">    <span class="keyword">else</span> _query:=max(seg[i],_query(i <span class="keyword">shl</span> <span class="number">1</span> <span class="keyword">or</span> <span class="number">1</span>,mid+<span class="number">1</span>,e,x));</span><br><span class="line"><span class="keyword">end</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">procedure</span> <span class="title">modify</span><span class="params">(u:int)</span>;</span></span><br><span class="line"><span class="keyword">var</span> v:int;</span><br><span class="line"><span class="keyword">begin</span></span><br><span class="line">    _modify(<span class="number">1</span>,<span class="number">1</span>,n,l[u],r[u],w[u]);</span><br><span class="line">    <span class="keyword">if</span> flg[u] <span class="keyword">then</span> <span class="keyword">exit</span>;</span><br><span class="line">    flg[u]:=true;v:=u;u:=par[u];</span><br><span class="line">    <span class="keyword">while</span> u&lt;&gt;<span class="number">0</span> <span class="keyword">do</span> <span class="keyword">begin</span> </span><br><span class="line">        _modify(<span class="number">1</span>,<span class="number">1</span>,n,l[u],l[v]-<span class="number">1</span>,w[u]);</span><br><span class="line">        _modify(<span class="number">1</span>,<span class="number">1</span>,n,r[v]+<span class="number">1</span>,r[u],w[u]);</span><br><span class="line">        <span class="keyword">if</span> flg[u] <span class="keyword">then</span> <span class="keyword">exit</span>;</span><br><span class="line">        flg[u]:=true;v:=u;u:=par[u];</span><br><span class="line">    <span class="keyword">end</span>;</span><br><span class="line"><span class="keyword">end</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">procedure</span> <span class="title">query</span><span class="params">(u:int)</span>;</span></span><br><span class="line"><span class="keyword">begin</span> writeln(_query(<span class="number">1</span>,<span class="number">1</span>,n,l[u])) <span class="keyword">end</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">begin</span></span><br><span class="line">    assign(input,<span class="string">'lca_sample2.in'</span>);reset(input);</span><br><span class="line">    assign(output,<span class="string">'lca.out'</span>);rewrite(output);</span><br><span class="line">    readln(n,m);</span><br><span class="line">    <span class="keyword">for</span> i:=<span class="number">1</span> <span class="keyword">to</span> n <span class="keyword">do</span> <span class="keyword">read</span>(w[i]);readln;</span><br><span class="line">    <span class="keyword">for</span> i:=<span class="number">1</span> <span class="keyword">to</span> n-<span class="number">1</span> <span class="keyword">do</span> <span class="keyword">begin</span></span><br><span class="line">        readln(u,v);add(u,v);add(v,u);</span><br><span class="line">    <span class="keyword">end</span>;</span><br><span class="line">    k:=<span class="number">0</span>;dfs(<span class="number">1</span>);</span><br><span class="line">    fillchar(seg,sizeof(seg),<span class="number">255</span>);</span><br><span class="line">    <span class="keyword">for</span> i:=<span class="number">1</span> <span class="keyword">to</span> m <span class="keyword">do</span> <span class="keyword">begin</span></span><br><span class="line">        readln(s);</span><br><span class="line">        <span class="keyword">case</span> s[<span class="number">1</span>] <span class="keyword">of</span></span><br><span class="line">            <span class="string">'Q'</span>:<span class="keyword">begin</span> val(copy(s,<span class="number">7</span>,length(s)-<span class="number">6</span>),u,v);query(u)<span class="keyword">end</span>;</span><br><span class="line">            <span class="string">'M'</span>:<span class="keyword">begin</span> val(copy(s,<span class="number">8</span>,length(s)-<span class="number">7</span>),u,v);modify(u)<span class="keyword">end</span>;</span><br><span class="line">        <span class="keyword">end</span>;</span><br><span class="line">    <span class="keyword">end</span>;</span><br><span class="line">    close(input);close(output);</span><br><span class="line"><span class="keyword">end</span>.</span><br></pre></td></tr></table></figure><br><br></div></div>
]]></content>
    
    <summary type="html">
    
      &lt;blockquote&gt;
&lt;p&gt;订正进度(3/3)&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h1 id=&quot;P1-lis&quot;&gt;&lt;a href=&quot;#P1-lis&quot; class=&quot;headerlink&quot; title=&quot;P1 lis&quot;&gt;&lt;/a&gt;P1 lis&lt;/h1&gt;&lt;p&gt;大意：&lt;br&gt;给定长度n和参数$t_0,A,B,C,D$，定义数列$a_n$：&lt;br&gt;$n=1,a[n]=t_0$&lt;br&gt;$n\geq 2,a[n]=(A\times a_{n-1}^2+B\times a_{n-1}+C)\% D$&lt;/p&gt;
&lt;p&gt;求$a_n$的最长不下降子序列&lt;br&gt;$0\leq t_0,A,B,C\leq150,1\leq D\leq150, 1\leq n\leq10^{12}$&lt;br&gt;
    
    </summary>
    
      <category term="Problem Set" scheme="https://cothrax.github.io/categories/Problem-Set/"/>
    
    
      <category term="OI" scheme="https://cothrax.github.io/tags/OI/"/>
    
      <category term="数据结构" scheme="https://cothrax.github.io/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"/>
    
      <category term="DP" scheme="https://cothrax.github.io/tags/DP/"/>
    
      <category term="二分答案" scheme="https://cothrax.github.io/tags/%E4%BA%8C%E5%88%86%E7%AD%94%E6%A1%88/"/>
    
      <category term="图论" scheme="https://cothrax.github.io/tags/%E5%9B%BE%E8%AE%BA/"/>
    
      <category term="最短路" scheme="https://cothrax.github.io/tags/%E6%9C%80%E7%9F%AD%E8%B7%AF/"/>
    
      <category term="LCA" scheme="https://cothrax.github.io/tags/LCA/"/>
    
      <category term="线段树" scheme="https://cothrax.github.io/tags/%E7%BA%BF%E6%AE%B5%E6%A0%91/"/>
    
      <category term="背包" scheme="https://cothrax.github.io/tags/%E8%83%8C%E5%8C%85/"/>
    
      <category term="线性DP" scheme="https://cothrax.github.io/tags/%E7%BA%BF%E6%80%A7DP/"/>
    
      <category term="数学" scheme="https://cothrax.github.io/tags/%E6%95%B0%E5%AD%A6/"/>
    
      <category term="矩阵" scheme="https://cothrax.github.io/tags/%E7%9F%A9%E9%98%B5/"/>
    
      <category term="DFS序" scheme="https://cothrax.github.io/tags/DFS%E5%BA%8F/"/>
    
  </entry>
  
  <entry>
    <title>NOIP十连测 Day 7</title>
    <link href="https://cothrax.github.io/2016/11/04/lydsy-noip-2016-test7/"/>
    <id>https://cothrax.github.io/2016/11/04/lydsy-noip-2016-test7/</id>
    <published>2016-11-04T08:14:18.000Z</published>
    <updated>2016-11-10T15:07:03.467Z</updated>
    
    <content type="html"><![CDATA[<blockquote>
<p>订正进度(2/3)</p>
</blockquote>
<h1 id="T1-约瑟夫游戏"><a href="#T1-约瑟夫游戏" class="headerlink" title="T1 约瑟夫游戏"></a>T1 约瑟夫游戏</h1><p>大意：定义约瑟夫游戏：个人围成一圈,从 1 号开始依次报数,当报到 m 时,报1、2、…、m-1 的人出局,下一个人接着从 1 开始报,保证(n-1)是(m-1)的倍数。最后剩的一个人获胜。<br>求获胜者的编号<br>$2\leq m \leq n\leq 2^{63}-2$</p>
<a id="more"></a>
<h2 id="水解"><a href="#水解" class="headerlink" title="水解"></a>水解</h2><p>记f[i]为i个人时的答案，递推：<br>$f[i]=f[i-(m-1)]\%(i-m+1)+m$<br>记$g[i]=f[1+i(m-1)]$<br>则$g[i+1]=f[1+(i+1)(m-1)]=f[1+i(m-1)]\%(1+i(m-1))+m$<br>$\therefore g[i+1]=g[i]\%(1+i(m-1))+m$</p>
<p>复杂度$O(n/m)$</p>
<div><br><div class="copy"><br>    <a href="/2016/11/04/lydsy-noip-2016-test7/joseph.pas" title="{plain text}">{plain text}</a><br></div><br><div><br><figure class="highlight delphi"><figcaption><span>joseph.pas</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">uses</span> math;</span><br><span class="line"><span class="keyword">type</span> int=longint;</span><br><span class="line"><span class="keyword">var</span> </span><br><span class="line">    n,m,k,i,j:int;</span><br><span class="line">    f:<span class="keyword">array</span>[<span class="number">0</span>..<span class="number">1000000</span>] <span class="keyword">of</span> int;</span><br><span class="line"></span><br><span class="line"><span class="keyword">begin</span></span><br><span class="line">    assign(input,<span class="string">'joseph.in'</span>);reset(input);</span><br><span class="line">    assign(output,<span class="string">'joseph.out'</span>);rewrite(output);</span><br><span class="line">    <span class="keyword">read</span>(n,m);</span><br><span class="line">    k:=(n-<span class="number">1</span>) <span class="keyword">div</span> (m-<span class="number">1</span>);</span><br><span class="line">    f[<span class="number">0</span>]:=<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span> i:=<span class="number">0</span> <span class="keyword">to</span> k-<span class="number">1</span> <span class="keyword">do</span></span><br><span class="line">        f[i+<span class="number">1</span>]:=f[i]<span class="keyword">mod</span>(i*(m-<span class="number">1</span>)+<span class="number">1</span>)+m;</span><br><span class="line">    <span class="keyword">write</span>(f[k]);</span><br><span class="line"><span class="keyword">end</span>.</span><br></pre></td></tr></table></figure><br><br></div></div>

<h2 id="正解"><a href="#正解" class="headerlink" title="正解"></a>正解</h2><p>基于递推的方法，打表观察：<br>发现：除了$i=m^a+m-1$外，所有的f[i]=km<br>找出这个规律后直接模拟即可</p>
<div><br><div class="copy"><br>    <a href="/2016/11/04/lydsy-noip-2016-test7/joseph_tmp.pas" title="{plain text}">{plain text}</a><br></div><br><div><br><figure class="highlight delphi"><figcaption><span>joseph_tmp.pas</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">uses</span> math;</span><br><span class="line"><span class="keyword">type</span> int=longint;</span><br><span class="line"><span class="keyword">var</span> </span><br><span class="line">    n,m,k,i,j:int;</span><br><span class="line">    f:<span class="keyword">array</span>[<span class="number">0</span>..<span class="number">1000000</span>] <span class="keyword">of</span> int;</span><br><span class="line"></span><br><span class="line"><span class="keyword">begin</span></span><br><span class="line">    <span class="keyword">read</span>(n,m);</span><br><span class="line">    assign(input,<span class="string">'joseph.in'</span>);reset(input);</span><br><span class="line">    assign(output,<span class="string">'joseph.out'</span>);rewrite(output);</span><br><span class="line">    i:=<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">while</span> i&lt;=n <span class="keyword">do</span> k:=k*m;</span><br><span class="line">    <span class="keyword">write</span>((n-i <span class="keyword">div</span> m) <span class="keyword">div</span> (m-<span class="number">1</span>)*m);</span><br><span class="line">    close(input);close(output);</span><br><span class="line"><span class="keyword">end</span>.</span><br></pre></td></tr></table></figure><br><br></div></div>

<h1 id="T2-密码游戏"><a href="#T2-密码游戏" class="headerlink" title="T2 密码游戏"></a>T2 密码游戏</h1><p>有两个0..m-1的全排列a和b，有n次操作x，每次的结果y=b[a[x]]，之后a排列向前循环一次，即a’[(i+1)%m]=a[i]，每操作m次之后b向前循环一次。<br>现在给定n次操作的x和y，求a和b的初值。如果有多解输出任意一组<br>$2\leq m\leq 26,m^2\leq n\leq 10^5$</p>
<h2 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h2><p>如果$y[i]=y[j]$<br>则$b[(a[(x[i]+i)\%m]+i/m)\%m]=b[(a[(x[j]+j)\%m]+j/m)\%m]$(*)</p>
<p>$(a[(x[i]+i)\%m]+i/m)\%m=a[(x[j]+j)\%m]+j/m)\%m$</p>
<p>$a[(x[i]+i)\%m]-a[(x[j]+j)\%m]\equiv j/m-i/m (\%m)$</p>
<p>这样就得到的若干形如$a[i]-a[j]\equiv k(\%m)$的形式<br>我们可以用带全并查集处理同余方程，然后设根节点为0，递推出所有的a[i]<br>然后在推出(*)推出b即可<br>注意点：由于题意是操作后移动，上述式子中的i代表的是第i+1次操作</p>
<p>题解告诉我们，有效方程个数的期望为$(n-m)(m-1)/m$<br>而$m^2\leq n$，则个数$\geq (m-1)^2\geq m-1$<br>所以可以得到m个节点间的关系（也就是最终合并到一颗树上）</p>
<blockquote>
<p>挖个坑：个数的期望不知道是怎么算的</p>
</blockquote>
<p>注：由于没有大样例，oj又不支持spj，下面的代码仅供参考<br>以及我的草稿</p>
<blockquote>
<p>y[i]=y[j]<br>b[(a[(x[i]+i)%m]+i/m)%m]=b[(a[(x[j]+j)%m]+j/m)%m]<br>a[(x[i]+i)%m]-a[(x[j]+j)%m]=j/m-i/m (%m)<br>=&gt;a[i]-a[j]=k (%m)<br>uf-set<br>a[i]-a[j]=k (i-&gt;j)=k<br>w[x-&gt;p[x]]=(x-p[x])%m<br>union(i,j,k)<br>a[0]=0<br>a[0]-p[a[0]]=w[0] =&gt; p[a[0]]=a[0]-w[0]<br>find<br>    w[par[x]]=par[x]-&gt;rt  w[x]=x-&gt;par[x]<br>    x-&gt;rt=w[x]+w[par[x]]=new w[x]<br>union<br>    x-&gt;y=k  w[x]=x-&gt;par[x]  w[y]=y-&gt;par[y]<br>    par[x]-&gt;par[y] = par[x]-&gt;x + x-&gt;y + y-&gt;par[y] =-w[x]+k+w[y]</p>
</blockquote>
<div><br><div class="copy"><br>    <a href="/2016/11/04/lydsy-noip-2016-test7/password.pas" title="{plain text}">{plain text}</a><br></div><br><div><br><figure class="highlight delphi"><figcaption><span>password.pas</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> int=longint;node=<span class="keyword">record</span> w,nxt:int <span class="keyword">end</span>;</span><br><span class="line"><span class="keyword">var</span></span><br><span class="line">    n,m,sz,i,j,u,v:int;</span><br><span class="line">    lnk:<span class="keyword">array</span>[<span class="number">0</span>..<span class="number">100010</span>] <span class="keyword">of</span> node;</span><br><span class="line">    x,y:<span class="keyword">array</span>[<span class="number">0</span>..<span class="number">100010</span>] <span class="keyword">of</span> int;</span><br><span class="line">    a,b,ptr,par,w:<span class="keyword">array</span>[<span class="number">0</span>..<span class="number">30</span>] <span class="keyword">of</span> int;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">procedure</span> <span class="title">insert</span><span class="params">(i,x:int)</span>;</span></span><br><span class="line"><span class="keyword">begin</span></span><br><span class="line">    inc(sz);lnk[sz].w:=x;</span><br><span class="line">    lnk[sz].nxt:=ptr[i];ptr[i]:=sz;</span><br><span class="line"><span class="keyword">end</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">find</span><span class="params">(x:int)</span>:</span>int;</span><br><span class="line"><span class="keyword">begin</span></span><br><span class="line">    <span class="keyword">if</span> par[x]=x <span class="keyword">then</span> find:=x</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">begin</span></span><br><span class="line">        find:=find(par[x]);</span><br><span class="line">        inc(w[x],w[par[x]]);</span><br><span class="line">        par[x]:=find;</span><br><span class="line">    <span class="keyword">end</span>;</span><br><span class="line"><span class="keyword">end</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">procedure</span> <span class="title">union</span><span class="params">(x,y,k:int)</span>;</span></span><br><span class="line"><span class="keyword">var</span> px,py:int;</span><br><span class="line"><span class="keyword">begin</span></span><br><span class="line">    px:=find(x);py:=find(y);</span><br><span class="line">    <span class="keyword">if</span> px=py <span class="keyword">then</span> <span class="keyword">exit</span>;</span><br><span class="line">    w[px]:=-w[x]+k+w[y];par[px]:=py;</span><br><span class="line"><span class="keyword">end</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">procedure</span> <span class="title">dfs</span><span class="params">(x:int)</span>;</span></span><br><span class="line"><span class="keyword">begin</span></span><br><span class="line">    <span class="keyword">if</span> par[x]=x <span class="keyword">then</span> a[x]:=<span class="number">0</span></span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">begin</span></span><br><span class="line">        <span class="keyword">if</span> a[par[x]]=-<span class="number">1</span> <span class="keyword">then</span> dfs(par[x]);</span><br><span class="line">        a[x]:=(a[par[x]]+w[x])<span class="keyword">mod</span> m;</span><br><span class="line">    <span class="keyword">end</span>;</span><br><span class="line"><span class="keyword">end</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">begin</span></span><br><span class="line">    assign(input,<span class="string">'password.in'</span>);reset(input);</span><br><span class="line">    assign(output,<span class="string">'password.out'</span>);rewrite(output);</span><br><span class="line">    <span class="keyword">read</span>(n,m);</span><br><span class="line">    <span class="keyword">for</span> i:=<span class="number">0</span> <span class="keyword">to</span> n-<span class="number">1</span> <span class="keyword">do</span> <span class="keyword">read</span>(x[i]);</span><br><span class="line">    <span class="keyword">for</span> i:=<span class="number">0</span> <span class="keyword">to</span> n-<span class="number">1</span> <span class="keyword">do</span> <span class="keyword">begin</span> <span class="keyword">read</span>(y[i]);insert(y[i],i) <span class="keyword">end</span>;</span><br><span class="line">    <span class="keyword">for</span> i:=<span class="number">0</span> <span class="keyword">to</span> m-<span class="number">1</span> <span class="keyword">do</span> <span class="keyword">begin</span> par[i]:=i;w[i]:=<span class="number">0</span> <span class="keyword">end</span>;</span><br><span class="line">    <span class="keyword">for</span> j:=<span class="number">0</span> <span class="keyword">to</span> m-<span class="number">1</span> <span class="keyword">do</span> <span class="keyword">begin</span></span><br><span class="line">        i:=ptr[j];u:=lnk[i].w;i:=lnk[i].nxt;</span><br><span class="line">        <span class="keyword">while</span> i&lt;&gt;<span class="number">0</span> <span class="keyword">do</span> <span class="keyword">begin</span></span><br><span class="line">            v:=lnk[i].w;</span><br><span class="line">            union((x[u]+u)<span class="keyword">mod</span> m,(x[v]+v)<span class="keyword">mod</span> m,</span><br><span class="line">                ((v <span class="keyword">div</span> m-u <span class="keyword">div</span> m)<span class="keyword">mod</span> m+m)<span class="keyword">mod</span> m);</span><br><span class="line">            u:=v;i:=lnk[i].nxt;</span><br><span class="line">        <span class="keyword">end</span>;</span><br><span class="line">    <span class="keyword">end</span>;</span><br><span class="line">    fillchar(a,sizeof(a),<span class="number">255</span>);</span><br><span class="line">    <span class="keyword">for</span> i:=<span class="number">0</span> <span class="keyword">to</span> m-<span class="number">1</span> <span class="keyword">do</span> <span class="keyword">if</span> a[i]=-<span class="number">1</span> <span class="keyword">then</span> dfs(i);</span><br><span class="line">    <span class="keyword">for</span> i:=<span class="number">0</span> <span class="keyword">to</span> n-<span class="number">1</span> <span class="keyword">do</span> b[(a[(x[i]+i)<span class="keyword">mod</span> m]+i <span class="keyword">div</span> m)<span class="keyword">mod</span> m]:=y[i];</span><br><span class="line">    <span class="keyword">for</span> i:=<span class="number">0</span> <span class="keyword">to</span> m-<span class="number">1</span> <span class="keyword">do</span> <span class="keyword">write</span>(a[i],<span class="string">' '</span>);writeln;</span><br><span class="line">    <span class="keyword">for</span> i:=<span class="number">0</span> <span class="keyword">to</span> m-<span class="number">1</span> <span class="keyword">do</span> <span class="keyword">write</span>(b[i],<span class="string">' '</span>);</span><br><span class="line">    close(input);close(output);</span><br><span class="line"><span class="keyword">end</span>.</span><br></pre></td></tr></table></figure><br><br></div></div>
]]></content>
    
    <summary type="html">
    
      &lt;blockquote&gt;
&lt;p&gt;订正进度(2/3)&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h1 id=&quot;T1-约瑟夫游戏&quot;&gt;&lt;a href=&quot;#T1-约瑟夫游戏&quot; class=&quot;headerlink&quot; title=&quot;T1 约瑟夫游戏&quot;&gt;&lt;/a&gt;T1 约瑟夫游戏&lt;/h1&gt;&lt;p&gt;大意：定义约瑟夫游戏：个人围成一圈,从 1 号开始依次报数,当报到 m 时,报1、2、…、m-1 的人出局,下一个人接着从 1 开始报,保证(n-1)是(m-1)的倍数。最后剩的一个人获胜。&lt;br&gt;求获胜者的编号&lt;br&gt;$2\leq m \leq n\leq 2^{63}-2$&lt;/p&gt;
    
    </summary>
    
      <category term="Problem Set" scheme="https://cothrax.github.io/categories/Problem-Set/"/>
    
    
      <category term="OI" scheme="https://cothrax.github.io/tags/OI/"/>
    
      <category term="并查集" scheme="https://cothrax.github.io/tags/%E5%B9%B6%E6%9F%A5%E9%9B%86/"/>
    
      <category term="数据结构" scheme="https://cothrax.github.io/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"/>
    
      <category term="DP" scheme="https://cothrax.github.io/tags/DP/"/>
    
      <category term="数论" scheme="https://cothrax.github.io/tags/%E6%95%B0%E8%AE%BA/"/>
    
      <category term="概率期望" scheme="https://cothrax.github.io/tags/%E6%A6%82%E7%8E%87%E6%9C%9F%E6%9C%9B/"/>
    
      <category term="数学" scheme="https://cothrax.github.io/tags/%E6%95%B0%E5%AD%A6/"/>
    
      <category term="打表" scheme="https://cothrax.github.io/tags/%E6%89%93%E8%A1%A8/"/>
    
  </entry>
  
  <entry>
    <title>NOIP十连测 Day 8</title>
    <link href="https://cothrax.github.io/2016/10/30/lydsy-noip-2016-test8/"/>
    <id>https://cothrax.github.io/2016/10/30/lydsy-noip-2016-test8/</id>
    <published>2016-10-30T04:41:39.000Z</published>
    <updated>2016-11-04T08:13:32.216Z</updated>
    
    <content type="html"><![CDATA[<blockquote>
<p>订正进度(3/3)</p>
</blockquote>
<h1 id="P1-神炎皇"><a href="#P1-神炎皇" class="headerlink" title="P1 神炎皇"></a>P1 神炎皇</h1><p>大意：给定n，求满足$a+b\leq n$且$(a+b)|ab$的有序对(a,b)的个数<br>$n\leq 10^{14}$</p>
<a id="more"></a>
<h2 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h2><p>坑爹数论<br>记$g=gcd(a,b),c=a/g,d=b/g$<br>则$(c+d)g|cdg^2$</p>
<blockquote>
<p>定理：若$gcd(c+d)=1$，则$(c+d)|cd$一定不成立</p>
</blockquote>
<p>先yy一下，c和d的约数都不是c+d的约数，那么c+d的质因子拆分中一定包含不是cd的约数的成分。<br>也可以反证：不妨设$k(c+d)=cd,k\in N*$<br>则$kc+kd=(c-k)d+kd$<br>那么$kc=(c-k)d$<br>因为$gcd(c,d)=1$<br>所以$c=c-k,k=d$无解，与假设矛盾</p>
<p>于是式子变成了$(c+d)|g$<br>令$k=c+d$，则$g=kp,p\in N*$，又$gk=k^2p\leq n$，那么$k\leq\sqrt{n}$<br>枚举k，则p有$n/k^2$个，下面要求(c,d)的对数</p>
<blockquote>
<p>根据辗转相减，$gcd(p,q)=gcd(p-q,q),p&gt;q$</p>
</blockquote>
<p>于是$gcd(c,d)=1$与$gcd(c+d,d)=(k,d)=1$一一对应，而(k,d)的对数就是$\varphi(k)$</p>
<p>于是，答案为$\sum_{k=2}^{\lfloor\sqrt{n}\rfloor} \varphi(k)*\lfloor n/k^2\rfloor$</p>
<div><br><div class="copy"><br>    <a href="/2016/10/30/lydsy-noip-2016-test8/uria.pas" title="{plain text}">{plain text}</a><br></div><br><div><br><figure class="highlight delphi"><figcaption><span>uria.pas</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> int=longint;</span><br><span class="line"><span class="keyword">var</span></span><br><span class="line">    n,ans,i,sq:int64;</span><br><span class="line">    phi,p:<span class="keyword">array</span>[<span class="number">0</span>..<span class="number">10000010</span>] <span class="keyword">of</span> int;</span><br><span class="line">    f:<span class="keyword">array</span>[<span class="number">0</span>..<span class="number">10000100</span>] <span class="keyword">of</span> boolean;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">procedure</span> <span class="title">euler</span><span class="params">()</span>;</span></span><br><span class="line"><span class="keyword">var</span> i,j,t,k:int;</span><br><span class="line"><span class="keyword">begin</span></span><br><span class="line">    phi[<span class="number">1</span>]:=<span class="number">1</span>;k:=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> i:=<span class="number">2</span> <span class="keyword">to</span> sq <span class="keyword">do</span> <span class="keyword">begin</span></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> f[i] <span class="keyword">then</span> <span class="keyword">begin</span></span><br><span class="line">            inc(k);p[k]:=i;phi[i]:=i-<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">end</span>;</span><br><span class="line">        j:=<span class="number">1</span>;t:=p[j]*i;</span><br><span class="line">        <span class="keyword">while</span> t&lt;=sq <span class="keyword">do</span> <span class="keyword">begin</span></span><br><span class="line">            f[t]:=true;</span><br><span class="line">            <span class="keyword">if</span> i <span class="keyword">mod</span> p[j]=<span class="number">0</span> <span class="keyword">then</span> <span class="keyword">begin</span></span><br><span class="line">                phi[t]:=p[j]*phi[i];<span class="keyword">break</span></span><br><span class="line">            <span class="keyword">end</span> <span class="keyword">else</span></span><br><span class="line">                phi[t]:=(p[j]-<span class="number">1</span>)*phi[i];</span><br><span class="line">            inc(j);t:=p[j]*i;</span><br><span class="line">        <span class="keyword">end</span>;</span><br><span class="line">    <span class="keyword">end</span>;</span><br><span class="line"><span class="keyword">end</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">begin</span></span><br><span class="line">    <span class="comment">//assign(input,'uria.in');reset(input);</span></span><br><span class="line">    <span class="comment">//assign(output,'uria.out');rewrite(output);</span></span><br><span class="line">    <span class="keyword">read</span>(n);sq:=trunc(sqrt(n));</span><br><span class="line">    foo();halt;</span><br><span class="line">    euler();ans:=<span class="number">0</span>;i:=<span class="number">2</span>;</span><br><span class="line">    <span class="keyword">while</span> i&lt;=sq <span class="keyword">do</span> <span class="keyword">begin</span></span><br><span class="line">        inc(ans,phi[i]*trunc(n/(i*i)));</span><br><span class="line">        inc(i);</span><br><span class="line">    <span class="keyword">end</span>;</span><br><span class="line">    <span class="keyword">write</span>(ans);</span><br><span class="line">    close(input);close(output);</span><br><span class="line"><span class="keyword">end</span>.</span><br></pre></td></tr></table></figure><br><br></div></div>

<h1 id="P2-降雷皇"><a href="#P2-降雷皇" class="headerlink" title="P2 降雷皇"></a>P2 降雷皇</h1><p>大意：给定长度n的序列a，求最长单调不降子序列，以及其方案数<br>$n,a_i\leq 10^5$</p>
<h2 id="题解-1"><a href="#题解-1" class="headerlink" title="题解"></a>题解</h2><p>数据结构优化的dp<br>第一问显然lis，考虑$O(N^2)$的求法</p>
<p>记f[i]为以a[i]结尾的最长lis长度</p>
<span>$f[i]=max_{i&lt;j,a[j]\leq a[i]}\{f[j]+1\}$</span><!-- Has MathJax -->
<p>有另一种思路优化到$O(NlogN)$，但由于第二问的存在，我们考虑数据结构优化<br>可以用树状数组以a[i]为下标，维护f[i]的前缀最大值<br>那么转移时查询[1..a[i]]中的最大的f[j]即可</p>
<p>第二问：<br>记g[i]为f[i]的方案数</p>
<span>$g[i]=\sum_{i&lt;j,a[i]&lt;=a[j],f[i]=f[j]+1}g[j]$</span><!-- Has MathJax -->
<p>这个可以对每以个f[i]维护一颗线段树，以a[i]为下标，维护区间[l,r]内的$\sum g[i]$<br>类似主席树的写法</p>
<p>这样，复杂度为$O(NlogN)$<br>一个sb错误：Line53的查询参数为x-1</p>
<div><br><div class="copy"><br>    <a href="/2016/10/30/lydsy-noip-2016-test8/hamon.pas" title="{plain text}">{plain text}</a><br></div><br><div><br><figure class="highlight delphi"><figcaption><span>hamon.pas</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">uses</span> math;</span><br><span class="line"><span class="keyword">type</span> int=longint;ll=int64;node=<span class="keyword">record</span> lc,rc,w:int <span class="keyword">end</span>;</span><br><span class="line"><span class="keyword">const</span> mx=<span class="number">100000</span>;md=<span class="number">123456789</span>;</span><br><span class="line"><span class="keyword">var</span></span><br><span class="line">    seg:<span class="keyword">array</span>[<span class="number">0</span>..mx*<span class="number">20</span>] <span class="keyword">of</span> node;</span><br><span class="line">    bit,rt,f,g:<span class="keyword">array</span>[<span class="number">0</span>..mx+<span class="number">10</span>] <span class="keyword">of</span> int;</span><br><span class="line">    n,sz,i,tp,x,ans,cnt:int;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">procedure</span> _<span class="title">add</span><span class="params">(x,k:int)</span>;</span></span><br><span class="line"><span class="keyword">begin</span></span><br><span class="line">    <span class="keyword">while</span> x&lt;=mx <span class="keyword">do</span> <span class="keyword">begin</span></span><br><span class="line">        bit[x]:=max(bit[x],k);</span><br><span class="line">        inc(x,x <span class="keyword">and</span> (-x));</span><br><span class="line">    <span class="keyword">end</span>;</span><br><span class="line"><span class="keyword">end</span>;</span><br><span class="line"><span class="function"><span class="keyword">function</span> _<span class="title">query</span><span class="params">(x:int)</span>:</span>int;</span><br><span class="line"><span class="keyword">begin</span></span><br><span class="line">    _query:=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span> x&gt;<span class="number">0</span> <span class="keyword">do</span> <span class="keyword">begin</span></span><br><span class="line">        _query:=max(_query,bit[x]);</span><br><span class="line">        x:=x <span class="keyword">and</span> (x-<span class="number">1</span>);</span><br><span class="line">    <span class="keyword">end</span>;</span><br><span class="line"><span class="keyword">end</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">procedure</span> <span class="title">add</span><span class="params">(<span class="keyword">var</span> i:int;l,r,x,k:int)</span>;</span></span><br><span class="line"><span class="keyword">var</span> mid:int;</span><br><span class="line"><span class="keyword">begin</span></span><br><span class="line">    inc(sz);seg[sz]:=seg[i];i:=sz;</span><br><span class="line">    seg[i].w:=(ll(seg[i].w)+ll(k))<span class="keyword">mod</span> md;</span><br><span class="line">    <span class="keyword">if</span> l=r <span class="keyword">then</span> <span class="keyword">exit</span>;</span><br><span class="line">    mid:=(l+r) <span class="keyword">shr</span> <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">if</span> x&lt;=mid <span class="keyword">then</span> add(seg[i].lc,l,mid,x,k)</span><br><span class="line">    <span class="keyword">else</span> add(seg[i].rc,mid+<span class="number">1</span>,r,x,k);</span><br><span class="line"><span class="keyword">end</span>;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">query</span><span class="params">(i,l,r,k:int)</span>:</span>int;</span><br><span class="line"><span class="keyword">var</span> mid,lc,rc:int;</span><br><span class="line"><span class="keyword">begin</span></span><br><span class="line">    <span class="keyword">if</span> l=r <span class="keyword">then</span> <span class="keyword">exit</span>(seg[i].w);</span><br><span class="line">    mid:=(l+r) <span class="keyword">shr</span> <span class="number">1</span>;</span><br><span class="line">    lc:=seg[i].lc;rc:=seg[i].rc;</span><br><span class="line">    <span class="keyword">if</span> k&lt;=mid <span class="keyword">then</span> query:=query(lc,l,mid,k)</span><br><span class="line">    <span class="keyword">else</span> query:=(ll(seg[lc].w)+ll(query(rc,mid+<span class="number">1</span>,r,k)))<span class="keyword">mod</span> md;</span><br><span class="line"><span class="keyword">end</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">begin</span></span><br><span class="line">    assign(input,<span class="string">'hamon.in'</span>);reset(input);</span><br><span class="line">    assign(output,<span class="string">'hamon.out'</span>);rewrite(output);</span><br><span class="line">    <span class="keyword">read</span>(n,tp);sz:=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> i:=<span class="number">1</span> <span class="keyword">to</span> n <span class="keyword">do</span> <span class="keyword">begin</span></span><br><span class="line">        <span class="keyword">read</span>(x);</span><br><span class="line">        f[i]:=_query(x-<span class="number">1</span>);</span><br><span class="line">        <span class="keyword">if</span> f[i]=<span class="number">0</span> <span class="keyword">then</span> g[i]:=<span class="number">1</span></span><br><span class="line">        <span class="keyword">else</span> g[i]:=query(rt[f[i]],<span class="number">1</span>,n,x-<span class="number">1</span>);</span><br><span class="line">        inc(f[i]);add(rt[f[i]],<span class="number">1</span>,n,x,g[i]);_add(x,f[i]);</span><br><span class="line">    <span class="keyword">end</span>;</span><br><span class="line">    ans:=<span class="number">0</span>;cnt:=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> i:=<span class="number">1</span> <span class="keyword">to</span> n <span class="keyword">do</span> ans:=max(ans,f[i]);</span><br><span class="line">    <span class="keyword">for</span> i:=<span class="number">1</span> <span class="keyword">to</span> n <span class="keyword">do</span></span><br><span class="line">        <span class="keyword">if</span> f[i]=ans <span class="keyword">then</span> cnt:=(cnt+g[i])<span class="keyword">mod</span> md;</span><br><span class="line">    writeln(ans);<span class="keyword">if</span> tp=<span class="number">1</span> <span class="keyword">then</span> <span class="keyword">write</span>(cnt);</span><br><span class="line">    close(input);close(output);</span><br><span class="line"><span class="keyword">end</span>.</span><br></pre></td></tr></table></figure><br><br></div></div>

<h1 id="P3-幻魔皇"><a href="#P3-幻魔皇" class="headerlink" title="P3 幻魔皇"></a>P3 幻魔皇</h1><p>定义斐波那契树：</p>
<ol>
<li>根为白色节点</li>
<li>白色节点有一个黑色子节点</li>
<li>黑色节点有一个黑色子节点和一个白色子节点</li>
</ol>
<p>给定树高n，对于$i\in [1,2n]$求距离为i的白色节点对数，答案对123456789取模<br>$n\leq 5000$</p>
<h2 id="80分题解"><a href="#80分题解" class="headerlink" title="80分题解"></a>80分题解</h2><p>我的思路：$O(N^3)$ DP<br>f[i,j] 高为i的子树到根距离为j的节点数<br>g[i,j] 高为i的子树中距离为j的节点对数</p>
<p>f[i,j]=f[i-1,j-1]+f[i-2,j-2]<br>特判新增的白色节点：f[i,1]+=1</p>
<p>统计到新增的白色节点的部分：g[i,j]=f[i-1,j-2]+f[i-2,j-1]<br>加上原来的：g[i,j]+=g[i-1,j]+g[i-2,j]<br>枚举左右子树i,j：g[i,j+k+3]+=f[i-1,j]*f[i-2,k]</p>
<p>递推n-2次，然后特判白色根节点：g[n-2,j]+=f[n-2,j-1]<br>答案是g[n-2,1..n*2]</p>
<p>复杂度的瓶颈在于枚举左右子树的部分，容易发现这一部分的计算实际上是多项式系数向量的卷积，于是可以用fft优化到$O(N^2logN)$，似乎会被卡常，而且这玩意不在noip范围</p>
<div><br><div class="copy"><br>    <a href="/2016/10/30/lydsy-noip-2016-test8/raviel_80.pas" title="{plain text}">{plain text}</a><br></div><br><div><br><figure class="highlight delphi"><figcaption><span>raviel_80.pas</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> int=longint;ll=int64;</span><br><span class="line"><span class="keyword">const</span></span><br><span class="line">    md=<span class="number">123456789</span>;mx=<span class="number">5000</span>;</span><br><span class="line">    nxt:<span class="keyword">array</span>[<span class="number">0</span>..<span class="number">2</span>] <span class="keyword">of</span> int=(<span class="number">1</span>,<span class="number">2</span>,<span class="number">0</span>);</span><br><span class="line"><span class="keyword">var</span></span><br><span class="line">    f,g:<span class="keyword">array</span>[<span class="number">0</span>..<span class="number">2</span>,-<span class="number">2</span>..mx*<span class="number">2</span>+<span class="number">10</span>] <span class="keyword">of</span> int;</span><br><span class="line">    n,i,j,k,i0,i1,i2:int;</span><br><span class="line"></span><br><span class="line"><span class="keyword">begin</span></span><br><span class="line">    assign(input,<span class="string">'raviel.in'</span>);reset(input);</span><br><span class="line">    assign(output,<span class="string">'raviel.ans'</span>);rewrite(output);</span><br><span class="line">    <span class="keyword">read</span>(n);</span><br><span class="line">    i0:=<span class="number">2</span>;i1:=<span class="number">1</span>;i2:=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> i:=<span class="number">1</span> <span class="keyword">to</span> n-<span class="number">2</span> <span class="keyword">do</span> <span class="keyword">begin</span></span><br><span class="line">        i0:=nxt[i0];i1:=nxt[i1];i2:=nxt[i2];</span><br><span class="line">        <span class="keyword">for</span> j:=<span class="number">1</span> <span class="keyword">to</span> i <span class="keyword">do</span> f[i0,j]:=<span class="number">0</span>;</span><br><span class="line">        <span class="comment">//calc f[i0]</span></span><br><span class="line">        <span class="keyword">for</span> j:=<span class="number">1</span> <span class="keyword">to</span> i <span class="keyword">do</span></span><br><span class="line">            f[i0,j]:=(f[i1,j-<span class="number">1</span>]+f[i2,j-<span class="number">2</span>])<span class="keyword">mod</span> md;</span><br><span class="line">        f[i0,<span class="number">1</span>]:=(f[i0,<span class="number">1</span>]+<span class="number">1</span>)<span class="keyword">mod</span> md;</span><br><span class="line">        <span class="comment">//calc g[i0]</span></span><br><span class="line">        <span class="keyword">for</span> j:=<span class="number">1</span> <span class="keyword">to</span> i*<span class="number">2</span> <span class="keyword">do</span></span><br><span class="line">            g[i0,j]:=(f[i1,j-<span class="number">2</span>]+f[i2,j-<span class="number">1</span>]+g[i1,j]+g[i2,j])<span class="keyword">mod</span> md;</span><br><span class="line">        <span class="keyword">for</span> j:=<span class="number">1</span> <span class="keyword">to</span> i*<span class="number">2</span> <span class="keyword">do</span></span><br><span class="line">            <span class="keyword">for</span> k:=<span class="number">1</span> <span class="keyword">to</span> i*<span class="number">2</span>-j <span class="keyword">do</span></span><br><span class="line">                g[i0,j+k+<span class="number">3</span>]:=(ll(g[i0,j+k+<span class="number">3</span>])+</span><br><span class="line">                    ll(f[i1,j])*ll(f[i2,k]))<span class="keyword">mod</span> md;</span><br><span class="line">    <span class="keyword">end</span>;</span><br><span class="line">    <span class="keyword">for</span> j:=<span class="number">1</span> <span class="keyword">to</span> <span class="number">2</span>*n <span class="keyword">do</span> g[i0,j]:=(g[i0,j]+f[i0,j-<span class="number">1</span>])<span class="keyword">mod</span> md;</span><br><span class="line">    <span class="keyword">for</span> i:=<span class="number">1</span> <span class="keyword">to</span> <span class="number">2</span>*n <span class="keyword">do</span> <span class="keyword">write</span>(g[i0,i],<span class="string">' '</span>);</span><br><span class="line">    close(input);close(output);</span><br><span class="line"><span class="keyword">end</span>.</span><br></pre></td></tr></table></figure><br><br></div></div>

<h2 id="100分题解"><a href="#100分题解" class="headerlink" title="100分题解"></a>100分题解</h2><p>标算：$O(N^2)$<br>考虑到其实每一棵黑色根节点的树都是同构的，不单独考虑树高直接枚举距离<br>可以发现：到黑色节点距离i的白色节点数是斐波那契数f[i]，记$s[i]=\sum_{i=1}^n f[i]$<br>而深度i的子树中的白色节点数为f[i-2]+1（特判根节点），黑色节点数为f[i-1]<br>分两种情况：记u,v为白色节点对</p>
<ol>
<li>lca(u,v)=u或v，那么可以算出lca的范围中的白色节点数s[n-2-i]，对于每个lca，距离为d的节点数为f[j-1]</li>
<li>lca(u,v)=一黑色节点，$O(N^2)$枚举u和v到lca的距离，类似1处理即可</li>
</ol>
<div><br><div class="copy"><br>    <a href="/2016/10/30/lydsy-noip-2016-test8/raviel.pas" title="{plain text}">{plain text}</a><br></div><br><div><br><figure class="highlight delphi"><figcaption><span>raviel.pas</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">uses</span> math;</span><br><span class="line"><span class="keyword">type</span> int=longint;ll=int64;</span><br><span class="line"><span class="keyword">const</span> md=<span class="number">123456789</span>;mx=<span class="number">5000</span>;</span><br><span class="line"><span class="keyword">var</span></span><br><span class="line">    f,s,g:<span class="keyword">array</span>[-<span class="number">1</span>..mx*<span class="number">2</span>+<span class="number">10</span>] <span class="keyword">of</span> int;</span><br><span class="line">    n,i,j:int;</span><br><span class="line"></span><br><span class="line"><span class="keyword">begin</span></span><br><span class="line">    assign(input,<span class="string">'raviel.in'</span>);reset(input);</span><br><span class="line">    assign(output,<span class="string">'raviel.out'</span>);rewrite(output);</span><br><span class="line">    <span class="keyword">read</span>(n);f[<span class="number">1</span>]:=<span class="number">1</span>;s[<span class="number">0</span>]:=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> i:=<span class="number">2</span> <span class="keyword">to</span> n <span class="keyword">do</span> f[i]:=(f[i-<span class="number">1</span>]+f[i-<span class="number">2</span>]) <span class="keyword">mod</span> md;</span><br><span class="line">    <span class="keyword">for</span> i:=<span class="number">1</span> <span class="keyword">to</span> n <span class="keyword">do</span> s[i]:=(s[i-<span class="number">1</span>]+f[i]) <span class="keyword">mod</span> md;</span><br><span class="line">    <span class="keyword">for</span> i:=<span class="number">1</span> <span class="keyword">to</span> n-<span class="number">1</span> <span class="keyword">do</span> g[i]:=ll(s[n-<span class="number">2</span>-i]+<span class="number">1</span>)*ll(f[i-<span class="number">1</span>]) <span class="keyword">mod</span> md;</span><br><span class="line">    f[-<span class="number">1</span>]:=<span class="number">1</span>; <span class="comment">//便于特判根节点</span></span><br><span class="line">    <span class="keyword">for</span> i:=<span class="number">1</span> <span class="keyword">to</span> n-<span class="number">1</span> <span class="keyword">do</span></span><br><span class="line">        <span class="keyword">for</span> j:=<span class="number">1</span> <span class="keyword">to</span> n-<span class="number">1</span> <span class="keyword">do</span></span><br><span class="line">            g[i+j]:=(ll(g[i+j])+(ll(f[i-<span class="number">2</span>])*ll(f[j-<span class="number">1</span>])<span class="keyword">mod</span> md)*</span><br><span class="line">                ll(s[n-<span class="number">1</span>-max(i,j)]))<span class="keyword">mod</span> md;</span><br><span class="line">    <span class="keyword">for</span> i:=<span class="number">1</span> <span class="keyword">to</span> n*<span class="number">2</span> <span class="keyword">do</span> <span class="keyword">write</span>(g[i],<span class="string">' '</span>);</span><br><span class="line">    close(input);close(output);</span><br><span class="line"><span class="keyword">end</span>.</span><br></pre></td></tr></table></figure><br><br></div></div>
]]></content>
    
    <summary type="html">
    
      &lt;blockquote&gt;
&lt;p&gt;订正进度(3/3)&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h1 id=&quot;P1-神炎皇&quot;&gt;&lt;a href=&quot;#P1-神炎皇&quot; class=&quot;headerlink&quot; title=&quot;P1 神炎皇&quot;&gt;&lt;/a&gt;P1 神炎皇&lt;/h1&gt;&lt;p&gt;大意：给定n，求满足$a+b\leq n$且$(a+b)|ab$的有序对(a,b)的个数&lt;br&gt;$n\leq 10^{14}$&lt;/p&gt;
    
    </summary>
    
      <category term="Problem Set" scheme="https://cothrax.github.io/categories/Problem-Set/"/>
    
    
      <category term="OI" scheme="https://cothrax.github.io/tags/OI/"/>
    
      <category term="数据结构" scheme="https://cothrax.github.io/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"/>
    
      <category term="DP" scheme="https://cothrax.github.io/tags/DP/"/>
    
      <category term="数论" scheme="https://cothrax.github.io/tags/%E6%95%B0%E8%AE%BA/"/>
    
      <category term="线段树" scheme="https://cothrax.github.io/tags/%E7%BA%BF%E6%AE%B5%E6%A0%91/"/>
    
      <category term="线性DP" scheme="https://cothrax.github.io/tags/%E7%BA%BF%E6%80%A7DP/"/>
    
      <category term="树状数组" scheme="https://cothrax.github.io/tags/%E6%A0%91%E7%8A%B6%E6%95%B0%E7%BB%84/"/>
    
      <category term="树结构" scheme="https://cothrax.github.io/tags/%E6%A0%91%E7%BB%93%E6%9E%84/"/>
    
      <category term="数学" scheme="https://cothrax.github.io/tags/%E6%95%B0%E5%AD%A6/"/>
    
      <category term="线性筛" scheme="https://cothrax.github.io/tags/%E7%BA%BF%E6%80%A7%E7%AD%9B/"/>
    
      <category term="欧拉函数" scheme="https://cothrax.github.io/tags/%E6%AC%A7%E6%8B%89%E5%87%BD%E6%95%B0/"/>
    
  </entry>
  
  <entry>
    <title>笔记 欧拉函数</title>
    <link href="https://cothrax.github.io/2016/10/30/note-euler-function/"/>
    <id>https://cothrax.github.io/2016/10/30/note-euler-function/</id>
    <published>2016-10-30T01:30:38.000Z</published>
    <updated>2016-11-11T16:08:54.479Z</updated>
    
    <content type="html"><![CDATA[<p>noip前复习数论，怎么感觉是在预习Q(AQ)*</p>
<h1 id="欧拉函数的性质"><a href="#欧拉函数的性质" class="headerlink" title="欧拉函数的性质"></a>欧拉函数的性质</h1><ol>
<li>$p$为素数，$\varphi(p)=p-1$</li>
<li>欧拉定理：若$gcd(a,n)=1$，则$a^{\varphi(n)}\equiv 1(mod\ n)$<br>注：这玩意可以用来证明费马小定理</li>
<li>$p$为素数，$\varphi(p^k)=p^k-p^{k-1}$</li>
<li>若$gcd(p,q)=1$，则$\varphi(pq)=\varphi(p)\varphi(q)$</li>
<li>任意$n\in N*$，$\varphi(n)=\varphi(\prod_i p_i^k)=\prod_i p^{k-1}(p_i-1)=n\prod_i(1-1/p_i)$</li>
<li>对于$n&gt;2$，$2|\varphi(n)$</li>
<li>若$n\ mod\ p=0$，则$\varphi(np)=p\cdot \varphi(n)$</li>
</ol>
<a id="more"></a>
<p>证明可以看：<a href="/2016/10/30/note-euler-function/eluer-funtion.doc" title="欧拉函数及其证明">欧拉函数及其证明</a></p>
<h1 id="求单个-varphi-n"><a href="#求单个-varphi-n" class="headerlink" title="求单个$\varphi(n)$"></a>求单个$\varphi(n)$</h1><p>根据性质5，质因数分解然后暴力即可，复杂度$O(\sqrt{N})$</p>
<figure class="highlight pascal"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">phi</span><span class="params">(n:int)</span>:</span>int;</span><br><span class="line"><span class="keyword">var</span> i:int;</span><br><span class="line"><span class="keyword">begin</span></span><br><span class="line">    phi:=n;</span><br><span class="line">    <span class="keyword">for</span> i:=<span class="number">2</span> <span class="keyword">to</span> ceil(sqrt(n)) <span class="keyword">do</span></span><br><span class="line">        <span class="keyword">if</span> n <span class="keyword">mod</span> i=<span class="number">0</span> <span class="keyword">then</span> <span class="keyword">begin</span></span><br><span class="line">            phi:=phi <span class="keyword">div</span> i*(i-<span class="number">1</span>);</span><br><span class="line">            <span class="keyword">while</span> n <span class="keyword">mod</span> i=<span class="number">0</span> <span class="keyword">do</span> n:=n <span class="keyword">div</span> i;</span><br><span class="line">        <span class="keyword">end</span>;</span><br><span class="line">    <span class="keyword">if</span> n&gt;<span class="number">1</span> <span class="keyword">then</span> phi:=phi <span class="keyword">div</span> n*(n-<span class="number">1</span>);</span><br><span class="line"><span class="keyword">end</span>;</span><br></pre></td></tr></table></figure>
<h1 id="线性筛-varphi-n"><a href="#线性筛-varphi-n" class="headerlink" title="线性筛$\varphi(n)$"></a>线性筛$\varphi(n)$</h1><p>由性质4和7得到，若p为素数，则<br><img src="/2016/10/30/note-euler-function/7350.gif" alt="7350.gif" title=""><br>就是在筛素数时顺便求欧拉函数，线性筛与普通筛的区别：<br>例如，对于合数6会在i=2和i=3被筛两次，而线性筛只会筛i=2一次<br>关键就在line16的那个break<br>当$p[j]|i$时，下一个要被筛的合数$p[j+1]\cdot i$能被表示为$(p[j+1]\cdot i’)\cdot p[j]$，因此它可以被更小的素数$p[j]$筛出，即当循环到合数$p[j+1]\cdot i’$时，再去筛它也不迟<br>这样每个数只会被筛一次，因此复杂度$O(N)$</p>
<figure class="highlight pascal"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">procedure</span> <span class="title">euler</span><span class="params">(n:int)</span>;</span></span><br><span class="line"><span class="keyword">var</span> </span><br><span class="line">    i,j,k:int;</span><br><span class="line">    f:<span class="keyword">array</span>[<span class="number">0</span>..<span class="number">1010</span>] <span class="keyword">of</span> boolean; <span class="comment">//素数标记</span></span><br><span class="line">    p:<span class="keyword">array</span>[<span class="number">0</span>..<span class="number">1010</span>] <span class="keyword">of</span> int; <span class="comment">//素数表，规模为k</span></span><br><span class="line"><span class="keyword">begin</span></span><br><span class="line">    fillchar(f,sizeof(f),false);</span><br><span class="line">    phi[<span class="number">1</span>]:=<span class="number">1</span>;k:=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> i:=<span class="number">2</span> <span class="keyword">to</span> n <span class="keyword">do</span> <span class="keyword">begin</span></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> f[i] <span class="keyword">then</span> </span><br><span class="line">            <span class="keyword">begin</span> inc(k);p[k]:=i;phi[i]:=i-<span class="number">1</span> <span class="keyword">end</span>;</span><br><span class="line">        j:=<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">while</span> i*p[j]&lt;=n <span class="keyword">do</span> <span class="keyword">begin</span></span><br><span class="line">            f[i*p[j]]:=true;</span><br><span class="line">            <span class="keyword">if</span> i <span class="keyword">mod</span> p[j]=<span class="number">0</span> <span class="keyword">then</span> <span class="keyword">begin</span></span><br><span class="line">                phi[i*p[j]]:=phi[i]*p[j];<span class="keyword">break</span></span><br><span class="line">            <span class="keyword">end</span> <span class="keyword">else</span></span><br><span class="line">                phi[i*p[j]]:=phi[i]*(p[j]-<span class="number">1</span>);</span><br><span class="line">            inc(j);</span><br><span class="line">        <span class="keyword">end</span>;</span><br><span class="line">    <span class="keyword">end</span>;</span><br><span class="line"><span class="keyword">end</span>;</span><br></pre></td></tr></table></figure>
<p>一坨pascal代码：<a href="/2016/10/30/note-euler-function/1030.pas" title="1030.pas">1030.pas</a></p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;noip前复习数论，怎么感觉是在预习Q(AQ)*&lt;/p&gt;
&lt;h1 id=&quot;欧拉函数的性质&quot;&gt;&lt;a href=&quot;#欧拉函数的性质&quot; class=&quot;headerlink&quot; title=&quot;欧拉函数的性质&quot;&gt;&lt;/a&gt;欧拉函数的性质&lt;/h1&gt;&lt;ol&gt;
&lt;li&gt;$p$为素数，$\varphi(p)=p-1$&lt;/li&gt;
&lt;li&gt;欧拉定理：若$gcd(a,n)=1$，则$a^{\varphi(n)}\equiv 1(mod\ n)$&lt;br&gt;注：这玩意可以用来证明费马小定理&lt;/li&gt;
&lt;li&gt;$p$为素数，$\varphi(p^k)=p^k-p^{k-1}$&lt;/li&gt;
&lt;li&gt;若$gcd(p,q)=1$，则$\varphi(pq)=\varphi(p)\varphi(q)$&lt;/li&gt;
&lt;li&gt;任意$n\in N*$，$\varphi(n)=\varphi(\prod_i p_i^k)=\prod_i p^{k-1}(p_i-1)=n\prod_i(1-1/p_i)$&lt;/li&gt;
&lt;li&gt;对于$n&amp;gt;2$，$2|\varphi(n)$&lt;/li&gt;
&lt;li&gt;若$n\ mod\ p=0$，则$\varphi(np)=p\cdot \varphi(n)$&lt;/li&gt;
&lt;/ol&gt;
    
    </summary>
    
    
      <category term="数论" scheme="https://cothrax.github.io/tags/%E6%95%B0%E8%AE%BA/"/>
    
      <category term="数学" scheme="https://cothrax.github.io/tags/%E6%95%B0%E5%AD%A6/"/>
    
      <category term="线性筛" scheme="https://cothrax.github.io/tags/%E7%BA%BF%E6%80%A7%E7%AD%9B/"/>
    
      <category term="欧拉函数" scheme="https://cothrax.github.io/tags/%E6%AC%A7%E6%8B%89%E5%87%BD%E6%95%B0/"/>
    
  </entry>
  
  <entry>
    <title>NOIP2016十连测 Day 9</title>
    <link href="https://cothrax.github.io/2016/10/28/lydsy-noip-2016-test9/"/>
    <id>https://cothrax.github.io/2016/10/28/lydsy-noip-2016-test9/</id>
    <published>2016-10-28T15:26:20.000Z</published>
    <updated>2016-11-09T15:14:41.910Z</updated>
    
    <content type="html"><![CDATA[<p>2016-10-28<br>已经挖了好多坑了。。<delete>大flag：noip前填完</delete><br><strong>P3由于过于noip拒绝订正</strong></p>
<blockquote>
<p>订正进度(2/3)</p>
</blockquote>
<h1 id="P1-小P的2048"><a href="#P1-小P的2048" class="headerlink" title="P1 小P的2048"></a>P1 小P的2048</h1><p>大意：2048都玩过吧。。。给定棋盘和操作序列，求得分和有效操作数<br>因为是蛋疼模拟，各种细节就不写了。<br><a id="more"></a></p>
<h2 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h2><p>都说了是模拟<br>不知怎么丢了10分，算了不想改了。。</p>
<div><br><div class="copy"><br>    <a href="/2016/10/28/lydsy-noip-2016-test9/game.pas" title="{plain text}">{plain text}</a><br></div><br><div><br><figure class="highlight delphi"><figcaption><span>game.pas</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&#123;90pts&#125;</span></span><br><span class="line"><span class="keyword">uses</span> math;</span><br><span class="line"><span class="keyword">type</span> int=longint;</span><br><span class="line"><span class="keyword">var</span> </span><br><span class="line">    n,m,d,i,j,k,v,r,amt:int;ans:int64;b:boolean;</span><br><span class="line">    a:<span class="keyword">array</span>[<span class="number">0</span>..<span class="number">10</span>,<span class="number">0</span>..<span class="number">10</span>] <span class="keyword">of</span> int;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">mv</span><span class="params">(x,y,dx,dy:int)</span>:</span>boolean;</span><br><span class="line"><span class="keyword">var</span> lx,ly:int;flg:boolean;</span><br><span class="line"><span class="keyword">begin</span></span><br><span class="line">    lx:=x-dx;ly:=y-dy;mv:=false;flg:=true;</span><br><span class="line">    <span class="keyword">while</span> (min(x,y)&gt;<span class="number">0</span>)<span class="keyword">and</span>(max(x,y)&lt;=n) <span class="keyword">do</span> <span class="keyword">begin</span></span><br><span class="line">        <span class="keyword">if</span> a[x,y]&gt;<span class="number">0</span> <span class="keyword">then</span> <span class="keyword">begin</span></span><br><span class="line">            <span class="keyword">if</span> flg <span class="keyword">and</span> (a[x,y]=a[lx,ly]) <span class="keyword">then</span> <span class="keyword">begin</span></span><br><span class="line">                a[lx,ly]:=a[lx,ly]*<span class="number">2</span>;inc(ans,a[lx,ly]);</span><br><span class="line">                a[x,y]:=<span class="number">0</span>;</span><br><span class="line">                inc(r);mv:=true;flg:=false;</span><br><span class="line">            <span class="keyword">end</span> <span class="keyword">else</span> <span class="keyword">begin</span></span><br><span class="line">                inc(lx,dx);inc(ly,dy);</span><br><span class="line">                a[lx,ly]:=a[x,y];flg:=true;</span><br><span class="line">                <span class="keyword">if</span> (lx&lt;&gt;x)<span class="keyword">or</span>(ly&lt;&gt;y) <span class="keyword">then</span> <span class="keyword">begin</span></span><br><span class="line">                    a[x,y]:=<span class="number">0</span>;mv:=true;</span><br><span class="line">                <span class="keyword">end</span>;</span><br><span class="line">            <span class="keyword">end</span>;</span><br><span class="line">        <span class="keyword">end</span>;</span><br><span class="line">        inc(x,dx);inc(y,dy);</span><br><span class="line">    <span class="keyword">end</span>;</span><br><span class="line">    b:=b <span class="keyword">or</span> mv;</span><br><span class="line"><span class="keyword">end</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">procedure</span> <span class="title">add</span><span class="params">(k,v:int)</span>;</span></span><br><span class="line"><span class="keyword">var</span> i,j,cnt:int;</span><br><span class="line"><span class="keyword">begin</span></span><br><span class="line">    cnt:=<span class="number">0</span>;dec(r);</span><br><span class="line">    <span class="keyword">for</span> i:=<span class="number">1</span> <span class="keyword">to</span> n <span class="keyword">do</span></span><br><span class="line">        <span class="keyword">for</span> j:=<span class="number">1</span> <span class="keyword">to</span> n <span class="keyword">do</span></span><br><span class="line">            <span class="keyword">if</span> a[i,j]=<span class="number">0</span> <span class="keyword">then</span> <span class="keyword">begin</span></span><br><span class="line">                inc(cnt);</span><br><span class="line">                <span class="keyword">if</span> cnt=k <span class="keyword">then</span> <span class="keyword">begin</span> a[i,j]:=v;<span class="keyword">exit</span> <span class="keyword">end</span>;</span><br><span class="line">            <span class="keyword">end</span>;</span><br><span class="line"><span class="keyword">end</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">begin</span></span><br><span class="line">    assign(input,<span class="string">'game.in'</span>);reset(input);</span><br><span class="line">    assign(output,<span class="string">'game.out'</span>);rewrite(output);</span><br><span class="line">    <span class="keyword">read</span>(n,m);r:=n*n-<span class="number">2</span>;ans:=<span class="number">0</span>;amt:=m;</span><br><span class="line">    <span class="keyword">read</span>(i,j,k);a[i,j]:=k;</span><br><span class="line">    <span class="keyword">read</span>(i,j,k);a[i,j]:=k;</span><br><span class="line">    <span class="keyword">for</span> i:=<span class="number">1</span> <span class="keyword">to</span> m <span class="keyword">do</span> <span class="keyword">begin</span></span><br><span class="line">        <span class="keyword">read</span>(d,k,v);b:=false;</span><br><span class="line">        <span class="keyword">case</span> d <span class="keyword">of</span> </span><br><span class="line">            <span class="number">0</span>:<span class="keyword">for</span> j:=<span class="number">1</span> <span class="keyword">to</span> n <span class="keyword">do</span> mv(<span class="number">1</span>,j,<span class="number">1</span>,<span class="number">0</span>);</span><br><span class="line">            <span class="number">1</span>:<span class="keyword">for</span> j:=<span class="number">1</span> <span class="keyword">to</span> n <span class="keyword">do</span> mv(n,j,-<span class="number">1</span>,<span class="number">0</span>);</span><br><span class="line">            <span class="number">2</span>:<span class="keyword">for</span> j:=<span class="number">1</span> <span class="keyword">to</span> n <span class="keyword">do</span> mv(j,<span class="number">1</span>,<span class="number">0</span>,<span class="number">1</span>);</span><br><span class="line">            <span class="number">3</span>:<span class="keyword">for</span> j:=<span class="number">1</span> <span class="keyword">to</span> n <span class="keyword">do</span> mv(j,n,<span class="number">0</span>,-<span class="number">1</span>);</span><br><span class="line">        <span class="keyword">end</span>;</span><br><span class="line">        <span class="keyword">if</span> (r=<span class="number">0</span>) <span class="keyword">or</span> <span class="keyword">not</span> b <span class="keyword">then</span> <span class="keyword">begin</span> amt:=i-<span class="number">1</span>;<span class="keyword">break</span> <span class="keyword">end</span>;</span><br><span class="line">        k:=<span class="number">1</span>+k <span class="keyword">mod</span> r;add(k,v);</span><br><span class="line">    <span class="keyword">end</span>;</span><br><span class="line">    writeln(amt);<span class="keyword">write</span>(ans);</span><br><span class="line">    close(input);close(output);</span><br><span class="line"><span class="keyword">end</span>.</span><br></pre></td></tr></table></figure><br><br></div></div>

<h1 id="P2-小P的单调数列"><a href="#P2-小P的单调数列" class="headerlink" title="P2 小P的单调数列"></a>P2 小P的单调数列</h1><p>定义一个单调数列的价值：所有数的总和<br>定义一个数列的价值：划分为若干极长单调区间后，这些区间价值的平均值，第一个区间必须单调增<br>注：极长单调区间即保证相邻两个区间单调性不同<br>给定长为n的数列$a_i$，求其价值最大的子序列</p>
<h2 id="40分解法"><a href="#40分解法" class="headerlink" title="40分解法"></a>40分解法</h2><p>即对于$a_i$的若干单调子序列和的平均值，求最大值<br>显然想到dp<br>记f[i,j] 为a[1..i]中划分j个单调区间的答案</p>
<ol>
<li>$j\%2=1$<ol>
<li>$a[k]&lt;a[j],f[i,j]=max(f[k,j],f[k,j-1])+a[i]$</li>
<li>$a[k]&gt;a[j],f[i,j]=max(f[k,j-1])+a[i]$</li>
</ol>
</li>
<li>$j\%2=0$ 类似</li>
</ol>
<p>答案为$max(f[i,j]/j)$<br>初始：$f[0,0]=0,f[i,j]=+\infty$<br>复杂度：$O(N^3)$</p>
<div><br><div class="copy"><br>    <a href="/2016/10/28/lydsy-noip-2016-test9/seq.pas" title="{plain text}">{plain text}</a><br></div><br><div><br><figure class="highlight delphi"><figcaption><span>seq.pas</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">uses</span> math;</span><br><span class="line"><span class="keyword">type</span> int=longint;</span><br><span class="line"><span class="keyword">var</span></span><br><span class="line">    f:<span class="keyword">array</span>[<span class="number">0</span>..<span class="number">210</span>,<span class="number">0</span>..<span class="number">210</span>] <span class="keyword">of</span> int64;</span><br><span class="line">    a:<span class="keyword">array</span>[<span class="number">0</span>..<span class="number">210</span>] <span class="keyword">of</span> int64;</span><br><span class="line">    n,i,j,k:int;ans:double;</span><br><span class="line"></span><br><span class="line"><span class="keyword">begin</span></span><br><span class="line">    assign(input,<span class="string">'seq.in'</span>);reset(input);</span><br><span class="line">    assign(output,<span class="string">'seq.ans'</span>);rewrite(output);</span><br><span class="line">    <span class="keyword">read</span>(n);</span><br><span class="line">    <span class="keyword">for</span> i:=<span class="number">1</span> <span class="keyword">to</span> n <span class="keyword">do</span> <span class="keyword">read</span>(a[i]);</span><br><span class="line">    fillchar(f,sizeof(f),<span class="number">192</span>);</span><br><span class="line">    f[<span class="number">0</span>,<span class="number">0</span>]:=<span class="number">0</span>;ans:=<span class="number">0</span>;a[<span class="number">0</span>]:=maxlongint;</span><br><span class="line">    <span class="keyword">for</span> i:=<span class="number">1</span> <span class="keyword">to</span> n <span class="keyword">do</span></span><br><span class="line">    <span class="keyword">for</span> j:=<span class="number">1</span> <span class="keyword">to</span> n <span class="keyword">do</span></span><br><span class="line">    <span class="keyword">for</span> k:=i-<span class="number">1</span> <span class="keyword">downto</span> <span class="number">0</span> <span class="keyword">do</span></span><br><span class="line">        <span class="keyword">if</span> ((a[k]&gt;a[i])xor(j <span class="keyword">and</span> <span class="number">1</span>=<span class="number">1</span>)) <span class="keyword">and</span> (a[k]&lt;&gt;a[i]) <span class="keyword">then</span></span><br><span class="line">            f[i,j]:=max(f[i,j],max(f[k,j],f[k,j-<span class="number">1</span>])+a[i])</span><br><span class="line">        <span class="keyword">else</span> f[i,j]:=max(f[i,j],f[k,j-<span class="number">1</span>]+a[i]);</span><br><span class="line">    <span class="keyword">for</span> i:=<span class="number">1</span> <span class="keyword">to</span> n <span class="keyword">do</span></span><br><span class="line">        <span class="keyword">for</span> j:=<span class="number">1</span> <span class="keyword">to</span> n <span class="keyword">do</span></span><br><span class="line">            ans:=max(ans,f[i,j]/j);</span><br><span class="line">    <span class="keyword">write</span>(ans:<span class="number">0</span>:<span class="number">3</span>);</span><br><span class="line">    close(input);close(output);</span><br><span class="line"><span class="keyword">end</span>.</span><br></pre></td></tr></table></figure><br><br></div></div>

<h2 id="100分解法"><a href="#100分解法" class="headerlink" title="100分解法"></a>100分解法</h2><p>结论是：最优解的单调区间数一定$\leq 2$<br>因为是平均值，如果区间数$\geq 3$，根据比例的性质，去掉其中和最小的那个区间，能得到更优解<br>这么说只有一个区间是更优的，但由于题目要求第一个区间是单调增的，所以会存在两个区间的情况<br>这样对于每个数，求左边的lis和右边的lds，然后枚举分界点找最大值即可<br>然后还要考虑一个单调增区间的情况，即拿整个数列的lis更新答案<br>至于dp可以用树状数组优化，详见<a href="/2016/10/30/lydsy-noip-2016-test8/" title="Test8的P2">Test8的P2</a><br>复杂度$O(NlogN)$</p>
<div><br><div class="copy"><br>    <a href="/2016/10/28/lydsy-noip-2016-test9/seq_.pas" title="{plain text}">{plain text}</a><br></div><br><div><br><figure class="highlight delphi"><figcaption><span>seq_.pas</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">uses</span> math;</span><br><span class="line"><span class="keyword">type</span> int=longint;</span><br><span class="line"><span class="keyword">var</span> </span><br><span class="line">    n,m,i:int;ans:double;</span><br><span class="line">    a:<span class="keyword">array</span>[<span class="number">0</span>..<span class="number">100010</span>,<span class="number">0</span>..<span class="number">1</span>] <span class="keyword">of</span> int;</span><br><span class="line">    b,l:<span class="keyword">array</span>[<span class="number">0</span>..<span class="number">100010</span>] <span class="keyword">of</span> int;</span><br><span class="line">    bit,lis,lds:<span class="keyword">array</span>[<span class="number">0</span>..<span class="number">100010</span>] <span class="keyword">of</span> int64;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">procedure</span> <span class="title">qsort</span><span class="params">(l,r:int)</span>;</span></span><br><span class="line"><span class="keyword">var</span> i,j,x:int;tmp:<span class="keyword">array</span>[<span class="number">0</span>..<span class="number">1</span>] <span class="keyword">of</span> int;</span><br><span class="line"><span class="keyword">begin</span></span><br><span class="line">    i:=l;j:=r;x:=a[random(r-l)+l,<span class="number">0</span>];</span><br><span class="line">    <span class="keyword">repeat</span></span><br><span class="line">        <span class="keyword">while</span> a[i,<span class="number">0</span>]&lt;x <span class="keyword">do</span> inc(i);</span><br><span class="line">        <span class="keyword">while</span> a[j,<span class="number">0</span>]&gt;x <span class="keyword">do</span> dec(j);</span><br><span class="line">        <span class="keyword">if</span> i&lt;=j <span class="keyword">then</span> <span class="keyword">begin</span></span><br><span class="line">            tmp:=a[i];a[i]:=a[j];a[j]:=tmp;</span><br><span class="line">            inc(i);dec(j);</span><br><span class="line">        <span class="keyword">end</span>;</span><br><span class="line">    <span class="keyword">until</span> i&gt;j;</span><br><span class="line">    <span class="keyword">if</span> l&lt;j <span class="keyword">then</span> qsort(l,j);</span><br><span class="line">    <span class="keyword">if</span> i&lt;r <span class="keyword">then</span> qsort(i,r);</span><br><span class="line"><span class="keyword">end</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">query</span><span class="params">(x:int)</span>:</span>int64;</span><br><span class="line"><span class="keyword">begin</span></span><br><span class="line">    query:=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span> x&gt;<span class="number">0</span> <span class="keyword">do</span> <span class="keyword">begin</span></span><br><span class="line">        query:=max(query,bit[x]);</span><br><span class="line">        x:=x <span class="keyword">and</span> (x-<span class="number">1</span>);</span><br><span class="line">    <span class="keyword">end</span>;</span><br><span class="line"><span class="keyword">end</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">procedure</span> <span class="title">add</span><span class="params">(x:int;k:int64)</span>;</span></span><br><span class="line"><span class="keyword">begin</span></span><br><span class="line">    <span class="keyword">while</span> x&lt;=n <span class="keyword">do</span> <span class="keyword">begin</span></span><br><span class="line">        bit[x]:=max(bit[x],k);</span><br><span class="line">        inc(x,x <span class="keyword">and</span> (-x));</span><br><span class="line">    <span class="keyword">end</span>;</span><br><span class="line"><span class="keyword">end</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">begin</span></span><br><span class="line">    assign(input,<span class="string">'seq.in'</span>);reset(input);</span><br><span class="line">    assign(output,<span class="string">'seq.out'</span>);rewrite(output);</span><br><span class="line">    <span class="keyword">read</span>(n);</span><br><span class="line">    <span class="keyword">for</span> i:=<span class="number">1</span> <span class="keyword">to</span> n <span class="keyword">do</span> <span class="keyword">read</span>(a[i,<span class="number">0</span>]);</span><br><span class="line">    <span class="keyword">for</span> i:=<span class="number">1</span> <span class="keyword">to</span> n <span class="keyword">do</span> a[i,<span class="number">1</span>]:=i;</span><br><span class="line">    qsort(<span class="number">1</span>,n);m:=<span class="number">0</span>;l[m]:=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> i:=<span class="number">1</span> <span class="keyword">to</span> n <span class="keyword">do</span> <span class="keyword">begin</span></span><br><span class="line">        <span class="keyword">if</span> a[i,<span class="number">0</span>]&gt;l[m] <span class="keyword">then</span> <span class="keyword">begin</span> inc(m);l[m]:=a[i,<span class="number">0</span>] <span class="keyword">end</span>;</span><br><span class="line">        b[a[i,<span class="number">1</span>]]:=m;</span><br><span class="line">    <span class="keyword">end</span>;</span><br><span class="line">    <span class="comment">//f[i]=max(f[j])+a[i] i&lt;j&amp;&amp;a[i]&lt;=a[j] max(1..a[j]) of f[]</span></span><br><span class="line">    <span class="keyword">for</span> i:=<span class="number">1</span> <span class="keyword">to</span> n <span class="keyword">do</span> <span class="keyword">begin</span></span><br><span class="line">        lis[i]:=query(b[i]-<span class="number">1</span>)+l[b[i]];</span><br><span class="line">        add(b[i],lis[i]);</span><br><span class="line">    <span class="keyword">end</span>;</span><br><span class="line">    fillchar(bit,sizeof(bit),<span class="number">0</span>);</span><br><span class="line">    <span class="keyword">for</span> i:=n <span class="keyword">downto</span> <span class="number">1</span> <span class="keyword">do</span> <span class="keyword">begin</span></span><br><span class="line">        lds[i]:=query(b[i]-<span class="number">1</span>)+l[b[i]];</span><br><span class="line">        add(b[i],lds[i]);</span><br><span class="line">    <span class="keyword">end</span>;</span><br><span class="line">    <span class="keyword">for</span> i:=<span class="number">2</span> <span class="keyword">to</span> n <span class="keyword">do</span> lis[i]:=max(lis[i],lis[i-<span class="number">1</span>]);</span><br><span class="line">    <span class="keyword">for</span> i:=n-<span class="number">1</span> <span class="keyword">downto</span> <span class="number">1</span> <span class="keyword">do</span> lds[i]:=max(lds[i],lds[i+<span class="number">1</span>]);</span><br><span class="line">    ans:=lis[n];</span><br><span class="line">    <span class="keyword">for</span> i:=<span class="number">1</span> <span class="keyword">to</span> n-<span class="number">1</span> <span class="keyword">do</span> ans:=max(ans,(lis[i]+lds[i+<span class="number">1</span>])/<span class="number">2</span>);</span><br><span class="line">    <span class="keyword">write</span>(ans:<span class="number">0</span>:<span class="number">3</span>);</span><br><span class="line">    close(input);close(output);</span><br><span class="line"><span class="keyword">end</span>.</span><br></pre></td></tr></table></figure><br><br></div></div>

<h1 id="P3-小P的生成树"><a href="#P3-小P的生成树" class="headerlink" title="P3 小P的生成树"></a>P3 小P的生成树</h1><p>给定n个节点，m条边的连通的带权无向简单图，边权为向量，求一个生成树，使得树上的边权向量和的模最大。<br>$n\leq 50, m\leq 200$</p>
<h2 id="注"><a href="#注" class="headerlink" title="注"></a>注</h2><blockquote>
<p>涉及计算几何内容，暂不订正</p>
</blockquote>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;2016-10-28&lt;br&gt;已经挖了好多坑了。。&lt;delete&gt;大flag：noip前填完&lt;/delete&gt;&lt;br&gt;&lt;strong&gt;P3由于过于noip拒绝订正&lt;/strong&gt;&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;订正进度(2/3)&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h1 id=&quot;P1-小P的2048&quot;&gt;&lt;a href=&quot;#P1-小P的2048&quot; class=&quot;headerlink&quot; title=&quot;P1 小P的2048&quot;&gt;&lt;/a&gt;P1 小P的2048&lt;/h1&gt;&lt;p&gt;大意：2048都玩过吧。。。给定棋盘和操作序列，求得分和有效操作数&lt;br&gt;因为是蛋疼模拟，各种细节就不写了。&lt;br&gt;
    
    </summary>
    
      <category term="Problem Set" scheme="https://cothrax.github.io/categories/Problem-Set/"/>
    
    
      <category term="OI" scheme="https://cothrax.github.io/tags/OI/"/>
    
      <category term="数据结构" scheme="https://cothrax.github.io/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"/>
    
      <category term="DP" scheme="https://cothrax.github.io/tags/DP/"/>
    
      <category term="线性DP" scheme="https://cothrax.github.io/tags/%E7%BA%BF%E6%80%A7DP/"/>
    
      <category term="树状数组" scheme="https://cothrax.github.io/tags/%E6%A0%91%E7%8A%B6%E6%95%B0%E7%BB%84/"/>
    
  </entry>
  
  <entry>
    <title>NOIP2016十连测 Day 5</title>
    <link href="https://cothrax.github.io/2016/10/28/lydsy-noip-2016-test5/"/>
    <id>https://cothrax.github.io/2016/10/28/lydsy-noip-2016-test5/</id>
    <published>2016-10-28T14:43:14.000Z</published>
    <updated>2016-11-03T15:40:10.063Z</updated>
    
    <content type="html"><![CDATA[<p>跪</p>
<blockquote>
<p>订正进度(2/3)</p>
</blockquote>
<h1 id="P1-Simple"><a href="#P1-Simple" class="headerlink" title="P1 Simple"></a>P1 Simple</h1><p>给定$n,m,q\in N*$，求$[1,q]内，$$\not\exists x,y\in N,c=nx+my$的c的个数<br>共T组询问<br>$n≤10^5,m≤10^9,q≤10^{18},T≤10$</p>
<a id="more"></a>
<h2 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h2><p>从反面入手，求可以表示成$nx+my,n,m\in N$的c的个数<br>根据裴蜀定理，$c=nx+my$有解当且仅当$gcd(n,m)|c$<br>记$g=gcd(n,m)$<br>这样解的范围被缩小到$[1,n/g]$，$n=n/g,m=m/g$，此时n和m互质<br>然后根据数论知识，不能被表示成$nx+my,n,m\in N*$的最大整数为$nm-n-m$</p>
<p>那么考虑$[1,nm]$的数，其中能表示为$ym-xn,y\in[0,n-1]$的数一定满足题意：<br>由扩展欧几里得可知，已知$ym+(-x)n=c$的一组解$(-x,y)$，那么它的所有解为$(-x+t\cdot m,y-t\cdot n)$，其中必定有一个是负数<br>这样枚举[0,n-1]统计即可。</p>
<div><br><div class="copy"><br>    <a href="/2016/10/28/lydsy-noip-2016-test5/simple.pas" title="{plain text}">{plain text}</a><br></div><br><div><br><figure class="highlight delphi"><figcaption><span>simple.pas</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">uses</span> math;</span><br><span class="line"><span class="keyword">type</span> int=longint;</span><br><span class="line"><span class="keyword">var</span> n,m,q,g,l,r,ans:int64;i,j,t:int;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">gcd</span><span class="params">(a,b:int64)</span>:</span>int64;</span><br><span class="line"><span class="keyword">begin</span> <span class="keyword">if</span> b=<span class="number">0</span> <span class="keyword">then</span> gcd:=a <span class="keyword">else</span> gcd:=gcd(b,a <span class="keyword">mod</span> b) <span class="keyword">end</span>;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">cldv</span><span class="params">(n,m:int64)</span>:</span>int64;</span><br><span class="line"><span class="keyword">begin</span></span><br><span class="line">    cldv:=n <span class="keyword">div</span> m;</span><br><span class="line">    <span class="keyword">if</span> n <span class="keyword">mod</span> m&lt;&gt;<span class="number">0</span> <span class="keyword">then</span> inc(cldv);</span><br><span class="line"><span class="keyword">end</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">begin</span></span><br><span class="line">    <span class="comment">//assign(input,'simple.in');reset(input);</span></span><br><span class="line">    <span class="comment">//assign(output,'simple.out');rewrite(output);</span></span><br><span class="line">    <span class="keyword">read</span>(t);</span><br><span class="line">    <span class="keyword">repeat</span></span><br><span class="line">        <span class="keyword">read</span>(n,m,q);g:=gcd(n,m);</span><br><span class="line">        ans:=q;q:=q <span class="keyword">div</span> g;dec(ans,q);</span><br><span class="line">        n:=n <span class="keyword">div</span> g;m:=m <span class="keyword">div</span> g;</span><br><span class="line">        <span class="keyword">for</span> i:=<span class="number">0</span> <span class="keyword">to</span> n-<span class="number">1</span> <span class="keyword">do</span> <span class="keyword">begin</span></span><br><span class="line">            l:=max(<span class="number">1</span>,cldv(i*m-q,n));</span><br><span class="line">            r:=trunc((i*m-<span class="number">1</span>)/n);</span><br><span class="line">            inc(ans,max(r-l+<span class="number">1</span>,<span class="number">0</span>));</span><br><span class="line">        <span class="keyword">end</span>;</span><br><span class="line">        writeln(ans);</span><br><span class="line">        dec(t);</span><br><span class="line">    <span class="keyword">until</span> t=<span class="number">0</span>;</span><br><span class="line">    close(input);close(output);</span><br><span class="line"><span class="keyword">end</span>.</span><br></pre></td></tr></table></figure><br><br></div></div>

<h1 id="P2-Walk"><a href="#P2-Walk" class="headerlink" title="P2 Walk"></a>P2 Walk</h1><p>大意：给定n个节点的树，边长为1，边权为w，定义一条路径的权值为路径上所有边权的最大公约数，对于任意$i\in[1,n]$,求树上所有长度为i的简单路径中权值最大的是多少。</p>
<h2 id="题解-1"><a href="#题解-1" class="headerlink" title="题解"></a>题解</h2><p>大暴力，枚举答案，每次都重新构图，跑树（森林）上最长链<br>一点总结：</p>
<ol>
<li>关于gcd的处理：枚举gcd，那么权为gcd倍数的边都是合法的</li>
<li>关于复杂度的分析：每条边e(u,v)=w只有在枚举值为w的约数时才会被遍历，理论复杂度为$O(N\sqrt{N})$</li>
<li>关于常数<ul>
<li>用链表维护边集，将边权相等的边串起来</li>
<li>用栈维护点集，在加边时将端点入栈</li>
<li>清空临时的边集数组时，由于只有在栈内的点的head值被修改，遍历栈中的点即可</li>
<li>标记数组：当前为第idx次遍历，用flag[u]=idx表示u以被访问，避免每次清空数组</li>
</ul>
</li>
<li>关于树上最长链：之前在学树形dp时用过一种比较复杂的方法，记录一个点的最长链、次长链、链经过的子节点，两次dp得到；更简单的方法见代码</li>
<li>关于一些sb错误<ul>
<li>栈要开2*n</li>
<li>混淆栈中元素和栈下标</li>
</ul>
</li>
</ol>
<div><br><div class="copy"><br>    <a href="/2016/10/28/lydsy-noip-2016-test5/walk.pas" title="{plain text}">{plain text}</a><br></div><br><div><br><figure class="highlight delphi"><figcaption><span>walk.pas</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">uses</span> math;</span><br><span class="line"><span class="keyword">type</span> </span><br><span class="line">    int=longint;</span><br><span class="line">    edge=<span class="keyword">record</span> v,next:int <span class="keyword">end</span>;</span><br><span class="line">    e1=<span class="keyword">record</span> u,v,next:int <span class="keyword">end</span>;</span><br><span class="line"><span class="keyword">var</span> </span><br><span class="line">    g:<span class="keyword">array</span>[<span class="number">0</span>..<span class="number">800010</span>] <span class="keyword">of</span> edge;</span><br><span class="line">    e:<span class="keyword">array</span>[<span class="number">0</span>..<span class="number">400010</span>] <span class="keyword">of</span> e1;</span><br><span class="line">    head,flag,ans:<span class="keyword">array</span>[<span class="number">0</span>..<span class="number">400010</span>] <span class="keyword">of</span> int;</span><br><span class="line">    stk:<span class="keyword">array</span>[<span class="number">0</span>..<span class="number">800010</span>] <span class="keyword">of</span> int;</span><br><span class="line">    ptr:<span class="keyword">array</span>[<span class="number">0</span>..<span class="number">1000010</span>] <span class="keyword">of</span> int;</span><br><span class="line">    sz,k,mx,n,i,j,l,u,v,w,idx,len,t:int;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">procedure</span> <span class="title">add</span><span class="params">(u,v:int)</span>;</span></span><br><span class="line"><span class="keyword">begin</span></span><br><span class="line">    inc(sz);g[sz].v:=v;</span><br><span class="line">    g[sz].next:=head[u];head[u]:=sz;</span><br><span class="line"><span class="keyword">end</span>;</span><br><span class="line"><span class="function"><span class="keyword">procedure</span> _<span class="title">add</span><span class="params">(u,v,w:int)</span>;</span></span><br><span class="line"><span class="keyword">begin</span></span><br><span class="line">    inc(k);e[k].u:=u;e[k].v:=v;</span><br><span class="line">    e[k].next:=ptr[w];ptr[w]:=k;</span><br><span class="line"><span class="keyword">end</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">dfs</span><span class="params">(u:int)</span>:</span>int;</span><br><span class="line"><span class="keyword">var</span> v,i,tmp:int;</span><br><span class="line"><span class="keyword">begin</span></span><br><span class="line">    flag[u]:=idx;i:=head[u];dfs:=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span> i&lt;&gt;<span class="number">0</span> <span class="keyword">do</span> <span class="keyword">begin</span></span><br><span class="line">        v:=g[i].v;</span><br><span class="line">        <span class="keyword">if</span> flag[v]&lt;idx <span class="keyword">then</span> <span class="keyword">begin</span></span><br><span class="line">            tmp:=dfs(v);</span><br><span class="line">            len:=max(len,dfs+tmp+<span class="number">1</span>);</span><br><span class="line">            dfs:=max(dfs,tmp+<span class="number">1</span>);</span><br><span class="line">        <span class="keyword">end</span>;</span><br><span class="line">        i:=g[i].next;</span><br><span class="line">    <span class="keyword">end</span>;</span><br><span class="line"><span class="keyword">end</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">begin</span></span><br><span class="line">    assign(input,<span class="string">'ex_walk3.in'</span>);reset(input);</span><br><span class="line">    assign(output,<span class="string">'walk.out'</span>);rewrite(output);</span><br><span class="line">    <span class="keyword">read</span>(n);k:=<span class="number">0</span>;mx:=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> i:=<span class="number">1</span> <span class="keyword">to</span> n-<span class="number">1</span> <span class="keyword">do</span> <span class="keyword">begin</span></span><br><span class="line">        <span class="keyword">read</span>(u,v,w);_add(u,v,w);mx:=max(mx,w);</span><br><span class="line">    <span class="keyword">end</span>;</span><br><span class="line">    idx:=<span class="number">0</span>;len:=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> i:=<span class="number">1</span> <span class="keyword">to</span> mx <span class="keyword">do</span> <span class="keyword">begin</span></span><br><span class="line">        sz:=<span class="number">0</span>;inc(idx);l:=i;t:=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span> l&lt;=mx <span class="keyword">do</span> <span class="keyword">begin</span></span><br><span class="line">            j:=ptr[l];inc(l,i);</span><br><span class="line">            <span class="keyword">while</span> j&lt;&gt;<span class="number">0</span> <span class="keyword">do</span> <span class="keyword">begin</span></span><br><span class="line">                add(e[j].u,e[j].v);add(e[j].v,e[j].u);</span><br><span class="line">                inc(t,<span class="number">2</span>);stk[t-<span class="number">1</span>]:=e[j].u;stk[t]:=e[j].v;</span><br><span class="line">                j:=e[j].next;</span><br><span class="line">            <span class="keyword">end</span>;</span><br><span class="line">        <span class="keyword">end</span>;</span><br><span class="line">        len:=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> j:=<span class="number">1</span> <span class="keyword">to</span> t <span class="keyword">do</span> <span class="keyword">if</span> flag[stk[j]]&lt;idx <span class="keyword">then</span> dfs(stk[j]);</span><br><span class="line">        <span class="keyword">for</span> j:=<span class="number">1</span> <span class="keyword">to</span> t <span class="keyword">do</span> head[stk[j]]:=<span class="number">0</span>;</span><br><span class="line">        ans[len]:=i;</span><br><span class="line">    <span class="keyword">end</span>;</span><br><span class="line">    <span class="keyword">for</span> i:=n-<span class="number">1</span> <span class="keyword">downto</span> <span class="number">1</span> <span class="keyword">do</span></span><br><span class="line">        ans[i]:=max(ans[i],ans[i+<span class="number">1</span>]);</span><br><span class="line">    <span class="keyword">for</span> i:=<span class="number">1</span> <span class="keyword">to</span> n <span class="keyword">do</span> writeln(ans[i]);</span><br><span class="line">    close(input);close(output);</span><br><span class="line"><span class="keyword">end</span>.</span><br></pre></td></tr></table></figure><br><br></div></div>

<h1 id="P3-Travel"><a href="#P3-Travel" class="headerlink" title="P3 Travel"></a>P3 Travel</h1><blockquote>
<p>挖个坑</p>
</blockquote>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;跪&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;订正进度(2/3)&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h1 id=&quot;P1-Simple&quot;&gt;&lt;a href=&quot;#P1-Simple&quot; class=&quot;headerlink&quot; title=&quot;P1 Simple&quot;&gt;&lt;/a&gt;P1 Simple&lt;/h1&gt;&lt;p&gt;给定$n,m,q\in N*$，求$[1,q]内，$$\not\exists x,y\in N,c=nx+my$的c的个数&lt;br&gt;共T组询问&lt;br&gt;$n≤10^5,m≤10^9,q≤10^{18},T≤10$&lt;/p&gt;
    
    </summary>
    
      <category term="Problem Set" scheme="https://cothrax.github.io/categories/Problem-Set/"/>
    
    
      <category term="OI" scheme="https://cothrax.github.io/tags/OI/"/>
    
      <category term="数据结构" scheme="https://cothrax.github.io/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"/>
    
      <category term="图论" scheme="https://cothrax.github.io/tags/%E5%9B%BE%E8%AE%BA/"/>
    
      <category term="数论" scheme="https://cothrax.github.io/tags/%E6%95%B0%E8%AE%BA/"/>
    
      <category term="树形DP" scheme="https://cothrax.github.io/tags/%E6%A0%91%E5%BD%A2DP/"/>
    
      <category term="链表" scheme="https://cothrax.github.io/tags/%E9%93%BE%E8%A1%A8/"/>
    
      <category term="裴蜀定理" scheme="https://cothrax.github.io/tags/%E8%A3%B4%E8%9C%80%E5%AE%9A%E7%90%86/"/>
    
      <category term="栈" scheme="https://cothrax.github.io/tags/%E6%A0%88/"/>
    
  </entry>
  
  <entry>
    <title>NOIP模拟赛 游戏</title>
    <link href="https://cothrax.github.io/2016/10/16/noip-2009-11-1-2-game/"/>
    <id>https://cothrax.github.io/2016/10/16/noip-2009-11-1-2-game/</id>
    <published>2016-10-16T02:56:41.000Z</published>
    <updated>2016-10-30T06:06:17.165Z</updated>
    
    <content type="html"><![CDATA[<h2 id="描述"><a href="#描述" class="headerlink" title="描述"></a>描述</h2><p>windy学会了一种游戏。<br>对于1到N这N个数字，都有唯一且不同的1到N的数字与之对应。<br>最开始windy把数字按顺序1，2，3，……，N写一排在纸上。<br>然后再在这一排下面写上它们对应的数字。<br>然后又在新的一排下面写上它们对应的数字。<br>如此反复，直到序列再次变为1，2，3，……，N。<br><a id="more"></a><br>如：<br>1 2 3 4 5 6<br>对应的关系为<br>1-&gt;2 2-&gt;3 3-&gt;1 4-&gt;5 5-&gt;4 6-&gt;6<br>windy的操作如下<br>1 2 3 4 5 6<br>2 3 1 5 4 6<br>3 1 2 4 5 6<br>1 2 3 5 4 6<br>2 3 1 4 5 6<br>3 1 2 5 4 6<br>1 2 3 4 5 6<br>这时，我们就有若干排1到N的排列，上例中有7排。<br>现在windy想知道，对于所有可能的对应关系，有多少种可能的排数。 </p>
<h2 id="格式"><a href="#格式" class="headerlink" title="格式"></a>格式</h2><h3 id="输入格式"><a href="#输入格式" class="headerlink" title="输入格式"></a>输入格式</h3><p>输入文件game.in包含一个整数，N。</p>
<h3 id="输出格式"><a href="#输出格式" class="headerlink" title="输出格式"></a>输出格式</h3><p>输出文件game.out包含一个整数，可能的排数。</p>
<h2 id="样例"><a href="#样例" class="headerlink" title="样例"></a>样例</h2><h3 id="样例输入"><a href="#样例输入" class="headerlink" title="样例输入"></a>样例输入</h3><blockquote>
<p>3</p>
</blockquote>
<h3 id="样例输出"><a href="#样例输出" class="headerlink" title="样例输出"></a>样例输出</h3><blockquote>
<p>3</p>
</blockquote>
<h2 id="提示​"><a href="#提示​" class="headerlink" title="提示​"></a>提示​</h2><p>30%的数据，满足 1 &lt;= N &lt;= 10 。<br>100%的数据，满足 1 &lt;= N &lt;= 1000 。 </p>
<h2 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h2><p>规约为：<span>$n\geq\sum_ia_i$</span><!-- Has MathJax -->，求不同的<span>$lcm\{a_i\}$</span><!-- Has MathJax -->的个数<br>先筛素数，然后dp<br>f[i,j]为1..i个素数，和为j的方案数</p>
<div><br><div class="copy"><br>    <a href="/2016/10/16/noip-2009-11-1-2-game/game.pas" title="{plain text}">{plain text}</a><br></div><br><div><br><figure class="highlight delphi"><figcaption><span>game.pas</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> int=longint;</span><br><span class="line"><span class="keyword">var</span> </span><br><span class="line">    p:<span class="keyword">array</span>[<span class="number">0</span>..<span class="number">1010</span>] <span class="keyword">of</span> boolean;</span><br><span class="line">    a:<span class="keyword">array</span>[<span class="number">0</span>..<span class="number">1010</span>] <span class="keyword">of</span> int;</span><br><span class="line">    f:<span class="keyword">array</span>[<span class="number">0</span>..<span class="number">1010</span>] <span class="keyword">of</span> int64;</span><br><span class="line">    n,m,i,j,k:int;ans:int64;</span><br><span class="line"></span><br><span class="line"><span class="keyword">begin</span></span><br><span class="line">    assign(input,<span class="string">'game.in'</span>);reset(input);</span><br><span class="line">    assign(output,<span class="string">'game.out'</span>);rewrite(output);</span><br><span class="line">    <span class="keyword">read</span>(n);m:=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> i:=<span class="number">2</span> <span class="keyword">to</span> n <span class="keyword">do</span></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> p[i] <span class="keyword">then</span> <span class="keyword">begin</span></span><br><span class="line">            inc(m);a[m]:=i;</span><br><span class="line">            j:=i*<span class="number">2</span>;</span><br><span class="line">            <span class="keyword">while</span> j&lt;=n <span class="keyword">do</span> <span class="keyword">begin</span></span><br><span class="line">                p[j]:=true;inc(j,i);</span><br><span class="line">            <span class="keyword">end</span>;</span><br><span class="line">        <span class="keyword">end</span>;</span><br><span class="line">    f[<span class="number">0</span>]:=<span class="number">1</span>;</span><br><span class="line">    <span class="comment">//j-k*a[i]&gt;=0 -&gt; k&lt;=j/a[i]</span></span><br><span class="line">    <span class="keyword">for</span> i:=<span class="number">1</span> <span class="keyword">to</span> m <span class="keyword">do</span></span><br><span class="line">        <span class="keyword">for</span> j:=n <span class="keyword">downto</span> <span class="number">1</span> <span class="keyword">do</span> <span class="keyword">begin</span></span><br><span class="line">            k:=a[i];</span><br><span class="line">            <span class="keyword">while</span> k&lt;=j <span class="keyword">do</span> <span class="keyword">begin</span></span><br><span class="line">                inc(f[j],f[j-k]);k:=k*a[i];</span><br><span class="line">            <span class="keyword">end</span>;</span><br><span class="line">        <span class="keyword">end</span>;</span><br><span class="line">    ans:=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> i:=<span class="number">0</span> <span class="keyword">to</span> n <span class="keyword">do</span> inc(ans,f[i]);</span><br><span class="line">    <span class="keyword">write</span>(ans);</span><br><span class="line">    close(input);close(output);</span><br><span class="line"><span class="keyword">end</span>.</span><br></pre></td></tr></table></figure><br><br></div></div>
]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;描述&quot;&gt;&lt;a href=&quot;#描述&quot; class=&quot;headerlink&quot; title=&quot;描述&quot;&gt;&lt;/a&gt;描述&lt;/h2&gt;&lt;p&gt;windy学会了一种游戏。&lt;br&gt;对于1到N这N个数字，都有唯一且不同的1到N的数字与之对应。&lt;br&gt;最开始windy把数字按顺序1，2，3，……，N写一排在纸上。&lt;br&gt;然后再在这一排下面写上它们对应的数字。&lt;br&gt;然后又在新的一排下面写上它们对应的数字。&lt;br&gt;如此反复，直到序列再次变为1，2，3，……，N。&lt;br&gt;
    
    </summary>
    
      <category term="Problem Set" scheme="https://cothrax.github.io/categories/Problem-Set/"/>
    
    
      <category term="OI" scheme="https://cothrax.github.io/tags/OI/"/>
    
      <category term="DP" scheme="https://cothrax.github.io/tags/DP/"/>
    
      <category term="数论" scheme="https://cothrax.github.io/tags/%E6%95%B0%E8%AE%BA/"/>
    
      <category term="数学" scheme="https://cothrax.github.io/tags/%E6%95%B0%E5%AD%A6/"/>
    
  </entry>
  
  <entry>
    <title>NOIP2016十连测 Day 6</title>
    <link href="https://cothrax.github.io/2016/10/16/lydsy-noip-2016-test6/"/>
    <id>https://cothrax.github.io/2016/10/16/lydsy-noip-2016-test6/</id>
    <published>2016-10-16T02:37:45.000Z</published>
    <updated>2016-11-03T15:40:16.957Z</updated>
    
    <content type="html"><![CDATA[<p>又一场NOIplus模拟赛。<br>第一题同样是暴力，pascal被卡常<br>第三题yy了scc+dfs，忘记判无解的情况，又是捆绑测试，然后爆0</p>
<blockquote>
<p>订正进度(2/3)</p>
</blockquote>
<h1 id="P1-幻想"><a href="#P1-幻想" class="headerlink" title="P1 幻想"></a>P1 幻想</h1><p>大意：（其实是描述的片段）<br>给定一个不小于 2 的整数 k ,按照如下方式生成一个无限长的序列S (下标从 0 开始)。<br>1.初始时序列只有一个元素 S(0) = 0 。<br>2.对于j=1,2,…,k-1分别把当前序列的每个元素都加上j,得到新的k-1个序列。<br>3.把新的k-1个序列依次接在当前序列后面,得到一个长度为当前序列长度 k 倍的序列。<br>4.把这个序列每一项都变成其除以 k 之后的余数,并把这个序列作为新的当前序列。<br>5.执行无穷次操作 2-4。<br>给定l,r，求$\sum_{i=L}^{R}h(i)\times S_i$<br>其中$h(i)=\lfloor\dfrac{(i\% 20000116)^2+i+804}{233}\rfloor$<br>答案对$2^{32}$取模<br>$T≤100 ; 2≤k≤1000 ; 0≤L≤R≤10^16;\sum(R-L)≤10^8$<br>时限2s</p>
<a id="more"></a>
<h2 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h2><p>观察发现S(i)就是i在k进制下，数位和mod k的值，r-l又不是很大，暴力求<br>pascal被卡常<br>附我的草稿</p>
<blockquote>
<p>123 456 789 012 345 678 901 234 567<br>012 120 201 120 201 012 201 012 120</p>
<p>f(i) i mod 3=1=d -&gt; init=d-1<br>bl=ceil(i/k) -&gt; 9 –&gt;<br>ceil(i/k^2)) -&gt; 3 –&gt;<br>ceil(i/k^3)) -&gt; 1 –&gt; 0</p>
<p>19=2*3^2+1*3^0 -&gt; (2+1 -1)%3<br>16=1*3^2+2*3^1+1*3^0 (1+2+1 -1)%3=1<br>O((r-l)*log_k(n)*(k-1))</p>
<p>l-&gt;r ??<br>∑i*3^k -&gt; ∑i*3^k+1 ??</p>
</blockquote>
<div><br><div class="copy"><br>    <a href="/2016/10/16/lydsy-noip-2016-test6/fantasy.pas" title="{plain text}">{plain text}</a><br></div><br><div><br><figure class="highlight delphi"><figcaption><span>fantasy.pas</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&#123;$R-&#125;</span></span><br><span class="line"><span class="keyword">uses</span> math;</span><br><span class="line"><span class="keyword">type</span> int=longint;qw=qword;dw=dword;</span><br><span class="line"><span class="keyword">const</span> z0:qw=<span class="number">20000116</span>;</span><br><span class="line"><span class="keyword">var</span> </span><br><span class="line">    T,i:int;l,r,x:qw;ans,k,cnt:dw;</span><br><span class="line">    nxt:<span class="keyword">array</span>[<span class="number">0</span>..<span class="number">1100</span>] <span class="keyword">of</span> dw;</span><br><span class="line">    f:<span class="keyword">array</span>[<span class="number">0</span>..<span class="number">60</span>] <span class="keyword">of</span> dw;</span><br><span class="line"></span><br><span class="line"><span class="keyword">begin</span></span><br><span class="line">    <span class="comment">//assign(input,'fantasy.in');reset(input);</span></span><br><span class="line">    <span class="comment">//assign(output,'fantasy.out');rewrite(output);</span></span><br><span class="line">    <span class="keyword">read</span>(T);</span><br><span class="line">    <span class="keyword">repeat</span></span><br><span class="line">        <span class="keyword">read</span>(k,l,r);</span><br><span class="line">        fillchar(f,sizeof(f),<span class="number">0</span>);</span><br><span class="line">        x:=l;i:=<span class="number">0</span>;cnt:=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span> x&gt;<span class="number">0</span> <span class="keyword">do</span> <span class="keyword">begin</span></span><br><span class="line">            f[i]:=x <span class="keyword">mod</span> k;x:=x <span class="keyword">div</span> k;cnt:=cnt+f[i];i:=i+<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">end</span>;</span><br><span class="line">        <span class="keyword">for</span> i:=<span class="number">0</span> <span class="keyword">to</span> k-<span class="number">2</span> <span class="keyword">do</span> nxt[i]:=i+<span class="number">1</span>;nxt[k-<span class="number">1</span>]:=<span class="number">0</span>;</span><br><span class="line">        cnt:=cnt <span class="keyword">mod</span> k;</span><br><span class="line">        ans:=qw(cnt)*trunc((sqr(l <span class="keyword">mod</span> z0)+l+<span class="number">804</span>)/<span class="number">233</span>);</span><br><span class="line">        <span class="keyword">if</span> l=r <span class="keyword">then</span> <span class="keyword">exit</span>;x:=l+<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">repeat</span></span><br><span class="line">            f[<span class="number">0</span>]:=f[<span class="number">0</span>]+<span class="number">1</span>;cnt:=nxt[cnt];i:=<span class="number">0</span>;</span><br><span class="line">            <span class="keyword">while</span> f[i]=k <span class="keyword">do</span> <span class="keyword">begin</span></span><br><span class="line">                f[i+<span class="number">1</span>]:=f[i+<span class="number">1</span>]+<span class="number">1</span>;f[i]:=<span class="number">0</span>;i:=i+<span class="number">1</span>;</span><br><span class="line">                cnt:=nxt[cnt];</span><br><span class="line">            <span class="keyword">end</span>;</span><br><span class="line">            ans:=qw(ans)+qw(cnt)*trunc((sqr(x <span class="keyword">mod</span> z0)+x+<span class="number">804</span>)/<span class="number">233</span>);</span><br><span class="line">            x:=x+<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">until</span> x=r+<span class="number">1</span>;</span><br><span class="line">        writeln(ans);</span><br><span class="line">        dec(T);</span><br><span class="line">    <span class="keyword">until</span> T=<span class="number">0</span>;</span><br><span class="line">    <span class="comment">//close(input);close(output);</span></span><br><span class="line"><span class="keyword">end</span>.</span><br></pre></td></tr></table></figure><br><br></div></div>

<h1 id="T3-现实"><a href="#T3-现实" class="headerlink" title="T3 现实"></a>T3 现实</h1><p>大意：给定n个节点、m条边的有向图，求所有图中满足如下条件的点v：删去点v后，图变成dag<br>$n\leq5\times 10^5;m\leq10^6$</p>
<h2 id="水解"><a href="#水解" class="headerlink" title="水解"></a>水解</h2><p>转换一下思路，就是求图中所有简单环的交集。<br>这个可以tarjan找出强连通分量，然后暴力dfs遍历所有环<br>当然是会TLE的</p>
<div><br><div class="copy"><br>    <a href="/2016/10/16/lydsy-noip-2016-test6/reality_che.pas" title="{plain text}">{plain text}</a><br></div><br><div><br><figure class="highlight delphi"><figcaption><span>reality.pas</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">uses</span> math;</span><br><span class="line"><span class="keyword">type</span> </span><br><span class="line">    int=longint;</span><br><span class="line">    edge=<span class="keyword">record</span> v,nxt:int <span class="keyword">end</span>;</span><br><span class="line"><span class="keyword">var</span></span><br><span class="line">    g:<span class="keyword">array</span>[<span class="number">0</span>..<span class="number">1000010</span>] <span class="keyword">of</span> edge;</span><br><span class="line">    head,s,dfn,low,scc,siz,f:<span class="keyword">array</span>[<span class="number">0</span>..<span class="number">500010</span>] <span class="keyword">of</span> int;</span><br><span class="line">    ins<span class="comment">&#123;,vis&#125;</span>:<span class="keyword">array</span>[<span class="number">0</span>..<span class="number">500010</span>] <span class="keyword">of</span> boolean;</span><br><span class="line">    sz,n,m,k,i,t,u,v,cc,tim,cnt,ans:int;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">procedure</span> <span class="title">add</span><span class="params">(u,v:int)</span>;</span></span><br><span class="line"><span class="keyword">begin</span></span><br><span class="line">    inc(sz);g[sz].v:=v;</span><br><span class="line">    g[sz].nxt:=head[u];head[u]:=sz;</span><br><span class="line"><span class="keyword">end</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">procedure</span> <span class="title">tarjan</span><span class="params">(u:int)</span>;</span></span><br><span class="line"><span class="keyword">var</span> i,v:int;</span><br><span class="line"><span class="keyword">begin</span></span><br><span class="line">    inc(tim);dfn[u]:=tim;low[u]:=tim;</span><br><span class="line">    inc(t);s[t]:=u;ins[u]:=true;</span><br><span class="line">    i:=head[u];</span><br><span class="line">    <span class="keyword">while</span> i&lt;&gt;<span class="number">0</span> <span class="keyword">do</span> <span class="keyword">begin</span></span><br><span class="line">        v:=g[i].v;</span><br><span class="line">        <span class="keyword">if</span> dfn[v]=<span class="number">0</span> <span class="keyword">then</span> <span class="keyword">begin</span></span><br><span class="line">            tarjan(v);low[u]:=min(low[v],low[u]);</span><br><span class="line">        <span class="keyword">end</span> <span class="keyword">else</span> <span class="keyword">if</span> ins[v] <span class="keyword">then</span></span><br><span class="line">            low[u]:=min(low[u],dfn[v]);        </span><br><span class="line">        i:=g[i].nxt;</span><br><span class="line">    <span class="keyword">end</span>;</span><br><span class="line">    <span class="keyword">if</span> dfn[u]=low[u] <span class="keyword">then</span> <span class="keyword">begin</span></span><br><span class="line">        inc(cc);siz[cc]:=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span> s[t+<span class="number">1</span>]&lt;&gt;u <span class="keyword">do</span> <span class="keyword">begin</span></span><br><span class="line">            scc[s[t]]:=cc;ins[s[t]]:=false;</span><br><span class="line">            inc(siz[cc]);dec(t);</span><br><span class="line">        <span class="keyword">end</span>;</span><br><span class="line">    <span class="keyword">end</span>;</span><br><span class="line"><span class="keyword">end</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">procedure</span> <span class="title">dfs</span><span class="params">(u:int)</span>;</span></span><br><span class="line"><span class="keyword">var</span> v,i,j:int;</span><br><span class="line"><span class="keyword">begin</span></span><br><span class="line">    inc(t);s[t]:=u;ins[u]:=true;</span><br><span class="line">    i:=head[u];</span><br><span class="line">    <span class="keyword">while</span> i&lt;&gt;<span class="number">0</span> <span class="keyword">do</span> <span class="keyword">begin</span></span><br><span class="line">        v:=g[i].v;</span><br><span class="line">        <span class="keyword">if</span> scc[v]=k <span class="keyword">then</span> <span class="keyword">begin</span></span><br><span class="line">            <span class="keyword">if</span> ins[v] <span class="keyword">then</span> <span class="keyword">begin</span></span><br><span class="line">                inc(cnt);j:=t;</span><br><span class="line">                <span class="keyword">while</span> s[j+<span class="number">1</span>]&lt;&gt;v <span class="keyword">do</span> </span><br><span class="line">                    <span class="keyword">begin</span> inc(f[s[j]]);dec(j) <span class="keyword">end</span>;</span><br><span class="line">            <span class="keyword">end</span> <span class="keyword">else</span> dfs(v);</span><br><span class="line">        <span class="keyword">end</span>;</span><br><span class="line">        i:=g[i].nxt;</span><br><span class="line">    <span class="keyword">end</span>;</span><br><span class="line">    ins[u]:=false;dec(t);</span><br><span class="line"><span class="keyword">end</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">begin</span></span><br><span class="line">    <span class="comment">//assign(input,'reality.in');reset(input);</span></span><br><span class="line">    <span class="comment">//assign(output,'reality.out');rewrite(output);</span></span><br><span class="line">    <span class="keyword">read</span>(n,m);</span><br><span class="line">    <span class="keyword">for</span> i:=<span class="number">1</span> <span class="keyword">to</span> m <span class="keyword">do</span> <span class="keyword">begin</span></span><br><span class="line">        <span class="keyword">read</span>(u,v);add(u,v);</span><br><span class="line">    <span class="keyword">end</span>;</span><br><span class="line">    t:=<span class="number">0</span>;tim:=<span class="number">0</span>;cc:=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> i:=<span class="number">1</span> <span class="keyword">to</span> n <span class="keyword">do</span></span><br><span class="line">        <span class="keyword">if</span> dfn[i]=<span class="number">0</span> <span class="keyword">then</span> tarjan(i);</span><br><span class="line">    k:=-<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span> i:=<span class="number">1</span> <span class="keyword">to</span> cc <span class="keyword">do</span></span><br><span class="line">        <span class="keyword">if</span> siz[i]&gt;<span class="number">1</span> <span class="keyword">then</span> <span class="keyword">begin</span> </span><br><span class="line">            <span class="keyword">if</span> k&lt;&gt;-<span class="number">1</span> <span class="keyword">then</span> <span class="keyword">begin</span> <span class="keyword">write</span>(<span class="number">0</span>);halt <span class="keyword">end</span>;</span><br><span class="line">            k:=i; </span><br><span class="line">        <span class="keyword">end</span>;</span><br><span class="line">    <span class="keyword">if</span> k=-<span class="number">1</span> <span class="keyword">then</span> <span class="keyword">begin</span> </span><br><span class="line">        writeln(n);<span class="keyword">for</span> i:=<span class="number">1</span> <span class="keyword">to</span> n <span class="keyword">do</span> <span class="keyword">write</span>(i,<span class="string">' '</span>);halt;</span><br><span class="line">    <span class="keyword">end</span>;</span><br><span class="line">    <span class="keyword">for</span> i:=<span class="number">1</span> <span class="keyword">to</span> n <span class="keyword">do</span></span><br><span class="line">        <span class="keyword">if</span> scc[i]=k <span class="keyword">then</span> <span class="keyword">begin</span> u:=i;<span class="keyword">break</span> <span class="keyword">end</span>;</span><br><span class="line">    fillchar(s,sizeof(s),<span class="number">0</span>);</span><br><span class="line">    ans:=<span class="number">0</span>;cnt:=<span class="number">0</span>;dfs(u);</span><br><span class="line">    <span class="keyword">for</span> i:=<span class="number">1</span> <span class="keyword">to</span> n <span class="keyword">do</span></span><br><span class="line">        <span class="keyword">if</span> f[i]=cnt <span class="keyword">then</span> <span class="keyword">begin</span> inc(ans);inc(t);s[t]:=i <span class="keyword">end</span>;</span><br><span class="line">    writeln(ans);</span><br><span class="line">    <span class="keyword">for</span> i:=<span class="number">1</span> <span class="keyword">to</span> t <span class="keyword">do</span> <span class="keyword">write</span>(s[i],<span class="string">' '</span>);</span><br><span class="line">    close(input);close(output);</span><br><span class="line"><span class="keyword">end</span>.</span><br></pre></td></tr></table></figure><br><br></div></div>

<h2 id="正解"><a href="#正解" class="headerlink" title="正解"></a>正解</h2><p>dfs找一个环+拓扑排序+dag上dp<br>同水解一样，考虑求环交的点集<br>直接求点集有如下缺陷</p>
<ol>
<li>删掉一个环后，剩下的不一定是dag</li>
<li>无法处理自环</li>
</ol>
<p>于是拆点，把点拆成入点和出点，入点向出点连边，这样点集变成了边集。<br>然后dfs找到一个环，如果找不到说明原来就是dag，特判输出<br>然后把这个环删掉，拓扑排序；如果还有环，说明无解，特判输出<br>破环成链，然后顺次给环上的点编号loc[u]<br>然后dp，考虑两种路径<br><img src="/2016/10/16/lydsy-noip-2016-test6/g.png" alt="g.png" title=""></p>
<ol>
<li>第一种<ol>
<li>求点u，顺着非环边能走到的环上点的最小编号f1[u]</li>
<li>求点u，逆着非环边能走到的环上点的最大编号f2[u]</li>
<li>考虑环上的点u，如果f1[u]&lt;loc[u]则loc[u]&lt;loc[v]的点v都不在环交中；如果loc[u]&lt;f2[u]，则loc[v]&lt;loc[u]的点v都不在环交中</li>
</ol>
</li>
<li>第二种<ol>
<li>求点u，顺着非环边能走到的环上的点的最大编号f3[u]</li>
<li>考虑环上的点u，如果loc[u]&lt;f3[u]，那么编号在(loc[u],f3[u])的点都不在环交中</li>
</ol>
</li>
</ol>
<p>区间修改可以用差分序列<br>一些细节：</p>
<ol>
<li>找环时记录路径上点的入边edg[u]和dfs树上的父节点pre[u]，找到环后回头标记</li>
<li>第一写非递归的拓扑排序（以前都是用dfs的）</li>
<li>在环上，出点u+n与原来的点u是一一对应的（因为记录的是入边）</li>
<li>第一种的两种子情况看似是等价的，但如果只求一种情况是有漏洞的，比如：<img src="/2016/10/16/lydsy-noip-2016-test6/sp.png" alt="sp.png" title="">
图中有两条非环边e1和e2，如果指对a4求f1的话，得到的答案是a2,a3,a4；但实际上a2不在环交中</li>
</ol>
<div><br><div class="copy"><br>    <a href="/2016/10/16/lydsy-noip-2016-test6/reality.pas" title="{plain text}">{plain text}</a><br></div><br><div><br><figure class="highlight delphi"><figcaption><span>reality.pas</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">uses</span> math;</span><br><span class="line"><span class="keyword">const</span> inf=<span class="number">1000000000</span>;</span><br><span class="line"><span class="keyword">type</span> </span><br><span class="line">    int=longint;</span><br><span class="line">    edge=<span class="keyword">record</span> u,v,nxt:int;f:boolean <span class="keyword">end</span>;</span><br><span class="line">    arr=<span class="keyword">array</span>[<span class="number">0</span>..<span class="number">1000010</span>] <span class="keyword">of</span> int;</span><br><span class="line"><span class="keyword">var</span></span><br><span class="line">    g:<span class="keyword">array</span>[<span class="number">0</span>..<span class="number">1500010</span>] <span class="keyword">of</span> edge;</span><br><span class="line">    head,top,pre,edg,flg,loc,cyc,f1,f2,f3,a,ans:arr;</span><br><span class="line">    sz,n,m,i,j,k,u,v,cnt:int;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">procedure</span> <span class="title">add</span><span class="params">(u,v:int)</span>;</span></span><br><span class="line"><span class="keyword">begin</span></span><br><span class="line">    inc(sz);g[sz].u:=u;g[sz].v:=v;g[sz].f:=true;</span><br><span class="line">    g[sz].nxt:=head[u];head[u]:=sz;</span><br><span class="line"><span class="keyword">end</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">dfs</span><span class="params">(u:int)</span>:</span>boolean;</span><br><span class="line"><span class="keyword">var</span> i,v,w:int;</span><br><span class="line"><span class="keyword">begin</span></span><br><span class="line">    flg[u]:=<span class="number">1</span>;i:=head[u];</span><br><span class="line">    <span class="keyword">while</span> i&lt;&gt;<span class="number">0</span> <span class="keyword">do</span> <span class="keyword">begin</span></span><br><span class="line">        v:=g[i].v;</span><br><span class="line">        <span class="keyword">if</span> flg[v]=<span class="number">1</span> <span class="keyword">then</span> <span class="keyword">begin</span></span><br><span class="line">            w:=u;k:=<span class="number">0</span>;</span><br><span class="line">            <span class="keyword">while</span> w&lt;&gt;v <span class="keyword">do</span> <span class="keyword">begin</span></span><br><span class="line">                inc(k);cyc[k]:=w;loc[w]:=k;</span><br><span class="line">                g[edg[w]].f:=false;</span><br><span class="line">                w:=pre[w];</span><br><span class="line">            <span class="keyword">end</span>;</span><br><span class="line">            inc(k);cyc[k]:=v;loc[v]:=k;</span><br><span class="line">            edg[v]:=i;g[i].f:=false;</span><br><span class="line">            <span class="keyword">exit</span>(true);</span><br><span class="line">        <span class="keyword">end</span>;</span><br><span class="line">        <span class="keyword">if</span> flg[v]=<span class="number">0</span> <span class="keyword">then</span> <span class="keyword">begin</span></span><br><span class="line">            pre[v]:=u;edg[v]:=i;</span><br><span class="line">            <span class="keyword">if</span> dfs(v) <span class="keyword">then</span> <span class="keyword">exit</span>(true);</span><br><span class="line">        <span class="keyword">end</span>;</span><br><span class="line">        i:=g[i].nxt;</span><br><span class="line">    <span class="keyword">end</span>;</span><br><span class="line">    flg[u]:=<span class="number">2</span>;dfs:=false;</span><br><span class="line"><span class="keyword">end</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">sort</span><span class="params">()</span>:</span>boolean;</span><br><span class="line"><span class="keyword">var</span> i,u,v,h,t:int;deg:arr;</span><br><span class="line"><span class="keyword">begin</span></span><br><span class="line">    fillchar(deg,sizeof(deg),<span class="number">0</span>);t:=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> i:=<span class="number">1</span> <span class="keyword">to</span> sz <span class="keyword">do</span></span><br><span class="line">        <span class="keyword">if</span> g[i].f <span class="keyword">then</span> inc(deg[g[i].v]);</span><br><span class="line">    <span class="keyword">for</span> i:=<span class="number">1</span> <span class="keyword">to</span> n*<span class="number">2</span> <span class="keyword">do</span></span><br><span class="line">        <span class="keyword">if</span> deg[i]=<span class="number">0</span> <span class="keyword">then</span></span><br><span class="line">            <span class="keyword">begin</span> inc(t);top[t]:=i <span class="keyword">end</span>;</span><br><span class="line">    h:=<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">while</span> h&lt;=t <span class="keyword">do</span> <span class="keyword">begin</span></span><br><span class="line">        u:=top[h];inc(h);i:=head[u];</span><br><span class="line">        <span class="keyword">while</span> i&lt;&gt;<span class="number">0</span> <span class="keyword">do</span> <span class="keyword">begin</span></span><br><span class="line">            <span class="keyword">if</span> g[i].f <span class="keyword">then</span> <span class="keyword">begin</span></span><br><span class="line">                v:=g[i].v;dec(deg[v]);</span><br><span class="line">                <span class="keyword">if</span> deg[v]=<span class="number">0</span> <span class="keyword">then</span> <span class="keyword">begin</span> inc(t);top[t]:=v <span class="keyword">end</span>;</span><br><span class="line">            <span class="keyword">end</span>;</span><br><span class="line">            i:=g[i].nxt;</span><br><span class="line">        <span class="keyword">end</span>;</span><br><span class="line">    <span class="keyword">end</span>;</span><br><span class="line">    sort:=t=n*<span class="number">2</span>;</span><br><span class="line"><span class="keyword">end</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">begin</span></span><br><span class="line">    assign(input,<span class="string">'ex_reality5.in'</span>);reset(input);</span><br><span class="line">    assign(output,<span class="string">'reality.out'</span>);rewrite(output);</span><br><span class="line">    <span class="keyword">read</span>(n,m);</span><br><span class="line">    <span class="keyword">for</span> i:=<span class="number">1</span> <span class="keyword">to</span> n <span class="keyword">do</span> add(i,i+n);</span><br><span class="line">    <span class="keyword">for</span> i:=<span class="number">1</span> <span class="keyword">to</span> m <span class="keyword">do</span> <span class="keyword">begin</span> </span><br><span class="line">        <span class="keyword">read</span>(u,v);add(u+n,v);</span><br><span class="line">    <span class="keyword">end</span>;</span><br><span class="line">    <span class="keyword">for</span> i:=<span class="number">1</span> <span class="keyword">to</span> n*<span class="number">2</span> <span class="keyword">do</span></span><br><span class="line">        <span class="keyword">if</span> (flg[i]=<span class="number">0</span>) <span class="keyword">and</span> dfs(i) <span class="keyword">then</span> <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">if</span> k=<span class="number">0</span> <span class="keyword">then</span> <span class="keyword">begin</span></span><br><span class="line">        writeln(n);</span><br><span class="line">        <span class="keyword">for</span> i:=<span class="number">1</span> <span class="keyword">to</span> n <span class="keyword">do</span> <span class="keyword">write</span>(i,<span class="string">' '</span>);halt;</span><br><span class="line">    <span class="keyword">end</span>;</span><br><span class="line">    <span class="keyword">if</span> <span class="keyword">not</span> sort() <span class="keyword">then</span> <span class="keyword">begin</span> <span class="keyword">write</span>(<span class="number">0</span>);halt <span class="keyword">end</span>;</span><br><span class="line">    filldword(f1,sizeof(f1) <span class="keyword">div</span> <span class="number">4</span>,inf);</span><br><span class="line">    filldword(f3,sizeof(f3) <span class="keyword">div</span> <span class="number">4</span>,inf);</span><br><span class="line">    <span class="keyword">for</span> i:=<span class="number">1</span> <span class="keyword">to</span> n*<span class="number">2</span> <span class="keyword">do</span></span><br><span class="line">        <span class="keyword">if</span> loc[i]&gt;<span class="number">0</span> <span class="keyword">then</span></span><br><span class="line">             <span class="keyword">begin</span> f1[i]:=loc[i];f2[i]:=loc[i];f3[i]:=loc[i] <span class="keyword">end</span>;</span><br><span class="line">    <span class="keyword">for</span> j:=n*<span class="number">2</span> <span class="keyword">downto</span> <span class="number">1</span> <span class="keyword">do</span> <span class="keyword">begin</span></span><br><span class="line">        u:=top[j];i:=head[u];</span><br><span class="line">        <span class="keyword">while</span> i&lt;&gt;<span class="number">0</span> <span class="keyword">do</span> <span class="keyword">begin</span></span><br><span class="line">            v:=g[i].v;</span><br><span class="line">            <span class="keyword">if</span> g[i].f <span class="keyword">then</span> <span class="keyword">begin</span></span><br><span class="line">                f1[u]:=min(f1[u],f1[v]);</span><br><span class="line">                f2[u]:=max(f2[u],f2[v]);</span><br><span class="line">            <span class="keyword">end</span>;</span><br><span class="line">            i:=g[i].nxt;</span><br><span class="line">        <span class="keyword">end</span>;</span><br><span class="line">    <span class="keyword">end</span>;</span><br><span class="line">    <span class="keyword">for</span> j:=<span class="number">1</span> <span class="keyword">to</span> n*<span class="number">2</span> <span class="keyword">do</span> <span class="keyword">begin</span></span><br><span class="line">        u:=top[j];i:=head[u];</span><br><span class="line">        <span class="keyword">while</span> i&lt;&gt;<span class="number">0</span> <span class="keyword">do</span> <span class="keyword">begin</span></span><br><span class="line">            v:=g[i].v;</span><br><span class="line">            <span class="keyword">if</span> g[i].f <span class="keyword">then</span> f3[v]:=min(f3[u],f3[v]);</span><br><span class="line">            i:=g[i].nxt;</span><br><span class="line">        <span class="keyword">end</span>;</span><br><span class="line">    <span class="keyword">end</span>;</span><br><span class="line">    <span class="keyword">for</span> i:=<span class="number">1</span> <span class="keyword">to</span> k <span class="keyword">do</span> <span class="keyword">begin</span></span><br><span class="line">        u:=cyc[i];</span><br><span class="line">        <span class="keyword">if</span> f1[u]&lt;i <span class="keyword">then</span> <span class="keyword">begin</span> inc(a[f1[u]]);dec(a[i]) <span class="keyword">end</span>;</span><br><span class="line">        <span class="keyword">if</span> f2[u]&gt;i <span class="keyword">then</span> <span class="keyword">begin</span> inc(a[<span class="number">1</span>]);dec(a[i]) <span class="keyword">end</span>;</span><br><span class="line">        <span class="keyword">if</span> f3[u]&lt;i <span class="keyword">then</span> inc(a[i]);</span><br><span class="line">    <span class="keyword">end</span>;</span><br><span class="line">    <span class="keyword">for</span> i:=<span class="number">2</span> <span class="keyword">to</span> k <span class="keyword">do</span> inc(a[i],a[i-<span class="number">1</span>]);</span><br><span class="line">    <span class="keyword">for</span> i:=<span class="number">1</span> <span class="keyword">to</span> k <span class="keyword">do</span></span><br><span class="line">        <span class="keyword">if</span> (a[i]=<span class="number">0</span>)<span class="keyword">and</span>(cyc[i]&gt;n) <span class="keyword">then</span> flg[cyc[i]-n]:=-<span class="number">1</span>;</span><br><span class="line">    cnt:=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> i:=<span class="number">1</span> <span class="keyword">to</span> n <span class="keyword">do</span></span><br><span class="line">        <span class="keyword">if</span> flg[i]=-<span class="number">1</span> <span class="keyword">then</span> <span class="keyword">begin</span> inc(cnt);ans[cnt]:=i <span class="keyword">end</span>;</span><br><span class="line">    writeln(cnt);</span><br><span class="line">    <span class="keyword">for</span> i:=<span class="number">1</span> <span class="keyword">to</span> cnt <span class="keyword">do</span> <span class="keyword">write</span>(ans[i],<span class="string">' '</span>);</span><br><span class="line"><span class="keyword">end</span>.</span><br></pre></td></tr></table></figure><br><br></div></div>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;又一场NOIplus模拟赛。&lt;br&gt;第一题同样是暴力，pascal被卡常&lt;br&gt;第三题yy了scc+dfs，忘记判无解的情况，又是捆绑测试，然后爆0&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;订正进度(2/3)&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h1 id=&quot;P1-幻想&quot;&gt;&lt;a href=&quot;#P1-幻想&quot; class=&quot;headerlink&quot; title=&quot;P1 幻想&quot;&gt;&lt;/a&gt;P1 幻想&lt;/h1&gt;&lt;p&gt;大意：（其实是描述的片段）&lt;br&gt;给定一个不小于 2 的整数 k ,按照如下方式生成一个无限长的序列S (下标从 0 开始)。&lt;br&gt;1.初始时序列只有一个元素 S(0) = 0 。&lt;br&gt;2.对于j=1,2,…,k-1分别把当前序列的每个元素都加上j,得到新的k-1个序列。&lt;br&gt;3.把新的k-1个序列依次接在当前序列后面,得到一个长度为当前序列长度 k 倍的序列。&lt;br&gt;4.把这个序列每一项都变成其除以 k 之后的余数,并把这个序列作为新的当前序列。&lt;br&gt;5.执行无穷次操作 2-4。&lt;br&gt;给定l,r，求$\sum_{i=L}^{R}h(i)\times S_i$&lt;br&gt;其中$h(i)=\lfloor\dfrac{(i\% 20000116)^2+i+804}{233}\rfloor$&lt;br&gt;答案对$2^{32}$取模&lt;br&gt;$T≤100 ; 2≤k≤1000 ; 0≤L≤R≤10^16;\sum(R-L)≤10^8$&lt;br&gt;时限2s&lt;/p&gt;
    
    </summary>
    
      <category term="Problem Set" scheme="https://cothrax.github.io/categories/Problem-Set/"/>
    
    
      <category term="OI" scheme="https://cothrax.github.io/tags/OI/"/>
    
      <category term="DP" scheme="https://cothrax.github.io/tags/DP/"/>
    
      <category term="图论" scheme="https://cothrax.github.io/tags/%E5%9B%BE%E8%AE%BA/"/>
    
      <category term="强连通分量" scheme="https://cothrax.github.io/tags/%E5%BC%BA%E8%BF%9E%E9%80%9A%E5%88%86%E9%87%8F/"/>
    
      <category term="DFS" scheme="https://cothrax.github.io/tags/DFS/"/>
    
      <category term="数学" scheme="https://cothrax.github.io/tags/%E6%95%B0%E5%AD%A6/"/>
    
      <category term="拓扑排序" scheme="https://cothrax.github.io/tags/%E6%8B%93%E6%89%91%E6%8E%92%E5%BA%8F/"/>
    
      <category term="拆点" scheme="https://cothrax.github.io/tags/%E6%8B%86%E7%82%B9/"/>
    
  </entry>
  
</feed>
