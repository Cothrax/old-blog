<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Cothrax&#39;s Blog</title>
  <subtitle>I don&#39;t wanna let you down.</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="https://cothrax.github.io/"/>
  <updated>2016-12-31T11:39:28.756Z</updated>
  <id>https://cothrax.github.io/</id>
  
  <author>
    <name>Cothrax</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>「笔记」梯度下降 &amp; 线性回归</title>
    <link href="https://cothrax.github.io/2016/12/30/MLearn-linear-regression/"/>
    <id>https://cothrax.github.io/2016/12/30/MLearn-linear-regression/</id>
    <published>2016-12-30T13:35:56.000Z</published>
    <updated>2016-12-31T11:39:28.756Z</updated>
    
    <content type="html"><![CDATA[<p><a href="https://www.coursera.org/learn/machine-learning" target="_blank" rel="external">Machine Learning</a>-Week1笔记，第一个简单的ML算法。<br>梯度下降是通过逼近的思想求一个多元函数的极值，可用于最小化线性回归中的二元代价函数。<br><a id="more"></a></p>
<h2 id="前置技能"><a href="#前置技能" class="headerlink" title="前置技能"></a>前置技能</h2><h3 id="机器学习"><a href="#机器学习" class="headerlink" title="机器学习"></a>机器学习</h3><ol>
<li>监督学习（Supervised Learning）：给定一组样本数据，以及其对应的正确输出，预测输入与输出之间的关系。<ol>
<li>回归（Regression）：以连续函数预测输出值</li>
<li>分类（Classification）：以离散值预测输出值</li>
</ol>
</li>
<li>无监督学习（Unsuperivised Learning）：给定一组样本数据，在没有对应输出的情况下，将数据分类。</li>
</ol>
<h3 id="线性回归"><a href="#线性回归" class="headerlink" title="线性回归"></a>线性回归</h3><ol>
<li>样本数据（Training Set）：$m$个离散的点$(x_i,y_i)$</li>
<li>假设（Hypothesis）：$h_{\theta}(x)=\theta_0+\theta_1x$</li>
<li>代价函数（Cost Function）：$J(\theta_0,\theta_1)=\dfrac{1}{2m}\sum_{i=1}^{m}(h_{\theta}(x_i)-y_i)^2$</li>
<li>线性回归（Linear Regression）：即最小化$J(\theta_0,\theta_1)$，即根据样本数据近似地预测输入与输出间的线性关系。</li>
</ol>
<h3 id="偏导数"><a href="#偏导数" class="headerlink" title="偏导数"></a>偏导数</h3><ol>
<li>对一个二元函数$f(\theta_0,\theta_1)$，把其他变量看做常数，对其中一个变量求导，记做$\dfrac{\partial\ f(\theta_0,\theta_1)}{\partial\ \theta_j}$</li>
<li>对于线性回归中的代价函数而言：<ul>
<li>$\dfrac{\partial\ J(\theta_0,\theta_1)}{\partial\ \theta_0}=\dfrac{1}{m}\sum_{i=1}^m(h_{\theta}(x_i)-y_i)$</li>
<li>$\dfrac{\partial\ J(\theta_0,\theta_1)}{\partial\ \theta_1}=\dfrac{1}{m}\sum_{i=1}^m(h_{\theta}(x_i)-y_i)\cdot x_i$</li>
</ul>
</li>
</ol>
<p>这也就是为什么$J(\theta_0,\theta_1)$前面的系数有一个$\dfrac{1}{2}$，对二次项求导时，系数消掉了。</p>
<h2 id="正文"><a href="#正文" class="headerlink" title="正文"></a>正文</h2><h3 id="算法思想"><a href="#算法思想" class="headerlink" title="算法思想"></a>算法思想</h3><p>梯度下降法（Gradient Descent Algorithm），通过偏导数作为增量迭代更新当前值，逼近极值点。</p>
<ol>
<li>初始时为$\theta_0=0,\theta_1=0$</li>
<li>通过增量不断更新当前位置，直到找到极小值点，其中$\alpha$为学习速率（Learning Rate），通俗的理解为步长<br>$$\theta_j=\theta_j-\alpha\cdot \dfrac{\partial\ J(\theta_0,\theta_1)}{\partial\ \theta_j}$$</li>
<li>直到当前$\dfrac{\partial\ J(\theta_0,\theta_1)}{\partial\ \theta_j}=0$达到极值点，而由于$J(\theta_0,\theta_1)$是一个凸函数，这意味着它有唯一一个极小值点，这个点也是全局的最小值点。</li>
</ol>
<p>由于每次迭代时都用到了所有样本数据，这种算法被称为批量（Batch）梯度下降法。</p>
<h3 id="算法实现"><a href="#算法实现" class="headerlink" title="算法实现"></a>算法实现</h3><p>我们可以将推一推偏导数的公式，得到：</p>
<ul>
<li>$\dfrac{\partial\ J(\theta_0,\theta_1)}{\partial\ \theta_0}=\dfrac{1}{m}(m\theta_0+\theta_1\sum x_i-\sum y_i)$</li>
<li>$\dfrac{\partial\ J(\theta_0,\theta_1)}{\partial\ \theta_1}=\dfrac{1}{m}(\theta_0\sum x_i+\theta_1\sum x_i^2-\sum y_ix_i)$</li>
</ul>
<p>这样，先算出x的和smX，y的和smY，x平方和smSqX，xy乘积和smXY，就可以在$O(1)$内求出偏导。</p>
<figure class="highlight c++"><figcaption><span>linear.cpp</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cmath&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N=<span class="number">1010</span>;<span class="keyword">const</span> <span class="keyword">double</span> EPS=<span class="number">1E-4</span>;</span><br><span class="line"><span class="keyword">int</span> m;<span class="keyword">double</span> x[N],y[N],smX,smY,smSqX,smXY;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">double</span> <span class="title">g0</span><span class="params">(<span class="keyword">double</span> t0,<span class="keyword">double</span> t1)</span></span>&#123; <span class="comment">//theta0 derivative</span></span><br><span class="line">    <span class="keyword">return</span> (t1*smX+t0*m-smY)/m;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">double</span> <span class="title">g1</span><span class="params">(<span class="keyword">double</span> t0,<span class="keyword">double</span> t1)</span></span>&#123; <span class="comment">//theta1 derivative</span></span><br><span class="line">    <span class="keyword">return</span> (t1*smSqX+t0*smX-smXY)/m;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">double</span> <span class="title">j</span><span class="params">(<span class="keyword">double</span> t0,<span class="keyword">double</span> t1)</span></span>&#123; <span class="comment">//cost function</span></span><br><span class="line">    <span class="keyword">double</span> ret=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;m;i++)ret+=<span class="built_in">pow</span>(t0+t1*x[i]-y[i],<span class="number">2</span>);</span><br><span class="line">    <span class="keyword">return</span> ret/(<span class="number">2</span>*m);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">grad</span><span class="params">(<span class="keyword">double</span> a)</span></span>&#123; <span class="comment">//gradient descent</span></span><br><span class="line">    <span class="keyword">double</span> t0=<span class="number">0</span>,t1=<span class="number">0</span>,d0=g0(t0,t1),d1=(t0,t1);</span><br><span class="line">    <span class="keyword">while</span>(<span class="built_in">abs</span>(d0)&gt;EPS||<span class="built_in">abs</span>(d1)&gt;EPS)&#123;</span><br><span class="line">        t0-=a*d0;t1-=a*d1;</span><br><span class="line">        d0=g0(t0,t1);d1=g1(t0,t1);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"h(x)=%0.3lf+(%0.3lf)x\nmin=%0.3lf"</span>,t0,t1,j(t0,t1));</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    freopen(<span class="string">"in"</span>,<span class="string">"r"</span>,<span class="built_in">stdin</span>);</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">"%d\n"</span>,&amp;m);</span><br><span class="line">    smX=smY=smSqX=smXY=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;m;i++)&#123;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">"%lf %lf\n"</span>,&amp;x[i],&amp;y[i]);</span><br><span class="line">        smX+=x[i];smY+=y[i];</span><br><span class="line">        smSqX+=<span class="built_in">pow</span>(x[i],<span class="number">2</span>);smXY+=x[i]*y[i];</span><br><span class="line">    &#125;</span><br><span class="line">    grad(<span class="number">1E-4</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这个算法的本质是近似算法，这意味着其复杂度与精度有很大关联：</p>
<ol>
<li>$\alpha$的取值与$\theta_1$的大小有关，且不影响精度，但过大可能无法逼近极值点，过小影响效率。</li>
<li>$\epsilon$的大小决定精度，并且制约算法效率，我在输出时保留3位小数，这样的话$\epsilon=10^{-4}$就足够了。</li>
</ol>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;a href=&quot;https://www.coursera.org/learn/machine-learning&quot;&gt;Machine Learning&lt;/a&gt;-Week1笔记，第一个简单的ML算法。&lt;br&gt;梯度下降是通过逼近的思想求一个多元函数的极值，可用于最小化线性回归中的二元代价函数。&lt;br&gt;
    
    </summary>
    
      <category term="AI/ML" scheme="https://cothrax.github.io/categories/AI-ML/"/>
    
    
      <category term="机器学习" scheme="https://cothrax.github.io/tags/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0/"/>
    
      <category term="线性回归" scheme="https://cothrax.github.io/tags/%E7%BA%BF%E6%80%A7%E5%9B%9E%E5%BD%92/"/>
    
      <category term="梯度下降" scheme="https://cothrax.github.io/tags/%E6%A2%AF%E5%BA%A6%E4%B8%8B%E9%99%8D/"/>
    
      <category term="偏导数" scheme="https://cothrax.github.io/tags/%E5%81%8F%E5%AF%BC%E6%95%B0/"/>
    
  </entry>
  
  <entry>
    <title>The End &amp; A New Beginning</title>
    <link href="https://cothrax.github.io/2016/12/24/the-end/"/>
    <id>https://cothrax.github.io/2016/12/24/the-end/</id>
    <published>2016-12-24T03:04:22.000Z</published>
    <updated>2016-12-31T11:36:56.118Z</updated>
    
    <content type="html"><![CDATA[<style>
    rt{
        font-size:60%;
    }
</style>

<p>这次真的结束了，NOIP2016<ruby>跪烂<rp> (</rp><rt>bèi cào</rt><rp>) </rp></ruby>，310分不忍直视，在JS勉强混个一等。<br><strong>不到一年的OI时光</strong>，从第一个hello world、第一场contest、第一篇blog，直至第一场NOIP，然后就结束了。<br>毕竟已经高二了，大概APIO、CTSC、NOI都是遥不可及的梦想吧。</p>
<blockquote>
<p>还没长大就老了。</p>
</blockquote>
<a id="more"></a>
<h2 id="OI小结"><a href="#OI小结" class="headerlink" title="OI小结"></a>OI小结</h2><p>至少在剩下的高中时光中不会再搞算法竞赛了，至于以后，或许会成为ACM酱油。<br>列了一下黄学长的<a href="/2016/12/24/the-end/省选算法.xlsx" title="算法表">算法表</a>，发现还有好多不会啊。。。</p>
<img src="/2016/12/24/the-end/1.png" alt="省选算法1" title="省选算法1">
<img src="/2016/12/24/the-end/2.png" alt="省选算法2" title="省选算法2">
<h2 id="胡策"><a href="#胡策" class="headerlink" title="胡策"></a>胡策</h2><p>所以说，要滚回去读文化课了，扔掉OI后就会有大量的<ruby>空余<rp> (</rp><rt>kāi chē</rt><rp>) </rp></ruby>时间，大概会玩一些<ruby>有趣<rp> (</rp><rt>chě dàn</rt><rp>) </rp></ruby>的东西，比如搞搞AI，弄弄Linux什么的。<br>打算旁听Coursera的<a href="https://www.coursera.org/learn/machine-learning" target="_blank" rel="external">Machine Learning</a>，对$\alpha$-Dog的有点兴趣，虽然线代什么的一窍不通。<br>最后，祝各位集训队爷、Au爷、国家队爷圣诞快乐。<br>我知道你会看的。</p>
]]></content>
    
    <summary type="html">
    
      &lt;style&gt;
    rt{
        font-size:60%;
    }
&lt;/style&gt;

&lt;p&gt;这次真的结束了，NOIP2016&lt;ruby&gt;跪烂&lt;rp&gt; (&lt;/rp&gt;&lt;rt&gt;bèi cào&lt;/rt&gt;&lt;rp&gt;) &lt;/rp&gt;&lt;/ruby&gt;，310分不忍直视，在JS勉强混个一等。&lt;br&gt;&lt;strong&gt;不到一年的OI时光&lt;/strong&gt;，从第一个hello world、第一场contest、第一篇blog，直至第一场NOIP，然后就结束了。&lt;br&gt;毕竟已经高二了，大概APIO、CTSC、NOI都是遥不可及的梦想吧。&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;还没长大就老了。&lt;/p&gt;
&lt;/blockquote&gt;
    
    </summary>
    
      <category term="OI/ACM" scheme="https://cothrax.github.io/categories/OI-ACM/"/>
    
    
  </entry>
  
  <entry>
    <title>bzoj-2400 Spoj 839 Optimal Marks</title>
    <link href="https://cothrax.github.io/2016/12/23/bzoj-2400/"/>
    <id>https://cothrax.github.io/2016/12/23/bzoj-2400/</id>
    <published>2016-12-23T13:21:16.000Z</published>
    <updated>2016-12-31T13:56:59.080Z</updated>
    
    <content type="html"><![CDATA[<p>定义无向图中的一条边的值为：这条边连接的两个点的值的异或值。<br>定义一个无向图的值为：这个无向图所有边的值的和。<br>给你一个有n个结点m条边的无向图。其中的一些点的值是给定的，而其余的点的值由你决定（但要求均为非负数），使得这个无向图的值最小。在无向图的值最小的前提下，使得无向图中所有点的值的和最小。<br>n&lt;=500，m&lt;=2000<br><a id="more"></a></p>
<h2 id="链接"><a href="#链接" class="headerlink" title="链接"></a>链接</h2><p><a href="http://www.lydsy.com/JudgeOnline/problem.php?id=2400" target="_blank" rel="external">bzoj-2400</a><br><a href="/2016/12/23/bzoj-2400/graph.cpp" title="graph.cpp">graph.cpp</a></p>
<h2 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h2><p>首先看到xor，显然要按位处理，这样每个点的值就变成了0或者1<br>设源汇s和t</p>
<ol>
<li>点v与s连通表示v的值为0</li>
<li>点v与t连通表示v的值为1</li>
</ol>
<p>xor意味着，只有当两边值不同时才会对答案产生贡献，也就是s集和t集的交界，要最小化答案，这符合最小割的定义<br>那么建图：</p>
<ol>
<li>对于确定的点v，如果v=0与s连边，v=1则与t连边</li>
<li>原图中的其他边直接加进去即可</li>
</ol>
<p>然后跑一次最大流就是第一问的答案<br>再考虑最小化点权和，当出现$u(\in s)\to x\to v(\in t)$时，最大流方案不唯一，此时把x放进s集是更优的，即割边$x\to v$更优，那么只要从t反向dfs，能dfs到的点即值为1的点，割$x\to v$会阻止dfs访问x节点</p>
<p>还有一种思路很神：<a href="http://blog.csdn.net/u012288458/article/details/50720724" target="_blank" rel="external">oxer</a></p>
<h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><figure class="highlight c++"><figcaption><span>graph.cpp</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cmath&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> ll long long</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N=<span class="number">510</span>,M=<span class="number">2010</span>,INF=<span class="number">1E8</span>;</span><br><span class="line"><span class="keyword">struct</span> edge&#123;<span class="keyword">int</span> v,cap,nxt;&#125;g[M*<span class="number">100</span>];</span><br><span class="line"><span class="keyword">int</span> head[N],sz=<span class="number">1</span>;</span><br><span class="line"><span class="keyword">void</span> _add(<span class="keyword">int</span> u,<span class="keyword">int</span> v,<span class="keyword">int</span> cap)&#123;</span><br><span class="line">    g[++sz].v=v;g[sz].cap=cap;</span><br><span class="line">    g[sz].nxt=head[u];head[u]=sz;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">add</span><span class="params">(<span class="keyword">int</span> u,<span class="keyword">int</span> v,<span class="keyword">int</span> cap)</span></span><br><span class="line"></span>&#123;_add(u,v,cap);_add(v,u,<span class="number">0</span>);&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> q[N],d[N];</span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">bfs</span><span class="params">(<span class="keyword">int</span> s,<span class="keyword">int</span> dest)</span></span>&#123;</span><br><span class="line">    fill(d,d+N,INF);</span><br><span class="line">    d[s]=<span class="number">0</span>;q[<span class="number">0</span>]=s;<span class="keyword">int</span> u,v;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> h=<span class="number">0</span>,t=<span class="number">1</span>;h!=t;h=(h+<span class="number">1</span>)%N)</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=head[u=q[h]];i;i=g[i].nxt)</span><br><span class="line">            <span class="keyword">if</span>(g[i].cap&amp;&amp;d[v=g[i].v]==INF)</span><br><span class="line">                d[v]=d[u]+<span class="number">1</span>,q[t++]=v,t%=N;</span><br><span class="line">    <span class="keyword">return</span> d[dest]!=INF;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">dfs</span><span class="params">(<span class="keyword">int</span> u,<span class="keyword">int</span> t,<span class="keyword">int</span> f)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(u==t)<span class="keyword">return</span> f;</span><br><span class="line">    <span class="keyword">int</span> ret=<span class="number">0</span>,v;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=head[u];i;i=g[i].nxt)</span><br><span class="line">        <span class="keyword">if</span>(d[v=g[i].v]==d[u]+<span class="number">1</span>)&#123;</span><br><span class="line">            <span class="keyword">int</span> lim=dfs(v,t,min(f-ret,g[i].cap));</span><br><span class="line">            g[i].cap-=lim;g[i^<span class="number">1</span>].cap+=lim;ret+=lim;</span><br><span class="line">            <span class="keyword">if</span>(f==ret)<span class="keyword">return</span> ret;</span><br><span class="line">        &#125;</span><br><span class="line">    <span class="keyword">return</span> ret;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">mf</span><span class="params">(<span class="keyword">int</span> s,<span class="keyword">int</span> t)</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> ret=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span>(bfs(s,t))ret+=dfs(s,t,INF);</span><br><span class="line">    <span class="keyword">return</span> ret;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">int</span> n,m,a[N],seg[M][<span class="number">2</span>];</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">init</span><span class="params">(<span class="keyword">int</span> s,<span class="keyword">int</span> t,<span class="keyword">int</span> x)</span></span>&#123;</span><br><span class="line">    fill(head,head+N,<span class="number">0</span>);sz=<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;i++)</span><br><span class="line">        <span class="keyword">if</span>(a[i]&gt;=<span class="number">0</span>)&#123;</span><br><span class="line">            <span class="keyword">if</span>(a[i]&amp;(<span class="number">1</span>&lt;&lt;x))add(i,t,INF);</span><br><span class="line">            <span class="keyword">else</span> add(s,i,INF);</span><br><span class="line">        &#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;m;i++)&#123;</span><br><span class="line">        add(seg[i][<span class="number">0</span>],seg[i][<span class="number">1</span>],<span class="number">1</span>);</span><br><span class="line">        add(seg[i][<span class="number">1</span>],seg[i][<span class="number">0</span>],<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">int</span> vis[N];</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">dfs</span><span class="params">(<span class="keyword">int</span> u)</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> ret=<span class="number">1</span>,v;vis[u]=<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=head[u];i;i=g[i].nxt)</span><br><span class="line">        <span class="keyword">if</span>(g[i^<span class="number">1</span>].cap&amp;&amp;!vis[v=g[i].v])ret+=dfs(v);</span><br><span class="line">    <span class="keyword">return</span> ret;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    freopen(<span class="string">"in"</span>,<span class="string">"r"</span>,<span class="built_in">stdin</span>);freopen(<span class="string">"out"</span>,<span class="string">"w"</span>,<span class="built_in">stdout</span>);</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">"%d %d\n"</span>,&amp;n,&amp;m);<span class="keyword">int</span> tmp=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;i++)<span class="built_in">scanf</span>(<span class="string">"%d\n"</span>,&amp;a[i]),tmp=max(tmp,a[i]);</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;m;i++)<span class="built_in">scanf</span>(<span class="string">"%d %d\n"</span>,&amp;seg[i][<span class="number">0</span>],&amp;seg[i][<span class="number">1</span>]);</span><br><span class="line">    <span class="keyword">int</span> lim=log2(tmp)+<span class="number">1</span>,s=n+<span class="number">1</span>,t=s+<span class="number">1</span>;</span><br><span class="line">    ll sumE=<span class="number">0</span>,sumV=<span class="number">0</span>,b=<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;lim;i++,b&lt;&lt;=<span class="number">1</span>)&#123;</span><br><span class="line">        init(s,t,i);</span><br><span class="line">        sumE+=((ll)mf(s,t))*b;</span><br><span class="line">        fill(vis,vis+N,<span class="number">0</span>);</span><br><span class="line">        sumV+=((ll)(dfs(t)<span class="number">-1</span>))*b;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"%lld\n%lld"</span>,sumE,sumV);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;定义无向图中的一条边的值为：这条边连接的两个点的值的异或值。&lt;br&gt;定义一个无向图的值为：这个无向图所有边的值的和。&lt;br&gt;给你一个有n个结点m条边的无向图。其中的一些点的值是给定的，而其余的点的值由你决定（但要求均为非负数），使得这个无向图的值最小。在无向图的值最小的前提下，使得无向图中所有点的值的和最小。&lt;br&gt;n&amp;lt;=500，m&amp;lt;=2000&lt;br&gt;
    
    </summary>
    
      <category term="OI/ACM" scheme="https://cothrax.github.io/categories/OI-ACM/"/>
    
    
      <category term="位运算" scheme="https://cothrax.github.io/tags/%E4%BD%8D%E8%BF%90%E7%AE%97/"/>
    
      <category term="DFS" scheme="https://cothrax.github.io/tags/DFS/"/>
    
      <category term="网络流" scheme="https://cothrax.github.io/tags/%E7%BD%91%E7%BB%9C%E6%B5%81/"/>
    
      <category term="最小割" scheme="https://cothrax.github.io/tags/%E6%9C%80%E5%B0%8F%E5%89%B2/"/>
    
  </entry>
  
  <entry>
    <title>【网络流24题】最长递增子序列问题</title>
    <link href="https://cothrax.github.io/2016/12/23/flow24-alis/"/>
    <id>https://cothrax.github.io/2016/12/23/flow24-alis/</id>
    <published>2016-12-23T13:16:11.000Z</published>
    <updated>2016-12-31T11:39:28.857Z</updated>
    
    <content type="html"><![CDATA[<p>给定正整数序列x1,….. , xn  。</p>
<ol>
<li>计算其最长递增子序列的长度s。</li>
<li>计算从给定的序列中最多可取出多少个长度为s的递增子序列。</li>
<li>如果允许在取出的序列中多次使用x1和xn，则从给定序列中最多可取出多少个长<br>度为s的递增子序列，如果可以取无限个则输出-1</li>
</ol>
<a id="more"></a>
<h2 id="链接"><a href="#链接" class="headerlink" title="链接"></a>链接</h2><a href="/2016/12/23/flow24-alis/alis.cpp" title="alis.cpp">alis.cpp</a>
<h2 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h2><p>黑书例题<br>第一问dp求f[i]以i开头的lis，用树状数组优化，或者直接暴力<br>第二问，拆点，根据f[i]分层建图，然后最大流即可<br>第三问就是把第二问建的图中，把1和n对应的那条边容量改成+∞，然后在跑一次最大流<br>lis=1时输出-1<br>lis=2且a[1]&lt;=a[n]时输出-1</p>
<h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><figure class="highlight c++"><figcaption><span>alis.cpp</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N=<span class="number">1010</span>,INF=<span class="number">1E7</span>;</span><br><span class="line"><span class="keyword">int</span> n,lis=<span class="number">0</span>,a[N],f[N];</span><br><span class="line"><span class="keyword">namespace</span> bit&#123;</span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">int</span> M=<span class="number">1.1E5</span>;<span class="keyword">int</span> v[M];</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">add</span><span class="params">(<span class="keyword">int</span> x,<span class="keyword">int</span> k)</span></span>&#123;</span><br><span class="line">        <span class="keyword">for</span>(;x&lt;M;x+=x&amp;(-x))v[x]=max(v[x],k);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">ask</span><span class="params">(<span class="keyword">int</span> x)</span></span>&#123;</span><br><span class="line">        <span class="keyword">int</span> ret=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(;x;x=x&amp;(x<span class="number">-1</span>))ret=max(ret,v[x]);</span><br><span class="line">        <span class="keyword">return</span> ret;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">dp</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">using</span> <span class="keyword">namespace</span> bit;</span><br><span class="line">    <span class="comment">//f[i] max-len begin_with_a[i]</span></span><br><span class="line">    <span class="comment">//f[i]=max(f[j])+1 (j&gt;i&amp;&amp;a[j]&gt;a[i])</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=n<span class="number">-1</span>;i&gt;=<span class="number">0</span>;i--)&#123;</span><br><span class="line">        add(M-a[i],f[i]=ask(M-a[i])+<span class="number">1</span>);</span><br><span class="line">        lis=max(lis,f[i]);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">struct</span> edge&#123;<span class="keyword">int</span> v,cap,nxt;&#125;g[N*<span class="number">10</span>];</span><br><span class="line"><span class="keyword">int</span> head[N],sz=<span class="number">1</span>;</span><br><span class="line"><span class="keyword">void</span> _add(<span class="keyword">int</span> u,<span class="keyword">int</span> v,<span class="keyword">int</span> cap)&#123;</span><br><span class="line">    g[++sz].v=v;g[sz].cap=cap;</span><br><span class="line">    g[sz].nxt=head[u];head[u]=sz;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">add</span><span class="params">(<span class="keyword">int</span> u,<span class="keyword">int</span> v,<span class="keyword">int</span> cap)</span></span><br><span class="line"></span>&#123;_add(u,v,cap);_add(v,u,<span class="number">0</span>);&#125;</span><br><span class="line"><span class="keyword">int</span> q[N],d[N];</span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">bfs</span><span class="params">(<span class="keyword">int</span> s,<span class="keyword">int</span> dest)</span></span>&#123;</span><br><span class="line">    fill(d,d+N,INF);d[s]=<span class="number">0</span>;q[<span class="number">0</span>]=s;<span class="keyword">int</span> u,v;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> h=<span class="number">0</span>,t=<span class="number">1</span>;h!=t;h=(h+<span class="number">1</span>)%N)</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=head[u=q[h]];i;i=g[i].nxt)</span><br><span class="line">            <span class="keyword">if</span>(g[i].cap&amp;&amp;d[v=g[i].v]==INF)</span><br><span class="line">                d[v]=d[u]+<span class="number">1</span>,q[t++]=v,t%=N;</span><br><span class="line">    <span class="keyword">return</span> d[dest]!=INF;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">dfs</span><span class="params">(<span class="keyword">int</span> u,<span class="keyword">int</span> t,<span class="keyword">int</span> f)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(u==t)<span class="keyword">return</span> f;</span><br><span class="line">    <span class="keyword">int</span> ret=<span class="number">0</span>,v;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=head[u];i;i=g[i].nxt)</span><br><span class="line">        <span class="keyword">if</span>(d[v=g[i].v]==d[u]+<span class="number">1</span>)&#123;</span><br><span class="line">            <span class="keyword">int</span> tmp=dfs(v,t,min(f-ret,g[i].cap));</span><br><span class="line">            g[i].cap-=tmp;g[i^<span class="number">1</span>].cap+=tmp;ret+=tmp;</span><br><span class="line">            <span class="keyword">if</span>(f==ret)<span class="keyword">return</span> ret;</span><br><span class="line">        &#125;</span><br><span class="line">    <span class="keyword">return</span> ret;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">mf</span><span class="params">(<span class="keyword">int</span> s,<span class="keyword">int</span> t)</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> ret=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span>(bfs(s,t))ret+=dfs(s,t,INF);</span><br><span class="line">    <span class="keyword">return</span> ret;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">init</span><span class="params">(<span class="keyword">int</span> s,<span class="keyword">int</span> t)</span></span>&#123;</span><br><span class="line">    fill(head,head+N,<span class="number">0</span>);</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;n;i++)</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j=i+<span class="number">1</span>;j&lt;n;j++)</span><br><span class="line">            <span class="keyword">if</span>(a[i]&lt;=a[j]&amp;&amp;f[i]==f[j]+<span class="number">1</span>)add(i+n,j,INF);</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;n;i++)add(i,i+n,<span class="number">1</span>);</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;n;i++)&#123;</span><br><span class="line">        <span class="keyword">if</span>(f[i]==<span class="number">1</span>)add(i+n,t,INF);</span><br><span class="line">        <span class="keyword">if</span>(f[i]==lis)add(s,i,INF);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    freopen(<span class="string">"in"</span>,<span class="string">"r"</span>,<span class="built_in">stdin</span>);freopen(<span class="string">"out"</span>,<span class="string">"w"</span>,<span class="built_in">stdout</span>);</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">"%d\n"</span>,&amp;n);</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;n;i++)<span class="built_in">scanf</span>(<span class="string">"%d"</span>,&amp;a[i]);</span><br><span class="line">    dp();<span class="built_in">printf</span>(<span class="string">"%d\n"</span>,lis);</span><br><span class="line">    <span class="keyword">int</span> s=n*<span class="number">2</span>,t=s+<span class="number">1</span>;</span><br><span class="line">    init(s,t);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"%d\n"</span>,mf(s,t));</span><br><span class="line">    <span class="keyword">if</span>(lis==<span class="number">1</span>||lis==<span class="number">2</span>&amp;&amp;a[<span class="number">0</span>]&lt;=a[n<span class="number">-1</span>])<span class="built_in">printf</span>(<span class="string">"-1"</span>);</span><br><span class="line">    <span class="keyword">else</span>&#123;</span><br><span class="line">        init(s,t);add(<span class="number">0</span>,n,INF);add(n<span class="number">-1</span>,<span class="number">2</span>*n<span class="number">-1</span>,INF);</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"%d"</span>,mf(s,t));</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;给定正整数序列x1,….. , xn  。&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;计算其最长递增子序列的长度s。&lt;/li&gt;
&lt;li&gt;计算从给定的序列中最多可取出多少个长度为s的递增子序列。&lt;/li&gt;
&lt;li&gt;如果允许在取出的序列中多次使用x1和xn，则从给定序列中最多可取出多少个长&lt;br&gt;度为s的递增子序列，如果可以取无限个则输出-1&lt;/li&gt;
&lt;/ol&gt;
    
    </summary>
    
      <category term="OI/ACM" scheme="https://cothrax.github.io/categories/OI-ACM/"/>
    
    
      <category term="DP" scheme="https://cothrax.github.io/tags/DP/"/>
    
      <category term="图论" scheme="https://cothrax.github.io/tags/%E5%9B%BE%E8%AE%BA/"/>
    
      <category term="线性DP" scheme="https://cothrax.github.io/tags/%E7%BA%BF%E6%80%A7DP/"/>
    
      <category term="网络流" scheme="https://cothrax.github.io/tags/%E7%BD%91%E7%BB%9C%E6%B5%81/"/>
    
      <category term="最大流" scheme="https://cothrax.github.io/tags/%E6%9C%80%E5%A4%A7%E6%B5%81/"/>
    
  </entry>
  
  <entry>
    <title>【网络流24题】最长k可重区间集问题</title>
    <link href="https://cothrax.github.io/2016/12/23/flow24-interv/"/>
    <id>https://cothrax.github.io/2016/12/23/flow24-interv/</id>
    <published>2016-12-23T13:05:10.000Z</published>
    <updated>2016-12-31T11:39:28.860Z</updated>
    
    <content type="html"><![CDATA[<p>给定实直线L上n个开区间组成的集合I，和一个正整数k，试设计一个算法，从开区<br>间集合I 中选取出开区间集合S属于I，使得在实直线L的任何一点x，S 中包含点x 的开区间个数不超过k，且$\sum|z|,z\in S$，达到最大。这样的集合S称为开区间集合I的最长k可重区间集。<br>$\sum|z|$属于S称为最长k可重区间集的长度。<br>对于给定的开区间集合I和正整数k，计算开区间集合I的最长k可重区间集的长度。<br><a id="more"></a></p>
<h2 id="链接"><a href="#链接" class="headerlink" title="链接"></a>链接</h2><p><a href="http://hzwer.com/5842.html" target="_blank" rel="external">hzwer</a><br><a href="/2016/12/23/flow24-interv/interv.cpp" title="interv.cpp">interv.cpp</a></p>
<h2 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h2><p>最大权不相交路径<br>任意点x处重合区间数不超过k，则将一些不相交的区间接起来看做一条路径，那么问题就变成了取权值和最大的k条路径<br>引用题解：</p>
<blockquote>
<p>离散化所有区间的端点，把每个端点看做一个顶点，建立附加源S汇T。</p>
<ol>
<li>从S到顶点1（最左边顶点）连接一条容量为K，费用为0的有向边。</li>
<li>从顶点2N（最右边顶点）到T连接一条容量为K，费用为0的有向边。</li>
<li>从顶点i到顶点i+1(i+1&lt;=2N)，连接一条容量为无穷大，费用为0的有向边。</li>
<li>对于每个区间[a,b]，从a对应的顶点i到b对应的顶点j连接一条容量为1，费用为区间长度的有向边。</li>
</ol>
</blockquote>
<h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><figure class="highlight c++"><figcaption><span>interv.cpp</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N=<span class="number">1000</span>,INF=<span class="number">1E7</span>;</span><br><span class="line"><span class="keyword">struct</span> edge&#123;<span class="keyword">int</span> v,w,cap,nxt;&#125;g[N*<span class="number">10</span>];</span><br><span class="line"><span class="keyword">int</span> head[N],sz=<span class="number">1</span>;</span><br><span class="line"><span class="keyword">void</span> _add(<span class="keyword">int</span> u,<span class="keyword">int</span> v,<span class="keyword">int</span> cap,<span class="keyword">int</span> w)&#123;</span><br><span class="line">    g[++sz].v=v;g[sz].w=w;g[sz].cap=cap;</span><br><span class="line">    g[sz].nxt=head[u];head[u]=sz;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">add</span><span class="params">(<span class="keyword">int</span> u,<span class="keyword">int</span> v,<span class="keyword">int</span> cap,<span class="keyword">int</span> w)</span></span><br><span class="line"></span>&#123;_add(u,v,cap,w);_add(v,u,<span class="number">0</span>,-w);&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> q[N],d[N],pre[N];<span class="keyword">bool</span> inq[N];</span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">spfa</span><span class="params">(<span class="keyword">int</span> s,<span class="keyword">int</span> dest)</span></span>&#123;</span><br><span class="line">    fill(d,d+N,-INF);</span><br><span class="line">    fill(inq,inq+N,<span class="number">0</span>);</span><br><span class="line">    fill(pre,pre+N,<span class="number">0</span>);</span><br><span class="line">    d[s]=<span class="number">0</span>;inq[s]=<span class="number">1</span>;q[<span class="number">0</span>]=s;<span class="keyword">int</span> u,v;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> h=<span class="number">0</span>,t=<span class="number">1</span>;h!=t;inq[q[h]]=<span class="number">0</span>,h=(h+<span class="number">1</span>)%N)</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=head[u=q[h]];i;i=g[i].nxt)</span><br><span class="line">            <span class="keyword">if</span>(g[i].cap&amp;&amp;d[v=g[i].v]&lt;d[u]+g[i].w)&#123;</span><br><span class="line">                d[v]=d[u]+g[i].w;pre[v]=i;</span><br><span class="line">                <span class="keyword">if</span>(!inq[v])q[t++]=v,inq[v]=<span class="number">1</span>,t%=N;</span><br><span class="line">            &#125;</span><br><span class="line">    <span class="keyword">return</span> d[dest]!=-INF;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">mcf</span><span class="params">(<span class="keyword">int</span> s,<span class="keyword">int</span> t)</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> ret=<span class="number">0</span>,f=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span>(spfa(s,t))&#123;</span><br><span class="line">        <span class="keyword">int</span> x=INF,y=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=pre[t];i;i=pre[g[i^<span class="number">1</span>].v])</span><br><span class="line">            x=min(x,g[i].cap),y+=g[i].w;</span><br><span class="line">        f+=x;ret+=x*y;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=pre[t];i;i=pre[g[i^<span class="number">1</span>].v])</span><br><span class="line">            g[i].cap-=x,g[i^<span class="number">1</span>].cap+=x;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> ret;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    freopen(<span class="string">"in"</span>,<span class="string">"r"</span>,<span class="built_in">stdin</span>);freopen(<span class="string">"out"</span>,<span class="string">"w"</span>,<span class="built_in">stdout</span>);</span><br><span class="line">    <span class="keyword">int</span> n,k,vtx[N],l[N],r[N];</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">"%d %d\n"</span>,&amp;n,&amp;k);</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;n;i++)&#123;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">"%d %d\n"</span>,&amp;l[i],&amp;r[i]);</span><br><span class="line">        vtx[i]=l[i];vtx[i+n]=r[i];</span><br><span class="line">    &#125;</span><br><span class="line">    sort(vtx,vtx+<span class="number">2</span>*n);</span><br><span class="line">    <span class="keyword">int</span> m=<span class="number">0</span>,loc[(<span class="keyword">int</span>)<span class="number">1E5</span>];<span class="comment">//[0,m]</span></span><br><span class="line">    loc[vtx[<span class="number">0</span>]]=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;<span class="number">2</span>*n;i++)</span><br><span class="line">        <span class="keyword">if</span>(vtx[i]&gt;vtx[m])</span><br><span class="line">            vtx[++m]=vtx[i],loc[vtx[m]]=m;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;m;i++)add(i,i+<span class="number">1</span>,INF,<span class="number">0</span>);</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;n;i++)</span><br><span class="line">        add(loc[l[i]],loc[r[i]],<span class="number">1</span>,r[i]-l[i]);</span><br><span class="line">    <span class="keyword">int</span> s=m+<span class="number">1</span>,t=m+<span class="number">2</span>;</span><br><span class="line">    add(s,<span class="number">0</span>,k,<span class="number">0</span>);add(m,t,k,<span class="number">0</span>);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"%d"</span>,mcf(s,t));</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;给定实直线L上n个开区间组成的集合I，和一个正整数k，试设计一个算法，从开区&lt;br&gt;间集合I 中选取出开区间集合S属于I，使得在实直线L的任何一点x，S 中包含点x 的开区间个数不超过k，且$\sum|z|,z\in S$，达到最大。这样的集合S称为开区间集合I的最长k可重区间集。&lt;br&gt;$\sum|z|$属于S称为最长k可重区间集的长度。&lt;br&gt;对于给定的开区间集合I和正整数k，计算开区间集合I的最长k可重区间集的长度。&lt;br&gt;
    
    </summary>
    
      <category term="OI/ACM" scheme="https://cothrax.github.io/categories/OI-ACM/"/>
    
    
      <category term="图论" scheme="https://cothrax.github.io/tags/%E5%9B%BE%E8%AE%BA/"/>
    
      <category term="网络流" scheme="https://cothrax.github.io/tags/%E7%BD%91%E7%BB%9C%E6%B5%81/"/>
    
      <category term="费用流" scheme="https://cothrax.github.io/tags/%E8%B4%B9%E7%94%A8%E6%B5%81/"/>
    
  </entry>
  
  <entry>
    <title>bzoj-3598 【FJ2014集训】XWW的难题</title>
    <link href="https://cothrax.github.io/2016/12/23/bzoj-3698/"/>
    <id>https://cothrax.github.io/2016/12/23/bzoj-3698/</id>
    <published>2016-12-23T12:40:54.000Z</published>
    <updated>2016-12-31T11:39:28.847Z</updated>
    
    <content type="html"><![CDATA[<p>XWW给你出了这么一个难题：XWW给你一个N*N的正实数矩阵A，满足XWW性。<br>称一个N*N的矩阵满足XWW性当且仅当：（1）A[N][N]=0；（2）矩阵中每行的最后一个元素等于该行前N-1个数的和；（3）矩阵中每列的最后一个元素等于该列前N-1个数的和。<br>现在你要给A中的数进行取整操作（可以是上取整或者下取整），使得最后的A矩阵仍然满足XWW性。同时XWW还要求A中的元素之和尽量大。<br>N≤100<br><a id="more"></a></p>
<h2 id="链接"><a href="#链接" class="headerlink" title="链接"></a>链接</h2><p><a href="http://www.lydsy.com/JudgeOnline/problem.php?id=3698" target="_blank" rel="external">bzoj-3698</a><br><a href="/2016/12/23/bzoj-3698/3698.cpp" title="3698.cpp">3698.cpp</a></p>
<h2 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h2><p>上下界最大流<br>建模：</p>
<ol>
<li>设超级源汇s和t，节点l(i)表示第i行，节点c(i)表示第i列</li>
<li>s-&gt;l(i)，容量为[floor(a[i][n]),ceil(a[i][n])]</li>
<li>r(i)-&gt;t，容量为[floor(a[n][i]),ceil(a[n][i])]</li>
<li>l(i)-&gt;r(j)，容量为[floor(a[i][j]),ceil(a[i][j])]</li>
</ol>
<p>关于如何将上下界最大流规约为普通流：<br>设边e下界为b(e)，上界为c(e)，伪流f’(e)=f(e)-b(e)<br>流量守恒：<br>$\sum_{e\in in(v)}[f’(e)+b(e)]=\sum_{e\in out(v)}[f’(e)+b(e)]$</p>
<p>则$\sum_{e\in in(v)}f’(e)=\sum_{e\in out(v)}f’(e)+[\sum_{e\in in(v)}b(e)-\sum_{e\in out(v)}b(e)]$</p>
<p>记$m(v)=\sum_{e\in in(v)}b(e)-\sum_{e\in out(v)}b(e)$</p>
<p>在原图上跑伪流f’，即把边e的容量变为c(e)-b(e)<br>为保证流量守恒，设附加源汇s’和t’<br>如果m(v)&gt;0，s’-&gt;v，容量m(v)<br>如果m(v)<0，v->t’，容量-m(v)<br>将超级源汇当做普通节点：t-&gt;s，容量∞<br>先从s’到t’跑最大流，如果从s’出发的边全部满载，则存在可行流以满足所有下界<br>然后从s到t跑最大流f，f即上下界最大流的答案</0，v-></p>
<h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><figure class="highlight c++"><figcaption><span>3698.cpp</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cmath&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N=<span class="number">105</span>,M=N*N,INF=<span class="number">1E7</span>,EPS=<span class="number">1E-7</span>;</span><br><span class="line"><span class="keyword">struct</span> edge&#123;<span class="keyword">int</span> v,cap,nxt;&#125; g[M*<span class="number">10</span>];</span><br><span class="line"><span class="keyword">int</span> head[M],sz=<span class="number">1</span>;</span><br><span class="line"><span class="keyword">void</span> _add(<span class="keyword">int</span> u,<span class="keyword">int</span> v,<span class="keyword">int</span> cap)&#123;</span><br><span class="line">    g[++sz].v=v;g[sz].cap=cap;</span><br><span class="line">    g[sz].nxt=head[u];head[u]=sz;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">add</span><span class="params">(<span class="keyword">int</span> u,<span class="keyword">int</span> v,<span class="keyword">int</span> cap)</span></span><br><span class="line"></span>&#123;_add(u,v,cap);_add(v,u,<span class="number">0</span>);&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">double</span> a[N][N];<span class="keyword">int</span> r[M],n,s,t,S,T,sum=<span class="number">0</span>;</span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">jud</span><span class="params">(<span class="keyword">double</span> n)</span></span>&#123;<span class="keyword">return</span> <span class="built_in">abs</span>(n-(<span class="keyword">int</span>)n)&lt;EPS;&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">init</span><span class="params">()</span></span>&#123;</span><br><span class="line">    s=<span class="number">2</span>*n+<span class="number">1</span>,t=s+<span class="number">1</span>,S=t+<span class="number">1</span>,T=S+<span class="number">1</span>;</span><br><span class="line">    fill(r,r+M,<span class="number">0</span>);</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;n;i++)&#123;</span><br><span class="line">        <span class="keyword">if</span>(!jud(a[i][n]))add(s,i,<span class="number">1</span>);</span><br><span class="line">        <span class="keyword">if</span>(!jud(a[n][i]))add(i+n,t,<span class="number">1</span>);</span><br><span class="line">        r[s]-=(<span class="keyword">int</span>)a[i][n];r[i]+=(<span class="keyword">int</span>)a[i][n];</span><br><span class="line">        r[t]+=(<span class="keyword">int</span>)a[n][i];r[i+n]-=(<span class="keyword">int</span>)a[n][i];</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">1</span>;j&lt;n;j++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(!jud(a[i][j]))add(i,j+n,<span class="number">1</span>);</span><br><span class="line">            r[i]-=(<span class="keyword">int</span>)a[i][j];r[j+n]+=(<span class="keyword">int</span>)a[i][j];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    add(t,s,INF);</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=t;i++)</span><br><span class="line">        <span class="keyword">if</span>(r[i]&gt;<span class="number">0</span>)add(S,i,r[i]),sum+=r[i];</span><br><span class="line">        <span class="keyword">else</span> add(i,T,-r[i]);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> q[M],d[M];</span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">bfs</span><span class="params">(<span class="keyword">int</span> s,<span class="keyword">int</span> dest)</span></span>&#123;</span><br><span class="line">    fill(d,d+M,INF);</span><br><span class="line">    d[s]=<span class="number">0</span>;q[<span class="number">0</span>]=s;<span class="keyword">int</span> u,v;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> h=<span class="number">0</span>,t=<span class="number">1</span>;h!=t;h=(h+<span class="number">1</span>)%M)</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=head[u=q[h]];i;i=g[i].nxt)</span><br><span class="line">            <span class="keyword">if</span>(g[i].cap&amp;&amp;d[v=g[i].v]==INF)</span><br><span class="line">                &#123;d[v]=d[u]+<span class="number">1</span>;q[t++]=v;t%=M;&#125;</span><br><span class="line">    <span class="keyword">return</span> d[dest]!=INF;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">dfs</span><span class="params">(<span class="keyword">int</span> u,<span class="keyword">int</span> t,<span class="keyword">int</span> f)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(u==t)<span class="keyword">return</span> f;</span><br><span class="line">    <span class="keyword">int</span> ret=<span class="number">0</span>;<span class="keyword">int</span> v;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=head[u];i;i=g[i].nxt)</span><br><span class="line">        <span class="keyword">if</span>(d[v=g[i].v]==d[u]+<span class="number">1</span>)&#123;</span><br><span class="line">            <span class="keyword">int</span> tmp=dfs(v,t,min(f-ret,g[i].cap));</span><br><span class="line">            g[i].cap-=tmp;g[i^<span class="number">1</span>].cap+=tmp;ret+=tmp;</span><br><span class="line">            <span class="keyword">if</span>(f==ret)<span class="keyword">return</span> f;</span><br><span class="line">        &#125;</span><br><span class="line">    <span class="keyword">if</span>(!ret)d[u]=INF;</span><br><span class="line">    <span class="keyword">return</span> ret;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">mf</span><span class="params">(<span class="keyword">int</span> s,<span class="keyword">int</span> t)</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> ret=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span>(bfs(s,t))ret+=dfs(s,t,INF);</span><br><span class="line">    <span class="keyword">return</span> ret;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    freopen(<span class="string">"in"</span>,<span class="string">"r"</span>,<span class="built_in">stdin</span>);</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">"%d\n"</span>,&amp;n);</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;i++)</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">1</span>;j&lt;=n;j++)<span class="built_in">scanf</span>(<span class="string">"%lf"</span>,&amp;a[i][j]);</span><br><span class="line">    init();</span><br><span class="line">    <span class="keyword">if</span>(mf(S,T)&lt;sum)<span class="built_in">printf</span>(<span class="string">"No"</span>);</span><br><span class="line">    <span class="keyword">else</span> <span class="built_in">printf</span>(<span class="string">"%d"</span>,mf(s,t)*<span class="number">3</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;XWW给你出了这么一个难题：XWW给你一个N*N的正实数矩阵A，满足XWW性。&lt;br&gt;称一个N*N的矩阵满足XWW性当且仅当：（1）A[N][N]=0；（2）矩阵中每行的最后一个元素等于该行前N-1个数的和；（3）矩阵中每列的最后一个元素等于该列前N-1个数的和。&lt;br&gt;现在你要给A中的数进行取整操作（可以是上取整或者下取整），使得最后的A矩阵仍然满足XWW性。同时XWW还要求A中的元素之和尽量大。&lt;br&gt;N≤100&lt;br&gt;
    
    </summary>
    
      <category term="OI/ACM" scheme="https://cothrax.github.io/categories/OI-ACM/"/>
    
    
      <category term="图论" scheme="https://cothrax.github.io/tags/%E5%9B%BE%E8%AE%BA/"/>
    
      <category term="网络流" scheme="https://cothrax.github.io/tags/%E7%BD%91%E7%BB%9C%E6%B5%81/"/>
    
      <category term="最大流" scheme="https://cothrax.github.io/tags/%E6%9C%80%E5%A4%A7%E6%B5%81/"/>
    
  </entry>
  
  <entry>
    <title>bzoj-1877 [SDOI2009]晨跑</title>
    <link href="https://cothrax.github.io/2016/12/23/bzoj-1877/"/>
    <id>https://cothrax.github.io/2016/12/23/bzoj-1877/</id>
    <published>2016-12-23T12:35:46.000Z</published>
    <updated>2016-12-31T11:39:28.898Z</updated>
    
    <content type="html"><![CDATA[<p> 现在给出一张学校附近的地图，这张地图中包含N个十字路口和M条街道，Elaxia只能从 一个十字路口跑向另外一个十字路口，街道之间只在十字路口处相交。Elaxia每天从寝室出发 跑到学校，保证寝室编号为1，学校编号为N。 Elaxia的晨跑计划是按周期（包含若干天）进行的，由于他不喜欢走重复的路线，所以 在一个周期内，每天的晨跑路线都不会相交（在十字路口处），寝室和学校不算十字路 口。Elaxia耐力不太好，他希望在一个周期内跑的路程尽量短，但是又希望训练周期包含的天 数尽量长。 除了练空手道，Elaxia其他时间都花在了学习和找MM上面，所有他想请你帮忙为他设计 一套满足他要求的晨跑计划。<br>N ≤ 200，M ≤ 20000<br><a id="more"></a></p>
<h2 id="链接"><a href="#链接" class="headerlink" title="链接"></a>链接</h2><p><a href="http://www.lydsy.com/JudgeOnline/problem.php?id=1877" target="_blank" rel="external">bzoj-1877</a><br><a href="/2016/12/23/bzoj-1877/1877.cpp" title="1877.cpp">1877.cpp</a></p>
<h2 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h2><p>裸的最小费用最大流。<br>每条边费用为它的长度，容量为1，然后从s到t跑费用流即可。</p>
<h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><figure class="highlight c++"><figcaption><span>1877.cpp</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N=<span class="number">410</span>,INF=<span class="number">1e7</span>;</span><br><span class="line"><span class="keyword">struct</span> edge&#123;<span class="keyword">int</span> v,w,cap,nxt;&#125; g[N*N];</span><br><span class="line"><span class="keyword">int</span> head[N],sz=<span class="number">1</span>,n,m;</span><br><span class="line"><span class="keyword">void</span> _add(<span class="keyword">int</span> u,<span class="keyword">int</span> v,<span class="keyword">int</span> w,<span class="keyword">int</span> cap)&#123;</span><br><span class="line">    g[++sz].v=v;g[sz].cap=cap;g[sz].w=w;</span><br><span class="line">    g[sz].nxt=head[u];head[u]=sz;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">add</span><span class="params">(<span class="keyword">int</span> u,<span class="keyword">int</span> v,<span class="keyword">int</span> w,<span class="keyword">int</span> cap)</span></span><br><span class="line"></span>&#123;_add(u,v,w,cap);_add(v,u,-w,<span class="number">0</span>);&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> d[N],q[N],pre[N];<span class="keyword">bool</span> inq[N];</span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">spfa</span><span class="params">(<span class="keyword">int</span> s,<span class="keyword">int</span> dest)</span></span>&#123;</span><br><span class="line">    fill(d,d+<span class="number">2</span>*n+<span class="number">1</span>,INF);d[s]=<span class="number">0</span>;</span><br><span class="line">    fill(inq,inq+<span class="number">2</span>*n+<span class="number">1</span>,<span class="number">0</span>);inq[s]=<span class="number">1</span>;</span><br><span class="line">    fill(pre,pre+<span class="number">2</span>*n+<span class="number">1</span>,<span class="number">0</span>);</span><br><span class="line">    q[<span class="number">0</span>]=s;<span class="keyword">int</span> u,v;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> h=<span class="number">0</span>,t=<span class="number">1</span>;h!=t;inq[q[h]]=<span class="number">0</span>,h=(h+<span class="number">1</span>)%N)</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=head[u=q[h]];i;i=g[i].nxt)</span><br><span class="line">            <span class="keyword">if</span>(g[i].cap&amp;&amp;d[v=g[i].v]&gt;d[u]+g[i].w)&#123;</span><br><span class="line">                d[v]=d[u]+g[i].w;pre[v]=i;</span><br><span class="line">                <span class="keyword">if</span>(!inq[v])q[t++]=v,inq[v]=<span class="number">1</span>,t%=N;</span><br><span class="line">            &#125;</span><br><span class="line">    <span class="keyword">return</span> d[dest]!=INF;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">mcf</span><span class="params">(<span class="keyword">int</span> s,<span class="keyword">int</span> t)</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> f=<span class="number">0</span>,ret=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span>(spfa(s,t))&#123;</span><br><span class="line">        <span class="keyword">int</span> x=INF,y=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=pre[t];i;i=pre[g[i^<span class="number">1</span>].v])</span><br><span class="line">            x=min(x,g[i].cap),y+=g[i].w;</span><br><span class="line">        f+=x;ret+=x*y;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=pre[t];i;i=pre[g[i^<span class="number">1</span>].v])</span><br><span class="line">            g[i].cap-=x,g[i^<span class="number">1</span>].cap+=x;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"%d %d"</span>,f,ret);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    freopen(<span class="string">"in"</span>,<span class="string">"r"</span>,<span class="built_in">stdin</span>);</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">"%d %d\n"</span>,&amp;n,&amp;m);<span class="keyword">int</span> u,v,w;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;i++)add(i,i+n,<span class="number">0</span>,<span class="number">1</span>);</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;m;i++)</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">"%d %d %d\n"</span>,&amp;u,&amp;v,&amp;w),add(u+n,v,w,<span class="number">1</span>);</span><br><span class="line">    mcf(<span class="number">1</span>+n,n);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt; 现在给出一张学校附近的地图，这张地图中包含N个十字路口和M条街道，Elaxia只能从 一个十字路口跑向另外一个十字路口，街道之间只在十字路口处相交。Elaxia每天从寝室出发 跑到学校，保证寝室编号为1，学校编号为N。 Elaxia的晨跑计划是按周期（包含若干天）进行的，由于他不喜欢走重复的路线，所以 在一个周期内，每天的晨跑路线都不会相交（在十字路口处），寝室和学校不算十字路 口。Elaxia耐力不太好，他希望在一个周期内跑的路程尽量短，但是又希望训练周期包含的天 数尽量长。 除了练空手道，Elaxia其他时间都花在了学习和找MM上面，所有他想请你帮忙为他设计 一套满足他要求的晨跑计划。&lt;br&gt;N ≤ 200，M ≤ 20000&lt;br&gt;
    
    </summary>
    
      <category term="OI/ACM" scheme="https://cothrax.github.io/categories/OI-ACM/"/>
    
    
      <category term="图论" scheme="https://cothrax.github.io/tags/%E5%9B%BE%E8%AE%BA/"/>
    
      <category term="网络流" scheme="https://cothrax.github.io/tags/%E7%BD%91%E7%BB%9C%E6%B5%81/"/>
    
      <category term="费用流" scheme="https://cothrax.github.io/tags/%E8%B4%B9%E7%94%A8%E6%B5%81/"/>
    
  </entry>
  
  <entry>
    <title>bzoj-1500 [NOI2005]维修数列</title>
    <link href="https://cothrax.github.io/2016/12/18/bzoj-1500/"/>
    <id>https://cothrax.github.io/2016/12/18/bzoj-1500/</id>
    <published>2016-12-18T05:15:33.000Z</published>
    <updated>2016-12-31T11:43:13.271Z</updated>
    
    <content type="html"><![CDATA[<p><img src="http://www.lydsy.com/JudgeOnline/images/1500_1.jpg" alt=""><br>Limit:<br>M≤20000<br>任何时刻数列中最多含有500000个数，数列中任何一个数字均在[-1000,1000]内。<br>插入的数字总数不超过4000000个，输入文件大小不超过20MBytes。<br><a id="more"></a></p>
<h2 id="链接"><a href="#链接" class="headerlink" title="链接"></a>链接</h2><p><a href="http://www.lydsy.com/JudgeOnline/problem.php?id=1500" target="_blank" rel="external">bzoj-1500</a><br><a href="/2016/12/18/bzoj-1500/1500.cpp" title="1500.cpp">1500.cpp</a></p>
<h2 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h2><p>Splay模板题<br>关于max-sum，由于Splay的中序序列即该序列：</p>
<ol>
<li>lmx[x]子树x中序序列的最大前缀和</li>
<li>rmx[x]子树x中序序列的最大前缀和</li>
<li>sub[x]子树x中序序列的最大子段和</li>
</ol>
<p>更新见upd函数<br>summary</p>
<ol>
<li>下标，注意splay中虚拟节点的左端点占一位</li>
<li>翻转时要维护max-sum</li>
<li>内存回收：开一个stack</li>
<li>初始值：lmx[0]=rmx[0]=0,sub[0]=-INF</li>
<li>max-sum子段不为空，因此make-same中当w[x]为负时，sub[x]=max(w[x],sum[x])，而lmx[x]=rmx[x]=max(0,sum[x])</li>
<li>维护make-same标记时，由于涉及权值修改，要判断t!=0</li>
</ol>
<h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><figure class="highlight c++"><figcaption><span>1500.cpp</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> L(x) c[x][0]</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> R(x) c[x][1]</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">namespace</span> spt&#123;</span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">int</span> N=<span class="number">5e5</span>+<span class="number">10</span>,INF=<span class="number">1e7</span>;</span><br><span class="line">    <span class="keyword">int</span> c[N][<span class="number">2</span>],par[N],siz[N]=&#123;<span class="number">0</span>&#125;,sz=<span class="number">0</span>,rt=<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">int</span> sub[N],lmx[N],rmx[N],w[N],sum[N];</span><br><span class="line">    <span class="keyword">bool</span> rev[N],tag[N];</span><br><span class="line">    <span class="keyword">int</span> loc[N],a[N];</span><br><span class="line">    <span class="keyword">namespace</span> mem&#123;</span><br><span class="line">        <span class="keyword">int</span> stk[N*<span class="number">2</span>],t=N;</span><br><span class="line">        <span class="function"><span class="keyword">void</span> <span class="title">init</span><span class="params">()</span></span>&#123;<span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;N;i++)stk[i]=N-i;&#125;</span><br><span class="line">        <span class="function"><span class="keyword">inline</span> <span class="keyword">int</span> <span class="title">ext</span><span class="params">()</span></span>&#123;<span class="keyword">return</span> stk[--t];&#125;</span><br><span class="line">        <span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">ins</span><span class="params">(<span class="keyword">int</span> x)</span></span>&#123;stk[t++]=x;&#125;</span><br><span class="line">        <span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">rec</span><span class="params">(<span class="keyword">int</span> x)</span></span>&#123;</span><br><span class="line">            <span class="keyword">if</span>(!x)<span class="keyword">return</span>;</span><br><span class="line">            ins(x);rec(L(x));rec(R(x));</span><br><span class="line">            L(x)=R(x)=par[x]=tag[x]=rev[x]=<span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">upd</span><span class="params">(<span class="keyword">int</span> x)</span></span>&#123;</span><br><span class="line">        siz[x]=siz[L(x)]+siz[R(x)]+<span class="number">1</span>;</span><br><span class="line">        sum[x]=sum[L(x)]+sum[R(x)]+w[x];</span><br><span class="line">        lmx[x]=max(lmx[L(x)],sum[L(x)]+lmx[R(x)]+w[x]);</span><br><span class="line">        rmx[x]=max(rmx[R(x)],sum[R(x)]+rmx[L(x)]+w[x]);</span><br><span class="line">        sub[x]=max(max(sub[L(x)],sub[R(x)]),lmx[R(x)]+rmx[L(x)]+w[x]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">pushdn</span><span class="params">(<span class="keyword">int</span> x)</span></span>&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;<span class="number">2</span>&amp;&amp;rev[x];i++)&#123;</span><br><span class="line">            <span class="keyword">int</span> t=c[x][i];rev[t]^=<span class="number">1</span>;</span><br><span class="line">            swap(L(t),R(t));swap(lmx[t],rmx[t]);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;<span class="number">2</span>&amp;&amp;tag[x];i++)&#123;</span><br><span class="line">            <span class="keyword">int</span> t=c[x][i];<span class="keyword">if</span>(!t)<span class="keyword">continue</span>;</span><br><span class="line">            w[t]=w[x];tag[t]=<span class="number">1</span>;</span><br><span class="line">            lmx[t]=rmx[t]=max(<span class="number">0</span>,sum[t]=w[t]*siz[t]);</span><br><span class="line">            sub[t]=max(sum[t],w[t]);</span><br><span class="line">        &#125;rev[x]=tag[x]=<span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">rotate</span><span class="params">(<span class="keyword">int</span> x,<span class="keyword">int</span> &amp;k)</span></span>&#123;</span><br><span class="line">        <span class="keyword">int</span> y=par[x],z=par[y],l=c[y][<span class="number">0</span>]!=x,r=l^<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">if</span>(y==k)k=x;<span class="keyword">else</span> c[z][c[z][<span class="number">0</span>]!=y]=x;</span><br><span class="line">        par[c[x][r]]=y;par[y]=x;par[x]=z;</span><br><span class="line">        c[y][l]=c[x][r];c[x][r]=y;</span><br><span class="line">        upd(y);upd(x);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">splay</span><span class="params">(<span class="keyword">int</span> x,<span class="keyword">int</span> &amp;k)</span></span>&#123;</span><br><span class="line">        <span class="keyword">while</span>(x!=k)&#123;</span><br><span class="line">            <span class="keyword">int</span> y=par[x],z=par[y];</span><br><span class="line">            <span class="keyword">if</span>(y!=k)&#123;</span><br><span class="line">                <span class="keyword">if</span>(L(y)==x^L(z)==y)rotate(x,k);</span><br><span class="line">                <span class="keyword">else</span> rotate(y,k);</span><br><span class="line">            &#125;rotate(x,k);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">find</span><span class="params">(<span class="keyword">int</span> x,<span class="keyword">int</span> rk)</span></span>&#123;</span><br><span class="line">        pushdn(x);</span><br><span class="line">        <span class="keyword">if</span>(siz[L(x)]+<span class="number">1</span>==rk)<span class="keyword">return</span> x;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span>(siz[L(x)]&gt;=rk)<span class="keyword">return</span> find(L(x),rk);</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">return</span> find(R(x),rk-siz[L(x)]<span class="number">-1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">build</span><span class="params">(<span class="keyword">int</span> l,<span class="keyword">int</span> r,<span class="keyword">int</span> p)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(l&gt;r)<span class="keyword">return</span>;</span><br><span class="line">        <span class="keyword">int</span> mid=(l+r)&gt;&gt;<span class="number">1</span>,x=loc[mid];</span><br><span class="line">        <span class="keyword">if</span>(l==r)&#123;</span><br><span class="line">            par[x]=loc[p];c[loc[p]][l&gt;p]=x;</span><br><span class="line">            w[x]=a[l];upd(x);</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        build(l,mid<span class="number">-1</span>,mid);build(mid+<span class="number">1</span>,r,mid);</span><br><span class="line">        par[x]=loc[p];c[loc[p]][mid&gt;p]=x;</span><br><span class="line">        w[x]=a[mid];upd(x);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">split</span><span class="params">(<span class="keyword">int</span> l,<span class="keyword">int</span> r)</span></span>&#123;</span><br><span class="line">        <span class="keyword">int</span> x=find(rt,l),y=find(rt,r+<span class="number">2</span>);</span><br><span class="line">        splay(x,rt);splay(y,R(rt));</span><br><span class="line">        <span class="keyword">return</span> L(y);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">namespace</span> opt&#123;</span><br><span class="line">        <span class="function"><span class="keyword">void</span> <span class="title">init</span><span class="params">(<span class="keyword">int</span> n)</span></span>&#123;</span><br><span class="line">            mem::init();</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;i++)<span class="built_in">scanf</span>(<span class="string">"%d"</span>,&amp;a[i]);</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;=n+<span class="number">1</span>;i++)loc[i]=mem::ext();</span><br><span class="line">            sub[<span class="number">0</span>]=a[<span class="number">0</span>]=a[n+<span class="number">1</span>]=-INF;</span><br><span class="line">            rt=loc[(n+<span class="number">1</span>)&gt;&gt;<span class="number">1</span>];build(<span class="number">0</span>,n+<span class="number">1</span>,n+<span class="number">2</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="function"><span class="keyword">void</span> <span class="title">rever</span><span class="params">(<span class="keyword">int</span> l,<span class="keyword">int</span> r)</span></span>&#123;</span><br><span class="line">            <span class="keyword">int</span> x=split(l,r);</span><br><span class="line">            <span class="keyword">if</span>(tag[x])<span class="keyword">return</span>;</span><br><span class="line">            rev[x]^=<span class="number">1</span>;</span><br><span class="line">            swap(L(x),R(x));swap(lmx[x],rmx[x]);</span><br><span class="line">            upd(par[x]);upd(rt);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="function"><span class="keyword">int</span> <span class="title">query</span><span class="params">(<span class="keyword">int</span> l,<span class="keyword">int</span> r)</span></span>&#123;</span><br><span class="line">            <span class="keyword">int</span> x=split(l,r);</span><br><span class="line">            <span class="keyword">return</span> sum[x];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="function"><span class="keyword">void</span> <span class="title">del</span><span class="params">(<span class="keyword">int</span> l,<span class="keyword">int</span> r)</span></span>&#123;</span><br><span class="line">            <span class="keyword">int</span> x=split(l,r);</span><br><span class="line">            L(par[x])=<span class="number">0</span>;upd(par[x]);upd(rt);</span><br><span class="line">            mem::rec(x);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="function"><span class="keyword">void</span> <span class="title">modify</span><span class="params">(<span class="keyword">int</span> l,<span class="keyword">int</span> r,<span class="keyword">int</span> k)</span></span>&#123;</span><br><span class="line">            <span class="keyword">int</span> x=split(l,r);tag[x]=<span class="number">1</span>;w[x]=k;</span><br><span class="line">            lmx[x]=rmx[x]=max(<span class="number">0</span>,sum[x]=w[x]*siz[x]);</span><br><span class="line">            sub[x]=max(sum[x],w[x]);</span><br><span class="line">            upd(par[x]);upd(rt);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="function"><span class="keyword">void</span> <span class="title">ins</span><span class="params">(<span class="keyword">int</span> l,<span class="keyword">int</span> tot)</span></span>&#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;tot;i++)<span class="built_in">scanf</span>(<span class="string">"%d "</span>,&amp;a[i]);</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;tot;i++)loc[i]=mem::ext();</span><br><span class="line">            split(l+<span class="number">1</span>,l);</span><br><span class="line">            loc[tot]=R(rt);build(<span class="number">0</span>,tot<span class="number">-1</span>,tot);</span><br><span class="line">            upd(loc[tot]);upd(rt);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="function"><span class="keyword">int</span> <span class="title">get</span><span class="params">()</span></span>&#123;<span class="keyword">return</span> sub[rt];&#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">using</span> <span class="keyword">namespace</span> spt::opt;</span><br><span class="line">    freopen(<span class="string">"in"</span>,<span class="string">"r"</span>,<span class="built_in">stdin</span>);freopen(<span class="string">"out"</span>,<span class="string">"w"</span>,<span class="built_in">stdout</span>);</span><br><span class="line">    <span class="keyword">int</span> n,m;<span class="built_in">scanf</span>(<span class="string">"%d %d\n"</span>,&amp;n,&amp;m);</span><br><span class="line">    init(n);</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;m;i++)&#123;</span><br><span class="line">        <span class="keyword">char</span> s[<span class="number">10</span>];<span class="keyword">int</span> p,t,k;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">"%s"</span>,s);</span><br><span class="line">        <span class="keyword">if</span>(s[<span class="number">2</span>]!=<span class="string">'X'</span>)<span class="built_in">scanf</span>(<span class="string">"%d %d"</span>,&amp;p,&amp;t);</span><br><span class="line">        <span class="keyword">if</span>(s[<span class="number">2</span>]==<span class="string">'K'</span>)<span class="built_in">scanf</span>(<span class="string">"%d"</span>,&amp;k);</span><br><span class="line">        <span class="keyword">switch</span>(s[<span class="number">0</span>])&#123;</span><br><span class="line">            <span class="keyword">case</span>'I':ins(p,t);<span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">case</span>'D':del(p,p+t<span class="number">-1</span>);<span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">case</span>'R':rever(p,p+t<span class="number">-1</span>);<span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">case</span>'G':<span class="built_in">printf</span>(<span class="string">"%d\n"</span>,query(p,p+t<span class="number">-1</span>));<span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">default</span>:</span><br><span class="line">                <span class="keyword">switch</span>(s[<span class="number">2</span>])&#123;</span><br><span class="line">                    <span class="keyword">case</span>'K':modify(p,p+t<span class="number">-1</span>,k);<span class="keyword">break</span>;</span><br><span class="line">                    <span class="keyword">case</span>'X':<span class="built_in">printf</span>(<span class="string">"%d\n"</span>,get());<span class="keyword">break</span>;</span><br><span class="line">                &#125;<span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;img src=&quot;http://www.lydsy.com/JudgeOnline/images/1500_1.jpg&quot; alt=&quot;&quot;&gt;&lt;br&gt;Limit:&lt;br&gt;M≤20000&lt;br&gt;任何时刻数列中最多含有500000个数，数列中任何一个数字均在[-1000,1000]内。&lt;br&gt;插入的数字总数不超过4000000个，输入文件大小不超过20MBytes。&lt;br&gt;
    
    </summary>
    
      <category term="OI/ACM" scheme="https://cothrax.github.io/categories/OI-ACM/"/>
    
    
      <category term="数据结构" scheme="https://cothrax.github.io/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"/>
    
      <category term="平衡树" scheme="https://cothrax.github.io/tags/%E5%B9%B3%E8%A1%A1%E6%A0%91/"/>
    
      <category term="Splay" scheme="https://cothrax.github.io/tags/Splay/"/>
    
  </entry>
  
  <entry>
    <title>bzoj-3173 [Tjoi2013]最长上升子序列</title>
    <link href="https://cothrax.github.io/2016/12/18/bzoj-3173/"/>
    <id>https://cothrax.github.io/2016/12/18/bzoj-3173/</id>
    <published>2016-12-18T05:06:47.000Z</published>
    <updated>2016-12-31T11:39:28.831Z</updated>
    
    <content type="html"><![CDATA[<p>给定一个序列，初始为空。现在我们将1到N的数字插入到序列中，每次将一个数字插入到一个特定的位置x_i。每插入一个数字，我们都想知道此时最长上升子序列长度是多少？<br>n&lt;=100000<br><a id="more"></a></p>
<h2 id="链接"><a href="#链接" class="headerlink" title="链接"></a>链接</h2><p><a href="http://www.lydsy.com/JudgeOnline/problem.php?id=3173" target="_blank" rel="external">bzoj-3173</a><br><a href="/2016/12/18/bzoj-3173/3173.cpp" title="3173.cpp">3173.cpp</a></p>
<h2 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h2><p>由于是从小到大插入，记f[i]为以i结尾的lis<br>那么f[i]=f[前x_i个数]的最大值+1<br>于是用treap维护该数列：</p>
<ol>
<li>该序列为treap的中序遍历，并维护子树的f[i]最大值</li>
<li>每次查询rank&lt;x_i的f[i]的最大值</li>
<li>插入i时，先找到rank=x_i+1的点，然后将i作为前驱插入</li>
</ol>
<p>attention:<br>ins等函数中&amp;x是引用，调用时要用c[x][0]而不是l</p>
<h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><figure class="highlight c++"><figcaption><span>3173.cpp</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstdlib&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> L(x) c[x][0]</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> R(x) c[x][1]</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N=<span class="number">1e5</span>+<span class="number">10</span>;</span><br><span class="line"><span class="keyword">namespace</span> treap&#123;</span><br><span class="line">    <span class="keyword">int</span> rnd[N]=&#123;<span class="number">0</span>&#125;,siz[N]=&#123;<span class="number">0</span>&#125;,c[N][<span class="number">2</span>],sz=<span class="number">0</span>,rt;</span><br><span class="line">    <span class="keyword">int</span> w[N],sub[N]=&#123;<span class="number">0</span>&#125;,ans=<span class="number">0</span>;</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">upd</span><span class="params">(<span class="keyword">int</span> &amp;x)</span></span>&#123;</span><br><span class="line">        siz[x]=siz[L(x)]+siz[R(x)]+<span class="number">1</span>;</span><br><span class="line">        sub[x]=max(max(sub[L(x)],sub[R(x)]),w[x]);</span><br><span class="line">        ans=max(ans,sub[x]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">rotate</span><span class="params">(<span class="keyword">int</span> &amp;x,<span class="keyword">int</span> l)</span></span>&#123;</span><br><span class="line">        <span class="keyword">int</span> r=l^<span class="number">1</span>,y=c[x][l];</span><br><span class="line">        c[x][l]=c[y][r];c[y][r]=x;</span><br><span class="line">        upd(x);upd(y);x=y;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">query</span><span class="params">(<span class="keyword">int</span> &amp;x,<span class="keyword">int</span> rk)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(!rk||!x)<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">if</span>(siz[L(x)]&gt;=rk)<span class="keyword">return</span> query(L(x),rk);</span><br><span class="line">        <span class="keyword">if</span>(siz[L(x)]&lt;rk)&#123;</span><br><span class="line">            <span class="keyword">int</span> ret=query(R(x),rk-siz[L(x)]<span class="number">-1</span>);</span><br><span class="line">            <span class="keyword">return</span> max(ret,max(sub[L(x)],w[x]));</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">add</span><span class="params">(<span class="keyword">int</span> &amp;x,<span class="keyword">int</span> val,<span class="keyword">int</span> l)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(!x)&#123;</span><br><span class="line">            x=++sz;w[sz]=val;upd(sz);</span><br><span class="line">            rnd[sz]=rand();<span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        add(c[x][l],val,l);upd(x);</span><br><span class="line">        <span class="keyword">if</span>(rnd[c[x][l]]&gt;rnd[x])rotate(x,l);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">ins</span><span class="params">(<span class="keyword">int</span> &amp;x,<span class="keyword">int</span> rk,<span class="keyword">int</span> val)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(siz[rt]+<span class="number">1</span>==rk)&#123;add(rt,val,<span class="number">1</span>);<span class="keyword">return</span>;&#125;</span><br><span class="line">        <span class="keyword">if</span>(siz[L(x)]+<span class="number">1</span>==rk)&#123;</span><br><span class="line">            add(L(x),val,<span class="number">1</span>);upd(x);</span><br><span class="line">            <span class="keyword">if</span>(rnd[L(x)]&gt;rnd[x])rotate(x,<span class="number">0</span>);</span><br><span class="line">        &#125;<span class="keyword">else</span> <span class="keyword">if</span>(siz[L(x)]&gt;=rk)ins(L(x),rk,val);</span><br><span class="line">         <span class="keyword">else</span> ins(R(x),rk-siz[L(x)]<span class="number">-1</span>,val);</span><br><span class="line">        upd(x);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">walk</span><span class="params">(<span class="keyword">int</span> x,<span class="keyword">int</span> dep)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(!x)<span class="keyword">return</span>;</span><br><span class="line">        walk(L(x),dep+<span class="number">1</span>);</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;dep;i++)<span class="built_in">printf</span>(<span class="string">"    "</span>);</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"%d:%d(%d)\n"</span>,x,w[x],siz[x]);</span><br><span class="line">        walk(R(x),dep+<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">using</span> <span class="keyword">namespace</span> treap;</span><br><span class="line">    srand(<span class="number">12345632</span>);</span><br><span class="line">    freopen(<span class="string">"in"</span>,<span class="string">"r"</span>,<span class="built_in">stdin</span>);freopen(<span class="string">"out"</span>,<span class="string">"w"</span>,<span class="built_in">stdout</span>);</span><br><span class="line">    <span class="keyword">int</span> n,x;<span class="built_in">scanf</span>(<span class="string">"%d"</span>,&amp;n);</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;n;i++)&#123;</span><br><span class="line">        <span class="keyword">int</span> x;<span class="built_in">scanf</span>(<span class="string">"%d"</span>,&amp;x);</span><br><span class="line">        ins(rt,x+<span class="number">1</span>,query(rt,x)+<span class="number">1</span>);</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"%d\n"</span>,ans);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;给定一个序列，初始为空。现在我们将1到N的数字插入到序列中，每次将一个数字插入到一个特定的位置x_i。每插入一个数字，我们都想知道此时最长上升子序列长度是多少？&lt;br&gt;n&amp;lt;=100000&lt;br&gt;
    
    </summary>
    
      <category term="OI/ACM" scheme="https://cothrax.github.io/categories/OI-ACM/"/>
    
    
      <category term="数据结构" scheme="https://cothrax.github.io/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"/>
    
      <category term="DP" scheme="https://cothrax.github.io/tags/DP/"/>
    
      <category term="Treap" scheme="https://cothrax.github.io/tags/Treap/"/>
    
      <category term="平衡树" scheme="https://cothrax.github.io/tags/%E5%B9%B3%E8%A1%A1%E6%A0%91/"/>
    
  </entry>
  
  <entry>
    <title>bzoj-3506 [Cqoi2014]排序机械臂</title>
    <link href="https://cothrax.github.io/2016/12/18/bzoj-3506/"/>
    <id>https://cothrax.github.io/2016/12/18/bzoj-3506/</id>
    <published>2016-12-18T04:57:17.000Z</published>
    <updated>2016-12-31T11:39:28.841Z</updated>
    
    <content type="html"><![CDATA[<p>给定一个长n的数列，有n次操作，第i次为：<br>找到i..n中最小的数，记它的下标为k，翻转区间[i,k]<br>并输出k值<br>n≤100000</p>
<a id="more"></a>
<h2 id="链接"><a href="#链接" class="headerlink" title="链接"></a>链接</h2><p><a href="http://www.lydsy.com/JudgeOnline/problem.php?id=3506" target="_blank" rel="external">bzoj-3506</a><br><a href="/2016/12/18/bzoj-3506/3506.cpp" title="3506.cpp">3506.cpp</a></p>
<h2 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h2><p>splay维护序列</p>
<ol>
<li>在建树时维护个点所在下标，将数列sort一下，升序处理</li>
<li>对于第i个数，下标为loc[i]，从loc[i]向上直到根节点压进一个栈，然后从上到下pushdown一遍，再遍历一遍统计loc[i]的rank</li>
<li>然后splay翻转[1,rank]即可</li>
</ol>
<h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><figure class="highlight c++"><figcaption><span>3506.cpp</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> P pair<span class="meta-string">&lt;int,int&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> mkp(x,y) make_pair(x,y)</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N=<span class="number">100010</span>;</span><br><span class="line"><span class="keyword">namespace</span> splay_tree&#123;</span><br><span class="line">    <span class="keyword">int</span> c[N][<span class="number">2</span>],w[N],par[N],siz[N],sz=<span class="number">0</span>,rt=<span class="number">1</span>,loc[N],a[N];</span><br><span class="line">    <span class="keyword">bool</span> rev[N];</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">upd</span><span class="params">(<span class="keyword">int</span> x)</span></span>&#123;siz[x]=siz[c[x][<span class="number">0</span>]]+siz[c[x][<span class="number">1</span>]]+<span class="number">1</span>;&#125;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">pushdn</span><span class="params">(<span class="keyword">int</span> x)</span></span>&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;<span class="number">2</span>&amp;&amp;rev[x];i++)&#123;</span><br><span class="line">            <span class="keyword">int</span> t=c[x][i];rev[t]^=<span class="number">1</span>;</span><br><span class="line">            swap(c[t][<span class="number">0</span>],c[t][<span class="number">1</span>]);</span><br><span class="line">        &#125;rev[x]=<span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">rotate</span><span class="params">(<span class="keyword">int</span> x,<span class="keyword">int</span> &amp;k)</span></span>&#123;</span><br><span class="line">        <span class="keyword">int</span> y=par[x],z=par[y],l=c[y][<span class="number">0</span>]==x?<span class="number">0</span>:<span class="number">1</span>,r=l^<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">if</span>(y==k)k=x;<span class="keyword">else</span> c[z][c[z][<span class="number">0</span>]==y?<span class="number">0</span>:<span class="number">1</span>]=x;</span><br><span class="line">        par[c[x][r]]=y;par[y]=x;par[x]=z;</span><br><span class="line">        c[y][l]=c[x][r];c[x][r]=y;</span><br><span class="line">        upd(y);upd(x);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">splay</span><span class="params">(<span class="keyword">int</span> x,<span class="keyword">int</span> &amp;k)</span></span>&#123;</span><br><span class="line">        <span class="keyword">while</span>(x!=k)&#123;</span><br><span class="line">            <span class="keyword">int</span> y=par[x],z=par[y];</span><br><span class="line">            <span class="keyword">if</span>(y!=k)&#123;</span><br><span class="line">                <span class="keyword">if</span>(c[y][<span class="number">0</span>]==x^c[z][<span class="number">0</span>]==y)rotate(x,k);</span><br><span class="line">                <span class="keyword">else</span> rotate(y,k);</span><br><span class="line">            &#125;rotate(x,k);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">find</span><span class="params">(<span class="keyword">int</span> x,<span class="keyword">int</span> rk)</span></span>&#123;</span><br><span class="line">        pushdn(x);</span><br><span class="line">        <span class="keyword">int</span> l=c[x][<span class="number">0</span>],r=c[x][<span class="number">1</span>];</span><br><span class="line">        <span class="keyword">if</span>(siz[l]+<span class="number">1</span>==rk)<span class="keyword">return</span> x;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span>(siz[l]&gt;=rk)<span class="keyword">return</span> find(l,rk);</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">return</span> find(r,rk-siz[l]<span class="number">-1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">rever</span><span class="params">(<span class="keyword">int</span> st,<span class="keyword">int</span> k)</span></span>&#123;</span><br><span class="line">        <span class="keyword">int</span> q[N],t=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> x=k;x;x=par[x])q[t++]=x;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=t<span class="number">-1</span>;i&gt;=<span class="number">0</span>;i--)pushdn(q[i]);</span><br><span class="line">        <span class="keyword">int</span> rk=siz[c[k][<span class="number">0</span>]];</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;t;i++)&#123;</span><br><span class="line">            <span class="keyword">int</span> x=q[i],l=c[x][<span class="number">0</span>],r=c[x][<span class="number">1</span>];</span><br><span class="line">            <span class="keyword">if</span>(q[i<span class="number">-1</span>]==r)rk+=siz[l]+<span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span> x=find(rt,st),y=find(rt,rk+<span class="number">2</span>);</span><br><span class="line">        splay(x,rt);splay(y,c[rt][<span class="number">1</span>]);</span><br><span class="line">        x=c[y][<span class="number">0</span>];rev[x]^=<span class="number">1</span>;swap(c[x][<span class="number">0</span>],c[x][<span class="number">1</span>]);</span><br><span class="line">        <span class="keyword">return</span> rk;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">build</span><span class="params">(<span class="keyword">int</span> l,<span class="keyword">int</span> r,<span class="keyword">int</span> p)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(l&gt;r)<span class="keyword">return</span>;</span><br><span class="line">        <span class="keyword">if</span>(l==r)&#123;</span><br><span class="line">            loc[l]=++sz;</span><br><span class="line">            par[sz]=loc[p];c[loc[p]][l&lt;p?<span class="number">0</span>:<span class="number">1</span>]=sz;</span><br><span class="line">            w[sz]=a[l];siz[sz]=<span class="number">1</span>;upd(sz);</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span> mid=(l+r)&gt;&gt;<span class="number">1</span>,x=loc[mid]=++sz;</span><br><span class="line">        build(l,mid<span class="number">-1</span>,mid);build(mid+<span class="number">1</span>,r,mid);</span><br><span class="line">        par[x]=loc[p];c[loc[p]][mid&lt;p?<span class="number">0</span>:<span class="number">1</span>]=x;</span><br><span class="line">        w[x]=a[mid];siz[x]=<span class="number">1</span>;upd(x);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">using</span> <span class="keyword">namespace</span> splay_tree;</span><br><span class="line">    <span class="comment">//freopen("in","r",stdin);freopen("out","w",stdout);</span></span><br><span class="line">    <span class="keyword">int</span> n;<span class="built_in">scanf</span>(<span class="string">"%d"</span>,&amp;n);</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;i++)<span class="built_in">scanf</span>(<span class="string">"%d"</span>,&amp;a[i]);</span><br><span class="line">    build(<span class="number">0</span>,n+<span class="number">1</span>,n+<span class="number">2</span>);</span><br><span class="line">    P b[N];</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;i++)b[i<span class="number">-1</span>]=mkp(a[i],i);</span><br><span class="line">    sort(b,b+n);</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;n;i++)</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"%d "</span>,rever(i+<span class="number">1</span>,loc[b[i].second]));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;给定一个长n的数列，有n次操作，第i次为：&lt;br&gt;找到i..n中最小的数，记它的下标为k，翻转区间[i,k]&lt;br&gt;并输出k值&lt;br&gt;n≤100000&lt;/p&gt;
    
    </summary>
    
      <category term="OI/ACM" scheme="https://cothrax.github.io/categories/OI-ACM/"/>
    
    
      <category term="平衡树" scheme="https://cothrax.github.io/tags/%E5%B9%B3%E8%A1%A1%E6%A0%91/"/>
    
      <category term="Splay" scheme="https://cothrax.github.io/tags/Splay/"/>
    
  </entry>
  
  <entry>
    <title>bzoj-3223 Tyvj 1729 文艺平衡树</title>
    <link href="https://cothrax.github.io/2016/12/18/bzoj-3223/"/>
    <id>https://cothrax.github.io/2016/12/18/bzoj-3223/</id>
    <published>2016-12-18T04:51:40.000Z</published>
    <updated>2016-12-31T11:39:28.833Z</updated>
    
    <content type="html"><![CDATA[<p>维护长n一个数列$a_n$，初始为$a_i=i$，支持m次区间翻转，输出翻转后的结果<br>N,M&lt;=100000<br><a id="more"></a></p>
<h2 id="链接"><a href="#链接" class="headerlink" title="链接"></a>链接</h2><p><a href="http://www.lydsy.com/JudgeOnline/problem.php?id=3223" target="_blank" rel="external">bzoj-3223</a><br><a href="/2016/12/18/bzoj-3223/3223.cpp" title="3223.cpp">3223.cpp</a></p>
<h2 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h2><p>splay即可<br>见：</p>
<ol>
<li><a href="https://oi.men.ci/splay-notes-1/" target="_blank" rel="external">Splay 学习笔记（一）</a></li>
<li><a href="https://oi.men.ci/splay-notes-2/" target="_blank" rel="external">Splay 学习笔记（二）</a></li>
</ol>
<p>静态数组的写法是跟黄学长学的</p>
<h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><figure class="highlight c++"><figcaption><span>3223.cpp</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N=<span class="number">100010</span>;</span><br><span class="line"><span class="comment">//splay::begin</span></span><br><span class="line"><span class="keyword">int</span> c[N][<span class="number">2</span>],siz[N],par[N],rt;<span class="keyword">bool</span> flg[N];</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">upd</span><span class="params">(<span class="keyword">int</span> x)</span></span>&#123;siz[x]=siz[c[x][<span class="number">0</span>]]+siz[c[x][<span class="number">1</span>]]+<span class="number">1</span>;&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">pushdn</span><span class="params">(<span class="keyword">int</span> x)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(!flg[x])<span class="keyword">return</span>;</span><br><span class="line">    swap(c[x][<span class="number">0</span>],c[x][<span class="number">1</span>]);</span><br><span class="line">    <span class="keyword">int</span> l=c[x][<span class="number">0</span>],r=c[x][<span class="number">1</span>];</span><br><span class="line">    flg[l]^=<span class="number">1</span>;flg[r]^=<span class="number">1</span>;flg[x]=<span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">rotate</span><span class="params">(<span class="keyword">int</span> x,<span class="keyword">int</span> &amp;k)</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> y=par[x],z=par[y],l=c[y][<span class="number">0</span>]==x?<span class="number">0</span>:<span class="number">1</span>,r=l^<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">if</span>(y==k)k=x;<span class="keyword">else</span> c[z][c[z][<span class="number">0</span>]==y?<span class="number">0</span>:<span class="number">1</span>]=x;</span><br><span class="line">    par[x]=z;par[y]=x;par[c[x][r]]=y;</span><br><span class="line">    c[y][l]=c[x][r];c[x][r]=y;</span><br><span class="line">    upd(y);upd(x);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">rank</span><span class="params">(<span class="keyword">int</span> x,<span class="keyword">int</span> rk)</span></span>&#123;</span><br><span class="line">    pushdn(x);<span class="keyword">int</span> l=c[x][<span class="number">0</span>],r=c[x][<span class="number">1</span>];</span><br><span class="line">    <span class="keyword">if</span>(siz[l]+<span class="number">1</span>==rk)<span class="keyword">return</span> x;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span>(siz[l]&gt;=rk)<span class="keyword">return</span> rank(l,rk);</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">return</span> rank(r,rk-siz[l]<span class="number">-1</span>); <span class="comment">//<span class="doctag">bug:</span> r,not l</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">find</span><span class="params">(<span class="keyword">int</span> rk)</span></span>&#123;<span class="keyword">return</span> rank(rt,rk);&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">splay</span><span class="params">(<span class="keyword">int</span> x,<span class="keyword">int</span> &amp;k)</span></span>&#123;</span><br><span class="line">    <span class="keyword">while</span>(x!=k)&#123;</span><br><span class="line">        <span class="keyword">int</span> y=par[x],z=par[y];</span><br><span class="line">        <span class="keyword">if</span>(y!=k)&#123;</span><br><span class="line">            <span class="keyword">if</span>(c[y][<span class="number">0</span>]==x^c[z][<span class="number">0</span>]==y)rotate(x,k); </span><br><span class="line">            <span class="keyword">else</span> rotate(y,k);</span><br><span class="line">        &#125;rotate(x,k); <span class="comment">//<span class="doctag">bug:</span>rotate,not splay</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">build</span><span class="params">(<span class="keyword">int</span> l,<span class="keyword">int</span> r,<span class="keyword">int</span> p)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(l&gt;r)<span class="keyword">return</span>;</span><br><span class="line">    <span class="keyword">if</span>(l==r)&#123;</span><br><span class="line">        par[l]=p;siz[l]=<span class="number">1</span>;c[p][l&lt;p?<span class="number">0</span>:<span class="number">1</span>]=l;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">int</span> mid=(l+r)&gt;&gt;<span class="number">1</span>;</span><br><span class="line">    build(l,mid<span class="number">-1</span>,mid);build(mid+<span class="number">1</span>,r,mid);</span><br><span class="line">    par[mid]=p;upd(mid);c[p][mid&lt;p?<span class="number">0</span>:<span class="number">1</span>]=mid;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">rev</span><span class="params">(<span class="keyword">int</span> l,<span class="keyword">int</span> r)</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> x=find(l),y=find(r+<span class="number">2</span>);</span><br><span class="line">    splay(x,rt);splay(y,c[rt][<span class="number">1</span>]);</span><br><span class="line">    flg[c[y][<span class="number">0</span>]]^=<span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">walk</span><span class="params">(<span class="keyword">int</span> x,<span class="keyword">int</span> lim)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(!x)<span class="keyword">return</span>;pushdn(x);</span><br><span class="line">    walk(c[x][<span class="number">0</span>],lim);</span><br><span class="line">    <span class="keyword">if</span>(x!=lim&amp;&amp;x!=<span class="number">1</span>)<span class="built_in">printf</span>(<span class="string">"%d "</span>,x<span class="number">-1</span>);</span><br><span class="line">    walk(c[x][<span class="number">1</span>],lim);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//splay::end</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="comment">//freopen("in","r",stdin);freopen("out","w",stdout);</span></span><br><span class="line">    <span class="keyword">int</span> n,m,l,r;<span class="built_in">scanf</span>(<span class="string">"%d %d\n"</span>,&amp;n,&amp;m);</span><br><span class="line">    rt=(n+<span class="number">3</span>)&gt;&gt;<span class="number">1</span>;build(<span class="number">1</span>,n+<span class="number">2</span>,<span class="number">0</span>);</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;m;i++)</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">"%d %d\n"</span>,&amp;l,&amp;r),rev(l,r);</span><br><span class="line">    walk(rt,n+<span class="number">2</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;维护长n一个数列$a_n$，初始为$a_i=i$，支持m次区间翻转，输出翻转后的结果&lt;br&gt;N,M&amp;lt;=100000&lt;br&gt;
    
    </summary>
    
      <category term="OI/ACM" scheme="https://cothrax.github.io/categories/OI-ACM/"/>
    
    
      <category term="数据结构" scheme="https://cothrax.github.io/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"/>
    
      <category term="平衡树" scheme="https://cothrax.github.io/tags/%E5%B9%B3%E8%A1%A1%E6%A0%91/"/>
    
      <category term="Splay" scheme="https://cothrax.github.io/tags/Splay/"/>
    
  </entry>
  
  <entry>
    <title>bzoj-1503 [NOI2004]郁闷的出纳员</title>
    <link href="https://cothrax.github.io/2016/12/18/bzoj-1503/"/>
    <id>https://cothrax.github.io/2016/12/18/bzoj-1503/</id>
    <published>2016-12-18T04:44:45.000Z</published>
    <updated>2016-12-31T11:39:28.890Z</updated>
    
    <content type="html"><![CDATA[<p>维护一个集合，支持如下操作：</p>
<ol>
<li>I_k 插入一个数k</li>
<li>A_k 将集合中的所有数加k</li>
<li>S_k 将集合中的所有数减k</li>
<li>F_k 查询第k大的数</li>
</ol>
<p>给定下界min，S_k之后会删除集合中值小于min的数，如果I_k插入的数值小于k会被立刻删除。</p>
<a id="more"></a>
<h2 id="链接"><a href="#链接" class="headerlink" title="链接"></a>链接</h2><p><a href="http://www.lydsy.com/JudgeOnline/problem.php?id=1503" target="_blank" rel="external">bzoj-1503</a><br><a href="/2016/12/18/bzoj-1503/1503.cpp" title="1503.cpp">1503.cpp</a></p>
<h2 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h2><p>平衡树+全局表示即可</p>
<h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><p>Treap<br><figure class="highlight c++"><figcaption><span>1503.cpp</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstdlib&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N=<span class="number">100010</span>;</span><br><span class="line"><span class="keyword">int</span> dlt=<span class="number">0</span>,sz=<span class="number">0</span>;</span><br><span class="line"><span class="keyword">struct</span> node&#123;<span class="keyword">int</span> l,r,w,rnd,cnt,s;&#125;t[N];</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">upd</span><span class="params">(<span class="keyword">int</span> &amp;k)</span></span>&#123;t[k].s=t[t[k].l].s+t[t[k].r].s+t[k].cnt;&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">lturn</span><span class="params">(<span class="keyword">int</span> &amp;k)</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> p=t[k].r;t[k].r=t[p].l;t[p].l=k;</span><br><span class="line">    t[p].s=t[k].s;upd(k);k=p;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">rturn</span><span class="params">(<span class="keyword">int</span> &amp;k)</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> p=t[k].l;t[k].l=t[p].r;t[p].r=k;</span><br><span class="line">    t[p].s=t[k].s;upd(k);k=p;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">ins</span><span class="params">(<span class="keyword">int</span> &amp;k,<span class="keyword">int</span> x)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(!k)t[k=++sz].rnd=rand(),t[k].w=x,t[k].cnt=t[k].s=<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span>(x&lt;t[k].w)&#123;</span><br><span class="line">        ins(t[k].l,x);upd(k);</span><br><span class="line">        <span class="keyword">if</span>(t[k].rnd&lt;t[t[k].l].rnd)rturn(k);</span><br><span class="line">    &#125;<span class="keyword">else</span> <span class="keyword">if</span>(x&gt;t[k].w)&#123;</span><br><span class="line">        ins(t[k].r,x);upd(k);</span><br><span class="line">        <span class="keyword">if</span>(t[k].rnd&lt;t[t[k].r].rnd)lturn(k);</span><br><span class="line">    &#125;<span class="keyword">else</span>&#123;t[k].cnt++;upd(k);&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">del</span><span class="params">(<span class="keyword">int</span> &amp;k,<span class="keyword">int</span> x)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(!k)<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">if</span>(t[k].w&lt;x)&#123;</span><br><span class="line">        <span class="keyword">int</span> ret=t[t[k].l].s+t[k].cnt;k=t[k].r;</span><br><span class="line">        ret+=del(k,x);upd(k);<span class="keyword">return</span> ret;</span><br><span class="line">    &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">        <span class="keyword">int</span> ret=del(t[k].l,x);upd(k);<span class="keyword">return</span> ret;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">kth</span><span class="params">(<span class="keyword">int</span> &amp;k,<span class="keyword">int</span> x)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(!k)<span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    <span class="keyword">int</span> tmp=t[k].s-t[t[k].l].s;</span><br><span class="line">    <span class="keyword">if</span>(t[t[k].r].s&gt;=x)<span class="keyword">return</span> kth(t[k].r,x);</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span>(tmp&lt;x) <span class="keyword">return</span> kth(t[k].l,x-tmp);</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">return</span> t[k].w+dlt;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">print</span><span class="params">(<span class="keyword">int</span> &amp;k,<span class="keyword">int</span> dep)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(!k)<span class="keyword">return</span>;</span><br><span class="line">    print(t[k].l,dep+<span class="number">1</span>);</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;dep;i++)<span class="built_in">printf</span>(<span class="string">"        "</span>);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"t[%d]=%d(%d/%d)%d\n"</span>,k,t[k].w,t[k].cnt,</span><br><span class="line">        t[k].s,t[k].rnd/<span class="number">1000000</span>);</span><br><span class="line">    print(t[k].r,dep+<span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="comment">//freopen("in","r",stdin);freopen("out","w",stdout);</span></span><br><span class="line">    srand(<span class="number">102458</span>);</span><br><span class="line">    <span class="keyword">int</span> n,m,ans=<span class="number">0</span>,rt=<span class="number">0</span>;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">"%d %d\n"</span>,&amp;n,&amp;m);</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;n;i++)&#123;</span><br><span class="line">        <span class="keyword">char</span> c;<span class="keyword">int</span> x;<span class="built_in">scanf</span>(<span class="string">"%c %d\n"</span>,&amp;c,&amp;x);</span><br><span class="line">        <span class="keyword">switch</span>(c)&#123;</span><br><span class="line">            <span class="keyword">case</span> <span class="string">'I'</span>:<span class="keyword">if</span>(x&gt;=m)ins(rt,x-dlt);<span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">case</span> <span class="string">'A'</span>:dlt+=x;<span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">case</span> <span class="string">'S'</span>:dlt-=x,ans+=del(rt,m-dlt);<span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">case</span> <span class="string">'F'</span>:<span class="built_in">printf</span>(<span class="string">"%d\n"</span>,kth(rt,x));<span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"%d"</span>,ans);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;维护一个集合，支持如下操作：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;I_k 插入一个数k&lt;/li&gt;
&lt;li&gt;A_k 将集合中的所有数加k&lt;/li&gt;
&lt;li&gt;S_k 将集合中的所有数减k&lt;/li&gt;
&lt;li&gt;F_k 查询第k大的数&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;给定下界min，S_k之后会删除集合中值小于min的数，如果I_k插入的数值小于k会被立刻删除。&lt;/p&gt;
    
    </summary>
    
      <category term="OI/ACM" scheme="https://cothrax.github.io/categories/OI-ACM/"/>
    
    
      <category term="数据结构" scheme="https://cothrax.github.io/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"/>
    
      <category term="Treap" scheme="https://cothrax.github.io/tags/Treap/"/>
    
      <category term="平衡树" scheme="https://cothrax.github.io/tags/%E5%B9%B3%E8%A1%A1%E6%A0%91/"/>
    
  </entry>
  
  <entry>
    <title>bzoj-1588 [HNOI2002]营业额统计</title>
    <link href="https://cothrax.github.io/2016/12/18/bzoj-1588/"/>
    <id>https://cothrax.github.io/2016/12/18/bzoj-1588/</id>
    <published>2016-12-18T04:35:23.000Z</published>
    <updated>2016-12-31T11:42:03.110Z</updated>
    
    <content type="html"><![CDATA[<p>Tiger最近被公司升任为营业部经理，他上任后接受公司交给的第一项任务便是统计并分析公司成立以来的营业情况。<br>Tiger拿出了公司的账本，账本上记录了公司成立以来每天的营业额。分析营业情况是一项相当复杂的工作。由于节假日，大减价或者是其他情况的时候，营业额会出现一定的波动，当然一定的波动是能够接受的，但是在某些时候营业额突变得很高或是很低，这就证明公司此时的经营状况出现了问题。经济管理学上定义了一种最小波动值来衡量这种情况： 该天的最小波动值 当最小波动值越大时，就说明营业情况越不稳定。<br>而分析整个公司的从成立到现在营业情况是否稳定，只需要把每一天的最小波动值加起来就可以了。你的任务就是编写一个程序帮助Tiger来计算这一个值。 第一天的最小波动值为第一天的营业额。<br><a id="more"></a></p>
<h2 id="链接"><a href="#链接" class="headerlink" title="链接"></a>链接</h2><p><a href="http://www.lydsy.com/JudgeOnline/problem.php?id=1588" target="_blank" rel="external">bzoj-1588</a><br><a href="/2016/12/18/bzoj-1588/1588.cpp" title="1588.cpp">1588.cpp</a><br><a href="/2016/12/18/bzoj-1588/1588_lnk.cpp" title="1588_lnk.cpp">1588_lnk.cpp</a></p>
<h2 id="在线-Treap"><a href="#在线-Treap" class="headerlink" title="在线-Treap"></a>在线-Treap</h2><h3 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h3><p>维护treap，找前/后驱取最小值即可。</p>
<h3 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h3><figure class="highlight c++"><figcaption><span>1588.cpp</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstdlib&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N=<span class="number">50010</span>,INF=<span class="number">1E8</span>;</span><br><span class="line"><span class="keyword">struct</span> treap&#123;</span><br><span class="line">    <span class="keyword">int</span> sz;</span><br><span class="line">    <span class="keyword">struct</span> node&#123;<span class="keyword">int</span> l,r,w,rnd;&#125;t[N];</span><br><span class="line">    treap()&#123;sz=<span class="number">0</span>;srand(<span class="number">20001106</span>);&#125;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">lturn</span><span class="params">(<span class="keyword">int</span> &amp;k)</span></span><br><span class="line">    </span>&#123;<span class="keyword">int</span> p=t[k].r;t[k].r=t[p].l;t[p].l=k;k=p;&#125;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">rturn</span><span class="params">(<span class="keyword">int</span> &amp;k)</span></span><br><span class="line">    </span>&#123;<span class="keyword">int</span> p=t[k].l;t[k].l=t[p].r;t[p].r=k;k=p;&#125;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">ins</span><span class="params">(<span class="keyword">int</span> &amp;k,<span class="keyword">int</span> x)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(!k)t[k=++sz].w=x,t[k].rnd=rand();</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span>(t[k].w&gt;x)&#123;</span><br><span class="line">            ins(t[k].l,x);</span><br><span class="line">            <span class="keyword">if</span>(t[k].rnd&lt;t[t[k].l].rnd)rturn(k);</span><br><span class="line">        &#125;<span class="keyword">else</span> <span class="keyword">if</span>(t[k].w&lt;x)&#123;</span><br><span class="line">            ins(t[k].r,x);</span><br><span class="line">            <span class="keyword">if</span>(t[k].rnd&lt;t[t[k].r].rnd)lturn(k);</span><br><span class="line">        &#125;;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">int</span> _max(<span class="keyword">int</span> &amp;k)</span><br><span class="line">    &#123;<span class="keyword">if</span>(!t[k].r)<span class="keyword">return</span> t[k].w;<span class="keyword">return</span> _max(t[k].r);&#125;</span><br><span class="line">    <span class="keyword">int</span> _min(<span class="keyword">int</span> &amp;k)</span><br><span class="line">    &#123;<span class="keyword">if</span>(!t[k].l)<span class="keyword">return</span> t[k].w;<span class="keyword">return</span> _min(t[k].l);&#125;</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">succ</span><span class="params">(<span class="keyword">int</span> &amp;k,<span class="keyword">int</span> x)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(!k)<span class="keyword">return</span> INF;</span><br><span class="line">        <span class="keyword">if</span>(t[k].w&lt;x)<span class="keyword">return</span> succ(t[k].r,x);</span><br><span class="line">        <span class="keyword">if</span>((!t[k].l)||_max(t[k].l)&lt;x)<span class="keyword">return</span> t[k].w;</span><br><span class="line">        <span class="keyword">return</span> succ(t[k].l,x);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">prev</span><span class="params">(<span class="keyword">int</span> &amp;k,<span class="keyword">int</span> x)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(!k)<span class="keyword">return</span> -INF;</span><br><span class="line">        <span class="keyword">if</span>(t[k].w&gt;x)<span class="keyword">return</span> prev(t[k].l,x);</span><br><span class="line">        <span class="keyword">if</span>((!t[k].r)||_min(t[k].r)&gt;x)<span class="keyword">return</span> t[k].w;</span><br><span class="line">        <span class="keyword">return</span> prev(t[k].r,x);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">print</span><span class="params">(<span class="keyword">int</span> &amp;k,<span class="keyword">int</span> dep)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(!k)<span class="keyword">return</span>;</span><br><span class="line">        print(t[k].l,dep+<span class="number">1</span>);</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;dep;i++)<span class="built_in">printf</span>(<span class="string">"    "</span>);</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"[%d]=%d(%d/%d)%d\n"</span>,k,t[k].w,t[k].cnt,t[k].s,</span><br><span class="line">            (<span class="keyword">int</span>)t[k].rnd/<span class="number">1000000</span>);</span><br><span class="line">        print(t[k].r,dep+<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;dat;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    freopen(<span class="string">"in"</span>,<span class="string">"r"</span>,<span class="built_in">stdin</span>);</span><br><span class="line">    <span class="keyword">int</span> n,x,ans,rt=<span class="number">0</span>;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">"%d\n%d\n"</span>,&amp;n,&amp;ans);</span><br><span class="line">    dat.ins(rt,ans);</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;n;i++)&#123;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">"%d\n"</span>,&amp;x);</span><br><span class="line">        ans+=min(dat.succ(rt,x)-x,x-dat.prev(rt,x));</span><br><span class="line">        dat.ins(rt,x);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"%d"</span>,ans);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="离线-链表"><a href="#离线-链表" class="headerlink" title="离线-链表"></a>离线-链表</h2><h3 id="题解-1"><a href="#题解-1" class="headerlink" title="题解"></a>题解</h3><p>类似某年noip的开车旅行那题的预处理<br>升序sort，链表链起来<br>逆着原始的顺序逐个处理，用左右指针得到该点的答案，然后把这个点从链表中删掉</p>
<h3 id="代码-1"><a href="#代码-1" class="headerlink" title="代码"></a>代码</h3><figure class="highlight c++"><figcaption><span>1588_lnk.cpp</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> P pair<span class="meta-string">&lt;int,int&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> mkp(x,y) make_pair(x,y)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> fir first</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> sec second</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N=<span class="number">50010</span>,INF=<span class="number">1E8</span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="comment">//freopen("in","r",stdin);</span></span><br><span class="line">    <span class="keyword">int</span> n,x,ans;P a[N];</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">"%d"</span>,&amp;n);</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;n;i++)<span class="built_in">scanf</span>(<span class="string">"%d"</span>,&amp;x),a[i]=mkp(x,i);</span><br><span class="line">    ans=a[<span class="number">0</span>].fir;sort(a,a+n);</span><br><span class="line">    <span class="keyword">int</span> l[N],r[N],loc[N];</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;n;i++)loc[a[i].sec]=i;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;n;i++)l[i]=i<span class="number">-1</span>,r[i]=i+<span class="number">1</span>;</span><br><span class="line">    l[<span class="number">0</span>]=n+<span class="number">1</span>;a[n].fir=INF;a[n+<span class="number">1</span>].fir=-INF;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=n<span class="number">-1</span>;i&gt;<span class="number">0</span>;i--)&#123;</span><br><span class="line">        <span class="keyword">int</span> j=loc[i];</span><br><span class="line">        ans+=min(a[j].fir-a[l[j]].fir,a[r[j]].fir-a[j].fir);</span><br><span class="line">        r[l[j]]=r[j];l[r[j]]=l[j];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"%d"</span>,ans);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;Tiger最近被公司升任为营业部经理，他上任后接受公司交给的第一项任务便是统计并分析公司成立以来的营业情况。&lt;br&gt;Tiger拿出了公司的账本，账本上记录了公司成立以来每天的营业额。分析营业情况是一项相当复杂的工作。由于节假日，大减价或者是其他情况的时候，营业额会出现一定的波动，当然一定的波动是能够接受的，但是在某些时候营业额突变得很高或是很低，这就证明公司此时的经营状况出现了问题。经济管理学上定义了一种最小波动值来衡量这种情况： 该天的最小波动值 当最小波动值越大时，就说明营业情况越不稳定。&lt;br&gt;而分析整个公司的从成立到现在营业情况是否稳定，只需要把每一天的最小波动值加起来就可以了。你的任务就是编写一个程序帮助Tiger来计算这一个值。 第一天的最小波动值为第一天的营业额。&lt;br&gt;
    
    </summary>
    
      <category term="OI/ACM" scheme="https://cothrax.github.io/categories/OI-ACM/"/>
    
    
      <category term="数据结构" scheme="https://cothrax.github.io/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"/>
    
      <category term="离线" scheme="https://cothrax.github.io/tags/%E7%A6%BB%E7%BA%BF/"/>
    
      <category term="链表" scheme="https://cothrax.github.io/tags/%E9%93%BE%E8%A1%A8/"/>
    
      <category term="Treap" scheme="https://cothrax.github.io/tags/Treap/"/>
    
      <category term="平衡树" scheme="https://cothrax.github.io/tags/%E5%B9%B3%E8%A1%A1%E6%A0%91/"/>
    
  </entry>
  
  <entry>
    <title>bzoj-1026 [SCOI2009]windy数</title>
    <link href="https://cothrax.github.io/2016/12/10/bzoj-1026/"/>
    <id>https://cothrax.github.io/2016/12/10/bzoj-1026/</id>
    <published>2016-12-10T12:20:17.000Z</published>
    <updated>2016-12-31T11:39:28.236Z</updated>
    
    <content type="html"><![CDATA[<p>windy定义了一种windy数。不含前导零且相邻两个数字之差至少为2的正整数被称为windy数。 windy想知道，<br>在A和B之间，包括A和B，总共有多少个windy数？<br>100%的数据，满足 1 &lt;= A &lt;= B &lt;= 2000000000 。<br><a id="more"></a></p>
<h2 id="链接"><a href="#链接" class="headerlink" title="链接"></a>链接</h2><p><a href="http://www.lydsy.com/JudgeOnline/problem.php?id=1026" target="_blank" rel="external">bzoj-1026</a><br><a href="/2016/12/10/bzoj-1026/1026.cpp" title="1026.cpp">1026.cpp</a></p>
<h2 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h2><p>数位DP入门题<br>推荐<a href="http://wenku.baidu.com/link?url=swqfY1eyFBIywbtd6_WrQnBpIKFVzHysq4KHbC99UfWCvzPJH5k15tj2bVUEqIAWSqmomKYOWemQztBbRl2uEogZd4mO6g7yxL6D2XCgXUq" target="_blank" rel="external">初探数位dp</a>和刘聪的论文《浅谈数位统计类问题》<br>关于本题：<br>记f[i][j]为有i位、最高位为j的所有数中的windy数个数<br>$f[i][j]+=f[i-1][k],|j-k|\geq 2$</p>
<p>关于前导0，由于形如01…这类数是不包含在内的f[i][0]，因为1-0&lt;2的<br>因此可以先统计不含前导0的情况，即最高位k不统计f[k][0]<br>然后考虑含前导0的数，枚举$x&lt;k$，即有k-x位前导0，则将$\sum_{i=1}^{9}f[x][i]$加入答案<br>这个还可以用前缀和优化一下</p>
<h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><figure class="highlight c++"><figcaption><span>1026.cpp</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cmath&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> ll long long</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N=<span class="number">12</span>;</span><br><span class="line">ll f[N][N],sum[N];</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">dp</span><span class="params">(<span class="keyword">int</span> n)</span></span>&#123;</span><br><span class="line">    fill(f[<span class="number">0</span>],f[<span class="number">0</span>]+N,(ll)<span class="number">1</span>);</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;n;i++)</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">0</span>;j&lt;<span class="number">10</span>;j++)</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> k=<span class="number">0</span>;k&lt;<span class="number">10</span>;k++)</span><br><span class="line">                <span class="keyword">if</span>(<span class="built_in">abs</span>(k-j)&gt;=<span class="number">2</span>)f[i][j]+=f[i<span class="number">-1</span>][k];</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;n;i++)</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">1</span>;j&lt;<span class="number">10</span>;j++)sum[i]+=f[i][j];</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;n;i++)sum[i]+=sum[i<span class="number">-1</span>];</span><br><span class="line">&#125;</span><br><span class="line"><span class="function">ll <span class="title">calc</span><span class="params">(ll n)</span></span>&#123;</span><br><span class="line">    ll ret=<span class="number">0</span>;<span class="keyword">int</span> a[N],k=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span>(n)a[k++]=n%<span class="number">10</span>,n/=<span class="number">10</span>;a[k]=<span class="number">20</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=k<span class="number">-1</span>;i&gt;=<span class="number">0</span>;i--)&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">0</span>;j&lt;a[i];j++)</span><br><span class="line">            <span class="keyword">if</span>(<span class="built_in">abs</span>(a[i+<span class="number">1</span>]-j)&gt;=<span class="number">2</span>)ret+=f[i][j];</span><br><span class="line">        <span class="keyword">if</span>(<span class="built_in">abs</span>(a[i+<span class="number">1</span>]-a[i])&lt;<span class="number">2</span>)<span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> ret-f[k<span class="number">-1</span>][<span class="number">0</span>]+sum[k<span class="number">-2</span>];</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="comment">//freopen("in","r",stdin);freopen("out","w",stdout);</span></span><br><span class="line">    ll a,b;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">"%lld %lld"</span>,&amp;a,&amp;b);</span><br><span class="line">    dp((<span class="keyword">int</span>)<span class="built_in">log10</span>(b)+<span class="number">2</span>);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"%lld"</span>,calc(b+<span class="number">1</span>)-calc(a));</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;windy定义了一种windy数。不含前导零且相邻两个数字之差至少为2的正整数被称为windy数。 windy想知道，&lt;br&gt;在A和B之间，包括A和B，总共有多少个windy数？&lt;br&gt;100%的数据，满足 1 &amp;lt;= A &amp;lt;= B &amp;lt;= 2000000000 。&lt;br&gt;
    
    </summary>
    
      <category term="OI/ACM" scheme="https://cothrax.github.io/categories/OI-ACM/"/>
    
    
      <category term="DP" scheme="https://cothrax.github.io/tags/DP/"/>
    
      <category term="数位DP" scheme="https://cothrax.github.io/tags/%E6%95%B0%E4%BD%8DDP/"/>
    
  </entry>
  
  <entry>
    <title>bzoj-1833 [ZJOI2010]数字计数</title>
    <link href="https://cothrax.github.io/2016/12/10/bzoj-1833/"/>
    <id>https://cothrax.github.io/2016/12/10/bzoj-1833/</id>
    <published>2016-12-10T12:12:39.000Z</published>
    <updated>2016-12-31T11:39:28.896Z</updated>
    
    <content type="html"><![CDATA[<p>给定两个正整数a和b，求在[a,b]中的所有整数中，每个数码(digit)各出现了多少次。<br>100%的数据中，a&lt;=b&lt;=10^12。<br><a id="more"></a></p>
<h2 id="链接"><a href="#链接" class="headerlink" title="链接"></a>链接</h2><p><a href="http://www.lydsy.com/JudgeOnline/problem.php?id=1833" target="_blank" rel="external">bzoj-1833</a><br><a href="/2016/12/10/bzoj-1833/1833.cpp" title="1833.cpp">1833.cpp</a></p>
<h2 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h2><p>很像pj的某题<br>数位dp<br>记f[i][j][k]为有i位、最高位为j的数中k出现的次数<br>sum[i][k]为i位数中k出现的次数<br>$f[i][j][k]+=sum[i-1][k]+[j=k]*10^{i-1}$<br>然后处理一下前导0，类似<a href="/2016/12/10/bzoj-1026/" title="bzoj-1026 [SCOI2009]windy数">bzoj-1026 [SCOI2009]windy数</a><br>然后就是套路的从高到低枚举数位统计即可<br>bug:</p>
<ol>
<li>log10写成log2（。。。）</li>
<li>没有注意$10^i$</li>
</ol>
<h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><figure class="highlight c++"><figcaption><span>1833.cpp</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cmath&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> ll long long</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N=<span class="number">16</span>;</span><br><span class="line">ll f[N][N][N],sum[N][N],amt[N][N],b[N]=&#123;<span class="number">1</span>&#125;;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">dp</span><span class="params">(<span class="keyword">int</span> n)</span></span>&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;n;i++)b[i]=b[i<span class="number">-1</span>]*<span class="number">10</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;<span class="number">10</span>;i++)f[<span class="number">0</span>][i][i]=<span class="number">1</span>,sum[<span class="number">0</span>][i]=<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;n;i++)</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">0</span>;j&lt;<span class="number">10</span>;j++)</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> k=<span class="number">0</span>;k&lt;<span class="number">10</span>;k++)</span><br><span class="line">                f[i][j][k]=sum[i<span class="number">-1</span>][k]+(j==k?<span class="number">1</span>:<span class="number">0</span>)*b[i],</span><br><span class="line">                sum[i][k]+=f[i][j][k];</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;n;i++)</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">1</span>;j&lt;<span class="number">10</span>;j++)</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> k=<span class="number">0</span>;k&lt;<span class="number">10</span>;k++)</span><br><span class="line">                amt[i][k]+=f[i][j][k];</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;n;i++)</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">0</span>;j&lt;<span class="number">10</span>;j++)</span><br><span class="line">            amt[i][j]+=amt[i<span class="number">-1</span>][j];</span><br><span class="line">&#125;</span><br><span class="line"><span class="function">ll <span class="title">calc</span><span class="params">(ll n,<span class="keyword">int</span> x)</span></span>&#123;</span><br><span class="line">    ll tmp=n;</span><br><span class="line">    <span class="keyword">int</span> a[N],k=<span class="number">0</span>,cnt=<span class="number">0</span>;ll ret=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span>(n)a[k++]=n%<span class="number">10</span>,n/=<span class="number">10</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=k<span class="number">-1</span>;i&gt;=<span class="number">0</span>;i--)&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j=(i==k<span class="number">-1</span>?<span class="number">1</span>:<span class="number">0</span>);j&lt;a[i];j++)</span><br><span class="line">            ret+=f[i][j][x]+cnt*b[i];</span><br><span class="line">        cnt+=(a[i]==x)?<span class="number">1</span>:<span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> ret+amt[k<span class="number">-2</span>][x];</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="comment">//freopen("in","r",stdin);freopen("out","w",stdout);</span></span><br><span class="line">    ll a,b;<span class="built_in">scanf</span>(<span class="string">"%lld %lld"</span>,&amp;a,&amp;b);</span><br><span class="line">    dp((<span class="keyword">int</span>)<span class="built_in">log10</span>(b)+<span class="number">2</span>);</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;<span class="number">10</span>;i++)&#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"%lld"</span>,calc(b+<span class="number">1</span>,i)-calc(a,i));</span><br><span class="line">        <span class="keyword">if</span>(i&lt;<span class="number">9</span>)<span class="built_in">printf</span>(<span class="string">" "</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//fclose(stdin);fclose(stdout);</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;给定两个正整数a和b，求在[a,b]中的所有整数中，每个数码(digit)各出现了多少次。&lt;br&gt;100%的数据中，a&amp;lt;=b&amp;lt;=10^12。&lt;br&gt;
    
    </summary>
    
      <category term="OI/ACM" scheme="https://cothrax.github.io/categories/OI-ACM/"/>
    
    
      <category term="DP" scheme="https://cothrax.github.io/tags/DP/"/>
    
      <category term="数位DP" scheme="https://cothrax.github.io/tags/%E6%95%B0%E4%BD%8DDP/"/>
    
  </entry>
  
  <entry>
    <title>bzoj-2595 [WC2008] 游览计划</title>
    <link href="https://cothrax.github.io/2016/12/09/bzoj-2595/"/>
    <id>https://cothrax.github.io/2016/12/09/bzoj-2595/</id>
    <published>2016-12-09T14:25:55.000Z</published>
    <updated>2016-12-31T11:45:58.199Z</updated>
    
    <content type="html"><![CDATA[<p>从未来过绍兴的小 D 有幸参加了 Winter Camp 2008,他被这座历史名城的秀丽风景所吸引,强烈要求游览绍兴及其周边的所有景点。<br>主办者将绍兴划分为 N 行 M 列(N×M)个方块,如下图(8×8):</p>
<table>
<thead>
<tr>
<th style="text-align:center">.</th>
<th style="text-align:center">.</th>
<th style="text-align:center">.</th>
<th style="text-align:center">.</th>
<th style="text-align:center">.</th>
<th style="text-align:center">.</th>
<th style="text-align:center">.</th>
<th style="text-align:center">.</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">.</td>
<td style="text-align:center">.</td>
<td style="text-align:center">.</td>
<td style="text-align:center">.</td>
<td style="text-align:center">沈园</td>
<td style="text-align:center">.</td>
<td style="text-align:center">.</td>
<td style="text-align:center">.</td>
</tr>
<tr>
<td style="text-align:center">.</td>
<td style="text-align:center">.</td>
<td style="text-align:center">.</td>
<td style="text-align:center">.</td>
<td style="text-align:center">八字桥</td>
<td style="text-align:center">.</td>
<td style="text-align:center">.</td>
<td style="text-align:center">.</td>
</tr>
<tr>
<td style="text-align:center">.</td>
<td style="text-align:center">.</td>
<td style="text-align:center">.</td>
<td style="text-align:center">周恩来故居</td>
<td style="text-align:center">.</td>
<td style="text-align:center">.</td>
<td style="text-align:center">.</td>
<td style="text-align:center">东湖</td>
</tr>
<tr>
<td style="text-align:center">.</td>
<td style="text-align:center">.</td>
<td style="text-align:center">.</td>
<td style="text-align:center">.</td>
<td style="text-align:center">.</td>
<td style="text-align:center">.</td>
<td style="text-align:center">.</td>
<td style="text-align:center">.</td>
</tr>
<tr>
<td style="text-align:center">.</td>
<td style="text-align:center">.</td>
<td style="text-align:center">.</td>
<td style="text-align:center">.</td>
<td style="text-align:center">.</td>
<td style="text-align:center">大禹陵</td>
<td style="text-align:center">.</td>
<td style="text-align:center">.</td>
</tr>
<tr>
<td style="text-align:center">.</td>
<td style="text-align:center">兰亭</td>
<td style="text-align:center">.</td>
<td style="text-align:center">.</td>
<td style="text-align:center">.</td>
<td style="text-align:center">.</td>
<td style="text-align:center">.</td>
<td style="text-align:center">.</td>
</tr>
<tr>
<td style="text-align:center">鉴湖</td>
<td style="text-align:center">.</td>
<td style="text-align:center">.</td>
<td style="text-align:center">.</td>
<td style="text-align:center">.</td>
<td style="text-align:center">.</td>
<td style="text-align:center">.</td>
<td style="text-align:center">.</td>
</tr>
</tbody>
</table>
<p>景点含于方块内,且一个方块至多有一个景点。无景点的方块视为路。<br>为了保证安全与便利,主办方依据路况和治安状况,在非景点的一些方块内安排不同数量的志愿者;在景点内聘请导游(导游不是志愿者)。<br>在选择旅游方案时,保证任意两个景点之间,存在一条路径,在这条路径所经过的每一个方块都有志愿者或者该方块为景点。既能满足选手们游览的需要,又能够让志愿者的总数最少。<br><a id="more"></a></p>
<table>
<thead>
<tr>
<th style="text-align:center">1</th>
<th style="text-align:center">4</th>
<th style="text-align:center">1</th>
<th style="text-align:center">3</th>
<th style="text-align:center">4</th>
<th style="text-align:center">2</th>
<th style="text-align:center">4</th>
<th style="text-align:center">1</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">4</td>
<td style="text-align:center">3</td>
<td style="text-align:center">1</td>
<td style="text-align:center">2</td>
<td style="text-align:center">沈园</td>
<td style="text-align:center">1</td>
<td style="text-align:center">2</td>
<td style="text-align:center">3</td>
</tr>
<tr>
<td style="text-align:center">3</td>
<td style="text-align:center">2</td>
<td style="text-align:center">1</td>
<td style="text-align:center">3</td>
<td style="text-align:center">八字桥</td>
<td style="text-align:center">3</td>
<td style="text-align:center">1</td>
<td style="text-align:center">2</td>
</tr>
<tr>
<td style="text-align:center">2</td>
<td style="text-align:center">6</td>
<td style="text-align:center">5</td>
<td style="text-align:center">周恩来故居</td>
<td style="text-align:center"><font color="red">2</font></td>
<td style="text-align:center">4</td>
<td style="text-align:center"><font color="red">1</font></td>
<td style="text-align:center">东湖</td>
</tr>
<tr>
<td style="text-align:center">5</td>
<td style="text-align:center">1</td>
<td style="text-align:center">2</td>
<td style="text-align:center"><font color="red">1</font></td>
<td style="text-align:center"><font color="red">3</font></td>
<td style="text-align:center"><font color="red">4</font></td>
<td style="text-align:center"><font color="red">2</font></td>
<td style="text-align:center">5</td>
</tr>
<tr>
<td style="text-align:center">5</td>
<td style="text-align:center"><font color="red">1</font></td>
<td style="text-align:center"><font color="red">3</font></td>
<td style="text-align:center"><font color="red">1</font></td>
<td style="text-align:center">5</td>
<td style="text-align:center">大禹陵</td>
<td style="text-align:center">1</td>
<td style="text-align:center">4</td>
</tr>
<tr>
<td style="text-align:center">5</td>
<td style="text-align:center">兰亭</td>
<td style="text-align:center">6</td>
<td style="text-align:center">1</td>
<td style="text-align:center">4</td>
<td style="text-align:center">5</td>
<td style="text-align:center">3</td>
<td style="text-align:center">4</td>
</tr>
<tr>
<td style="text-align:center">鉴湖</td>
<td style="text-align:center"><font color="red">2</font></td>
<td style="text-align:center">2</td>
<td style="text-align:center">2</td>
<td style="text-align:center">3</td>
<td style="text-align:center">4</td>
<td style="text-align:center">1</td>
<td style="text-align:center">1</td>
</tr>
</tbody>
</table>
<p>例如,在上面的例子中,在每个没有景点的方块中填入一个数字,表示控制该方块最少需要的志愿者数目:</p>
<p>图中用深色标出的方块区域就是一种可行的志愿者安排方案,一共需要 20名志愿者。由图可见,两个相邻的景点是直接(有景点内的路)连通的(如沈园和八字桥)。<br>现在,希望你能够帮助主办方找到一种最好的安排方案。</p>
<p>$n,m,k\leq 10$</p>
<h2 id="链接"><a href="#链接" class="headerlink" title="链接"></a>链接</h2><p><a href="http://www.lydsy.com/JudgeOnline/problem.php?id=2595" target="_blank" rel="external">bzoj-2595</a><br><a href="/2016/12/09/bzoj-2595/2595.cpp" title="2595.cpp">2595.cpp</a></p>
<h2 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h2><p>斯坦纳树，即经过定点的最小生成树，换句话说，就是在生成树的过程中允许新增一些点来最小化代价<br>首先可以给格子(x,y)编号x*m+y<br>景点数≤10，可以状压dp解决<br>记f[i][s] 为生成树根为i，连通状态至少为s的最小代价，其中s(x)表示i是否与第x个景点连通<br>初始状态：记sp[i]为第i个景点，则$f[sp[i]][2^i]=0$<br>然后转移：<br>$f[i][s]=min(f[i][s]+f[i][s-t]-a[i]),t\in s$<br>$f[i][s]=min(f[j][s]+a[i]),\exists e(j\to i)$</p>
<p>前一个直接枚举子集（手贱把枚举子集码成了枚举lowbit,wa一次）<br>至于后一个，由于这个方程的转移中有环，但最优解的转移一定是拓扑的，所以用多源点的spfa解决<br>dp之后任意$f[sp[i]][2^k-1]$都是最优答案<br>至于输出方案，用pre[i][s]记录f[i][s]是由哪个状态转移过来的，dfs一下即可</p>
<h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><figure class="highlight c++"><figcaption><span>2595.cpp</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> P pair<span class="meta-string">&lt;int,int&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> mkp(x,y) make_pair(x,y)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> ll long long</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N=<span class="number">11</span>,Z=N*N*<span class="number">2</span>;<span class="keyword">const</span> ll INF=<span class="number">10E16</span>;</span><br><span class="line"><span class="keyword">int</span> n,m,nm,l;ll a[N*N];</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">int</span> <span class="title">p</span><span class="params">(<span class="keyword">int</span> x,<span class="keyword">int</span> y)</span></span>&#123;<span class="keyword">return</span> x*m+y;&#125;</span><br><span class="line"></span><br><span class="line">P pre[N*N][<span class="number">1</span>&lt;&lt;N];ll f[N*N][<span class="number">1</span>&lt;&lt;N];</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> X[<span class="number">4</span>]=&#123;<span class="number">0</span>,<span class="number">1</span>,<span class="number">0</span>,<span class="number">-1</span>&#125;,Y[<span class="number">4</span>]=&#123;<span class="number">1</span>,<span class="number">0</span>,<span class="number">-1</span>,<span class="number">0</span>&#125;;</span><br><span class="line"><span class="keyword">int</span> q[Z],h,t;<span class="keyword">bool</span> inq[Z];</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">spfa</span><span class="params">(<span class="keyword">int</span> i)</span></span>&#123;</span><br><span class="line">    <span class="keyword">for</span>(;h!=t;inq[q[h]]=<span class="number">0</span>,h=(h+<span class="number">1</span>)%Z)</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">0</span>;j&lt;<span class="number">4</span>;j++)&#123;</span><br><span class="line">            <span class="keyword">int</span> u=q[h],x=u/m+X[j],y=u%m+Y[j],v=p(x,y);</span><br><span class="line">            <span class="keyword">if</span>(x&lt;<span class="number">0</span>||y&lt;<span class="number">0</span>||x&gt;=n||y&gt;=m)<span class="keyword">continue</span>;</span><br><span class="line">            <span class="keyword">if</span>(f[v][i]&gt;f[u][i]+a[v])&#123;</span><br><span class="line">                f[v][i]=f[u][i]+a[v];pre[v][i]=mkp(u,i);</span><br><span class="line">                <span class="keyword">if</span>(!inq[v])q[t++]=v,inq[v]=<span class="number">1</span>,t%=Z;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">bool</span> flg[Z];</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">dfs</span><span class="params">(<span class="keyword">int</span> i,<span class="keyword">int</span> j)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(f[i][j]==INF||i==<span class="number">-1</span>||j==<span class="number">0</span>)<span class="keyword">return</span>;</span><br><span class="line">    flg[i]=<span class="number">1</span>;<span class="keyword">int</span> x,y;</span><br><span class="line">    dfs(x=pre[i][j].first,y=pre[i][j].second);</span><br><span class="line">    <span class="keyword">if</span>(x==i)dfs(x,y^j);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="comment">//freopen("in","r",stdin);freopen("out","w",stdout);</span></span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">"%d %d"</span>,&amp;n,&amp;m);nm=n*m;</span><br><span class="line">    <span class="keyword">int</span> sp[N],k=<span class="number">0</span>;<span class="keyword">bool</span> mk[Z];</span><br><span class="line">    fill(mk,mk+Z,<span class="number">0</span>);</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;n;i++)</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">0</span>;j&lt;m;j++)&#123;</span><br><span class="line">            <span class="built_in">scanf</span>(<span class="string">"%lld"</span>,&amp;a[p(i,j)]);</span><br><span class="line">            <span class="keyword">if</span>(!a[p(i,j)])sp[k++]=p(i,j),mk[p(i,j)]=<span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    l=<span class="number">1</span>&lt;&lt;k;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;nm;i++)&#123;</span><br><span class="line">        fill(f[i],f[i]+l+<span class="number">1</span>,INF);</span><br><span class="line">        fill(pre[i],pre[i]+l+<span class="number">1</span>,mkp(<span class="number">-1</span>,<span class="number">0</span>));</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;k;i++)f[sp[i]][<span class="number">1</span>&lt;&lt;i]=<span class="number">0</span>;</span><br><span class="line">    fill(inq,inq+Z,<span class="number">0</span>);</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;l;i++)&#123;</span><br><span class="line">        ll tmp;h=t=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">0</span>;j&lt;nm;j++)&#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> s=i;s;s=i&amp;(s<span class="number">-1</span>))</span><br><span class="line">                <span class="keyword">if</span>(f[j][i]&gt;(tmp=f[j][s]+f[j][i^s]-a[j]))</span><br><span class="line">                    f[j][i]=tmp,pre[j][i]=mkp(j,s);</span><br><span class="line">            <span class="keyword">if</span>(f[j][i]!=INF)q[t++]=j,inq[j]=<span class="number">1</span>,t%=Z;</span><br><span class="line">        &#125;spfa(i);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"%lld\n"</span>,f[sp[<span class="number">0</span>]][l<span class="number">-1</span>]);dfs(sp[<span class="number">0</span>],l<span class="number">-1</span>);</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;n;i++)&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">0</span>;j&lt;m;j++)</span><br><span class="line">            <span class="keyword">if</span>(mk[p(i,j)])<span class="built_in">printf</span>(<span class="string">"x"</span>);</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span>(flg[p(i,j)])<span class="built_in">printf</span>(<span class="string">"o"</span>);</span><br><span class="line">            <span class="keyword">else</span> <span class="built_in">printf</span>(<span class="string">"_"</span>);</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"\n"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;从未来过绍兴的小 D 有幸参加了 Winter Camp 2008,他被这座历史名城的秀丽风景所吸引,强烈要求游览绍兴及其周边的所有景点。&lt;br&gt;主办者将绍兴划分为 N 行 M 列(N×M)个方块,如下图(8×8):&lt;/p&gt;
&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th style=&quot;text-align:center&quot;&gt;.&lt;/th&gt;
&lt;th style=&quot;text-align:center&quot;&gt;.&lt;/th&gt;
&lt;th style=&quot;text-align:center&quot;&gt;.&lt;/th&gt;
&lt;th style=&quot;text-align:center&quot;&gt;.&lt;/th&gt;
&lt;th style=&quot;text-align:center&quot;&gt;.&lt;/th&gt;
&lt;th style=&quot;text-align:center&quot;&gt;.&lt;/th&gt;
&lt;th style=&quot;text-align:center&quot;&gt;.&lt;/th&gt;
&lt;th style=&quot;text-align:center&quot;&gt;.&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td style=&quot;text-align:center&quot;&gt;.&lt;/td&gt;
&lt;td style=&quot;text-align:center&quot;&gt;.&lt;/td&gt;
&lt;td style=&quot;text-align:center&quot;&gt;.&lt;/td&gt;
&lt;td style=&quot;text-align:center&quot;&gt;.&lt;/td&gt;
&lt;td style=&quot;text-align:center&quot;&gt;沈园&lt;/td&gt;
&lt;td style=&quot;text-align:center&quot;&gt;.&lt;/td&gt;
&lt;td style=&quot;text-align:center&quot;&gt;.&lt;/td&gt;
&lt;td style=&quot;text-align:center&quot;&gt;.&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td style=&quot;text-align:center&quot;&gt;.&lt;/td&gt;
&lt;td style=&quot;text-align:center&quot;&gt;.&lt;/td&gt;
&lt;td style=&quot;text-align:center&quot;&gt;.&lt;/td&gt;
&lt;td style=&quot;text-align:center&quot;&gt;.&lt;/td&gt;
&lt;td style=&quot;text-align:center&quot;&gt;八字桥&lt;/td&gt;
&lt;td style=&quot;text-align:center&quot;&gt;.&lt;/td&gt;
&lt;td style=&quot;text-align:center&quot;&gt;.&lt;/td&gt;
&lt;td style=&quot;text-align:center&quot;&gt;.&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td style=&quot;text-align:center&quot;&gt;.&lt;/td&gt;
&lt;td style=&quot;text-align:center&quot;&gt;.&lt;/td&gt;
&lt;td style=&quot;text-align:center&quot;&gt;.&lt;/td&gt;
&lt;td style=&quot;text-align:center&quot;&gt;周恩来故居&lt;/td&gt;
&lt;td style=&quot;text-align:center&quot;&gt;.&lt;/td&gt;
&lt;td style=&quot;text-align:center&quot;&gt;.&lt;/td&gt;
&lt;td style=&quot;text-align:center&quot;&gt;.&lt;/td&gt;
&lt;td style=&quot;text-align:center&quot;&gt;东湖&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td style=&quot;text-align:center&quot;&gt;.&lt;/td&gt;
&lt;td style=&quot;text-align:center&quot;&gt;.&lt;/td&gt;
&lt;td style=&quot;text-align:center&quot;&gt;.&lt;/td&gt;
&lt;td style=&quot;text-align:center&quot;&gt;.&lt;/td&gt;
&lt;td style=&quot;text-align:center&quot;&gt;.&lt;/td&gt;
&lt;td style=&quot;text-align:center&quot;&gt;.&lt;/td&gt;
&lt;td style=&quot;text-align:center&quot;&gt;.&lt;/td&gt;
&lt;td style=&quot;text-align:center&quot;&gt;.&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td style=&quot;text-align:center&quot;&gt;.&lt;/td&gt;
&lt;td style=&quot;text-align:center&quot;&gt;.&lt;/td&gt;
&lt;td style=&quot;text-align:center&quot;&gt;.&lt;/td&gt;
&lt;td style=&quot;text-align:center&quot;&gt;.&lt;/td&gt;
&lt;td style=&quot;text-align:center&quot;&gt;.&lt;/td&gt;
&lt;td style=&quot;text-align:center&quot;&gt;大禹陵&lt;/td&gt;
&lt;td style=&quot;text-align:center&quot;&gt;.&lt;/td&gt;
&lt;td style=&quot;text-align:center&quot;&gt;.&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td style=&quot;text-align:center&quot;&gt;.&lt;/td&gt;
&lt;td style=&quot;text-align:center&quot;&gt;兰亭&lt;/td&gt;
&lt;td style=&quot;text-align:center&quot;&gt;.&lt;/td&gt;
&lt;td style=&quot;text-align:center&quot;&gt;.&lt;/td&gt;
&lt;td style=&quot;text-align:center&quot;&gt;.&lt;/td&gt;
&lt;td style=&quot;text-align:center&quot;&gt;.&lt;/td&gt;
&lt;td style=&quot;text-align:center&quot;&gt;.&lt;/td&gt;
&lt;td style=&quot;text-align:center&quot;&gt;.&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td style=&quot;text-align:center&quot;&gt;鉴湖&lt;/td&gt;
&lt;td style=&quot;text-align:center&quot;&gt;.&lt;/td&gt;
&lt;td style=&quot;text-align:center&quot;&gt;.&lt;/td&gt;
&lt;td style=&quot;text-align:center&quot;&gt;.&lt;/td&gt;
&lt;td style=&quot;text-align:center&quot;&gt;.&lt;/td&gt;
&lt;td style=&quot;text-align:center&quot;&gt;.&lt;/td&gt;
&lt;td style=&quot;text-align:center&quot;&gt;.&lt;/td&gt;
&lt;td style=&quot;text-align:center&quot;&gt;.&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;p&gt;景点含于方块内,且一个方块至多有一个景点。无景点的方块视为路。&lt;br&gt;为了保证安全与便利,主办方依据路况和治安状况,在非景点的一些方块内安排不同数量的志愿者;在景点内聘请导游(导游不是志愿者)。&lt;br&gt;在选择旅游方案时,保证任意两个景点之间,存在一条路径,在这条路径所经过的每一个方块都有志愿者或者该方块为景点。既能满足选手们游览的需要,又能够让志愿者的总数最少。&lt;br&gt;
    
    </summary>
    
      <category term="OI/ACM" scheme="https://cothrax.github.io/categories/OI-ACM/"/>
    
    
      <category term="DP" scheme="https://cothrax.github.io/tags/DP/"/>
    
      <category term="图论" scheme="https://cothrax.github.io/tags/%E5%9B%BE%E8%AE%BA/"/>
    
      <category term="状压DP" scheme="https://cothrax.github.io/tags/%E7%8A%B6%E5%8E%8BDP/"/>
    
      <category term="斯坦纳树" scheme="https://cothrax.github.io/tags/%E6%96%AF%E5%9D%A6%E7%BA%B3%E6%A0%91/"/>
    
  </entry>
  
  <entry>
    <title>bzoj-2004 [HNOI2010]Bus 公交线路</title>
    <link href="https://cothrax.github.io/2016/12/09/bzoj-2004/"/>
    <id>https://cothrax.github.io/2016/12/09/bzoj-2004/</id>
    <published>2016-12-09T11:21:31.000Z</published>
    <updated>2016-12-31T11:39:28.901Z</updated>
    
    <content type="html"><![CDATA[<p>小Z所在的城市有N个公交车站，排列在一条长(N-1)km的直线上，从左到右依次编号为1到N，相邻公交车站间的距<br>离均为1km。 作为公交车线路的规划者，小Z调查了市民的需求，决定按下述规则设计线路：</p>
<ol>
<li>设共K辆公交车，则1到K号站作为始发站，N-K+1到N号台作为终点站。</li>
<li>每个车站必须被一辆且仅一辆公交车经过（始发站和<br>终点站也算被经过）。 </li>
<li>公交车只能从编号较小的站台驶往编号较大的站台。 </li>
<li>一辆公交车经过的相邻两个站台间距离不得超过Pkm</li>
</ol>
<p>在最终设计线路之前，小Z想知道有多少种满足要求的方案。由于答案可能很大，你只<br>需求出答案对30031取模的结果。</p>
<span>$N\leq 10^9,1&lt;P\leq 10,K&lt;N,2&lt;K\leq P$</span><!-- Has MathJax -->
<a id="more"></a>
<h2 id="链接"><a href="#链接" class="headerlink" title="链接"></a>链接</h2><p><a href="http://www.lydsy.com/JudgeOnline/problem.php?id=2004" target="_blank" rel="external">bzoj-2004</a><br><a href="/2016/12/09/bzoj-2004/2004.cpp" title="2004.cpp">2004.cpp</a></p>
<h2 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h2><p>状压dp+矩阵快速幂<br>直接状压+矩乘$O(2^{3P}logN)$是会T的<br>实际上最低位不是1、1的个数!=k的状态都是无效的<br>预处理有效状态，再构造矩阵就好</p>
<h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><figure class="highlight c++"><figcaption><span>2004.cpp</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N=<span class="number">200</span>,M=<span class="number">2050</span>,Z=<span class="number">30031</span>;</span><br><span class="line"><span class="keyword">int</span> n,k,p,m,t=<span class="number">0</span>,cnt[M],a[M],loc[M];</span><br><span class="line"><span class="keyword">struct</span> mat&#123;</span><br><span class="line">    <span class="keyword">int</span> v[N][N];</span><br><span class="line">    mat()&#123;<span class="built_in">memset</span>(v,<span class="number">0</span>,<span class="keyword">sizeof</span>(v));&#125;</span><br><span class="line">    <span class="keyword">friend</span> mat <span class="keyword">operator</span>*(mat a,mat b)&#123;</span><br><span class="line">        mat ret;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;t;i++)</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">0</span>;j&lt;t;j++)</span><br><span class="line">                <span class="keyword">for</span>(<span class="keyword">int</span> k=<span class="number">0</span>;k&lt;t;k++)</span><br><span class="line">                    ret.v[i][j]+=a.v[i][k]*b.v[k][j],</span><br><span class="line">                    ret.v[i][j]%=Z;</span><br><span class="line">        <span class="keyword">return</span> ret;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">friend</span> mat <span class="keyword">operator</span>^(mat a,<span class="keyword">int</span> n)&#123;</span><br><span class="line">        mat ret;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;t;i++)ret.v[i][i]=<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span>(;n;n&gt;&gt;=<span class="number">1</span>,a=a*a)<span class="keyword">if</span>(n&amp;<span class="number">1</span>)ret=ret*a;</span><br><span class="line">        <span class="keyword">return</span> ret;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;f;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="comment">//freopen("in","r",stdin);</span></span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">"%d %d %d"</span>,&amp;n,&amp;k,&amp;p);m=<span class="number">1</span>&lt;&lt;p;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;m;i++)cnt[i]=cnt[i&amp;(i<span class="number">-1</span>)]+<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;m;i++)</span><br><span class="line">        <span class="keyword">if</span>(cnt[i]==k&amp;&amp;(i&amp;<span class="number">1</span>))loc[i]=t,a[t++]=i;</span><br><span class="line">        <span class="keyword">else</span> loc[i]=N<span class="number">-1</span>;</span><br><span class="line">    <span class="comment">//printf("%d\n",t);</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;t;i++)&#123;</span><br><span class="line">        <span class="keyword">int</span> x=a[i];</span><br><span class="line">        f.v[loc[(x&lt;&lt;<span class="number">1</span>)&amp;(m<span class="number">-1</span>)|<span class="number">1</span>]][i]=<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">if</span>(x&gt;&gt;(p<span class="number">-1</span>))<span class="keyword">continue</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">1</span>;j&lt;m;j&lt;&lt;=<span class="number">1</span>)f.v[loc[(x&lt;&lt;<span class="number">1</span>)^j|<span class="number">1</span>]][i]=<span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">int</span> st=loc[(<span class="number">1</span>&lt;&lt;k)<span class="number">-1</span>];</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"%d"</span>,(f^(n-k)).v[st][st]);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;小Z所在的城市有N个公交车站，排列在一条长(N-1)km的直线上，从左到右依次编号为1到N，相邻公交车站间的距&lt;br&gt;离均为1km。 作为公交车线路的规划者，小Z调查了市民的需求，决定按下述规则设计线路：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;设共K辆公交车，则1到K号站作为始发站，N-K+1到N号台作为终点站。&lt;/li&gt;
&lt;li&gt;每个车站必须被一辆且仅一辆公交车经过（始发站和&lt;br&gt;终点站也算被经过）。 &lt;/li&gt;
&lt;li&gt;公交车只能从编号较小的站台驶往编号较大的站台。 &lt;/li&gt;
&lt;li&gt;一辆公交车经过的相邻两个站台间距离不得超过Pkm&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;在最终设计线路之前，小Z想知道有多少种满足要求的方案。由于答案可能很大，你只&lt;br&gt;需求出答案对30031取模的结果。&lt;/p&gt;
&lt;span&gt;$N\leq 10^9,1&amp;lt;P\leq 10,K&amp;lt;N,2&amp;lt;K\leq P$&lt;/span&gt;&lt;!-- Has MathJax --&gt;
    
    </summary>
    
      <category term="OI/ACM" scheme="https://cothrax.github.io/categories/OI-ACM/"/>
    
    
      <category term="DP" scheme="https://cothrax.github.io/tags/DP/"/>
    
      <category term="状压DP" scheme="https://cothrax.github.io/tags/%E7%8A%B6%E5%8E%8BDP/"/>
    
      <category term="矩阵" scheme="https://cothrax.github.io/tags/%E7%9F%A9%E9%98%B5/"/>
    
  </entry>
  
  <entry>
    <title>bzoj-1097 [POI2007]旅游景点atr</title>
    <link href="https://cothrax.github.io/2016/12/09/bzoj-1097/"/>
    <id>https://cothrax.github.io/2016/12/09/bzoj-1097/</id>
    <published>2016-12-09T11:11:26.000Z</published>
    <updated>2016-12-31T11:39:28.240Z</updated>
    
    <content type="html"><![CDATA[<p>大意：给定n个节点，m条边的带权无向图，要最小化这样一条路径的代价：</p>
<ol>
<li>从点1出发</li>
<li>经过点2..k+1，顺序有一定的要求</li>
<li>终点为n</li>
</ol>
<p>$n\leq 20000,m\leq 200000,k\leq 20$</p>
<a id="more"></a>
<h2 id="链接"><a href="#链接" class="headerlink" title="链接"></a>链接</h2><p><a href="http://hzwer.com/4742.html" target="_blank" rel="external">hzwer</a><br><a href="/2016/12/09/bzoj-1097/atr.cpp" title="atr.cpp">atr.cpp</a></p>
<h2 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h2><p>先处理1..k+1及n之间的最短路<br>然后状压dp，记f[s][i]为状态为s，s(x)表示第x个点是否已经经过，i为这条路径终点<br>转移直接枚举补集中的点即可</p>
<h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><figure class="highlight c++"><figcaption><span>atr.cpp</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;queue&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> P pair<span class="meta-string">&lt;int,int&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> mkp(x,y) make_pair(x,y)</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N=<span class="number">20010</span>,M=<span class="number">400010</span>,K=<span class="number">25</span>,L=<span class="number">1</span>&lt;&lt;<span class="number">21</span>,INF=<span class="number">10E8</span>;</span><br><span class="line"><span class="keyword">struct</span> edge&#123;<span class="keyword">int</span> v,w,nxt;&#125; g[M];</span><br><span class="line"><span class="keyword">int</span> head[N],d[N],a[K][K],f[L][K],bf[K],af[K],b[K];</span><br><span class="line"><span class="keyword">int</span> n,m,k,t,l,sz=<span class="number">0</span>;</span><br><span class="line"><span class="keyword">bool</span> flg[N];</span><br><span class="line"><span class="keyword">void</span> _add(<span class="keyword">int</span> u,<span class="keyword">int</span> v,<span class="keyword">int</span> w)</span><br><span class="line">&#123;g[++sz]=&#123;v,w,head[u]&#125;;head[u]=sz;&#125;;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">add</span><span class="params">(<span class="keyword">int</span> u,<span class="keyword">int</span> v,<span class="keyword">int</span> w)</span></span><br><span class="line"></span>&#123;_add(u,v,w);_add(v,u,w);&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">dij</span><span class="params">(<span class="keyword">int</span> s)</span></span>&#123;</span><br><span class="line">    priority_queue&lt;P,<span class="built_in">vector</span>&lt;P&gt;,greater&lt;P&gt; &gt;q;</span><br><span class="line">    fill(d,d+n+<span class="number">1</span>,INF);fill(flg,flg+n+<span class="number">1</span>,<span class="literal">false</span>);</span><br><span class="line">    d[s]=<span class="number">0</span>;q.push(mkp(<span class="number">0</span>,s));</span><br><span class="line">    <span class="keyword">while</span>(!q.empty())&#123;</span><br><span class="line">        <span class="keyword">int</span> u=q.top().second,v;q.pop();</span><br><span class="line">        <span class="keyword">if</span>(flg[u])<span class="keyword">continue</span>;flg[u]=<span class="literal">true</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=head[u];i;i=g[i].nxt)</span><br><span class="line">            <span class="keyword">if</span>(d[u]+g[i].w&lt;d[v=g[i].v])</span><br><span class="line">                d[v]=d[u]+g[i].w,q.push(mkp(d[v],v));</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=k+<span class="number">1</span>;i++)a[s][i]=d[i];</span><br><span class="line">    a[s][<span class="number">0</span>]=d[n];</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">bool</span> <span class="title">jud</span><span class="params">(<span class="keyword">int</span> x,<span class="keyword">int</span> i)</span></span><br><span class="line"></span>&#123;<span class="keyword">return</span> (x&amp;bf[i])==bf[i]&amp;&amp;(x&amp;af[i])==<span class="number">0</span>;&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="comment">//freopen("atr9b.in","r",stdin);freopen("out","w",stdout);</span></span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">"%d %d %d\n"</span>,&amp;n,&amp;m,&amp;k);</span><br><span class="line">    <span class="keyword">int</span> u,v,w;l=<span class="number">1</span>&lt;&lt;k;b[<span class="number">2</span>]=<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">3</span>;i&lt;=k+<span class="number">1</span>;i++)b[i]=b[i<span class="number">-1</span>]&lt;&lt;<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;m;i++)</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">"%d %d %d\n"</span>,&amp;u,&amp;v,&amp;w),add(u,v,w);</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">2</span>;i&lt;=k+<span class="number">1</span>;i++)dij(i);</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">"%d\n"</span>,&amp;t);</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;t;i++)&#123;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">"%d %d\n"</span>,&amp;u,&amp;v);</span><br><span class="line">        bf[v]|=b[u];af[u]|=b[v];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;l;i++)</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">2</span>;j&lt;=k+<span class="number">1</span>;j++)f[i][j]=INF;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">2</span>;i&lt;=k+<span class="number">1</span>;i++)</span><br><span class="line">        <span class="keyword">if</span>(!bf[i])f[b[i]][i]=a[i][<span class="number">1</span>]<span class="comment">/*,printf("%d, ",i)*/</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;l;i++)</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">2</span>;j&lt;=k+<span class="number">1</span>;j++)<span class="keyword">if</span>(f[i][j]!=INF)</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> p=<span class="number">2</span>;p&lt;=k+<span class="number">1</span>;p++)<span class="keyword">if</span>(!(i&amp;b[p])&amp;&amp;jud(i,p))</span><br><span class="line">                f[i|b[p]][p]=min(f[i|b[p]][p],f[i][j]+a[j][p]);</span><br><span class="line">    <span class="keyword">int</span> ans=INF;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">2</span>;i&lt;=k+<span class="number">1</span>;i++)ans=min(ans,f[l<span class="number">-1</span>][i]+a[i][<span class="number">0</span>]);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"%d"</span>,ans);</span><br><span class="line">    <span class="comment">//fclose(stdin);fclose(stdout);</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;大意：给定n个节点，m条边的带权无向图，要最小化这样一条路径的代价：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;从点1出发&lt;/li&gt;
&lt;li&gt;经过点2..k+1，顺序有一定的要求&lt;/li&gt;
&lt;li&gt;终点为n&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;$n\leq 20000,m\leq 200000,k\leq 20$&lt;/p&gt;
    
    </summary>
    
      <category term="OI/ACM" scheme="https://cothrax.github.io/categories/OI-ACM/"/>
    
    
      <category term="DP" scheme="https://cothrax.github.io/tags/DP/"/>
    
      <category term="图论" scheme="https://cothrax.github.io/tags/%E5%9B%BE%E8%AE%BA/"/>
    
      <category term="最短路" scheme="https://cothrax.github.io/tags/%E6%9C%80%E7%9F%AD%E8%B7%AF/"/>
    
      <category term="状压DP" scheme="https://cothrax.github.io/tags/%E7%8A%B6%E5%8E%8BDP/"/>
    
  </entry>
  
  <entry>
    <title>bzoj-2734 [HNOI2012]集合选数</title>
    <link href="https://cothrax.github.io/2016/12/09/bzoj-2734/"/>
    <id>https://cothrax.github.io/2016/12/09/bzoj-2734/</id>
    <published>2016-12-09T11:06:32.000Z</published>
    <updated>2016-12-31T11:42:21.751Z</updated>
    
    <content type="html"><![CDATA[<p>约束条件：若x在集合s中，则2x和3x不能在该集合中。<br>对于任意一个正整数 n≤100000，如何求出{1, 2,…, n} 的满足上述约束条件的子集的个数（只需输出对 1,000,000,001 取模的结果）。<br>n≤20</p>
<a id="more"></a>
<h2 id="链接"><a href="#链接" class="headerlink" title="链接"></a>链接</h2><p><a href="http://www.lydsy.com/JudgeOnline/problem.php?id=1013" target="_blank" rel="external">bzoj-2734</a><br><a href="/2016/12/09/bzoj-2734/2734.cpp" title="2734.cpp">2734.cpp</a></p>
<h2 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h2><p>基于状压dp的想法题<br>详见：<a href="http://hzwer.com/5149.html" target="_blank" rel="external">hzwer</a></p>
<h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><figure class="highlight c++"><figcaption><span>2734.cpp</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> ll long long</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N=<span class="number">100050</span>,K=<span class="number">20</span>,Z=<span class="number">1E9</span>+<span class="number">1</span>;</span><br><span class="line"><span class="keyword">int</span> n,m=<span class="number">0</span>,b[K]=&#123;<span class="number">1</span>&#125;,h[<span class="number">1</span>&lt;&lt;K],f[K][<span class="number">1</span>&lt;&lt;K];</span><br><span class="line"><span class="keyword">bool</span> flg[N];</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">calc</span><span class="params">(<span class="keyword">int</span> x)</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> cnt=<span class="number">0</span>,a[K];<span class="built_in">memset</span>(a,<span class="number">0</span>,<span class="keyword">sizeof</span>(a));</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=x;i&lt;=n;i*=<span class="number">2</span>,cnt++)</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j=i;j&lt;=n;j*=<span class="number">3</span>)</span><br><span class="line">            a[cnt+<span class="number">1</span>]++,flg[j]=<span class="literal">true</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=cnt;i++)fill(f[i],f[i]+b[a[i]],<span class="number">0</span>);</span><br><span class="line">    f[<span class="number">0</span>][<span class="number">0</span>]=<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;=cnt;i++)</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">0</span>;h[j]&lt;b[a[i]]&amp;&amp;j&lt;m;j++)<span class="keyword">if</span>(f[i][j])</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> k=<span class="number">0</span>;h[k]&lt;b[a[i+<span class="number">1</span>]]&amp;&amp;k&lt;m;k++)</span><br><span class="line">                <span class="keyword">if</span>(!(h[k]&amp;(h[k]&lt;&lt;<span class="number">1</span>))&amp;&amp;!(h[k]&amp;h[j]))</span><br><span class="line">                    f[i+<span class="number">1</span>][k]=((ll)f[i+<span class="number">1</span>][k]+(ll)f[i][j])%Z;</span><br><span class="line">    <span class="keyword">int</span> ret=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;h[i]&lt;b[a[cnt]]&amp;&amp;i&lt;m;i++)</span><br><span class="line">        ret=((ll)ret+(ll)f[cnt][i])%Z;</span><br><span class="line">    <span class="keyword">return</span> ret;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="comment">//freopen("in","r",stdin);</span></span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">"%d"</span>,&amp;n);<span class="keyword">int</span> ans=<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;K;i++)b[i]=b[i<span class="number">-1</span>]&lt;&lt;<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;<span class="number">1</span>&lt;&lt;K;i++)<span class="keyword">if</span>(!(i&amp;(i&lt;&lt;<span class="number">1</span>)))h[m++]=i;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;i++)<span class="keyword">if</span>(!flg[i])ans=((ll)ans*(ll)calc(i))%Z;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"%d"</span>,ans);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;约束条件：若x在集合s中，则2x和3x不能在该集合中。&lt;br&gt;对于任意一个正整数 n≤100000，如何求出{1, 2,…, n} 的满足上述约束条件的子集的个数（只需输出对 1,000,000,001 取模的结果）。&lt;br&gt;n≤20&lt;/p&gt;
    
    </summary>
    
      <category term="OI/ACM" scheme="https://cothrax.github.io/categories/OI-ACM/"/>
    
    
      <category term="DP" scheme="https://cothrax.github.io/tags/DP/"/>
    
      <category term="状压DP" scheme="https://cothrax.github.io/tags/%E7%8A%B6%E5%8E%8BDP/"/>
    
      <category term="想法题" scheme="https://cothrax.github.io/tags/%E6%83%B3%E6%B3%95%E9%A2%98/"/>
    
  </entry>
  
  <entry>
    <title>bzoj-2964 分裂</title>
    <link href="https://cothrax.github.io/2016/12/09/bzoj-2064/"/>
    <id>https://cothrax.github.io/2016/12/09/bzoj-2064/</id>
    <published>2016-12-09T10:59:59.000Z</published>
    <updated>2016-12-31T11:39:28.903Z</updated>
    
    <content type="html"><![CDATA[<p> 中国历史上上分分和和次数非常多。。通读中国历史的WJMZBMR表示毫无压力。 同时经常搞OI的他把这个变成了一个数学模型。 假设中国的国土总和是不变的。 每个国家都可以用他的国土面积代替， 又两种可能，一种是两个国家合并为1个，那么新国家的面积为两者之和。 一种是一个国家分裂为2个，那么2个新国家的面积之和为原国家的面积。 WJMZBMR现在知道了很遥远的过去中国的状态，又知道了中国现在的状态，想知道至少要几次操作（分裂和合并各算一次操作），能让中国从当时状态到达现在的状态。<br>$n1,n2\leq 10$<br><a id="more"></a></p>
<h2 id="链接"><a href="#链接" class="headerlink" title="链接"></a>链接</h2><p><a href="http://hzwer.com/2001.html" target="_blank" rel="external">hzwer</a><br><a href="/2016/12/09/bzoj-2064/2064.cpp" title="2064.cpp">2064.cpp</a></p>
<h2 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h2><p>基于状压dp的想法题<br>见：<a href="http://www.cnblogs.com/xkui/p/4540093.html" target="_blank" rel="external">神犇的blog</a></p>
<h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><figure class="highlight c++"><figcaption><span>2064.cpp</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N=<span class="number">25</span>,M=<span class="number">1</span>&lt;&lt;<span class="number">21</span>;</span><br><span class="line"><span class="keyword">int</span> n=<span class="number">0</span>,m,a[N],b[N]=&#123;<span class="number">1</span>&#125;,s[M],f[M];</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">"%d"</span>,&amp;n);</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;n;i++)<span class="built_in">scanf</span>(<span class="string">"%d"</span>,&amp;a[i]);</span><br><span class="line">    <span class="keyword">int</span> x;<span class="built_in">scanf</span>(<span class="string">"%d"</span>,&amp;x);n+=x;m=<span class="number">1</span>&lt;&lt;n;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=n-x;i&lt;n;i++)<span class="built_in">scanf</span>(<span class="string">"%d"</span>,&amp;a[i]),a[i]*=<span class="number">-1</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;n;i++)b[i]=b[i<span class="number">-1</span>]&lt;&lt;<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;n;i++)s[b[i]]=a[i];</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;m;i++)s[i]=s[i&amp;(i<span class="number">-1</span>)]+s[i&amp;(-i)];</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;m;i++)&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">0</span>;j&lt;n;j++)<span class="keyword">if</span>(i&amp;b[j])</span><br><span class="line">            f[i]=max(f[i^b[j]],f[i]);</span><br><span class="line">        <span class="keyword">if</span>(!s[i])f[i]++;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"%d"</span>,n<span class="number">-2</span>*f[m<span class="number">-1</span>]);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt; 中国历史上上分分和和次数非常多。。通读中国历史的WJMZBMR表示毫无压力。 同时经常搞OI的他把这个变成了一个数学模型。 假设中国的国土总和是不变的。 每个国家都可以用他的国土面积代替， 又两种可能，一种是两个国家合并为1个，那么新国家的面积为两者之和。 一种是一个国家分裂为2个，那么2个新国家的面积之和为原国家的面积。 WJMZBMR现在知道了很遥远的过去中国的状态，又知道了中国现在的状态，想知道至少要几次操作（分裂和合并各算一次操作），能让中国从当时状态到达现在的状态。&lt;br&gt;$n1,n2\leq 10$&lt;br&gt;
    
    </summary>
    
      <category term="OI/ACM" scheme="https://cothrax.github.io/categories/OI-ACM/"/>
    
    
      <category term="DP" scheme="https://cothrax.github.io/tags/DP/"/>
    
      <category term="状压DP" scheme="https://cothrax.github.io/tags/%E7%8A%B6%E5%8E%8BDP/"/>
    
      <category term="想法题" scheme="https://cothrax.github.io/tags/%E6%83%B3%E6%B3%95%E9%A2%98/"/>
    
  </entry>
  
</feed>
