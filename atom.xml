<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Cothrax</title>
  <subtitle>I don&#39;t need a subtitle.</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="https://cothrax.github.io/"/>
  <updated>2016-11-13T02:15:58.504Z</updated>
  <id>https://cothrax.github.io/</id>
  
  <author>
    <name>Cothrax</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>BZOJ-3224 普通平衡树</title>
    <link href="https://cothrax.github.io/2016/11/13/bzoj-3224/"/>
    <id>https://cothrax.github.io/2016/11/13/bzoj-3224/</id>
    <published>2016-11-13T02:07:18.000Z</published>
    <updated>2016-11-13T02:15:58.504Z</updated>
    
    <content type="html"><![CDATA[<h2 id="大意"><a href="#大意" class="headerlink" title="大意"></a>大意</h2><p>实现一系列操作维护一个数集：插入、删除、查询数x的排名、查询排名为x的数、求前驱和后驱</p>
<a id="more"></a>
<h2 id="链接"><a href="#链接" class="headerlink" title="链接"></a>链接</h2><p><a href="http://www.lydsy.com/JudgeOnline/problem.php?id=3224" target="_blank" rel="external">BZOJ-3224</a><br><a href="https://www.luogu.org/problem/show?pid=3369#sub" target="_blank" rel="external">luogu-3369</a><br><a href="/2016/11/13/bzoj-3224/treap.pas" title="treap.pas">treap.pas</a></p>
<h2 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h2><p>treap模板题，本蒟蒻第一次写平衡树</p>
<h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><figure class="highlight delphi"><figcaption><span>treap.pas</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">uses</span> math;</span><br><span class="line"><span class="keyword">type</span> </span><br><span class="line">    int=longint;</span><br><span class="line">    node=<span class="keyword">record</span> l,r,w,s,cnt,rnd:int <span class="keyword">end</span>;</span><br><span class="line"><span class="keyword">const</span> inf=maxlongint;</span><br><span class="line"><span class="keyword">var</span></span><br><span class="line">    tp:<span class="keyword">array</span>[<span class="number">0</span>..<span class="number">100010</span>] <span class="keyword">of</span> node;</span><br><span class="line">    sz,rt,i,n,op,x:int;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">procedure</span> <span class="title">upd</span><span class="params">(k:int)</span>;</span> <span class="comment">//更新tp[k].s即子树规模</span></span><br><span class="line"><span class="keyword">begin</span> tp[k].s:=tp[tp[k].l].s+tp[tp[k].r].s+tp[k].cnt <span class="keyword">end</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">procedure</span> <span class="title">lturn</span><span class="params">(<span class="keyword">var</span> k:int)</span>;</span> <span class="comment">//左旋</span></span><br><span class="line"><span class="keyword">var</span> t:int;</span><br><span class="line"><span class="keyword">begin</span></span><br><span class="line">    t:=tp[k].r;tp[k].r:=tp[t].l;tp[t].l:=k;</span><br><span class="line">    tp[t].s:=tp[k].s;upd(k);k:=t;</span><br><span class="line"><span class="keyword">end</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">procedure</span> <span class="title">rturn</span><span class="params">(<span class="keyword">var</span> k:int)</span>;</span> <span class="comment">//右旋</span></span><br><span class="line"><span class="keyword">var</span> t:int;</span><br><span class="line"><span class="keyword">begin</span></span><br><span class="line">    t:=tp[k].l;tp[k].l:=tp[t].r;tp[t].r:=k;</span><br><span class="line">    tp[t].s:=tp[k].s;upd(k);k:=t;</span><br><span class="line"><span class="keyword">end</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">procedure</span> <span class="title">ins</span><span class="params">(<span class="keyword">var</span> k:int;x:int)</span>;</span> <span class="comment">//插入</span></span><br><span class="line"><span class="keyword">begin</span></span><br><span class="line">    <span class="keyword">if</span> k=<span class="number">0</span> <span class="keyword">then</span> <span class="keyword">begin</span></span><br><span class="line">        inc(sz);k:=sz;tp[sz].w:=x;tp[sz].cnt:=<span class="number">1</span>;</span><br><span class="line">        tp[k].s:=<span class="number">1</span>;tp[sz].rnd:=random(inf);<span class="keyword">exit</span>;</span><br><span class="line">    <span class="keyword">end</span>;</span><br><span class="line">    <span class="keyword">if</span> x=tp[k].w <span class="keyword">then</span> <span class="keyword">begin</span> inc(tp[k].cnt);upd(k) <span class="keyword">end</span> <span class="comment">//<span class="doctag">bug:</span>缺upd(k)</span></span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> x&lt;tp[k].w <span class="keyword">then</span> <span class="keyword">begin</span></span><br><span class="line">        ins(tp[k].l,x);upd(k);</span><br><span class="line">        <span class="keyword">if</span> tp[k].rnd&lt;tp[tp[k].l].rnd <span class="keyword">then</span> rturn(k);</span><br><span class="line">    <span class="keyword">end</span> <span class="keyword">else</span> <span class="keyword">begin</span></span><br><span class="line">        ins(tp[k].r,x);upd(k);</span><br><span class="line">        <span class="keyword">if</span> tp[k].rnd&lt;tp[tp[k].r].rnd <span class="keyword">then</span> lturn(k);</span><br><span class="line">    <span class="keyword">end</span>;</span><br><span class="line"><span class="keyword">end</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">procedure</span> <span class="title">del</span><span class="params">(<span class="keyword">var</span> k:int;x:int)</span>;</span> <span class="comment">//堆式删除</span></span><br><span class="line"><span class="keyword">begin</span></span><br><span class="line">    <span class="keyword">if</span> k=<span class="number">0</span> <span class="keyword">then</span> <span class="keyword">exit</span>;</span><br><span class="line">    <span class="keyword">if</span> x&lt;tp[k].w <span class="keyword">then</span> del(tp[k].l,x)</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> x&gt;tp[k].w <span class="keyword">then</span> del(tp[k].r,x)</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">begin</span></span><br><span class="line">        <span class="keyword">if</span> tp[k].cnt&gt;<span class="number">1</span> <span class="keyword">then</span> dec(tp[k].cnt)</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> tp[k].l*tp[k].r=<span class="number">0</span> <span class="keyword">then</span> k:=max(tp[k].l,tp[k].r)</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> tp[tp[k].l].rnd&lt;tp[tp[k].r].rnd <span class="keyword">then</span></span><br><span class="line">            <span class="keyword">begin</span> lturn(k);del(tp[k].l,x) <span class="keyword">end</span></span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">begin</span> rturn(k);del(tp[k].r,x) <span class="keyword">end</span>;</span><br><span class="line">    <span class="keyword">end</span>;</span><br><span class="line">    <span class="keyword">if</span> k&lt;&gt;<span class="number">0</span> <span class="keyword">then</span> upd(k);</span><br><span class="line"><span class="keyword">end</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">low</span><span class="params">(k,x:int)</span>:</span>int; <span class="comment">//查询比x小的数的个数</span></span><br><span class="line"><span class="keyword">begin</span></span><br><span class="line">    <span class="keyword">if</span> k=<span class="number">0</span> <span class="keyword">then</span> <span class="keyword">exit</span>(<span class="number">0</span>)</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> x=tp[k].w <span class="keyword">then</span> <span class="keyword">exit</span>(tp[tp[k].l].s)</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> x&lt;tp[k].w <span class="keyword">then</span> <span class="keyword">exit</span>(low(tp[k].l,x))</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">exit</span>(tp[tp[k].l].s+tp[k].cnt+low(tp[k].r,x)); <span class="comment">//考虑cnt</span></span><br><span class="line"><span class="keyword">end</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">kth</span><span class="params">(k,x:int)</span>:</span>int; <span class="comment">//查询第k个树</span></span><br><span class="line"><span class="keyword">begin</span></span><br><span class="line">    <span class="keyword">if</span> k=<span class="number">0</span> <span class="keyword">then</span> <span class="keyword">exit</span>(<span class="number">0</span>)</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> tp[tp[k].l].s+tp[k].cnt&lt;x <span class="keyword">then</span></span><br><span class="line">        <span class="keyword">exit</span>(kth(tp[k].r,x-tp[tp[k].l].s-tp[k].cnt))</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> tp[tp[k].l].s&gt;=x <span class="keyword">then</span> <span class="keyword">exit</span>(kth(tp[k].l,x))</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">exit</span>(tp[k].w);</span><br><span class="line"><span class="keyword">end</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> _<span class="title">min</span><span class="params">(k:int)</span>:</span>int; <span class="comment">//查询子树k中的最小值</span></span><br><span class="line"><span class="keyword">begin</span></span><br><span class="line">    <span class="keyword">if</span> k=<span class="number">0</span> <span class="keyword">then</span> <span class="keyword">exit</span>(inf)</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> tp[k].l=<span class="number">0</span> <span class="keyword">then</span> <span class="keyword">exit</span>(tp[k].w)</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">exit</span>(_min(tp[k].l));</span><br><span class="line"><span class="keyword">end</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> _<span class="title">max</span><span class="params">(k:int)</span>:</span>int; <span class="comment">//查询子树k中的最大值</span></span><br><span class="line"><span class="keyword">begin</span></span><br><span class="line">    <span class="keyword">if</span> k=<span class="number">0</span> <span class="keyword">then</span> <span class="keyword">exit</span>(-inf)</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> tp[k].r=<span class="number">0</span> <span class="keyword">then</span> <span class="keyword">exit</span>(tp[k].w)</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">exit</span>(_max(tp[k].r));</span><br><span class="line"><span class="keyword">end</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">pvs</span><span class="params">(k,x:int)</span>:</span>int; <span class="comment">//求树中比x小的最大的数</span></span><br><span class="line"><span class="keyword">var</span> tmp:int;</span><br><span class="line"><span class="keyword">begin</span></span><br><span class="line">    tmp:=_min(tp[k].r);</span><br><span class="line">    <span class="keyword">if</span> tp[k].w&gt;=x <span class="keyword">then</span> <span class="keyword">exit</span>(pvs(tp[k].l,x))</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> tmp&gt;=x <span class="keyword">then</span> <span class="keyword">exit</span>(tp[k].w)</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">exit</span>(pvs(tp[k].r,x));</span><br><span class="line"><span class="keyword">end</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">nxt</span><span class="params">(k,x:int)</span>:</span>int; <span class="comment">//求树中比x大的最小的数</span></span><br><span class="line"><span class="keyword">var</span> tmp:int;</span><br><span class="line"><span class="keyword">begin</span></span><br><span class="line">    tmp:=_max(tp[k].l);</span><br><span class="line">    <span class="keyword">if</span> tp[k].w&lt;=x <span class="keyword">then</span> <span class="keyword">exit</span>(nxt(tp[k].r,x))</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> tmp&lt;=x <span class="keyword">then</span> <span class="keyword">exit</span>(tp[k].w)</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">exit</span>(nxt(tp[k].l,x));</span><br><span class="line"><span class="keyword">end</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">procedure</span> <span class="title">walk</span><span class="params">(k,d:int)</span>;</span> <span class="comment">//debug-output</span></span><br><span class="line"><span class="keyword">var</span> i:int;</span><br><span class="line"><span class="keyword">begin</span></span><br><span class="line">    <span class="keyword">if</span> k=<span class="number">0</span> <span class="keyword">then</span> <span class="keyword">exit</span>;</span><br><span class="line">    walk(tp[k].l,d+<span class="number">1</span>);</span><br><span class="line">    <span class="keyword">for</span> i:=<span class="number">1</span> <span class="keyword">to</span> d*<span class="number">7</span> <span class="keyword">do</span> <span class="keyword">write</span>(<span class="string">' '</span>);</span><br><span class="line">    writeln(tp[k].w,<span class="string">':'</span>,tp[k].cnt,<span class="string">':'</span>,tp[k].s);</span><br><span class="line">    walk(tp[k].r,d+<span class="number">1</span>);</span><br><span class="line"><span class="keyword">end</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">begin</span></span><br><span class="line">    randomize;<span class="keyword">read</span>(n);sz:=<span class="number">0</span>;rt:=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> i:=<span class="number">1</span> <span class="keyword">to</span> n <span class="keyword">do</span> <span class="keyword">begin</span></span><br><span class="line">        <span class="keyword">read</span>(op,x);</span><br><span class="line">        <span class="keyword">case</span> op <span class="keyword">of</span> </span><br><span class="line">            <span class="number">1</span>:ins(rt,x);</span><br><span class="line">            <span class="number">2</span>:del(rt,x);</span><br><span class="line">            <span class="number">3</span>:writeln(low(rt,x)+<span class="number">1</span>);</span><br><span class="line">            <span class="number">4</span>:writeln(kth(rt,x));</span><br><span class="line">            <span class="number">5</span>:writeln(pvs(rt,x));</span><br><span class="line">            <span class="number">6</span>:writeln(nxt(rt,x));</span><br><span class="line">        <span class="keyword">end</span>;</span><br><span class="line">        <span class="comment">//walk(rt,1);</span></span><br><span class="line">    <span class="keyword">end</span>;</span><br><span class="line"><span class="keyword">end</span>.</span><br></pre></td></tr></table></figure>
<p></p>
]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;大意&quot;&gt;&lt;a href=&quot;#大意&quot; class=&quot;headerlink&quot; title=&quot;大意&quot;&gt;&lt;/a&gt;大意&lt;/h2&gt;&lt;p&gt;实现一系列操作维护一个数集：插入、删除、查询数x的排名、查询排名为x的数、求前驱和后驱&lt;/p&gt;
    
    </summary>
    
      <category term="Problem Set" scheme="https://cothrax.github.io/categories/Problem-Set/"/>
    
    
      <category term="OI" scheme="https://cothrax.github.io/tags/OI/"/>
    
      <category term="平衡树" scheme="https://cothrax.github.io/tags/%E5%B9%B3%E8%A1%A1%E6%A0%91/"/>
    
      <category term="Treap" scheme="https://cothrax.github.io/tags/Treap/"/>
    
      <category term="数据结构" scheme="https://cothrax.github.io/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"/>
    
  </entry>
  
  <entry>
    <title>XJOI NOIP2016提高组冲剌题1</title>
    <link href="https://cothrax.github.io/2016/11/12/xjoi-noip-2016-test1/"/>
    <id>https://cothrax.github.io/2016/11/12/xjoi-noip-2016-test1/</id>
    <published>2016-11-12T13:20:18.000Z</published>
    <updated>2016-11-12T23:53:26.441Z</updated>
    
    <content type="html"><![CDATA[<p>在大学军的OJ上找点题练手，出题人果然比BZOJ的十连测良心。。</p>
<h1 id="T1-挖金矿"><a href="#T1-挖金矿" class="headerlink" title="T1 挖金矿"></a>T1 挖金矿</h1><p>大意：给定n×m的矩阵，在每一行选长为$k(1\leq k\leq m)$的前缀，要最大化所选数的平均值<br>$n\times m\leq 10^5,1\leq a[i,j]\leq 10^9$<br><a id="more"></a></p>
<h2 id="链接"><a href="#链接" class="headerlink" title="链接"></a>链接</h2><p><a href="http://www.hzxjhs.com:83/contest/622/problem/1" target="_blank" rel="external">XJOI</a><br><a href="/2016/11/12/xjoi-noip-2016-test1/gold.pas" title="gold.pas">gold.pas</a></p>
<h2 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h2><p>关于平均值的题目：</p>
<ol>
<li>二分统计逆序对：<a href="/2016/10/09/lydsy-noip-2016-test3/" title="十连测Test3-T1">十连测Test3-T1</a></li>
<li>二分判负环：<a href="/2016/08/30/雅礼中学2015模拟赛-Day3/" title="雅礼2015-T2">雅礼2015-T2</a></li>
</ol>
<p>考虑二分答案$x\in [0,\sum a[i,j]]$</p>
<p>将矩阵中的所有数减去x后，将每一列前缀和的最大值加起来</p>
<p>即$sum=\sum_{i=1}^n max_{1\leq k\leq h}(\sum_{j=1}^k a[i,j])$</p>
<p>如果$sum\geq 0$，那么x合法</p>
<p>细节：题中没有给出n,m的范围，用链表处理</p>
<h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><figure class="highlight delphi"><figcaption><span>gold.pas</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">uses</span> math;</span><br><span class="line"><span class="keyword">type</span> int=longint;node=<span class="keyword">record</span> w,nxt:int <span class="keyword">end</span>;</span><br><span class="line"><span class="keyword">const</span> eps=<span class="number">0.000001</span>;inf:double=<span class="number">100000000000</span>;</span><br><span class="line"><span class="keyword">var</span> </span><br><span class="line">    lnk:<span class="keyword">array</span>[<span class="number">0</span>..<span class="number">100010</span>] <span class="keyword">of</span> node;</span><br><span class="line">    head,tail:<span class="keyword">array</span>[<span class="number">0</span>..<span class="number">100010</span>] <span class="keyword">of</span> int;</span><br><span class="line">    n,m,sz,i,j,x:int;l,r,mid,ans:double;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">procedure</span> <span class="title">insert</span><span class="params">(i,x:int)</span>;</span></span><br><span class="line"><span class="keyword">begin</span></span><br><span class="line">    inc(sz);lnk[sz].w:=x;</span><br><span class="line">    <span class="keyword">if</span> head[i]=<span class="number">0</span> <span class="keyword">then</span> <span class="keyword">begin</span> head[i]:=sz;tail[i]:=sz <span class="keyword">end</span></span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">begin</span> lnk[tail[i]].nxt:=sz;tail[i]:=sz <span class="keyword">end</span>;</span><br><span class="line"><span class="keyword">end</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">jud</span><span class="params">(x:double)</span>:</span>boolean;</span><br><span class="line"><span class="keyword">var</span> sum,cur,ans:double;i,j:int;</span><br><span class="line"><span class="keyword">begin</span></span><br><span class="line">    sum:=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> i:=<span class="number">1</span> <span class="keyword">to</span> n <span class="keyword">do</span> <span class="keyword">begin</span></span><br><span class="line">        j:=head[i];cur:=<span class="number">0</span>;ans:=-inf;</span><br><span class="line">        <span class="keyword">while</span> j&lt;&gt;<span class="number">0</span> <span class="keyword">do</span> <span class="keyword">begin</span></span><br><span class="line">            cur:=cur+int64(lnk[j].w)-x;</span><br><span class="line">            ans:=max(ans,cur);</span><br><span class="line">            j:=lnk[j].nxt;</span><br><span class="line">        <span class="keyword">end</span>;</span><br><span class="line">        sum:=sum+ans;</span><br><span class="line">    <span class="keyword">end</span>;</span><br><span class="line">    jud:=sum&gt;=<span class="number">0</span>;</span><br><span class="line"><span class="keyword">end</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">begin</span></span><br><span class="line">    <span class="comment">//assign(input,'gold.in');reset(input);</span></span><br><span class="line">    <span class="comment">//assign(output,'gold.out');rewrite(output);</span></span><br><span class="line">    <span class="keyword">read</span>(n,m);sz:=<span class="number">0</span>;</span><br><span class="line">    l:=<span class="number">0</span>;r:=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> i:=<span class="number">1</span> <span class="keyword">to</span> n <span class="keyword">do</span></span><br><span class="line">        <span class="keyword">for</span> j:=<span class="number">1</span> <span class="keyword">to</span> m <span class="keyword">do</span> <span class="keyword">begin</span></span><br><span class="line">            <span class="keyword">read</span>(x);insert(i,x);r:=r+x;</span><br><span class="line">        <span class="keyword">end</span>;</span><br><span class="line">    <span class="keyword">while</span> r-l&gt;eps <span class="keyword">do</span> <span class="keyword">begin</span></span><br><span class="line">        mid:=(l+r)/<span class="number">2</span>;</span><br><span class="line">        <span class="keyword">if</span> jud(mid) <span class="keyword">then</span> <span class="keyword">begin</span> ans:=mid;l:=mid <span class="keyword">end</span></span><br><span class="line">        <span class="keyword">else</span> r:=mid;</span><br><span class="line">    <span class="keyword">end</span>;</span><br><span class="line">    <span class="keyword">write</span>(ans:<span class="number">0</span>:<span class="number">4</span>);</span><br><span class="line">    <span class="comment">//close(input);close(output);</span></span><br><span class="line"><span class="keyword">end</span>.</span><br></pre></td></tr></table></figure>
<h1 id="T2-道路规划"><a href="#T2-道路规划" class="headerlink" title="T2 道路规划"></a>T2 道路规划</h1><p>大意：给定1..n的两个全排列a和b，一上一下排成一行，把a和b中对应的数字用直线连起来，定义点集S：该集合中的任意两个数对应的连线相交。求S的最大规模<br>如图：<br><img src="/2016/11/12/xjoi-noip-2016-test1/g.png" alt="g.png" title=""></p>
<h2 id="链接-1"><a href="#链接-1" class="headerlink" title="链接"></a>链接</h2><p><a href="http://www.hzxjhs.com:83/contest/622/problem/2" target="_blank" rel="external">XJOI</a><br><a href="/2016/11/12/xjoi-noip-2016-test1/road.pas" title="road.pas">road.pas</a></p>
<h2 id="题解-1"><a href="#题解-1" class="headerlink" title="题解"></a>题解</h2><p>记la[i]为i在a中的下标，lb[i]为i在b中的下标<br>因为如果i和j的线相交，那么必然有$(la[i]-la[j])(lb[i]-lb[j])&lt;0$<br>以lb[a[i]]作为i的权值，就规约为了LDS<br>可以二分或用树状数组优化到$O(NlogN)$</p>
<h2 id="代码-1"><a href="#代码-1" class="headerlink" title="代码"></a>代码</h2><figure class="highlight delphi"><figcaption><span>road.pas</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">uses</span> math;</span><br><span class="line"><span class="keyword">type</span> int=longint;</span><br><span class="line"><span class="keyword">var</span> </span><br><span class="line">    n,i,j:int;</span><br><span class="line">    a,b,f,bit:<span class="keyword">array</span>[<span class="number">0</span>..<span class="number">100010</span>] <span class="keyword">of</span> int;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">procedure</span> <span class="title">add</span><span class="params">(x,k:int)</span>;</span></span><br><span class="line"><span class="keyword">begin</span></span><br><span class="line">    <span class="keyword">while</span> x&lt;=n <span class="keyword">do</span> <span class="keyword">begin</span></span><br><span class="line">        bit[x]:=max(bit[x],k);</span><br><span class="line">        x:=x+x <span class="keyword">and</span> (-x);</span><br><span class="line">    <span class="keyword">end</span>;</span><br><span class="line"><span class="keyword">end</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">query</span><span class="params">(x:int)</span>:</span>int;</span><br><span class="line"><span class="keyword">begin</span></span><br><span class="line">    query:=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span> x&gt;<span class="number">0</span> <span class="keyword">do</span> <span class="keyword">begin</span></span><br><span class="line">        query:=max(query,bit[x]);</span><br><span class="line">        x:=x <span class="keyword">and</span> (x-<span class="number">1</span>);</span><br><span class="line">    <span class="keyword">end</span>;</span><br><span class="line"><span class="keyword">end</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">begin</span></span><br><span class="line">    <span class="comment">//assign(input,'road.in');reset(input);</span></span><br><span class="line">    <span class="comment">//assign(output,'road.out');rewrite(output);</span></span><br><span class="line">    <span class="keyword">read</span>(n);</span><br><span class="line">    <span class="keyword">for</span> i:=<span class="number">1</span> <span class="keyword">to</span> n <span class="keyword">do</span> <span class="keyword">begin</span> <span class="keyword">read</span>(j);a[j]:=i <span class="keyword">end</span>;</span><br><span class="line">    <span class="keyword">for</span> i:=<span class="number">1</span> <span class="keyword">to</span> n <span class="keyword">do</span> <span class="keyword">begin</span> <span class="keyword">read</span>(j);b[a[j]]:=i <span class="keyword">end</span>;</span><br><span class="line">    <span class="keyword">for</span> i:=<span class="number">1</span> <span class="keyword">to</span> n <span class="keyword">do</span> <span class="keyword">begin</span></span><br><span class="line">        f[i]:=query(n-b[i]+<span class="number">1</span>)+<span class="number">1</span>;  <span class="comment">//i-&gt;n-i+1</span></span><br><span class="line">        add(n-b[i]+<span class="number">1</span>,f[i]);</span><br><span class="line">    <span class="keyword">end</span>;</span><br><span class="line">    <span class="keyword">for</span> i:=<span class="number">2</span> <span class="keyword">to</span> n <span class="keyword">do</span> f[i]:=max(f[i],f[i-<span class="number">1</span>]);</span><br><span class="line">    <span class="keyword">write</span>(f[n]);</span><br><span class="line">    <span class="comment">//close(input);close(output);</span></span><br><span class="line"><span class="keyword">end</span>.</span><br></pre></td></tr></table></figure>
<h1 id="T3-排队"><a href="#T3-排队" class="headerlink" title="T3 排队"></a>T3 排队</h1><p>题意很崎岖，自己去看链接吧</p>
<h2 id="链接-2"><a href="#链接-2" class="headerlink" title="链接"></a>链接</h2><p><a href="http://www.hzxjhs.com:83/contest/622/problem/3" target="_blank" rel="external">XJOI</a><br><a href="/2016/11/12/xjoi-noip-2016-test1/queue.pas" title="queue.pas">queue.pas</a><br><a href="/2016/11/12/xjoi-noip-2016-test1/queue_tmp.pas" title="queue_tmp.pas">queue_tmp.pas</a></p>
<h2 id="题解-2"><a href="#题解-2" class="headerlink" title="题解"></a>题解</h2><p>可以先按儿子升序的顺序dfs整棵树，其<strong>post-dfs序</strong>就是所有点的优先级，记一个点u在post-dfs序中的下标为f[u]，即一个人进来一定会选取可用点集中f值最小的点。<br>可以用一个<strong>小根堆</strong>维护可用的（空的）(f[u],u)的值对<br>这样对于操作1，直接暴力从堆中取x个最优值即可，输出值即最后一次取出的值。<br>然后对于操作2，先说说标算的方法吧<br>显然取出点x只会对x到根的路径上的点产生影响，而路径上被占用的点一定是连续的一段，影响就是将这一段下移一格，记这一段最上面的点为u，u就会空出，将它插入堆中即可。输出值为dep[x]-dep[u]，dep表示深度<br>至于怎么找u，<strong>倍增</strong>处理即可</p>
<p>然而由于没有考虑到占用的点是连续的这个性质，身为一个蒟蒻写了180+的<strong>dfs序+树状数组+线段树</strong></p>
<blockquote>
<p>Too young too naive</p>
</blockquote>
<p>bug:注意堆中值对的顺序</p>
<h2 id="代码-2"><a href="#代码-2" class="headerlink" title="代码"></a>代码</h2><p>标算解法<br><figure class="highlight delphi"><figcaption><span>queue.pas</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> int=longint;edge=<span class="keyword">record</span> v,nxt:int <span class="keyword">end</span>;</span><br><span class="line"><span class="keyword">var</span></span><br><span class="line">    g:<span class="keyword">array</span>[<span class="number">0</span>..<span class="number">200010</span>] <span class="keyword">of</span> edge;</span><br><span class="line">    head,stk,f,dep:<span class="keyword">array</span>[<span class="number">0</span>..<span class="number">100010</span>] <span class="keyword">of</span> int;</span><br><span class="line">    par:<span class="keyword">array</span>[<span class="number">0</span>..<span class="number">100010</span>,<span class="number">0</span>..<span class="number">20</span>] <span class="keyword">of</span> int;</span><br><span class="line">    hp:<span class="keyword">array</span>[<span class="number">0</span>..<span class="number">150010</span>,<span class="number">0</span>..<span class="number">1</span>] <span class="keyword">of</span> int;</span><br><span class="line">    flg:<span class="keyword">array</span>[<span class="number">0</span>..<span class="number">100010</span>] <span class="keyword">of</span> boolean;</span><br><span class="line">    n,m,sz,hs,k,lg,op,i,j,u,v,t:int;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">procedure</span> <span class="title">add</span><span class="params">(u,v:int)</span>;</span></span><br><span class="line"><span class="keyword">begin</span></span><br><span class="line">    inc(sz);g[sz].v:=v;</span><br><span class="line">    g[sz].nxt:=head[u];head[u]:=sz;</span><br><span class="line"><span class="keyword">end</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">procedure</span> <span class="title">qsort</span><span class="params">(l,r:int)</span>;</span></span><br><span class="line"><span class="keyword">var</span> i,j,x,tmp:int;</span><br><span class="line"><span class="keyword">begin</span></span><br><span class="line">    <span class="keyword">if</span> l&gt;=r <span class="keyword">then</span> <span class="keyword">exit</span>;</span><br><span class="line">    i:=l;j:=r;x:=stk[random(r-l)+l];</span><br><span class="line">    <span class="keyword">repeat</span></span><br><span class="line">        <span class="keyword">while</span> stk[i]&lt;x <span class="keyword">do</span> inc(i);</span><br><span class="line">        <span class="keyword">while</span> stk[j]&gt;x <span class="keyword">do</span> dec(j);</span><br><span class="line">        <span class="keyword">if</span> i&lt;=j <span class="keyword">then</span> <span class="keyword">begin</span></span><br><span class="line">            tmp:=stk[i];stk[i]:=stk[j];stk[j]:=tmp;</span><br><span class="line">            inc(i);dec(j);</span><br><span class="line">        <span class="keyword">end</span>;</span><br><span class="line">    <span class="keyword">until</span> i&gt;j;</span><br><span class="line">    <span class="keyword">if</span> i&lt;r <span class="keyword">then</span> qsort(i,r);</span><br><span class="line">    <span class="keyword">if</span> l&lt;j <span class="keyword">then</span> qsort(l,j);</span><br><span class="line"><span class="keyword">end</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">procedure</span> <span class="title">dfs</span><span class="params">(u,p:int)</span>;</span></span><br><span class="line"><span class="keyword">var</span> i,v,h:int;</span><br><span class="line"><span class="keyword">begin</span></span><br><span class="line">    par[u,<span class="number">0</span>]:=p;dep[u]:=dep[p]+<span class="number">1</span>;</span><br><span class="line">    i:=head[u];h:=t+<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">while</span> i&lt;&gt;<span class="number">0</span> <span class="keyword">do</span> <span class="keyword">begin</span></span><br><span class="line">        v:=g[i].v;</span><br><span class="line">        <span class="keyword">if</span> v&lt;&gt;p <span class="keyword">then</span> <span class="keyword">begin</span> inc(t);stk[t]:=v <span class="keyword">end</span>;</span><br><span class="line">        i:=g[i].nxt;</span><br><span class="line">    <span class="keyword">end</span>;</span><br><span class="line">    qsort(h,t);</span><br><span class="line">    <span class="keyword">for</span> i:=h <span class="keyword">to</span> t <span class="keyword">do</span> dfs(stk[i],u);</span><br><span class="line">    inc(k);f[u]:=k;t:=h-<span class="number">1</span>;</span><br><span class="line"><span class="keyword">end</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">//begin heap</span></span><br><span class="line"><span class="function"><span class="keyword">procedure</span> <span class="title">hfy</span><span class="params">(i:int)</span>;</span></span><br><span class="line"><span class="keyword">var</span> l,r,s:int;tmp:<span class="keyword">array</span>[<span class="number">0</span>..<span class="number">1</span>] <span class="keyword">of</span> int;</span><br><span class="line"><span class="keyword">begin</span></span><br><span class="line">    l:=i <span class="keyword">shl</span> <span class="number">1</span>;r:=l <span class="keyword">or</span> <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">if</span> (l&lt;=hs) <span class="keyword">and</span> (hp[l,<span class="number">0</span>]&lt;hp[i,<span class="number">0</span>]) <span class="keyword">then</span> s:=l <span class="keyword">else</span> s:=i;</span><br><span class="line">    <span class="keyword">if</span> (r&lt;=hs) <span class="keyword">and</span> (hp[r,<span class="number">0</span>]&lt;hp[s,<span class="number">0</span>]) <span class="keyword">then</span> s:=r;</span><br><span class="line">    <span class="keyword">if</span> s&lt;&gt;i <span class="keyword">then</span> <span class="keyword">begin</span></span><br><span class="line">        tmp:=hp[s];hp[s]:=hp[i];hp[i]:=tmp;hfy(s);</span><br><span class="line">    <span class="keyword">end</span>;</span><br><span class="line"><span class="keyword">end</span>;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">ext</span><span class="params">()</span>:</span>int;</span><br><span class="line"><span class="keyword">begin</span></span><br><span class="line">    ext:=hp[<span class="number">1</span>,<span class="number">1</span>];hp[<span class="number">1</span>]:=hp[hs];dec(hs);hfy(<span class="number">1</span>);</span><br><span class="line"><span class="keyword">end</span>;</span><br><span class="line"><span class="function"><span class="keyword">procedure</span> <span class="title">ins</span><span class="params">(w,k:int)</span>;</span></span><br><span class="line"><span class="keyword">var</span> i:int;tmp:<span class="keyword">array</span>[<span class="number">0</span>..<span class="number">1</span>] <span class="keyword">of</span> int;</span><br><span class="line"><span class="keyword">begin</span></span><br><span class="line">    inc(hs);hp[hs,<span class="number">0</span>]:=w;hp[hs,<span class="number">1</span>]:=k;i:=hs;</span><br><span class="line">    <span class="keyword">while</span> (i&gt;<span class="number">1</span>) <span class="keyword">and</span> (hp[i,<span class="number">0</span>]&lt;hp[i <span class="keyword">shr</span> <span class="number">1</span>,<span class="number">0</span>]) <span class="keyword">do</span> <span class="keyword">begin</span></span><br><span class="line">        tmp:=hp[i];hp[i]:=hp[i <span class="keyword">shr</span> <span class="number">1</span>];hp[i <span class="keyword">shr</span> <span class="number">1</span>]:=tmp;</span><br><span class="line">        i:=i <span class="keyword">shr</span> <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">end</span>;</span><br><span class="line"><span class="keyword">end</span>;</span><br><span class="line"><span class="comment">//end heap</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">procedure</span> <span class="title">op1</span><span class="params">(x:int)</span>;</span></span><br><span class="line"><span class="keyword">var</span> i:int;</span><br><span class="line"><span class="keyword">begin</span></span><br><span class="line">    <span class="keyword">for</span> i:=<span class="number">1</span> <span class="keyword">to</span> x <span class="keyword">do</span> <span class="keyword">begin</span></span><br><span class="line">        u:=ext();flg[u]:=true;</span><br><span class="line">    <span class="keyword">end</span>;</span><br><span class="line">    writeln(u);</span><br><span class="line"><span class="keyword">end</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">procedure</span> <span class="title">op2</span><span class="params">(u:int)</span>;</span></span><br><span class="line"><span class="keyword">var</span> i,v:int;</span><br><span class="line"><span class="keyword">begin</span></span><br><span class="line">    v:=u;</span><br><span class="line">    <span class="keyword">for</span> i:=lg <span class="keyword">downto</span> <span class="number">0</span> <span class="keyword">do</span></span><br><span class="line">        <span class="keyword">if</span> flg[par[v,i]] <span class="keyword">then</span> v:=par[v,i];</span><br><span class="line">    flg[v]:=false;ins(f[v],v);</span><br><span class="line">    writeln(dep[u]-dep[v]);</span><br><span class="line"><span class="keyword">end</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">begin</span></span><br><span class="line">    <span class="keyword">read</span>(n,m);sz:=<span class="number">0</span>;lg:=trunc(ln(n)/ln(<span class="number">2</span>));</span><br><span class="line">    <span class="keyword">for</span> i:=<span class="number">1</span> <span class="keyword">to</span> n-<span class="number">1</span> <span class="keyword">do</span> <span class="keyword">begin</span></span><br><span class="line">        <span class="keyword">read</span>(u,v);add(u,v);add(v,u);</span><br><span class="line">    <span class="keyword">end</span>;</span><br><span class="line">    k:=<span class="number">0</span>;t:=<span class="number">0</span>;dfs(<span class="number">1</span>,<span class="number">1</span>);</span><br><span class="line">    <span class="keyword">for</span> i:=<span class="number">1</span> <span class="keyword">to</span> lg <span class="keyword">do</span></span><br><span class="line">        <span class="keyword">for</span> j:=<span class="number">1</span> <span class="keyword">to</span> n <span class="keyword">do</span> par[j,i]:=par[par[j,i-<span class="number">1</span>],i-<span class="number">1</span>];</span><br><span class="line">    hs:=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> i:=<span class="number">1</span> <span class="keyword">to</span> n <span class="keyword">do</span> ins(f[i],i);</span><br><span class="line">    fillchar(flg,sizeof(flg),false);</span><br><span class="line">    <span class="keyword">for</span> i:=<span class="number">1</span> <span class="keyword">to</span> m <span class="keyword">do</span> <span class="keyword">begin</span></span><br><span class="line">        <span class="keyword">read</span>(op,u);</span><br><span class="line">        <span class="keyword">case</span> op <span class="keyword">of</span> <span class="number">1</span>:op1(u);<span class="number">2</span>:op2(u) <span class="keyword">end</span>;</span><br><span class="line">    <span class="keyword">end</span>;</span><br><span class="line"><span class="keyword">end</span>.</span><br></pre></td></tr></table></figure></p>
<p>巨长的sb解法<br><figure class="highlight delphi"><figcaption><span>queue.pas</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> int=longint;edge=<span class="keyword">record</span> v,nxt:int <span class="keyword">end</span>;</span><br><span class="line"><span class="keyword">var</span></span><br><span class="line">    g:<span class="keyword">array</span>[<span class="number">0</span>..<span class="number">200010</span>] <span class="keyword">of</span> edge;</span><br><span class="line">    head,stk,f,bit,lp,rp,par:<span class="keyword">array</span>[<span class="number">0</span>..<span class="number">100010</span>] <span class="keyword">of</span> int;</span><br><span class="line">    seg,tag:<span class="keyword">array</span>[<span class="number">0</span>..<span class="number">400010</span>] <span class="keyword">of</span> int;</span><br><span class="line">    hp:<span class="keyword">array</span>[<span class="number">0</span>..<span class="number">150010</span>,<span class="number">0</span>..<span class="number">1</span>] <span class="keyword">of</span> int;</span><br><span class="line">    n,m,sz,hs,k,cnt,op,i,u,v,t:int;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">procedure</span> <span class="title">add</span><span class="params">(u,v:int)</span>;</span></span><br><span class="line"><span class="keyword">begin</span></span><br><span class="line">    inc(sz);g[sz].v:=v;</span><br><span class="line">    g[sz].nxt:=head[u];head[u]:=sz;</span><br><span class="line"><span class="keyword">end</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">procedure</span> <span class="title">swap</span><span class="params">(<span class="keyword">var</span> a,b:int)</span>;</span></span><br><span class="line"><span class="keyword">var</span> tmp:int;</span><br><span class="line"><span class="keyword">begin</span> tmp:=a;a:=b;b:=tmp <span class="keyword">end</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">procedure</span> <span class="title">qsort</span><span class="params">(l,r:int)</span>;</span></span><br><span class="line"><span class="keyword">var</span> i,j,x:int;</span><br><span class="line"><span class="keyword">begin</span></span><br><span class="line">    <span class="keyword">if</span> l&gt;=r <span class="keyword">then</span> <span class="keyword">exit</span>;</span><br><span class="line">    i:=l;j:=r;x:=stk[random(r-l)+l];</span><br><span class="line">    <span class="keyword">repeat</span></span><br><span class="line">        <span class="keyword">while</span> stk[i]&lt;x <span class="keyword">do</span> inc(i);</span><br><span class="line">        <span class="keyword">while</span> stk[j]&gt;x <span class="keyword">do</span> dec(j);</span><br><span class="line">        <span class="keyword">if</span> i&lt;=j <span class="keyword">then</span> <span class="keyword">begin</span></span><br><span class="line">            swap(stk[i],stk[j]);inc(i);dec(j);</span><br><span class="line">        <span class="keyword">end</span>;</span><br><span class="line">    <span class="keyword">until</span> i&gt;j;</span><br><span class="line">    <span class="keyword">if</span> i&lt;r <span class="keyword">then</span> qsort(i,r);</span><br><span class="line">    <span class="keyword">if</span> l&lt;j <span class="keyword">then</span> qsort(l,j);</span><br><span class="line"><span class="keyword">end</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">procedure</span> <span class="title">dfs</span><span class="params">(u,p:int)</span>;</span></span><br><span class="line"><span class="keyword">var</span> i,v,h:int;</span><br><span class="line"><span class="keyword">begin</span></span><br><span class="line">    par[u]:=p;i:=head[u];h:=t+<span class="number">1</span>;inc(cnt);lp[u]:=cnt;</span><br><span class="line">    <span class="keyword">while</span> i&lt;&gt;<span class="number">0</span> <span class="keyword">do</span> <span class="keyword">begin</span></span><br><span class="line">        v:=g[i].v;</span><br><span class="line">        <span class="keyword">if</span> v&lt;&gt;p <span class="keyword">then</span> <span class="keyword">begin</span> inc(t);stk[t]:=v <span class="keyword">end</span>;</span><br><span class="line">        i:=g[i].nxt;</span><br><span class="line">    <span class="keyword">end</span>;</span><br><span class="line">    qsort(h,t);</span><br><span class="line">    <span class="keyword">for</span> i:=h <span class="keyword">to</span> t <span class="keyword">do</span> dfs(stk[i],u);</span><br><span class="line">    inc(k);f[u]:=k;t:=h-<span class="number">1</span>;rp[u]:=cnt;</span><br><span class="line"><span class="keyword">end</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">//begin heap</span></span><br><span class="line"><span class="function"><span class="keyword">procedure</span> <span class="title">hfy</span><span class="params">(i:int)</span>;</span></span><br><span class="line"><span class="keyword">var</span> l,r,s:int;</span><br><span class="line"><span class="keyword">begin</span></span><br><span class="line">    l:=i <span class="keyword">shl</span> <span class="number">1</span>;r:=l <span class="keyword">or</span> <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">if</span> (l&lt;=hs) <span class="keyword">and</span> (hp[l,<span class="number">0</span>]&lt;hp[i,<span class="number">0</span>]) <span class="keyword">then</span> s:=l <span class="keyword">else</span> s:=i;</span><br><span class="line">    <span class="keyword">if</span> (r&lt;=hs) <span class="keyword">and</span> (hp[r,<span class="number">0</span>]&lt;hp[s,<span class="number">0</span>]) <span class="keyword">then</span> s:=r;</span><br><span class="line">    <span class="keyword">if</span> s&lt;&gt;i <span class="keyword">then</span> <span class="keyword">begin</span></span><br><span class="line">        swap(hp[s,<span class="number">0</span>],hp[i,<span class="number">0</span>]);swap(hp[s,<span class="number">1</span>],hp[i,<span class="number">1</span>]);</span><br><span class="line">        hfy(s);</span><br><span class="line">    <span class="keyword">end</span>;</span><br><span class="line"><span class="keyword">end</span>;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">ext</span><span class="params">()</span>:</span>int;</span><br><span class="line"><span class="keyword">begin</span></span><br><span class="line">    ext:=hp[<span class="number">1</span>,<span class="number">1</span>];hp[<span class="number">1</span>]:=hp[hs];dec(hs);hfy(<span class="number">1</span>);</span><br><span class="line"><span class="keyword">end</span>;</span><br><span class="line"><span class="function"><span class="keyword">procedure</span> <span class="title">ins</span><span class="params">(w,k:int)</span>;</span></span><br><span class="line"><span class="keyword">var</span> i,p:int;</span><br><span class="line"><span class="keyword">begin</span></span><br><span class="line">    inc(hs);hp[hs,<span class="number">0</span>]:=w;hp[hs,<span class="number">1</span>]:=k;</span><br><span class="line">    i:=hs;p:=i <span class="keyword">shr</span> <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">while</span> (i&gt;<span class="number">1</span>) <span class="keyword">and</span> (hp[i,<span class="number">0</span>]&lt;hp[p,<span class="number">0</span>]) <span class="keyword">do</span> <span class="keyword">begin</span></span><br><span class="line">        swap(hp[i,<span class="number">0</span>],hp[p,<span class="number">0</span>]);swap(hp[i,<span class="number">1</span>],hp[p,<span class="number">1</span>]);</span><br><span class="line">        i:=p;p:=p <span class="keyword">shr</span> <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">end</span>;</span><br><span class="line"><span class="keyword">end</span>;</span><br><span class="line"><span class="comment">//end heap</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//begin bit</span></span><br><span class="line"><span class="function"><span class="keyword">procedure</span> _<span class="title">add</span><span class="params">(x,k:int)</span>;</span></span><br><span class="line"><span class="keyword">begin</span></span><br><span class="line">    <span class="keyword">if</span> x=<span class="number">0</span> <span class="keyword">then</span> <span class="keyword">exit</span>;</span><br><span class="line">    <span class="keyword">while</span> x&lt;=n <span class="keyword">do</span> <span class="keyword">begin</span></span><br><span class="line">        inc(bit[x],k);inc(x,x <span class="keyword">and</span> (-x));</span><br><span class="line">    <span class="keyword">end</span>;</span><br><span class="line"><span class="keyword">end</span>;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">ask</span><span class="params">(x:int)</span>:</span>int;</span><br><span class="line"><span class="keyword">begin</span></span><br><span class="line">    ask:=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span> x&gt;<span class="number">0</span> <span class="keyword">do</span> <span class="keyword">begin</span></span><br><span class="line">        inc(ask,bit[x]);x:=x <span class="keyword">and</span> (x-<span class="number">1</span>);</span><br><span class="line">    <span class="keyword">end</span>;</span><br><span class="line"><span class="keyword">end</span>;</span><br><span class="line"><span class="comment">//end bit</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//seg-tree begin</span></span><br><span class="line"><span class="function"><span class="keyword">procedure</span> <span class="title">pushdown</span><span class="params">(i,b,e:int)</span>;</span></span><br><span class="line"><span class="keyword">begin</span></span><br><span class="line">    <span class="keyword">if</span> b&lt;e <span class="keyword">then</span> <span class="keyword">begin</span> </span><br><span class="line">        seg[i <span class="keyword">shl</span> <span class="number">1</span>]:=tag[i];tag[i <span class="keyword">shl</span> <span class="number">1</span>]:=tag[i];</span><br><span class="line">        seg[i <span class="keyword">shl</span> <span class="number">1</span> <span class="keyword">or</span> <span class="number">1</span>]:=tag[i];tag[i <span class="keyword">shl</span> <span class="number">1</span> <span class="keyword">or</span> <span class="number">1</span>]:=tag[i];</span><br><span class="line">    <span class="keyword">end</span>;</span><br><span class="line">    tag[i]:=-<span class="number">1</span>;</span><br><span class="line"><span class="keyword">end</span>;</span><br><span class="line"><span class="function"><span class="keyword">procedure</span> <span class="title">modify</span><span class="params">(i,b,e,l,r,k:int)</span>;</span></span><br><span class="line"><span class="keyword">var</span> mid:int;</span><br><span class="line"><span class="keyword">begin</span></span><br><span class="line">    <span class="keyword">if</span> (b&gt;e) <span class="keyword">or</span> (e&lt;l) <span class="keyword">or</span> (r&lt;b) <span class="keyword">then</span> <span class="keyword">exit</span>;</span><br><span class="line">    <span class="keyword">if</span> (l&lt;=b) <span class="keyword">and</span> (e&lt;=r) <span class="keyword">then</span> <span class="keyword">begin</span></span><br><span class="line">        seg[i]:=k;tag[i]:=k;<span class="keyword">exit</span>;</span><br><span class="line">    <span class="keyword">end</span>;</span><br><span class="line">    <span class="keyword">if</span> tag[i]&lt;&gt;-<span class="number">1</span> <span class="keyword">then</span> pushdown(i,b,e);</span><br><span class="line">    mid:=(b+e) <span class="keyword">shr</span> <span class="number">1</span>;seg[i]:=k;</span><br><span class="line">    modify(i <span class="keyword">shl</span> <span class="number">1</span>,b,mid,l,r,k);</span><br><span class="line">    modify(i <span class="keyword">shl</span> <span class="number">1</span> <span class="keyword">or</span> <span class="number">1</span>,mid+<span class="number">1</span>,e,l,r,k);</span><br><span class="line"><span class="keyword">end</span>;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">query</span><span class="params">(i,b,e,x:int)</span>:</span>int;</span><br><span class="line"><span class="keyword">var</span> mid:int;</span><br><span class="line"><span class="keyword">begin</span></span><br><span class="line">    <span class="keyword">if</span> b=e <span class="keyword">then</span> <span class="keyword">exit</span>(seg[i]);</span><br><span class="line">    <span class="keyword">if</span> tag[i]&lt;&gt;-<span class="number">1</span> <span class="keyword">then</span> pushdown(i,b,e);</span><br><span class="line">    mid:=(b+e) <span class="keyword">shr</span> <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">if</span> x&lt;=mid <span class="keyword">then</span> query:=query(i <span class="keyword">shl</span> <span class="number">1</span>,b,mid,x)</span><br><span class="line">    <span class="keyword">else</span> query:=query(i <span class="keyword">shl</span> <span class="number">1</span> <span class="keyword">or</span> <span class="number">1</span>,mid+<span class="number">1</span>,e,x);</span><br><span class="line"><span class="keyword">end</span>;</span><br><span class="line"><span class="comment">//seg-tree end</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//op begin</span></span><br><span class="line"><span class="function"><span class="keyword">procedure</span> <span class="title">op1</span><span class="params">(x:int)</span>;</span></span><br><span class="line"><span class="keyword">var</span> i,u:int;</span><br><span class="line"><span class="keyword">begin</span></span><br><span class="line">    <span class="keyword">for</span> i:=<span class="number">1</span> <span class="keyword">to</span> x <span class="keyword">do</span> <span class="keyword">begin</span></span><br><span class="line">        u:=ext();</span><br><span class="line">        _add(lp[u],<span class="number">1</span>);_add(rp[u]+<span class="number">1</span>,-<span class="number">1</span>);</span><br><span class="line">        modify(<span class="number">1</span>,<span class="number">1</span>,n,lp[u],rp[u],u);</span><br><span class="line">    <span class="keyword">end</span>;</span><br><span class="line">    writeln(u);</span><br><span class="line"><span class="keyword">end</span>;</span><br><span class="line"><span class="function"><span class="keyword">procedure</span> <span class="title">op2</span><span class="params">(x:int)</span>;</span></span><br><span class="line"><span class="keyword">var</span> u,v,i:int;</span><br><span class="line"><span class="keyword">begin</span></span><br><span class="line">    writeln(ask(lp[x])-<span class="number">1</span>); <span class="comment">//<span class="doctag">bug:</span> 这写在前面</span></span><br><span class="line">    u:=query(<span class="number">1</span>,<span class="number">1</span>,n,lp[x]);ins(f[u],u); <span class="comment">//<span class="doctag">bug:</span> 记得ins</span></span><br><span class="line">    _add(lp[u],-<span class="number">1</span>);_add(rp[u]+<span class="number">1</span>,<span class="number">1</span>);</span><br><span class="line">    i:=head[u];</span><br><span class="line">    <span class="keyword">while</span> i&lt;&gt;<span class="number">0</span> <span class="keyword">do</span> <span class="keyword">begin</span></span><br><span class="line">        v:=g[i].v;</span><br><span class="line">        <span class="keyword">if</span> v&lt;&gt;par[u] <span class="keyword">then</span> modify(<span class="number">1</span>,<span class="number">1</span>,n,lp[v],rp[v],v);</span><br><span class="line">        i:=g[i].nxt;</span><br><span class="line">    <span class="keyword">end</span>;</span><br><span class="line"><span class="keyword">end</span>;</span><br><span class="line"><span class="comment">//op end</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">begin</span></span><br><span class="line">    <span class="keyword">read</span>(n,m);sz:=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> i:=<span class="number">1</span> <span class="keyword">to</span> n-<span class="number">1</span> <span class="keyword">do</span> <span class="keyword">begin</span></span><br><span class="line">        <span class="keyword">read</span>(u,v);add(u,v);add(v,u);</span><br><span class="line">    <span class="keyword">end</span>;</span><br><span class="line">    cnt:=<span class="number">0</span>;k:=<span class="number">0</span>;t:=<span class="number">0</span>;dfs(<span class="number">1</span>,<span class="number">0</span>);hs:=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> i:=<span class="number">1</span> <span class="keyword">to</span> n <span class="keyword">do</span> ins(f[i],i);</span><br><span class="line">    fillchar(tag,sizeof(tag),<span class="number">255</span>);</span><br><span class="line">    <span class="keyword">for</span> i:=<span class="number">1</span> <span class="keyword">to</span> m <span class="keyword">do</span> <span class="keyword">begin</span></span><br><span class="line">        <span class="keyword">read</span>(op,u);</span><br><span class="line">        <span class="keyword">case</span> op <span class="keyword">of</span> <span class="number">1</span>:op1(u);<span class="number">2</span>:op2(u) <span class="keyword">end</span>;</span><br><span class="line">    <span class="keyword">end</span>;</span><br><span class="line"><span class="keyword">end</span>.</span><br></pre></td></tr></table></figure></p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;在大学军的OJ上找点题练手，出题人果然比BZOJ的十连测良心。。&lt;/p&gt;
&lt;h1 id=&quot;T1-挖金矿&quot;&gt;&lt;a href=&quot;#T1-挖金矿&quot; class=&quot;headerlink&quot; title=&quot;T1 挖金矿&quot;&gt;&lt;/a&gt;T1 挖金矿&lt;/h1&gt;&lt;p&gt;大意：给定n×m的矩阵，在每一行选长为$k(1\leq k\leq m)$的前缀，要最大化所选数的平均值&lt;br&gt;$n\times m\leq 10^5,1\leq a[i,j]\leq 10^9$&lt;br&gt;
    
    </summary>
    
      <category term="Problem Set" scheme="https://cothrax.github.io/categories/Problem-Set/"/>
    
    
      <category term="OI" scheme="https://cothrax.github.io/tags/OI/"/>
    
      <category term="数据结构" scheme="https://cothrax.github.io/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"/>
    
      <category term="DP" scheme="https://cothrax.github.io/tags/DP/"/>
    
      <category term="二分答案" scheme="https://cothrax.github.io/tags/%E4%BA%8C%E5%88%86%E7%AD%94%E6%A1%88/"/>
    
      <category term="堆" scheme="https://cothrax.github.io/tags/%E5%A0%86/"/>
    
      <category term="树状数组" scheme="https://cothrax.github.io/tags/%E6%A0%91%E7%8A%B6%E6%95%B0%E7%BB%84/"/>
    
      <category term="倍增" scheme="https://cothrax.github.io/tags/%E5%80%8D%E5%A2%9E/"/>
    
      <category term="线段树" scheme="https://cothrax.github.io/tags/%E7%BA%BF%E6%AE%B5%E6%A0%91/"/>
    
      <category term="线性DP" scheme="https://cothrax.github.io/tags/%E7%BA%BF%E6%80%A7DP/"/>
    
      <category term="DFS序" scheme="https://cothrax.github.io/tags/DFS%E5%BA%8F/"/>
    
  </entry>
  
  <entry>
    <title>NOIP2016 模板整理和复习</title>
    <link href="https://cothrax.github.io/2016/11/11/noip-2016-review-template/"/>
    <id>https://cothrax.github.io/2016/11/11/noip-2016-review-template/</id>
    <published>2016-11-11T14:27:34.000Z</published>
    <updated>2016-11-13T02:22:49.772Z</updated>
    
    <content type="html"><![CDATA[<p>noip前复习一些不熟悉的模板<br>在历时4个月的刷题过程中，有些算法一带而过，之写过一两次或者年代久远或者理解肤浅，需要在考前复习。<br><a id="more"></a></p>
<h2 id="Todo-List"><a href="#Todo-List" class="headerlink" title="Todo List"></a>Todo List</h2><ol>
<li><del>字符串类</del><ol>
<li><del>KMP</del></li>
<li><del>BKDRhash等</del></li>
<li><del>双Hash、rabin-karp</del></li>
</ol>
</li>
<li><del>高斯消元</del></li>
<li><del>dp类</del><ol>
<li><del>斜率优化</del></li>
<li><del>单调队列优化多重背包</del></li>
</ol>
</li>
<li>图论类<ol>
<li><del>Dinic流、二分图最大匹配</del></li>
<li><del>差分约束</del></li>
<li><del>非递归拓扑排序</del></li>
<li>割点/边、点双连通、边双连通</li>
<li>tarjan求lca</li>
<li>树剖</li>
</ol>
</li>
<li><del>数据结构类</del><ol>
<li><del>莫队</del></li>
<li><del>分块</del></li>
<li><del>Treap</del></li>
</ol>
</li>
<li>博弈论：SG函数</li>
<li>双向BFS</li>
<li>康托展开</li>
</ol>
<h2 id="字符串类"><a href="#字符串类" class="headerlink" title="字符串类"></a>字符串类</h2><h3 id="KMP"><a href="#KMP" class="headerlink" title="KMP"></a>KMP</h3><p>前缀匹配后缀，参见matrix67的讲解<br><figure class="highlight delphi"><figcaption><span>kmp.pas</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> int=longint;</span><br><span class="line"><span class="function"><span class="keyword">procedure</span> <span class="title">kmp</span><span class="params">(<span class="keyword">var</span> a,b:ansistring)</span>;</span></span><br><span class="line"><span class="keyword">var</span> </span><br><span class="line">    i,j,n,m:int;</span><br><span class="line">    p:<span class="keyword">array</span>[<span class="number">0</span>..<span class="number">100010</span>] <span class="keyword">of</span> int;</span><br><span class="line"><span class="keyword">begin</span></span><br><span class="line">    n:=length(a);m:=length(b);</span><br><span class="line">    j:=<span class="number">0</span>;p[<span class="number">1</span>]:=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> i:=<span class="number">2</span> <span class="keyword">to</span> m <span class="keyword">do</span> <span class="keyword">begin</span></span><br><span class="line">        <span class="keyword">while</span> (j&gt;<span class="number">0</span>) <span class="keyword">and</span> (b[i]&lt;&gt;b[j+<span class="number">1</span>]) <span class="keyword">do</span> j:=p[j];</span><br><span class="line">        <span class="keyword">if</span> b[i]=b[j+<span class="number">1</span>] <span class="keyword">then</span> inc(j);</span><br><span class="line">        p[i]:=j;</span><br><span class="line">    <span class="keyword">end</span>;</span><br><span class="line">    j:=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> i:=<span class="number">1</span> <span class="keyword">to</span> n <span class="keyword">do</span> <span class="keyword">begin</span></span><br><span class="line">        <span class="keyword">while</span> (j&gt;<span class="number">0</span>) <span class="keyword">and</span> (a[i]&lt;&gt;b[j+<span class="number">1</span>]) <span class="keyword">do</span> j:=p[j];</span><br><span class="line">        <span class="keyword">if</span> a[i]=b[j+<span class="number">1</span>] <span class="keyword">then</span> inc(j);</span><br><span class="line">        <span class="keyword">if</span> j=m <span class="keyword">then</span> <span class="keyword">begin</span></span><br><span class="line">            writeln(i-m+<span class="number">1</span>); <span class="comment">//match</span></span><br><span class="line">            j:=p[j];</span><br><span class="line">        <span class="keyword">end</span>;</span><br><span class="line">    <span class="keyword">end</span>;</span><br><span class="line"><span class="keyword">end</span>;</span><br></pre></td></tr></table></figure></p>
<p>相关神题：</p>
<ol>
<li>应用匹配思想的dp：<a href="/2016/08/28/雅礼中学2015模拟赛-prefix/" title="雅礼2015 prefix">雅礼2015 prefix</a></li>
<li>广义匹配：<a href="/2016/08/28/JSOI2016-提高1班-Day3-message/" title="josi2016 message">josi2016 message</a></li>
</ol>
<h3 id="字符串Hash"><a href="#字符串Hash" class="headerlink" title="字符串Hash"></a>字符串Hash</h3><h4 id="Rabin-Karp类Hash"><a href="#Rabin-Karp类Hash" class="headerlink" title="Rabin-Karp类Hash"></a>Rabin-Karp类Hash</h4><p>通过进制展开得到Hash</p>
<p>$h(s)=\sum_{i=1}^{len(s)}p^{n-i}*s[i]$</p>
<p>化成递推式就是：$h(s[1,i])=h(s[1,i-1])*p+s[i]$</p>
<p>$O(N)$处理出s的前缀hash值，可以$O(1)$得到任意一段区间的hash值</p>
<p>$h(s[l,r])=h(s[1,r)-h(s[1,l-1])*p^{r-l+1}$</p>
<p>一道双hash题：<a href="/2016/08/17/JSOI2016-提高1班-Day2/" title="josi t2 drunk">josi t2 drunk</a><br>这里贴片段<br><figure class="highlight delphi"><figcaption><span>drunk.pas</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> int=longint;</span><br><span class="line"><span class="keyword">const</span></span><br><span class="line">    q:<span class="keyword">array</span>[<span class="number">0</span>..<span class="number">1</span>] <span class="keyword">of</span> int=(<span class="number">1000019</span>,<span class="number">100000007</span>);</span><br><span class="line">    p:<span class="keyword">array</span>[<span class="number">0</span>..<span class="number">1</span>] <span class="keyword">of</span> int=(<span class="number">1009</span>,<span class="number">133</span>);</span><br><span class="line"><span class="keyword">var</span></span><br><span class="line">    s:ansistring;</span><br><span class="line">    pn,f:<span class="keyword">array</span>[<span class="number">0</span>..<span class="number">1</span>,<span class="number">0</span>..<span class="number">100010</span>] <span class="keyword">of</span> int64;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">hash</span><span class="params">(l,r,j:int)</span>:</span>int64; <span class="comment">//[l,r]的hash</span></span><br><span class="line"><span class="keyword">begin</span></span><br><span class="line">    hash:=((f[j,r]-f[j,l-<span class="number">1</span>]*pn[j,r-l+<span class="number">1</span>])<span class="keyword">mod</span> q[j]+q[j])<span class="keyword">mod</span> q[j];</span><br><span class="line"><span class="keyword">end</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">procedure</span> <span class="title">init</span><span class="params">()</span>;</span> <span class="comment">//预处理前缀hash</span></span><br><span class="line"><span class="keyword">var</span> i,j,n:int;</span><br><span class="line"><span class="keyword">begin</span></span><br><span class="line">    n:=length(s);</span><br><span class="line">    <span class="keyword">for</span> i:=<span class="number">0</span> <span class="keyword">to</span> <span class="number">1</span> <span class="keyword">do</span> <span class="keyword">begin</span> f[i,<span class="number">0</span>]:=<span class="number">0</span>;pn[i,<span class="number">0</span>]:=<span class="number">1</span> <span class="keyword">end</span>;</span><br><span class="line">    <span class="keyword">for</span> i:=<span class="number">1</span> <span class="keyword">to</span> n <span class="keyword">do</span></span><br><span class="line">        <span class="keyword">for</span> j:=<span class="number">0</span> <span class="keyword">to</span> <span class="number">1</span> <span class="keyword">do</span> <span class="keyword">begin</span></span><br><span class="line">            pn[j,i]:=pn[j,i-<span class="number">1</span>]*p[j] <span class="keyword">mod</span> q[i];</span><br><span class="line">            f[j,i]:=(f[j,i-<span class="number">1</span>]*p[j]+ord(s[i])) <span class="keyword">mod</span> q[i];</span><br><span class="line">        <span class="keyword">end</span>;</span><br><span class="line"><span class="keyword">end</span>;</span><br></pre></td></tr></table></figure></p>
<h4 id="BKDRhash"><a href="#BKDRhash" class="headerlink" title="BKDRhash"></a>BKDRhash</h4><figure class="highlight delphi"><figcaption><span>string_hash</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">bkdr</span><span class="params">(<span class="keyword">var</span> s:<span class="keyword">string</span>)</span>:</span>dword;</span><br><span class="line"><span class="keyword">var</span> i:int;</span><br><span class="line"><span class="keyword">begin</span></span><br><span class="line">    bkdr:=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> i:=<span class="number">1</span> <span class="keyword">to</span> length(s) <span class="keyword">do</span></span><br><span class="line">        bkdr:=(bkdr*p+ord(s[i])) <span class="keyword">and</span> <span class="keyword">not</span> (<span class="number">15</span> <span class="keyword">shl</span> <span class="number">7</span>);</span><br><span class="line"><span class="keyword">end</span>;</span><br></pre></td></tr></table></figure>
<h2 id="DP类"><a href="#DP类" class="headerlink" title="DP类"></a>DP类</h2><h3 id="单调队列优化多重背包"><a href="#单调队列优化多重背包" class="headerlink" title="单调队列优化多重背包"></a>单调队列优化多重背包</h3><p>原来的方程：$f[i,j]=max(f[i-1,j-k*c[i]+k*v[i])$</p>
<p>记$j=b+a*v[i]$，代入得：</p>
<p>$f[i,j]=max(f[i-1,b+(a-k)*c[i]]-(a-k)*v[i]+a*v[i])$</p>
<p>即分离出具有单调性的部分，记$k=a-k$：</p>
<p>$f[i,j]=max(f[i-1,b+k*c[i]]-k*v[i])+a*v[i],a-k\leq a[i]$</p>
<p>然后可以根据剩余系b分别做单调队列<br>题目见此：<a href="/2016/08/20/JSOI2016-提高2班-单调队列及动规优化/" title="t2 war">t2 war</a><br><figure class="highlight delphi"><figcaption><span>war.pas</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">d:=<span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span> i:=<span class="number">1</span> <span class="keyword">to</span> n <span class="keyword">do</span> <span class="keyword">begin</span></span><br><span class="line">    d:=min(m,d+c[i]*a[i]); <span class="comment">//当前最大总体积</span></span><br><span class="line">    <span class="keyword">for</span> j:=<span class="number">0</span> <span class="keyword">to</span> c[i]-<span class="number">1</span> <span class="keyword">do</span> <span class="keyword">begin</span> <span class="comment">//枚举剩余系b</span></span><br><span class="line">        h:=<span class="number">1</span>;t:=<span class="number">0</span>;k:=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span> j+c[i]*k&lt;=d <span class="keyword">do</span> <span class="keyword">begin</span> <span class="comment">//枚举系数</span></span><br><span class="line">            <span class="keyword">while</span> (h&lt;=t) <span class="keyword">and</span> (q[t,<span class="number">0</span>]&lt;=f[j+c[i]*k]-v[i]*k) <span class="keyword">do</span> dec(t);</span><br><span class="line">            inc(t);q[t,<span class="number">1</span>]:=k;q[t,<span class="number">0</span>]:=f[j+c[i]*k]-v[i]*k; <span class="comment">//max()中维护的值入队</span></span><br><span class="line">            <span class="keyword">while</span> (h&lt;=t) <span class="keyword">and</span> (k-q[h,<span class="number">1</span>]&gt;a[i]) <span class="keyword">do</span> inc(h); <span class="comment">//超出数量限制出队</span></span><br><span class="line">            f[j+c[i]*k]:=max(f[j+c[i]*k,q[h,<span class="number">0</span>]+k*v[i]);</span><br><span class="line">            inc(k);</span><br><span class="line">        <span class="keyword">end</span>;</span><br><span class="line">    <span class="keyword">end</span>;</span><br><span class="line"><span class="keyword">end</span>;</span><br></pre></td></tr></table></figure></p>
<h3 id="斜率优化"><a href="#斜率优化" class="headerlink" title="斜率优化"></a>斜率优化</h3><p>具体题目，以及推<del>倒</del>导细节见：<a href="/2016/08/29/JSOI2016-提高1班-Day3-separate/" title="[JSOI2016] 提高1班 Day3 separate">[JSOI2016] 提高1班 Day3 separate</a></p>
<p><strong>简要的思路：</strong><br>原方程：$f[i,j]=min(f[i-1,k-1]+(a[k]-a[j])^2)$</p>
<p>记：$x[i]=a[i],y[i]=f[i-1,j-1]+a[i]^2$</p>
<p>推得：$g(k,t)\leq 2a[j],k&gt;t$(*)，则k优于t</p>
<p><strong>新的认识：</strong></p>
<ol>
<li>根据式(*)，若$t=q[h],k=q[h+1]$，则从头出队，因为此时$g(k,t)$已经小于$a[i]$，<strong>a是单调递增的</strong>，k不可能再成为最优解</li>
<li>然后是从尾出队，这个单调队列维护的实际上是一个<strong>上凸的凸包</strong>，因为根据式(*)，我们希望<strong>斜率尽量小</strong><br>那么记$k=q[t-1],t=q[t],l$为新插入的点，如果$g(k,t)&gt;g(t,l)$，那么此时直接将l接到队尾<strong>破坏了上凸的性质</strong>，因此t出队。也可以理解成由于g(t,l)一定优于g(k,t)，那么t不再可能成为最优解</li>
</ol>
<p><strong>核心代码</strong>：（出入队条件很长很丑，可以写成函数但会增大常数）</p>
<figure class="highlight delphi"><figcaption><span>glope.pas</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> i:=<span class="number">1</span> <span class="keyword">to</span> n <span class="keyword">do</span> f[<span class="number">1</span>,i]:=sqr(a[i]);</span><br><span class="line"><span class="keyword">for</span> i:=<span class="number">2</span> <span class="keyword">to</span> m <span class="keyword">do</span> <span class="keyword">begin</span></span><br><span class="line">    h:=<span class="number">0</span>;t:=<span class="number">0</span>;q[h]:=i-<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span> j:=i <span class="keyword">to</span> n <span class="keyword">do</span> <span class="keyword">begin</span> <span class="comment">//f[i,j]当j&lt;i时不合法</span></span><br><span class="line">        x[j]:=a[j];</span><br><span class="line">        y[j]:=f[i-<span class="number">1</span>,j-<span class="number">1</span>]+sqr(a[j]);</span><br><span class="line">        <span class="comment">//g(j,q[t])&lt;=g(q[t],q[t-1])</span></span><br><span class="line">        <span class="keyword">while</span> (h&lt;t) <span class="keyword">and</span> ((y[j]-y[q[t]])*(x[q[t]]-x[q[t]-<span class="number">1</span>])</span><br><span class="line">            &lt;=(y[q[t]]-y[q[t]-<span class="number">1</span>])*(x[j]-x[q[t]])) <span class="keyword">do</span> dec(t);</span><br><span class="line">        inc(t);q[t]:=j;</span><br><span class="line">        <span class="comment">//g(q[h],q[h+1])&lt;=2*a[i]</span></span><br><span class="line">        <span class="keyword">while</span> (h&lt;t) <span class="keyword">and</span> ((y[q[h]]-y[q[h+<span class="number">1</span>]])</span><br><span class="line">            &lt;=<span class="number">2</span>*a[i]*(x[q[h]]-x[q[h+<span class="number">1</span>]])) <span class="keyword">do</span> inc(h);</span><br><span class="line">        f[i,j]:=f[i-<span class="number">1</span>,q[h]-<span class="number">1</span>]+sqr(a[q[h]]-a[j]);</span><br><span class="line">    <span class="keyword">end</span>;</span><br><span class="line"><span class="keyword">end</span>;</span><br></pre></td></tr></table></figure>
<h2 id="图论类"><a href="#图论类" class="headerlink" title="图论类"></a>图论类</h2><h3 id="Dinic最大流"><a href="#Dinic最大流" class="headerlink" title="Dinic最大流"></a>Dinic最大流</h3><p>这玩意noip不考吧，费用流到现在还不会orz<br>注意点</p>
<ol>
<li>邻接表从下标2开始存，这样的话方便用<code>i xor 1</code>找到反向边</li>
<li>这种dinic写法应用了一个优化：一次dfs找出多条增广路，因此不需要iter数组</li>
</ol>
<figure class="highlight delphi"><figcaption><span>dinic.pas</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">uses</span> math;</span><br><span class="line"><span class="keyword">const</span> mxn=<span class="number">100010</span>;mxm=<span class="number">100010</span>;inf=maxlongint;</span><br><span class="line"><span class="keyword">type</span></span><br><span class="line">    int=longint;</span><br><span class="line">    edge=<span class="keyword">record</span> v,w,nxt:int <span class="keyword">end</span>;</span><br><span class="line"><span class="keyword">var</span></span><br><span class="line">    g:<span class="keyword">array</span>[<span class="number">0</span>..mxm*<span class="number">2</span>] <span class="keyword">of</span> edge;</span><br><span class="line">    head,d:<span class="keyword">array</span>[<span class="number">0</span>..mxn] <span class="keyword">of</span> int;</span><br><span class="line">    n,m,sz:int;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">procedure</span> <span class="title">add</span><span class="params">(u,v,w:int)</span>;</span></span><br><span class="line"><span class="keyword">begin</span></span><br><span class="line">    inc(sz);g[sz].v:=v;</span><br><span class="line">    g[sz].nxt:=head[u];head[u]:=sz;</span><br><span class="line"><span class="keyword">end</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">bfs</span><span class="params">(s,t0:int)</span>:</span>boolean;</span><br><span class="line"><span class="keyword">var</span></span><br><span class="line">    q:<span class="keyword">array</span>[<span class="number">0</span>..mxn] <span class="keyword">of</span> int;</span><br><span class="line">    h,t,i,u,v:int;</span><br><span class="line"><span class="keyword">begin</span></span><br><span class="line">    fillchar(d,sizeof(d),<span class="number">255</span>);</span><br><span class="line">    h:=<span class="number">1</span>;t:=<span class="number">2</span>;q[h]:=s;d[s]:=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span> h&lt;&gt;t <span class="keyword">do</span> <span class="keyword">begin</span></span><br><span class="line">        u:=q[h];inc(h);i:=head[u];</span><br><span class="line">        <span class="keyword">while</span> i&lt;&gt;<span class="number">0</span> <span class="keyword">do</span> <span class="keyword">begin</span></span><br><span class="line">            v:=g[i].v;</span><br><span class="line">            <span class="keyword">if</span> (g[i].w&gt;<span class="number">0</span>)<span class="keyword">and</span>(d[v]=-<span class="number">1</span>) <span class="keyword">then</span></span><br><span class="line">                <span class="keyword">begin</span> d[v]:=d[u]+<span class="number">1</span>;q[t]:=v;inc(t) <span class="keyword">end</span>;</span><br><span class="line">            i:=g[i].nxt;</span><br><span class="line">        <span class="keyword">end</span>;</span><br><span class="line">    <span class="keyword">end</span>;</span><br><span class="line">    bfs:=d[t0]&lt;&gt;-<span class="number">1</span>;</span><br><span class="line"><span class="keyword">end</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">dfs</span><span class="params">(u,t,f:int)</span>:</span>int;</span><br><span class="line"><span class="keyword">var</span> tmp,v,i:int;</span><br><span class="line"><span class="keyword">begin</span></span><br><span class="line">    <span class="keyword">if</span> u=t <span class="keyword">then</span> <span class="keyword">exit</span>(f);</span><br><span class="line">    i:=head[u];dfs:=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span> i&lt;&gt;<span class="number">0</span> <span class="keyword">do</span> <span class="keyword">begin</span></span><br><span class="line">        v:=g[i].v;</span><br><span class="line">        <span class="keyword">if</span> (g[i].w&gt;<span class="number">0</span>)<span class="keyword">and</span>(d[v]=d[u]+<span class="number">1</span>) <span class="keyword">then</span> <span class="keyword">begin</span> <span class="comment">//&gt;0的条件不要忘</span></span><br><span class="line">            tmp:=dfs(v,t,min(g[i].w,f-dfs));</span><br><span class="line">            dec(g[i].w,tmp);inc(g[i xor <span class="number">1</span>].w,tmp);inc(dfs,tmp);</span><br><span class="line">            <span class="keyword">if</span> dfs=f <span class="keyword">then</span> <span class="keyword">exit</span>(f);</span><br><span class="line">        <span class="keyword">end</span>;</span><br><span class="line">        i:=g[i].nxt;</span><br><span class="line">    <span class="keyword">end</span>;</span><br><span class="line">    <span class="keyword">if</span> dfs=<span class="number">0</span> <span class="keyword">then</span> d[u]:=-<span class="number">1</span>;</span><br><span class="line"><span class="keyword">end</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">maxflow</span><span class="params">(s,t:int)</span>:</span>int;</span><br><span class="line"><span class="keyword">begin</span></span><br><span class="line">    maxflow:=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span> bfs(s,t) <span class="keyword">do</span> inc(maxflow,dfs(s,t,inf));</span><br><span class="line"><span class="keyword">end</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">begin</span> <span class="keyword">end</span>.</span><br></pre></td></tr></table></figure>
<h3 id="非递归拓扑排序"><a href="#非递归拓扑排序" class="headerlink" title="非递归拓扑排序"></a>非递归拓扑排序</h3><p>topo返回值表示是否是dag</p>
<figure class="highlight delphi"><figcaption><span>topo.pas</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">topo</span><span class="params">()</span>:</span>boolean;</span><br><span class="line"><span class="keyword">var</span> </span><br><span class="line">    i,v,u,h,t:int;</span><br><span class="line">    deg,q:<span class="keyword">array</span>[<span class="number">0</span>..mxn] <span class="keyword">of</span> int;</span><br><span class="line"><span class="keyword">begin</span></span><br><span class="line">    fillchar(deg,sizeof(deg),<span class="number">0</span>);</span><br><span class="line">    <span class="keyword">for</span> i:=<span class="number">1</span> <span class="keyword">to</span> sz <span class="keyword">do</span> inc(deg[g[i].v]);</span><br><span class="line">    h:=<span class="number">1</span>;t:=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> i:=<span class="number">1</span> <span class="keyword">to</span> n <span class="keyword">do</span></span><br><span class="line">        <span class="keyword">if</span> deg[i]=<span class="number">0</span> <span class="keyword">then</span> <span class="keyword">begin</span> inc(t);q[t]:=i <span class="keyword">end</span>;</span><br><span class="line">    <span class="keyword">while</span> h&lt;=t <span class="keyword">do</span> <span class="keyword">begin</span></span><br><span class="line">        u:=q[h];inc(h);i:=head[u];</span><br><span class="line">        <span class="keyword">while</span> i&lt;&gt;<span class="number">0</span> <span class="keyword">do</span> <span class="keyword">begin</span></span><br><span class="line">            v:=g[i].v;dec(deg[v]);</span><br><span class="line">            <span class="keyword">if</span> deg[v]=<span class="number">0</span> <span class="keyword">then</span> <span class="keyword">begin</span> inc(t);q[t]:=v <span class="keyword">end</span>;</span><br><span class="line">            i:=g[i].nxt;</span><br><span class="line">        <span class="keyword">end</span>;</span><br><span class="line">    <span class="keyword">end</span>;</span><br><span class="line">    topo:=t=n;</span><br><span class="line"><span class="keyword">end</span>;</span><br></pre></td></tr></table></figure>
<h3 id="差分约束"><a href="#差分约束" class="headerlink" title="差分约束"></a>差分约束</h3><p>规约为最短路即可，可以先想最短路：从u-&gt;v有权为w的边，那么$d[v]\geq d[u]+w$<br>然后将所有不等式变形成这个形式，建图即可。<br>如果求某两个变量差的最小值，则要用最长路解决<br>这类题目做的很少，<a href="/2016/07/25/Luogu-P1993-小K的农场/" title="[Luogu] P1993 小K的农场">[Luogu] P1993 小K的农场</a></p>
<blockquote>
<p>留一个坑：<a href="http://www.cppblog.com/menjitianya/archive/2015/11/19/212292.html" target="_blank" rel="external">http://www.cppblog.com/menjitianya/archive/2015/11/19/212292.html</a></p>
</blockquote>
<h2 id="数据结构类"><a href="#数据结构类" class="headerlink" title="数据结构类"></a>数据结构类</h2><h3 id="莫队"><a href="#莫队" class="headerlink" title="莫队"></a>莫队</h3><p>这其实不算数据结构吧，只是一类数据结构题的一种偷懒的解法罢了<br>写过一次：<a href="/2016/09/08/NOIP模拟赛-2014-7-18/" title="p1-harem">p1-harem</a></p>
<p>其核心思想是离线处理区间统计问题，要求统计量具有这种性质：<br>能在$O(1)$内由区间$[l,r]$的答案得到$[l\pm 1,r\pm 1]$的答案</p>
<p>区间的排序方法是：按$\sqrt{n}$分块，第一关键字为所在块编号，第二关键字为右端点<br>复杂度：</p>
<ul>
<li>同一块内<ol>
<li>由于按块编号排序，左端点每次变化$O(\sqrt{N})$，则总复杂度$O(N\sqrt{N})$</li>
<li>右端点顺序排列，因此为$O(N)$，而总共$\sqrt{N}$块，总复杂度$O(N\sqrt{N})$。</li>
</ol>
</li>
<li>跨块的复杂度也类似，是同阶的</li>
</ul>
<p>注意点：区间初始为$l=1,r=0$，注意端点</p>
<p>上面那题的核心代码</p>
<figure class="highlight delphi"><figcaption><span>mo.pas</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> int=longint;</span><br><span class="line"><span class="keyword">var</span></span><br><span class="line">    n,m,k:int;</span><br><span class="line">    q:<span class="keyword">array</span>[<span class="number">0</span>..<span class="number">100010</span>,<span class="number">0</span>..<span class="number">3</span>] <span class="keyword">of</span> int; <span class="comment">//[编号,l,r,所在块]</span></span><br><span class="line">    ans,a:<span class="keyword">array</span>[<span class="number">0</span>..<span class="number">100010</span>] <span class="keyword">of</span> int;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">com</span><span class="params">(i,j:int)</span>:</span>boolean; <span class="comment">//i&lt;j</span></span><br><span class="line"><span class="keyword">begin</span></span><br><span class="line">    com:=(q[i,<span class="number">3</span>]&lt;q[j,<span class="number">3</span>]) <span class="keyword">or</span> ((q[i,<span class="number">3</span>]=q[j,<span class="number">3</span>]) <span class="keyword">and</span> (q[i,<span class="number">2</span>]&lt;q[j,<span class="number">2</span>]));</span><br><span class="line"><span class="keyword">end</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">procedure</span> <span class="title">qsort</span><span class="params">(l,r:int)</span>;</span> <span class="comment">//用com函数排序，略</span></span><br><span class="line"><span class="function"><span class="keyword">procedure</span> <span class="title">update</span><span class="params">(x,i:int)</span>;</span> <span class="comment">//相关更新操作，略</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">procedure</span> <span class="title">init</span><span class="params">()</span>;</span></span><br><span class="line"><span class="keyword">var</span> i:int;</span><br><span class="line"><span class="keyword">begin</span></span><br><span class="line">    <span class="comment">&#123;...data input&#125;</span></span><br><span class="line">    <span class="keyword">read</span>(n);k:=trunc(sqrt(n)); <span class="comment">//n=询问数,k=块的大小</span></span><br><span class="line">    <span class="keyword">for</span> i:=<span class="number">1</span> <span class="keyword">to</span> n <span class="keyword">do</span> <span class="keyword">begin</span></span><br><span class="line">        <span class="keyword">read</span>(q[i,<span class="number">1</span>],q[i,<span class="number">2</span>]);q[i,<span class="number">0</span>]:=i;</span><br><span class="line">        q[i,<span class="number">3</span>]:=(q[i,<span class="number">1</span>]-<span class="number">1</span>)<span class="keyword">div</span> k+<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">end</span>;</span><br><span class="line">    qsort(<span class="number">1</span>,n);</span><br><span class="line"><span class="keyword">end</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">procedure</span> <span class="title">mo</span><span class="params">()</span>;</span></span><br><span class="line"><span class="keyword">var</span> i,j,l,r,cnt:int;</span><br><span class="line"><span class="keyword">begin</span></span><br><span class="line">    l:=<span class="number">1</span>;r:=<span class="number">0</span>;cnt:=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> i:=<span class="number">1</span> <span class="keyword">to</span> n <span class="keyword">do</span> <span class="keyword">begin</span></span><br><span class="line">        <span class="keyword">for</span> j:=r+<span class="number">1</span> <span class="keyword">to</span> q[i,<span class="number">2</span>] <span class="keyword">do</span> update(a[j],<span class="number">1</span>);</span><br><span class="line">        <span class="keyword">for</span> j:=r <span class="keyword">downto</span> q[i,<span class="number">2</span>]+<span class="number">1</span> <span class="keyword">do</span> update(a[j],-<span class="number">1</span>);</span><br><span class="line">        <span class="keyword">for</span> j:=l <span class="keyword">to</span> q[i,<span class="number">1</span>]-<span class="number">1</span> <span class="keyword">do</span> update(a[j],-<span class="number">1</span>);</span><br><span class="line">        <span class="keyword">for</span> j:=l-<span class="number">1</span> <span class="keyword">downto</span> q[i,<span class="number">1</span>] <span class="keyword">do</span> update(a[j],<span class="number">1</span>);</span><br><span class="line">        l:=q[i,<span class="number">1</span>];r:=q[i,<span class="number">2</span>];ans[q[i,<span class="number">0</span>]]:=cnt;</span><br><span class="line">    <span class="keyword">end</span>;</span><br><span class="line">    <span class="keyword">for</span> i:=<span class="number">1</span> <span class="keyword">to</span> n <span class="keyword">do</span> writeln(ans[i]);</span><br><span class="line"><span class="keyword">end</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">begin</span> <span class="keyword">end</span>.</span><br></pre></td></tr></table></figure>
<h3 id="分块（块状数组）"><a href="#分块（块状数组）" class="headerlink" title="分块（块状数组）"></a>分块（块状数组）</h3><p>只写过一次分块题：<a href="/2016/09/06/NOIP模拟赛-教主的魔法/" title="NOIP模拟赛 教主的魔法">NOIP模拟赛 教主的魔法</a><br>注意点：</p>
<ol>
<li>不要混淆块编号和元素编号</li>
<li>在下面的模型中，tag维护块的懒标记，再暴力首尾两块时不必重新处理，因为尽管块内元素的顺序有变化，但总的增量是不变的</li>
</ol>
<p>带修改，区间中统计不小于k的元素个数<br><figure class="highlight delphi"><figcaption><span>block.pas</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">uses</span> math;</span><br><span class="line"><span class="keyword">const</span> mxn=<span class="number">100010</span>;</span><br><span class="line"><span class="keyword">type</span> int=longint;</span><br><span class="line"><span class="keyword">var</span></span><br><span class="line">    a,b,blk,tag:<span class="keyword">array</span>[<span class="number">0</span>..mxn] <span class="keyword">of</span> int;</span><br><span class="line">    n,k:int;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">bin</span><span class="params">(i,x:int)</span>:</span>int; <span class="comment">//省略</span></span><br><span class="line"><span class="function"><span class="keyword">procedure</span> <span class="title">qsort</span><span class="params">(l,r:int)</span>;</span> <span class="comment">//省略</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">procedure</span> <span class="title">sort</span><span class="params">(x:int)</span>;</span></span><br><span class="line"><span class="keyword">var</span> i,l,r:int;</span><br><span class="line"><span class="keyword">begin</span></span><br><span class="line">    l:=(x-<span class="number">1</span>)*k+<span class="number">1</span>;r:=min(n,x*k); <span class="comment">//<span class="doctag">bug:</span> x是块编号</span></span><br><span class="line">    <span class="keyword">for</span> i:=l <span class="keyword">to</span> r <span class="keyword">do</span> b[i]:=a[i]<span class="comment">&#123;+tag[x]&#125;</span>;</span><br><span class="line">    <span class="comment">&#123;tag[x]:=0;&#125;</span>qsort(l,r);</span><br><span class="line"><span class="keyword">end</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">procedure</span> <span class="title">modify</span><span class="params">(l,r,x:int)</span>;</span></span><br><span class="line"><span class="keyword">var</span> i:int;</span><br><span class="line"><span class="keyword">begin</span></span><br><span class="line">    <span class="keyword">for</span> i:=l <span class="keyword">to</span> min(r,blk[l]*k) <span class="keyword">do</span> inc(a[i],x); <span class="comment">//<span class="doctag">bug:</span>起始为l</span></span><br><span class="line">    sort(blk[l]);</span><br><span class="line">    <span class="keyword">if</span> blk[l]=blk[r] <span class="keyword">then</span> <span class="keyword">exit</span>;</span><br><span class="line">    <span class="keyword">for</span> i:=(blk[r]-<span class="number">1</span>)*k+<span class="number">1</span> <span class="keyword">to</span> r <span class="keyword">do</span> inc(a[i],x); <span class="comment">//<span class="doctag">bug:</span>结束为r</span></span><br><span class="line">    sort(blk[r]);</span><br><span class="line">    <span class="keyword">for</span> i:=blk[l]+<span class="number">1</span> <span class="keyword">to</span> blk[r]-<span class="number">1</span> <span class="keyword">do</span> inc(tag[i],x);</span><br><span class="line"><span class="keyword">end</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">query</span><span class="params">(l,r,x:int)</span>:</span>int;</span><br><span class="line"><span class="keyword">var</span> i:int;</span><br><span class="line"><span class="keyword">begin</span></span><br><span class="line">    query:=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> i:=l <span class="keyword">to</span> min(r,blk[l]*k) <span class="keyword">do</span></span><br><span class="line">        <span class="keyword">if</span> a[i]+tag[blk[l]]&gt;=x <span class="keyword">then</span> inc(query); <span class="comment">//tag下标是块编号</span></span><br><span class="line">    <span class="keyword">if</span> blk[l]=blk[r] <span class="keyword">then</span> <span class="keyword">exit</span>(query);</span><br><span class="line">    <span class="keyword">for</span> i:=(blk[r]-<span class="number">1</span>)*k+<span class="number">1</span> <span class="keyword">to</span> r <span class="keyword">do</span></span><br><span class="line">        <span class="keyword">if</span> a[i]+tag[blk[r]]&gt;=x <span class="keyword">then</span> inc(query);</span><br><span class="line">    <span class="keyword">for</span> i:=blk[l]+<span class="number">1</span> <span class="keyword">to</span> blk[r]-<span class="number">1</span> <span class="keyword">do</span> inc(query,min(i*k,n)-bin(i,x));</span><br><span class="line">    <span class="comment">//bin(i,x): max_j&#123;b[j]+tag[i]&lt;x,j in i&#125;</span></span><br><span class="line"><span class="keyword">end</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">procedure</span> <span class="title">init</span><span class="params">()</span>;</span></span><br><span class="line"><span class="keyword">var</span> i:int;</span><br><span class="line"><span class="keyword">begin</span></span><br><span class="line">    k:=trunc(sqrt(n));</span><br><span class="line">    <span class="keyword">for</span> i:=<span class="number">1</span> <span class="keyword">to</span> n <span class="keyword">do</span> blk[i]:=(i-<span class="number">1</span>)<span class="keyword">div</span> k+<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span> i:=<span class="number">1</span> <span class="keyword">to</span> blk[n] <span class="keyword">do</span> sort(i);</span><br><span class="line"><span class="keyword">end</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">begin</span> <span class="keyword">end</span>.</span><br></pre></td></tr></table></figure></p>
<h3 id="Treap"><a href="#Treap" class="headerlink" title="Treap"></a>Treap</h3><p>模板题见此：</p>
<h2 id="其他"><a href="#其他" class="headerlink" title="其他"></a>其他</h2><h3 id="高斯消元"><a href="#高斯消元" class="headerlink" title="高斯消元"></a>高斯消元</h3><p>解线性方程组，做一道物理题：<a href="/2016/08/29/JSOI2016-提高1班-Day3-resistor/" title="jsoi2016 resistor">jsoi2016 resistor</a></p>
<figure class="highlight delphi"><figcaption><span>gs.pas</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> mxn=<span class="number">110</span>;eps=<span class="number">0.000000001</span>;</span><br><span class="line"><span class="keyword">type</span></span><br><span class="line">    int=longint;</span><br><span class="line">    mat=<span class="keyword">array</span>[<span class="number">0</span>..mxn,<span class="number">0</span>..mxn] <span class="keyword">of</span> double;</span><br><span class="line"><span class="function"><span class="keyword">procedure</span> <span class="title">gauss</span><span class="params">(<span class="keyword">var</span> a:mat;n:int)</span>;</span></span><br><span class="line"><span class="keyword">var</span></span><br><span class="line">    i,j,k,p:int;</span><br><span class="line">    tmp:<span class="keyword">array</span>[<span class="number">0</span>..mxn] <span class="keyword">of</span> double;</span><br><span class="line"><span class="keyword">begin</span></span><br><span class="line">    <span class="keyword">for</span> i:=<span class="number">1</span> <span class="keyword">to</span> n <span class="keyword">do</span> <span class="keyword">begin</span></span><br><span class="line">        p:=i; <span class="comment">//换主元</span></span><br><span class="line">        <span class="keyword">for</span> j:=i+<span class="number">1</span> <span class="keyword">to</span> n <span class="keyword">do</span> <span class="keyword">if</span> a[j,i]&gt;a[p,i] <span class="keyword">then</span> p:=j;</span><br><span class="line">        <span class="keyword">if</span> abs(a[p,i])&lt;eps <span class="keyword">then</span> <span class="keyword">exit</span>; <span class="comment">//无解</span></span><br><span class="line">        tmp:=a[i];a[i]:=a[p];a[p]:=tmp;</span><br><span class="line">        <span class="keyword">for</span> j:=i+<span class="number">1</span> <span class="keyword">to</span> n+<span class="number">1</span> <span class="keyword">do</span> a[i,j]:=a[i,j]/a[i,i]; <span class="comment">//处理主元所在行</span></span><br><span class="line">        <span class="keyword">for</span> j:=<span class="number">1</span> <span class="keyword">to</span> n <span class="keyword">do</span> <span class="keyword">if</span> i&lt;&gt;j <span class="keyword">then</span> <span class="comment">//处理余下行</span></span><br><span class="line">            <span class="keyword">for</span> k:=i+<span class="number">1</span> <span class="keyword">to</span> n+<span class="number">1</span> <span class="keyword">do</span> a[j,k]:=a[j,k]-a[j,i]*a[i,k];</span><br><span class="line">    <span class="keyword">end</span>;</span><br><span class="line">    <span class="keyword">for</span> i:=<span class="number">1</span> <span class="keyword">to</span> n <span class="keyword">do</span> writeln(<span class="string">'x'</span>,i,<span class="string">'='</span>,a[i,n+<span class="number">1</span>]:<span class="number">0</span>:<span class="number">3</span>);</span><br><span class="line"><span class="keyword">end</span>;</span><br></pre></td></tr></table></figure>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;noip前复习一些不熟悉的模板&lt;br&gt;在历时4个月的刷题过程中，有些算法一带而过，之写过一两次或者年代久远或者理解肤浅，需要在考前复习。&lt;br&gt;
    
    </summary>
    
      <category term="Algorithm Note" scheme="https://cothrax.github.io/categories/Algorithm-Note/"/>
    
    
  </entry>
  
  <entry>
    <title>NOIP2016十连测总结</title>
    <link href="https://cothrax.github.io/2016/11/10/lydsy-noip-2016-summary/"/>
    <id>https://cothrax.github.io/2016/11/10/lydsy-noip-2016-summary/</id>
    <published>2016-11-10T15:08:22.000Z</published>
    <updated>2016-11-11T16:08:56.080Z</updated>
    
    <content type="html"><![CDATA[<p>NOIP2016十连测在12天前已经完结，除了几个神坑没有填之外，基本订正完毕。<br>从一个蒟蒻的noiper的角度看，除了god出的前两场，其余均为NOIplus难度。</p>
<blockquote>
<p>I good vegetable.</p>
</blockquote>
<a id="more"></a>
<h2 id="挖坑"><a href="#挖坑" class="headerlink" title="挖坑"></a>挖坑</h2><ol>
<li><a href="/2016/10/03/lydsy-noip-2016-test2/" title="Test2 T3 speed">Test2 T3 speed</a>：好吧题解都看不懂</li>
<li><a href="/2016/10/28/lydsy-noip-2016-test9/" title="Test9 T3 mst">Test9 T3 mst</a>：过于noip的计算几何题</li>
<li><a href="/2016/11/04/lydsy-noip-2016-test7/" title="Test7 T3 tournament">Test7 T3 tournament</a>和<a href="/2016/10/16/lydsy-noip-2016-test6/" title="Test6 T2 goodbye">Test6 T2 goodbye</a>：概率期望的知识要补</li>
<li><a href="/2016/10/28/lydsy-noip-2016-test5/" title="Test5 T3 travel">Test5 T3 travel</a>：题解好长，想法题，先留着吧</li>
<li>一些不明白的地方<ol>
<li><a href="/2016/10/10/lydsy-noip-2016-test4/" title="Test4 T3 ra">Test4 T3 ra</a>的部分分解法和复杂度的分析</li>
<li><a href="/2016/11/04/lydsy-noip-2016-test7/" title="Test7 T2 password">Test7 T2 password</a>的方程个数的期望</li>
</ol>
</li>
</ol>
<h2 id="简单题"><a href="#简单题" class="headerlink" title="简单题"></a>简单题</h2><ol>
<li><a href="/2016/10/02/lydsy-noip-2016-test1/" title="Test1 T1 master">Test1 T1 master</a>：字符串dp</li>
<li><a href="/2016/10/03/lydsy-noip-2016-test2/" title="Test2 T1 div">Test2 T1 div</a>：乱搞</li>
<li><a href="/2016/10/10/lydsy-noip-2016-test4/" title="Test4 T1 orisis">Test4 T1 orisis</a>：水</li>
<li><a href="/2016/10/30/lydsy-noip-2016-test8/" title="Test9 T1 2048">Test9 T1 2048</a>：模拟</li>
<li><a href="/2016/10/16/lydsy-noip-2016-test6/" title="Test6 T1 fantasy">Test6 T1 fantasy</a>：观察+乱搞（被卡常）</li>
</ol>
<h2 id="新知"><a href="#新知" class="headerlink" title="新知"></a>新知</h2><ol>
<li>数论<ol>
<li>裴蜀定理：<a href="/2016/10/28/lydsy-noip-2016-test5/" title="Test5 T1 simple">Test5 T1 simple</a></li>
<li>杜教筛？：<a href="/2016/10/10/lydsy-noip-2016-test4/" title="Test4 T3 ra">Test4 T3 ra</a></li>
</ol>
</li>
<li>dfs序：<a href="/2016/10/28/lydsy-noip-2016-test9/" title="Test10 T3 lca">Test10 T3 lca</a><ul>
<li>“贡献”的思想，还有<a href="/2016/10/09/lydsy-noip-2016-test3/" title="Test3 T3 seq">Test3 T3 seq</a></li>
</ul>
</li>
<li>容斥dp：<a href="/2016/10/10/lydsy-noip-2016-test4/" title="Test4 T2 obelisk">Test4 T2 obelisk</a></li>
</ol>
<h2 id="长见识"><a href="#长见识" class="headerlink" title="长见识"></a>长见识</h2><ol>
<li>dp类<ol>
<li>强行单调后二分：<a href="/2016/10/03/lydsy-noip-2016-test2/" title="Test2 T2 market">Test2 T2 market</a></li>
<li>数据结构优化lis：<a href="/2016/10/30/lydsy-noip-2016-test8/" title="Test8 T2 hamon">Test8 T2 hamon</a></li>
<li>广义矩阵乘法+快速幂：<a href="/2016/10/28/lydsy-noip-2016-test9/" title="Test10 T1 lis">Test10 T1 lis</a></li>
<li>最短路处理dp（woc这是图论题）：<a href="/2016/10/28/lydsy-noip-2016-test9/" title="Test10 T2 bag">Test10 T2 bag</a></li>
</ol>
</li>
<li>位运算求交集：<a href="/2016/10/02/lydsy-noip-2016-test1/" title="Test1 T2 tour">Test1 T2 tour</a></li>
<li>图论<ol>
<li>增点：<a href="/2016/10/02/lydsy-noip-2016-test1/" title="Test1 T3 walk">Test1 T3 walk</a></li>
<li>拆点+路径求交+破环成链+dag上dp：<a href="/2016/10/16/lydsy-noip-2016-test6/" title="Test6 T3 reality">Test6 T3 reality</a></li>
</ol>
</li>
</ol>
<h2 id="脑洞"><a href="#脑洞" class="headerlink" title="脑洞"></a>脑洞</h2><ol>
<li>神奇二分，化最优解为统计问题：<a href="/2016/10/09/lydsy-noip-2016-test3/" title="Test3 T1 ave">Test3 T1 ave</a></li>
<li><a href="/2016/10/28/lydsy-noip-2016-test5/" title="Test5 T2 walk">Test5 T2 walk</a>
<ol>
<li>如何处理常数：链表、栈</li>
<li>如何处理gcd：按倍数枚举</li>
</ol>
</li>
<li>自己看吧：<a href="/2016/10/30/lydsy-noip-2016-test8/" title="Test8 T3 raviel">Test8 T3 raviel</a></li>
<li><a href="/2016/10/30/lydsy-noip-2016-test8/" title="Test9 T2 seq">Test9 T2 seq</a>
<ol>
<li>40分可以dp，noip难度类似2015的子串</li>
<li>结论</li>
</ol>
</li>
<li>可以乱搞：<a href="/2016/10/28/lydsy-noip-2016-test9/" title="Test10 T1 lis">Test10 T1 lis</a></li>
</ol>
<h2 id="知识强化"><a href="#知识强化" class="headerlink" title="知识强化"></a>知识强化</h2><ol>
<li>主席树二维数点：<a href="/2016/10/09/lydsy-noip-2016-test3/" title="Test3 T3 seq">Test3 T3 seq</a></li>
<li>好像没有了</li>
</ol>
<h2 id="数学啊数学"><a href="#数学啊数学" class="headerlink" title="数学啊数学"></a>数学啊数学</h2><ol>
<li>恶心的组合数学dp：<a href="/2016/10/09/lydsy-noip-2016-test3/" title="Test3 T2 color">Test3 T2 color</a></li>
<li>坑爹数论：<a href="/2016/10/30/lydsy-noip-2016-test8/" title="Test8 T1 uria">Test8 T1 uria</a></li>
<li>递推解约瑟夫+<strong>打表</strong>：<a href="/2016/11/04/lydsy-noip-2016-test7/" title="Test7 T1 joseph">Test7 T1 joseph</a></li>
<li>同余方程组+带权并查集：<a href="/2016/11/04/lydsy-noip-2016-test7/" title="Test7 T2 password">Test7 T2 password</a></li>
</ol>
<h2 id="写在后面"><a href="#写在后面" class="headerlink" title="写在后面"></a>写在后面</h2><p>可以说这次十连测暴露出了大量的知识盲区，题目的思维深度超出了一个蒟蒻的能力范围。<br>在算法能力方面，这次测试给了我很大的提升，但完全没有达到训练应试能力/代码能力的效果<del>（因为看完题面连暴力都懒得打了orz）</del></p>
<blockquote>
<p>while true do inc(rp);</p>
</blockquote>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;NOIP2016十连测在12天前已经完结，除了几个神坑没有填之外，基本订正完毕。&lt;br&gt;从一个蒟蒻的noiper的角度看，除了god出的前两场，其余均为NOIplus难度。&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;I good vegetable.&lt;/p&gt;
&lt;/blockquote&gt;
    
    </summary>
    
      <category term="Algorithm Note" scheme="https://cothrax.github.io/categories/Algorithm-Note/"/>
    
    
  </entry>
  
  <entry>
    <title>NOIP2016十连测 Day 10</title>
    <link href="https://cothrax.github.io/2016/11/04/lydsy-noip-2016-test10/"/>
    <id>https://cothrax.github.io/2016/11/04/lydsy-noip-2016-test10/</id>
    <published>2016-11-04T13:55:20.000Z</published>
    <updated>2016-11-08T14:47:42.991Z</updated>
    
    <content type="html"><![CDATA[<blockquote>
<p>订正进度(3/3)</p>
</blockquote>
<h1 id="P1-lis"><a href="#P1-lis" class="headerlink" title="P1 lis"></a>P1 lis</h1><p>大意：<br>给定长度n和参数$t_0,A,B,C,D$，定义数列$a_n$：<br>$n=1,a[n]=t_0$<br>$n\geq 2,a[n]=(A\times a_{n-1}^2+B\times a_{n-1}+C)\% D$</p>
<p>求$a_n$的最长不下降子序列<br>$0\leq t_0,A,B,C\leq150,1\leq D\leq150, 1\leq n\leq10^{12}$<br><a id="more"></a></p>
<h2 id="解法一"><a href="#解法一" class="headerlink" title="解法一"></a>解法一</h2><p>复杂度：$O(D^3logN)$<br>根据鸽巢原理，该数列一定有循环节$T\leq D$，该数列为<span>$\{l+m*T+r\}$</span><!-- Has MathJax -->，l为前面不属于循环节的部分，r为末尾剩余的不完整循环<br>考虑纯循环数列的lis<br>记f[n,i,j]为以a[i]开头，a[nT+j]结尾的lis<br>那么$f[n,i,j]=max_{1\leq k\leq T,a[i]\leq a[j]\leq a[k]}(f[n-1,i,k]+f[1,k,j]-1)$</p>
<p>这里定义矩阵$C=A\times B$：$$C[i,j]=max_{k=1}^n(A[i,k]+B[k,j]-1)$$</p>
<p>可以证明该乘法满足结合律，那么可以用矩阵快速幂求解f[n]：<br>$f[n]=f[n-1]\times f[1]=f[1]^n$<br>要求$a[i]\leq a[j]$，则不合法的g[i,j]标记为$-\infty$<br>单位矩阵的对角线上为0，其余为$-\infty$<br>初始矩阵f[1]直接dp求即可</p>
<p>记l[i]为<span>$\{l\}$</span><!-- Has MathJax -->中满足上界为T[i]的lis<br>记r[i]为<span>$\{r\}$</span><!-- Has MathJax -->中满足下界为T[i]的lis<br>这两个用直接dp求得</p>
<p>然后枚举中间部分的左右端点<br>$ans=max_{1\leq i,j\leq T}(l[i]+r[i]+g[m-1,i,j])$</p>
<p>细节：</p>
<ol>
<li>两个特判<ol>
<li>$n\leq l+T$，此时暴力求</li>
<li>循环节长为1时特判</li>
</ol>
</li>
<li>初始化矩阵时，枚举i,j求i..T+j的lis值，注意必须要以i开头、T+j结尾</li>
<li>快速幂的指数为m-1</li>
<li>不要让$-\infty$参与运算，防止出现诡异的错误</li>
</ol>
<div><br><div class="copy"><br>    <a href="/2016/11/04/lydsy-noip-2016-test10/lis_.pas" title="{plain text}">{plain text}</a><br></div><br><div><br><figure class="highlight delphi"><figcaption><span>_lis.pas</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">uses</span> math;</span><br><span class="line"><span class="keyword">const</span> inf=<span class="number">1000000000</span>;</span><br><span class="line"><span class="keyword">type</span> </span><br><span class="line">    int=longint;</span><br><span class="line">    mat=<span class="keyword">array</span>[<span class="number">0</span>..<span class="number">155</span>,<span class="number">0</span>..<span class="number">155</span>] <span class="keyword">of</span> int64;</span><br><span class="line"><span class="keyword">var</span> </span><br><span class="line">    a,b,c,d,k,i,j,x,til,len,rst:int;</span><br><span class="line">    l,r,f,s,loc:<span class="keyword">array</span>[<span class="number">0</span>..<span class="number">2240</span>] <span class="keyword">of</span> int;</span><br><span class="line">    g:mat;n,m,ans:int64;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">bin</span><span class="params">(x,n:int)</span>:</span>int;</span><br><span class="line"><span class="keyword">var</span> l,r,mid:int;</span><br><span class="line"><span class="keyword">begin</span></span><br><span class="line">    <span class="comment">//max_j&#123;f[j]&lt;=x&#125;</span></span><br><span class="line">    l:=<span class="number">1</span>;r:=n;bin:=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span> l&lt;=r <span class="keyword">do</span> <span class="keyword">begin</span></span><br><span class="line">        mid:=(l+r) <span class="keyword">shr</span> <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">if</span> f[mid]&lt;=x <span class="keyword">then</span> <span class="keyword">begin</span> bin:=mid;l:=mid+<span class="number">1</span> <span class="keyword">end</span></span><br><span class="line">        <span class="keyword">else</span> r:=mid-<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">end</span>;</span><br><span class="line"><span class="keyword">end</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">lis</span><span class="params">(dn,up,n,b:int)</span>:</span>int;</span><br><span class="line"><span class="keyword">var</span> i,j:int;</span><br><span class="line"><span class="keyword">begin</span></span><br><span class="line">    <span class="keyword">for</span> i:=<span class="number">1</span> <span class="keyword">to</span> n <span class="keyword">do</span> f[i]:=inf;</span><br><span class="line">    lis:=<span class="number">0</span>;f[<span class="number">0</span>]:=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> i:=<span class="number">1</span> <span class="keyword">to</span> n <span class="keyword">do</span> <span class="keyword">begin</span></span><br><span class="line">        <span class="keyword">if</span> (s[b+i]&lt;dn)<span class="keyword">or</span>(s[b+i]&gt;up) <span class="keyword">then</span> <span class="keyword">continue</span>;</span><br><span class="line">        j:=bin(s[b+i],lis);</span><br><span class="line">        f[j+<span class="number">1</span>]:=min(f[j+<span class="number">1</span>],s[b+i]);</span><br><span class="line">        <span class="keyword">if</span> j=lis <span class="keyword">then</span> inc(lis);</span><br><span class="line">    <span class="keyword">end</span>;</span><br><span class="line"><span class="keyword">end</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> _<span class="title">lis</span><span class="params">(n,b:int)</span>:</span>int;</span><br><span class="line"><span class="keyword">var</span> i,j,len:int;</span><br><span class="line"><span class="keyword">begin</span></span><br><span class="line">    <span class="keyword">for</span> i:=<span class="number">1</span> <span class="keyword">to</span> n <span class="keyword">do</span> f[i]:=inf;</span><br><span class="line">    f[<span class="number">1</span>]:=s[b+<span class="number">1</span>];len:=<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span> i:=<span class="number">2</span> <span class="keyword">to</span> n <span class="keyword">do</span> <span class="keyword">begin</span></span><br><span class="line">        j:=bin(s[b+i],len);</span><br><span class="line">        <span class="keyword">if</span> j&gt;<span class="number">0</span> <span class="keyword">then</span> f[j+<span class="number">1</span>]:=min(f[j+<span class="number">1</span>],s[b+i]);</span><br><span class="line">        <span class="keyword">if</span> j=len <span class="keyword">then</span> inc(len);</span><br><span class="line">    <span class="keyword">end</span>;</span><br><span class="line">    _lis:=j+<span class="number">1</span>;</span><br><span class="line"><span class="keyword">end</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">mul</span><span class="params">(<span class="keyword">var</span> a,b:mat)</span>:</span>mat;</span><br><span class="line"><span class="keyword">var</span> i,j,k:int;</span><br><span class="line"><span class="keyword">begin</span></span><br><span class="line">    fillchar(mul,sizeof(mul),<span class="number">224</span>);</span><br><span class="line">    <span class="keyword">for</span> i:=<span class="number">1</span> <span class="keyword">to</span> len <span class="keyword">do</span></span><br><span class="line">        <span class="keyword">for</span> j:=<span class="number">1</span> <span class="keyword">to</span> len <span class="keyword">do</span></span><br><span class="line">            <span class="keyword">for</span> k:=<span class="number">1</span> <span class="keyword">to</span> len <span class="keyword">do</span> <span class="keyword">if</span> min(a[i,k],b[k,j])&gt;=<span class="number">0</span> <span class="keyword">then</span></span><br><span class="line">                mul[i,j]:=max(mul[i,j],a[i,k]+b[k,j]-<span class="number">1</span>);</span><br><span class="line"><span class="keyword">end</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">mpow</span><span class="params">(<span class="keyword">var</span> a:mat;p:int64)</span>:</span>mat;</span><br><span class="line"><span class="keyword">var</span> i:int;</span><br><span class="line"><span class="keyword">begin</span></span><br><span class="line">    fillchar(mpow,sizeof(mpow),<span class="number">224</span>);</span><br><span class="line">    <span class="keyword">for</span> i:=<span class="number">1</span> <span class="keyword">to</span> len <span class="keyword">do</span> mpow[i,i]:=<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">while</span> p&gt;<span class="number">0</span> <span class="keyword">do</span> <span class="keyword">begin</span></span><br><span class="line">        <span class="keyword">if</span> p <span class="keyword">and</span> <span class="number">1</span>=<span class="number">1</span> <span class="keyword">then</span> mpow:=mul(mpow,a);</span><br><span class="line">        a:=mul(a,a);</span><br><span class="line">        p:=p <span class="keyword">shr</span> <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">end</span>;</span><br><span class="line"><span class="keyword">end</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">begin</span></span><br><span class="line">    assign(input,<span class="string">'lis.in'</span>);reset(input);</span><br><span class="line">    assign(output,<span class="string">'lis.out'</span>);rewrite(output);</span><br><span class="line">    <span class="keyword">read</span>(n,s[<span class="number">1</span>],a,b,c,d);k:=<span class="number">1</span>;</span><br><span class="line">    <span class="comment">//找循环节</span></span><br><span class="line">    <span class="keyword">while</span> true <span class="keyword">do</span> <span class="keyword">begin</span></span><br><span class="line">        x:=(a*sqr(s[k])+b*s[k]+c)<span class="keyword">mod</span> d;</span><br><span class="line">        <span class="keyword">if</span> loc[x]&gt;<span class="number">0</span> <span class="keyword">then</span> <span class="keyword">break</span>;</span><br><span class="line">        inc(k);s[k]:=x;loc[x]:=k;</span><br><span class="line">    <span class="keyword">end</span>;</span><br><span class="line">    til:=loc[x]-<span class="number">1</span>;len:=k-loc[x]+<span class="number">1</span>;</span><br><span class="line">    rst:=(n-til)<span class="keyword">mod</span> len;m:=(n-til)<span class="keyword">div</span> len;</span><br><span class="line">    <span class="keyword">if</span> n&lt;=k <span class="keyword">then</span> <span class="comment">//不足一个周期特判</span></span><br><span class="line">        <span class="keyword">begin</span> <span class="keyword">write</span>(lis(-<span class="number">1</span>,d,n,<span class="number">0</span>));halt <span class="keyword">end</span>;</span><br><span class="line">    <span class="keyword">if</span> len=<span class="number">1</span> <span class="keyword">then</span> <span class="comment">//周期为1特判</span></span><br><span class="line">        <span class="keyword">begin</span> <span class="keyword">write</span>(m+lis(-<span class="number">1</span>,s[til+<span class="number">1</span>],til,<span class="number">0</span>));halt <span class="keyword">end</span>;</span><br><span class="line">    <span class="keyword">for</span> i:=k+<span class="number">1</span> <span class="keyword">to</span> k+len <span class="keyword">do</span> s[i]:=s[i-len];</span><br><span class="line">    <span class="comment">//预处理</span></span><br><span class="line">    <span class="keyword">for</span> i:=<span class="number">1</span> <span class="keyword">to</span> len <span class="keyword">do</span> <span class="keyword">begin</span></span><br><span class="line">        l[i]:=lis(-<span class="number">1</span>,s[til+i],til,<span class="number">0</span>);</span><br><span class="line">        r[i]:=lis(s[til+i],d,rst,til);</span><br><span class="line">    <span class="keyword">end</span>;</span><br><span class="line">    <span class="comment">//矩阵快速幂</span></span><br><span class="line">    <span class="comment">//g[n,i,j]=max(g[n-1,i,j]+g[1,j,k]) a[i]&lt;=a[j]&lt;=a[k]</span></span><br><span class="line">    <span class="keyword">for</span> i:=<span class="number">1</span> <span class="keyword">to</span> len <span class="keyword">do</span></span><br><span class="line">        <span class="keyword">for</span> j:=<span class="number">1</span> <span class="keyword">to</span> len <span class="keyword">do</span></span><br><span class="line">            <span class="keyword">if</span> s[til+i]&gt;s[til+j] <span class="keyword">then</span> g[i,j]:=-inf</span><br><span class="line">            <span class="keyword">else</span> g[i,j]:=_lis(len-i+j+<span class="number">1</span>,til-<span class="number">1</span>+i);</span><br><span class="line">    g:=mpow(g,m-<span class="number">1</span>);ans:=<span class="number">0</span>;</span><br><span class="line">    <span class="comment">//统计答案</span></span><br><span class="line">    <span class="keyword">for</span> i:=<span class="number">1</span> <span class="keyword">to</span> len <span class="keyword">do</span></span><br><span class="line">        <span class="keyword">for</span> j:=<span class="number">1</span> <span class="keyword">to</span> len <span class="keyword">do</span></span><br><span class="line">            ans:=max(ans,l[i]+r[j]+g[i,j]);</span><br><span class="line">    <span class="keyword">write</span>(ans);</span><br><span class="line">    close(input);close(output);</span><br><span class="line"><span class="keyword">end</span>.</span><br></pre></td></tr></table></figure><br><br></div></div>

<h2 id="解法二"><a href="#解法二" class="headerlink" title="解法二"></a>解法二</h2><p>复杂度：$O(D^2logN)$<br>其实这题可以乱搞：<br>在n比较小时，可以直接暴力生成$O(NlogN)$求LIS<br>而当n足够大时，有如下解法：<br>为叙述方便，记$LIS(dn,up,seq)$为求在数列seq中$seq[i]\in[dn,up]$的LIS值<br>枚举一个循环节中的数T[i]，记$dt=l^2$<br>用<span>$LIS(-\infty,T[i],\{l+dt*T\})+(m-2*l)+LIS(T[i],+\infty,\{dt*T+r\})$</span><!-- Has MathJax --><br>简单来说，就是求l并上$l^2$个T的lis、$l^2$个T并上r的lis，中间部分的lis=循环节数<br>正确性显然<br>细节：注意端点</p>
<div><br><div class="copy"><br>    <a href="/2016/11/04/lydsy-noip-2016-test10/lis.pas" title="{plain text}">{plain text}</a><br></div><br><div><br><figure class="highlight delphi"><figcaption><span>lis.pas</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">uses</span> math;</span><br><span class="line"><span class="keyword">type</span> int=longint;ll=int64;</span><br><span class="line"><span class="keyword">const</span> inf=<span class="number">1000000</span>;mx=<span class="number">100000</span>;</span><br><span class="line"><span class="keyword">var</span> </span><br><span class="line">    loc:<span class="keyword">array</span>[<span class="number">0</span>..<span class="number">155</span>] <span class="keyword">of</span> int;</span><br><span class="line">    seq,f:<span class="keyword">array</span>[<span class="number">0</span>..mx+<span class="number">10</span>] <span class="keyword">of</span> int;</span><br><span class="line">    a,b,c,d,k,x,i:int;n:int64;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">bin</span><span class="params">(x,n:int)</span>:</span>int;</span><br><span class="line"><span class="keyword">var</span> l,r,mid:int;</span><br><span class="line"><span class="keyword">begin</span></span><br><span class="line">    l:=<span class="number">0</span>;r:=n;bin:=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span> l&lt;=r <span class="keyword">do</span> <span class="keyword">begin</span></span><br><span class="line">        mid:=(l+r) <span class="keyword">shr</span> <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">if</span> f[mid]&lt;=x <span class="keyword">then</span> <span class="keyword">begin</span> bin:=mid;l:=mid+<span class="number">1</span> <span class="keyword">end</span></span><br><span class="line">        <span class="keyword">else</span> r:=mid-<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">end</span>;</span><br><span class="line"><span class="keyword">end</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">lis</span><span class="params">(dn,up,n,b:int)</span>:</span>int;</span><br><span class="line"><span class="keyword">var</span> i,j:int;</span><br><span class="line"><span class="keyword">begin</span></span><br><span class="line">    <span class="keyword">for</span> i:=<span class="number">1</span> <span class="keyword">to</span> n <span class="keyword">do</span> f[i]:=inf;</span><br><span class="line">    f[<span class="number">0</span>]:=<span class="number">0</span>;lis:=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> i:=<span class="number">1</span> <span class="keyword">to</span> n <span class="keyword">do</span> <span class="keyword">begin</span></span><br><span class="line">        <span class="keyword">if</span> (seq[b+i]&lt;dn)<span class="keyword">or</span>(seq[b+i]&gt;up) <span class="keyword">then</span> <span class="keyword">continue</span>;</span><br><span class="line">        j:=bin(seq[b+i],lis);</span><br><span class="line">        f[j+<span class="number">1</span>]:=min(f[j+<span class="number">1</span>],seq[b+i]);</span><br><span class="line">        <span class="keyword">if</span> j=lis <span class="keyword">then</span> inc(lis);</span><br><span class="line">    <span class="keyword">end</span>;</span><br><span class="line"><span class="keyword">end</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">procedure</span> <span class="title">solv</span><span class="params">()</span>;</span></span><br><span class="line"><span class="keyword">var</span> b,r,l,i,dt:int;ans,m:int64;</span><br><span class="line"><span class="keyword">begin</span></span><br><span class="line">    b:=loc[x];l:=k-loc[x]+<span class="number">1</span>;</span><br><span class="line">    m:=(n-b+<span class="number">1</span>)<span class="keyword">div</span> l;r:=(n-b+<span class="number">1</span>)<span class="keyword">mod</span> l;</span><br><span class="line">    dt:=l*l;</span><br><span class="line">    <span class="keyword">for</span> i:=k+<span class="number">1</span> <span class="keyword">to</span> k+dt <span class="keyword">do</span> seq[i]:=seq[i-l];</span><br><span class="line">    ans:=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> i:=b <span class="keyword">to</span> k <span class="keyword">do</span></span><br><span class="line">        ans:=max(ans,ll(lis(-<span class="number">1</span>,seq[i],b-<span class="number">1</span>+dt,<span class="number">0</span>))+</span><br><span class="line">            ll(lis(seq[i],d,r+dt,b-<span class="number">1</span>))+m-<span class="number">2</span>*l);</span><br><span class="line">    <span class="keyword">write</span>(ans);</span><br><span class="line"><span class="keyword">end</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">begin</span></span><br><span class="line">    assign(input,<span class="string">'lis.in'</span>);reset(input);</span><br><span class="line">    assign(output,<span class="string">'lis.out'</span>);rewrite(output);</span><br><span class="line">    <span class="keyword">read</span>(n,seq[<span class="number">1</span>],a,b,c,d);</span><br><span class="line">    <span class="keyword">if</span> n&lt;=mx <span class="keyword">then</span> <span class="keyword">begin</span></span><br><span class="line">        <span class="keyword">for</span> i:=<span class="number">2</span> <span class="keyword">to</span> n <span class="keyword">do</span></span><br><span class="line">            seq[i]:=(a*sqr(seq[i-<span class="number">1</span>])+b*seq[i-<span class="number">1</span>]+c) <span class="keyword">mod</span> d;</span><br><span class="line">        <span class="keyword">write</span>(lis(-<span class="number">1</span>,d,n,<span class="number">0</span>));halt;</span><br><span class="line">    <span class="keyword">end</span>;</span><br><span class="line">    loc[seq[<span class="number">1</span>]]:=<span class="number">1</span>;k:=<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">while</span> true <span class="keyword">do</span> <span class="keyword">begin</span></span><br><span class="line">        x:=(a*sqr(seq[k])+b*seq[k]+c) <span class="keyword">mod</span> d;</span><br><span class="line">        <span class="keyword">if</span> loc[x]&lt;&gt;<span class="number">0</span> <span class="keyword">then</span> <span class="keyword">break</span>;</span><br><span class="line">        inc(k);seq[k]:=x;loc[x]:=k;</span><br><span class="line">    <span class="keyword">end</span>;</span><br><span class="line">    solv();</span><br><span class="line">    close(input);close(output);</span><br><span class="line"><span class="keyword">end</span>.</span><br></pre></td></tr></table></figure><br><br></div></div>

<h1 id="P2-bag"><a href="#P2-bag" class="headerlink" title="P2 bag"></a>P2 bag</h1><p>大意：给定n种物品，第i种体积为$v_i$，其中体积不小于l的物品总数不能超过c件，其他个数无限。有m次询问，第i次给定容量$w_i$的背包，问是否存在恰好装满的方案<br>$n\leq 50;m\leq 10^5;v_i,l\leq 10^4;$<br>$c\leq 30,w_i\leq 10^{18}$</p>
<h2 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h2><p>最短路处理dp<br>记最小的物品体积为v0，分类讨论</p>
<ul>
<li>$v0&gt;l$</li>
</ul>
<p>这种情况下体积有上限cV<br>于是直接dp：<br>f[i,j,k] 1..i种物品，大物品有j件，总体积为k的方案是否存在<br>转移：$f[i,j,k]=f[i-1,j,k]\ or\ f[i,j-1,k-v[i]]$<br>对于一个w，答案是f[n,0..c,w]<br>可以用bitset优化，但pascal没有所以不讨论</p>
<ul>
<li>$v0\leq l$</li>
</ul>
<p>如果存在体积为w的方案，那么一定存在体积为w+v0的方案<br>答案具有一定的单调性，也就是说可以表示为w=p*v0+k的方案可以归为一类<br>记s=f[i,j,k] 1..i种物品，大物品限制j件，当$s\% v0=k$时s的最小值<br>转移：<br>$v[i]&gt;v0$,$f[i,j,k]=min(f[i-1,j,k],f[i,j-1,(k-v[i])\% v0]+v[i])$<br>$v[i]\leq v0$,$f[i,j,k]=min(f[i-1,j,k],f[i,j,(k-v[i])\% v0]+v[i])$</p>
<p>第一种直接for循环即可<br>第二种的转移是存在环的，用节点建图，就规约为最短路的求解<br>记原点s，从s向f[i,j,k]连权为f[i-1,j,k]的边<br>从f[i,j,k]向f[i,j,(k+v[i])%v0]连权为v[i]的边<br>然后spfa</p>
<p>其实图是不用存的，转移时处理即可</p>
<p>bug</p>
<ol>
<li>记得检查输出格式，换行</li>
<li>状态f[i,j,k]的含义是 大物品件数=j时的解，最后要用前缀最小值f[n,0..j,k]</li>
<li>up和lim不可混用</li>
<li>数据范围！$w\leq 10^{18}$</li>
</ol>
<div><br><div class="copy"><br>    <a href="/2016/11/04/lydsy-noip-2016-test10/bag.pas" title="{plain text}">{plain text}</a><br></div><br><div><br><figure class="highlight delphi"><figcaption><span>bag.pas</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">uses</span> math;</span><br><span class="line"><span class="keyword">type</span> int=longint;</span><br><span class="line"><span class="keyword">var</span> </span><br><span class="line">    n,m,mn,mx,up,lim,i:int;</span><br><span class="line">    v:<span class="keyword">array</span>[<span class="number">0</span>..<span class="number">55</span>] <span class="keyword">of</span> int;</span><br><span class="line">    f:<span class="keyword">array</span>[<span class="number">0</span>..<span class="number">35</span>,<span class="number">0</span>..<span class="number">300010</span>] <span class="keyword">of</span> int64;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">procedure</span> <span class="title">solv1</span><span class="params">()</span>;</span></span><br><span class="line"><span class="keyword">var</span> </span><br><span class="line">    f:<span class="keyword">array</span>[<span class="number">0</span>..<span class="number">35</span>,<span class="number">0</span>..<span class="number">300010</span>] <span class="keyword">of</span> boolean;</span><br><span class="line">    i,j,k:int;w:int64;</span><br><span class="line"><span class="keyword">begin</span></span><br><span class="line">    fillchar(f,sizeof(f),false);</span><br><span class="line">    f[<span class="number">0</span>,<span class="number">0</span>]:=true;mx:=mx*n;</span><br><span class="line">    <span class="keyword">for</span> i:=<span class="number">1</span> <span class="keyword">to</span> n <span class="keyword">do</span></span><br><span class="line">        <span class="keyword">for</span> j:=<span class="number">1</span> <span class="keyword">to</span> lim <span class="keyword">do</span></span><br><span class="line">            <span class="keyword">for</span> k:=v[i] <span class="keyword">to</span> mx <span class="keyword">do</span></span><br><span class="line">                f[j,k]:=f[j,k] <span class="keyword">or</span> f[j-<span class="number">1</span>,k-v[i]];</span><br><span class="line">    <span class="keyword">for</span> i:=<span class="number">1</span> <span class="keyword">to</span> m <span class="keyword">do</span> <span class="keyword">begin</span></span><br><span class="line">        <span class="keyword">read</span>(w);</span><br><span class="line">        <span class="keyword">if</span> (w&lt;=mx) <span class="keyword">and</span> f[lim,w] <span class="keyword">then</span> writeln(<span class="string">'Yes'</span>) </span><br><span class="line">        <span class="keyword">else</span> writeln(<span class="string">'No'</span>);</span><br><span class="line">    <span class="keyword">end</span>;</span><br><span class="line"><span class="keyword">end</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">procedure</span> <span class="title">solv2</span><span class="params">()</span>;</span></span><br><span class="line"><span class="keyword">var</span> </span><br><span class="line">    q:<span class="keyword">array</span>[<span class="number">0</span>..<span class="number">10010</span>] <span class="keyword">of</span> int;</span><br><span class="line">    inq:<span class="keyword">array</span>[<span class="number">0</span>..<span class="number">10010</span>] <span class="keyword">of</span> boolean;</span><br><span class="line">    i,j,k:int;w:int64;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">procedure</span> <span class="title">spfa</span><span class="params">(x:int64)</span>;</span></span><br><span class="line">    <span class="keyword">var</span> i,v,u,h,t:int;</span><br><span class="line">    <span class="keyword">begin</span></span><br><span class="line">        h:=<span class="number">0</span>;t:=mn;</span><br><span class="line">        <span class="keyword">for</span> i:=<span class="number">0</span> <span class="keyword">to</span> mn-<span class="number">1</span> <span class="keyword">do</span> q[i]:=i;</span><br><span class="line">        fillchar(inq,sizeof(inq),true);</span><br><span class="line">        <span class="keyword">while</span> h&lt;&gt;t <span class="keyword">do</span> <span class="keyword">begin</span></span><br><span class="line">            u:=q[h];v:=(u+x)<span class="keyword">mod</span> mn;</span><br><span class="line">            <span class="keyword">if</span> f[j,v]&gt;f[j,u]+x <span class="keyword">then</span> <span class="keyword">begin</span></span><br><span class="line">                f[j,v]:=f[j,u]+x;</span><br><span class="line">                <span class="keyword">if</span> <span class="keyword">not</span> inq[v] <span class="keyword">then</span> <span class="keyword">begin</span></span><br><span class="line">                    q[t]:=v;inq[v]:=true;</span><br><span class="line">                    inc(t);<span class="keyword">if</span> t&gt;<span class="number">10010</span> <span class="keyword">then</span> t:=<span class="number">0</span>;</span><br><span class="line">                <span class="keyword">end</span>;</span><br><span class="line">            <span class="keyword">end</span>;</span><br><span class="line">            inq[u]:=false;inc(h);<span class="keyword">if</span> h&gt;<span class="number">10010</span> <span class="keyword">then</span> h:=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">end</span>;</span><br><span class="line">    <span class="keyword">end</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">begin</span></span><br><span class="line">    fillchar(f,sizeof(f),<span class="number">31</span>);</span><br><span class="line">    f[<span class="number">0</span>,<span class="number">0</span>]:=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> i:=<span class="number">1</span> <span class="keyword">to</span> n <span class="keyword">do</span> <span class="keyword">begin</span></span><br><span class="line">        <span class="keyword">if</span> v[i]&gt;=up <span class="keyword">then</span> <span class="keyword">for</span> j:=<span class="number">1</span> <span class="keyword">to</span> lim <span class="keyword">do</span> <span class="keyword">for</span> k:=<span class="number">0</span> <span class="keyword">to</span> mn-<span class="number">1</span> <span class="keyword">do</span></span><br><span class="line">            f[j,k]:=min(f[j,k],f[j-<span class="number">1</span>,((k-v[i])<span class="keyword">mod</span> mn+mn)<span class="keyword">mod</span> mn]+v[i])</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">for</span> j:=<span class="number">0</span> <span class="keyword">to</span> lim <span class="keyword">do</span> spfa(v[i]);</span><br><span class="line">    <span class="keyword">end</span>;</span><br><span class="line">    <span class="keyword">for</span> k:=<span class="number">0</span> <span class="keyword">to</span> mn-<span class="number">1</span> <span class="keyword">do</span></span><br><span class="line">        <span class="keyword">for</span> j:=<span class="number">0</span> <span class="keyword">to</span> lim-<span class="number">1</span> <span class="keyword">do</span> f[lim,k]:=min(f[lim,k],f[j,k]);</span><br><span class="line">    <span class="keyword">for</span> i:=<span class="number">1</span> <span class="keyword">to</span> m <span class="keyword">do</span> <span class="keyword">begin</span></span><br><span class="line">        <span class="keyword">read</span>(w);</span><br><span class="line">        <span class="keyword">if</span> f[lim,w <span class="keyword">mod</span> mn]&lt;=w <span class="keyword">then</span> writeln(<span class="string">'Yes'</span>)</span><br><span class="line">        <span class="keyword">else</span> writeln(<span class="string">'No'</span>);</span><br><span class="line">    <span class="keyword">end</span>;</span><br><span class="line"><span class="keyword">end</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">begin</span></span><br><span class="line">    assign(input,<span class="string">'bag_sample3.in'</span>);reset(input);</span><br><span class="line">    assign(output,<span class="string">'bag.out'</span>);rewrite(output);</span><br><span class="line">    <span class="keyword">read</span>(n,m);mn:=maxlongint;</span><br><span class="line">    <span class="keyword">for</span> i:=<span class="number">1</span> <span class="keyword">to</span> n <span class="keyword">do</span> <span class="keyword">begin</span> </span><br><span class="line">        <span class="keyword">read</span>(v[i]);mn:=min(mn,v[i]);mx:=max(mx,v[i]) </span><br><span class="line">    <span class="keyword">end</span>;</span><br><span class="line">    <span class="keyword">read</span>(up,lim);</span><br><span class="line">    <span class="keyword">if</span> mn&gt;=up <span class="keyword">then</span> solv1() <span class="keyword">else</span> solv2();</span><br><span class="line">    close(input);close(output);</span><br><span class="line"><span class="keyword">end</span>.</span><br></pre></td></tr></table></figure><br><br></div></div>

<h1 id="P2-lca"><a href="#P2-lca" class="headerlink" title="P2 lca"></a>P2 lca</h1><p>大意：给定n个节点的树，点上有权值，开始所有点是白色的<br>共有m次操作，分为两种：</p>
<ol>
<li><code>Modify v</code> 把v改成黑色</li>
<li><code>Query v</code> 求lca(v,一个黑色节点)的权值的最大值</li>
</ol>
<p>$n\leq 10^5,m\leq 2*10^5$</p>
<h2 id="题解-1"><a href="#题解-1" class="headerlink" title="题解"></a>题解</h2><p>dfs序+线段树<br>考虑一个点u的权值对查询v的贡献，显然只有当v在u的子树中时才会产生贡献<br>于是对于每次修改u，遍历u到根的路径，对于路径上的每个点v，更新v的子树的答案，排除u所在的那颗子树<br>这样只要先求出dfs序，然后用线段树维护最大值即可<br>此外，如果一个点w之前被遍历过，那么其父节点p一定被以相同的方式处理过，因此更新完w后break即可</p>
<p>线段树注意点：</p>
<ol>
<li>pushdown下移标记时不是简单赋值</li>
<li>处理区间时，分清当前区间[b,e]和操作区间[l,r]，mid=(b+e) shr 1</li>
<li>其实本题只有单点查值，没有pushdown的必要</li>
</ol>
<div><br><div class="copy"><br>    <a href="/2016/11/04/lydsy-noip-2016-test10/lca.pas" title="{plain text}">{plain text}</a><br></div><br><div><br><figure class="highlight delphi"><figcaption><span>lca.pas</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">uses</span> math;</span><br><span class="line"><span class="keyword">type</span> int=longint;edge=<span class="keyword">record</span> v,nxt:int <span class="keyword">end</span>;</span><br><span class="line"><span class="keyword">var</span> </span><br><span class="line">    g:<span class="keyword">array</span>[<span class="number">0</span>..<span class="number">200010</span>] <span class="keyword">of</span> edge;</span><br><span class="line">    seg:<span class="keyword">array</span>[<span class="number">0</span>..<span class="number">400010</span>] <span class="keyword">of</span> int;</span><br><span class="line">    w,l,r,head,par:<span class="keyword">array</span>[<span class="number">0</span>..<span class="number">100010</span>] <span class="keyword">of</span> int;</span><br><span class="line">    flg:<span class="keyword">array</span>[<span class="number">0</span>..<span class="number">100010</span>] <span class="keyword">of</span> boolean;</span><br><span class="line">    n,m,sz,i,k,u,v:int;s:<span class="keyword">string</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">procedure</span> <span class="title">add</span><span class="params">(u,v:int)</span>;</span></span><br><span class="line"><span class="keyword">begin</span></span><br><span class="line">    inc(sz);g[sz].v:=v;</span><br><span class="line">    g[sz].nxt:=head[u];head[u]:=sz;</span><br><span class="line"><span class="keyword">end</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">procedure</span> <span class="title">dfs</span><span class="params">(u:int)</span>;</span></span><br><span class="line"><span class="keyword">var</span> i,v:int;</span><br><span class="line"><span class="keyword">begin</span></span><br><span class="line">    inc(k);l[u]:=k;i:=head[u];</span><br><span class="line">    <span class="keyword">while</span> i&lt;&gt;<span class="number">0</span> <span class="keyword">do</span> <span class="keyword">begin</span></span><br><span class="line">        v:=g[i].v;</span><br><span class="line">        <span class="keyword">if</span> l[v]=<span class="number">0</span> <span class="keyword">then</span> <span class="keyword">begin</span> par[v]:=u;dfs(v) <span class="keyword">end</span>;</span><br><span class="line">        i:=g[i].nxt;</span><br><span class="line">    <span class="keyword">end</span>;</span><br><span class="line">    r[u]:=k;</span><br><span class="line"><span class="keyword">end</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">procedure</span> _<span class="title">modify</span><span class="params">(i,b,e,l,r,k:int)</span>;</span></span><br><span class="line"><span class="keyword">var</span> mid:int;</span><br><span class="line"><span class="keyword">begin</span></span><br><span class="line">    <span class="keyword">if</span> (l&gt;r) <span class="keyword">or</span> (e&lt;l) <span class="keyword">or</span> (b&gt;r) <span class="keyword">then</span> <span class="keyword">exit</span>;</span><br><span class="line">    <span class="keyword">if</span> (l&lt;=b) <span class="keyword">and</span> (e&lt;=r) <span class="keyword">then</span> <span class="keyword">begin</span></span><br><span class="line">        seg[i]:=max(seg[i],k);</span><br><span class="line">        <span class="keyword">exit</span>;</span><br><span class="line">    <span class="keyword">end</span>;</span><br><span class="line">    mid:=(b+e) <span class="keyword">shr</span> <span class="number">1</span>;</span><br><span class="line">    _modify(i <span class="keyword">shl</span> <span class="number">1</span>,b,mid,l,r,k);</span><br><span class="line">    _modify(i <span class="keyword">shl</span> <span class="number">1</span> <span class="keyword">or</span> <span class="number">1</span>,mid+<span class="number">1</span>,e,l,r,k);</span><br><span class="line"><span class="keyword">end</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> _<span class="title">query</span><span class="params">(i,b,e,x:int)</span>:</span>int;</span><br><span class="line"><span class="keyword">var</span> mid:int;</span><br><span class="line"><span class="keyword">begin</span></span><br><span class="line">    <span class="keyword">if</span> b=e <span class="keyword">then</span> <span class="keyword">exit</span>(seg[i]);</span><br><span class="line">    mid:=(b+e) <span class="keyword">shr</span> <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">if</span> x&lt;=mid <span class="keyword">then</span> _query:=max(seg[i],_query(i <span class="keyword">shl</span> <span class="number">1</span>,b,mid,x))</span><br><span class="line">    <span class="keyword">else</span> _query:=max(seg[i],_query(i <span class="keyword">shl</span> <span class="number">1</span> <span class="keyword">or</span> <span class="number">1</span>,mid+<span class="number">1</span>,e,x));</span><br><span class="line"><span class="keyword">end</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">procedure</span> <span class="title">modify</span><span class="params">(u:int)</span>;</span></span><br><span class="line"><span class="keyword">var</span> v:int;</span><br><span class="line"><span class="keyword">begin</span></span><br><span class="line">    _modify(<span class="number">1</span>,<span class="number">1</span>,n,l[u],r[u],w[u]);</span><br><span class="line">    <span class="keyword">if</span> flg[u] <span class="keyword">then</span> <span class="keyword">exit</span>;</span><br><span class="line">    flg[u]:=true;v:=u;u:=par[u];</span><br><span class="line">    <span class="keyword">while</span> u&lt;&gt;<span class="number">0</span> <span class="keyword">do</span> <span class="keyword">begin</span> </span><br><span class="line">        _modify(<span class="number">1</span>,<span class="number">1</span>,n,l[u],l[v]-<span class="number">1</span>,w[u]);</span><br><span class="line">        _modify(<span class="number">1</span>,<span class="number">1</span>,n,r[v]+<span class="number">1</span>,r[u],w[u]);</span><br><span class="line">        <span class="keyword">if</span> flg[u] <span class="keyword">then</span> <span class="keyword">exit</span>;</span><br><span class="line">        flg[u]:=true;v:=u;u:=par[u];</span><br><span class="line">    <span class="keyword">end</span>;</span><br><span class="line"><span class="keyword">end</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">procedure</span> <span class="title">query</span><span class="params">(u:int)</span>;</span></span><br><span class="line"><span class="keyword">begin</span> writeln(_query(<span class="number">1</span>,<span class="number">1</span>,n,l[u])) <span class="keyword">end</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">begin</span></span><br><span class="line">    assign(input,<span class="string">'lca_sample2.in'</span>);reset(input);</span><br><span class="line">    assign(output,<span class="string">'lca.out'</span>);rewrite(output);</span><br><span class="line">    readln(n,m);</span><br><span class="line">    <span class="keyword">for</span> i:=<span class="number">1</span> <span class="keyword">to</span> n <span class="keyword">do</span> <span class="keyword">read</span>(w[i]);readln;</span><br><span class="line">    <span class="keyword">for</span> i:=<span class="number">1</span> <span class="keyword">to</span> n-<span class="number">1</span> <span class="keyword">do</span> <span class="keyword">begin</span></span><br><span class="line">        readln(u,v);add(u,v);add(v,u);</span><br><span class="line">    <span class="keyword">end</span>;</span><br><span class="line">    k:=<span class="number">0</span>;dfs(<span class="number">1</span>);</span><br><span class="line">    fillchar(seg,sizeof(seg),<span class="number">255</span>);</span><br><span class="line">    <span class="keyword">for</span> i:=<span class="number">1</span> <span class="keyword">to</span> m <span class="keyword">do</span> <span class="keyword">begin</span></span><br><span class="line">        readln(s);</span><br><span class="line">        <span class="keyword">case</span> s[<span class="number">1</span>] <span class="keyword">of</span></span><br><span class="line">            <span class="string">'Q'</span>:<span class="keyword">begin</span> val(copy(s,<span class="number">7</span>,length(s)-<span class="number">6</span>),u,v);query(u)<span class="keyword">end</span>;</span><br><span class="line">            <span class="string">'M'</span>:<span class="keyword">begin</span> val(copy(s,<span class="number">8</span>,length(s)-<span class="number">7</span>),u,v);modify(u)<span class="keyword">end</span>;</span><br><span class="line">        <span class="keyword">end</span>;</span><br><span class="line">    <span class="keyword">end</span>;</span><br><span class="line">    close(input);close(output);</span><br><span class="line"><span class="keyword">end</span>.</span><br></pre></td></tr></table></figure><br><br></div></div>
]]></content>
    
    <summary type="html">
    
      &lt;blockquote&gt;
&lt;p&gt;订正进度(3/3)&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h1 id=&quot;P1-lis&quot;&gt;&lt;a href=&quot;#P1-lis&quot; class=&quot;headerlink&quot; title=&quot;P1 lis&quot;&gt;&lt;/a&gt;P1 lis&lt;/h1&gt;&lt;p&gt;大意：&lt;br&gt;给定长度n和参数$t_0,A,B,C,D$，定义数列$a_n$：&lt;br&gt;$n=1,a[n]=t_0$&lt;br&gt;$n\geq 2,a[n]=(A\times a_{n-1}^2+B\times a_{n-1}+C)\% D$&lt;/p&gt;
&lt;p&gt;求$a_n$的最长不下降子序列&lt;br&gt;$0\leq t_0,A,B,C\leq150,1\leq D\leq150, 1\leq n\leq10^{12}$&lt;br&gt;
    
    </summary>
    
      <category term="Problem Set" scheme="https://cothrax.github.io/categories/Problem-Set/"/>
    
    
      <category term="OI" scheme="https://cothrax.github.io/tags/OI/"/>
    
      <category term="数据结构" scheme="https://cothrax.github.io/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"/>
    
      <category term="DP" scheme="https://cothrax.github.io/tags/DP/"/>
    
      <category term="二分答案" scheme="https://cothrax.github.io/tags/%E4%BA%8C%E5%88%86%E7%AD%94%E6%A1%88/"/>
    
      <category term="图论" scheme="https://cothrax.github.io/tags/%E5%9B%BE%E8%AE%BA/"/>
    
      <category term="最短路" scheme="https://cothrax.github.io/tags/%E6%9C%80%E7%9F%AD%E8%B7%AF/"/>
    
      <category term="LCA" scheme="https://cothrax.github.io/tags/LCA/"/>
    
      <category term="背包" scheme="https://cothrax.github.io/tags/%E8%83%8C%E5%8C%85/"/>
    
      <category term="线段树" scheme="https://cothrax.github.io/tags/%E7%BA%BF%E6%AE%B5%E6%A0%91/"/>
    
      <category term="线性DP" scheme="https://cothrax.github.io/tags/%E7%BA%BF%E6%80%A7DP/"/>
    
      <category term="数学" scheme="https://cothrax.github.io/tags/%E6%95%B0%E5%AD%A6/"/>
    
      <category term="矩阵" scheme="https://cothrax.github.io/tags/%E7%9F%A9%E9%98%B5/"/>
    
      <category term="DFS序" scheme="https://cothrax.github.io/tags/DFS%E5%BA%8F/"/>
    
  </entry>
  
  <entry>
    <title>NOIP十连测 Day 7</title>
    <link href="https://cothrax.github.io/2016/11/04/lydsy-noip-2016-test7/"/>
    <id>https://cothrax.github.io/2016/11/04/lydsy-noip-2016-test7/</id>
    <published>2016-11-04T08:14:18.000Z</published>
    <updated>2016-11-10T15:07:03.467Z</updated>
    
    <content type="html"><![CDATA[<blockquote>
<p>订正进度(2/3)</p>
</blockquote>
<h1 id="T1-约瑟夫游戏"><a href="#T1-约瑟夫游戏" class="headerlink" title="T1 约瑟夫游戏"></a>T1 约瑟夫游戏</h1><p>大意：定义约瑟夫游戏：个人围成一圈,从 1 号开始依次报数,当报到 m 时,报1、2、…、m-1 的人出局,下一个人接着从 1 开始报,保证(n-1)是(m-1)的倍数。最后剩的一个人获胜。<br>求获胜者的编号<br>$2\leq m \leq n\leq 2^{63}-2$</p>
<a id="more"></a>
<h2 id="水解"><a href="#水解" class="headerlink" title="水解"></a>水解</h2><p>记f[i]为i个人时的答案，递推：<br>$f[i]=f[i-(m-1)]\%(i-m+1)+m$<br>记$g[i]=f[1+i(m-1)]$<br>则$g[i+1]=f[1+(i+1)(m-1)]=f[1+i(m-1)]\%(1+i(m-1))+m$<br>$\therefore g[i+1]=g[i]\%(1+i(m-1))+m$</p>
<p>复杂度$O(n/m)$</p>
<div><br><div class="copy"><br>    <a href="/2016/11/04/lydsy-noip-2016-test7/joseph.pas" title="{plain text}">{plain text}</a><br></div><br><div><br><figure class="highlight delphi"><figcaption><span>joseph.pas</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">uses</span> math;</span><br><span class="line"><span class="keyword">type</span> int=longint;</span><br><span class="line"><span class="keyword">var</span> </span><br><span class="line">    n,m,k,i,j:int;</span><br><span class="line">    f:<span class="keyword">array</span>[<span class="number">0</span>..<span class="number">1000000</span>] <span class="keyword">of</span> int;</span><br><span class="line"></span><br><span class="line"><span class="keyword">begin</span></span><br><span class="line">    assign(input,<span class="string">'joseph.in'</span>);reset(input);</span><br><span class="line">    assign(output,<span class="string">'joseph.out'</span>);rewrite(output);</span><br><span class="line">    <span class="keyword">read</span>(n,m);</span><br><span class="line">    k:=(n-<span class="number">1</span>) <span class="keyword">div</span> (m-<span class="number">1</span>);</span><br><span class="line">    f[<span class="number">0</span>]:=<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span> i:=<span class="number">0</span> <span class="keyword">to</span> k-<span class="number">1</span> <span class="keyword">do</span></span><br><span class="line">        f[i+<span class="number">1</span>]:=f[i]<span class="keyword">mod</span>(i*(m-<span class="number">1</span>)+<span class="number">1</span>)+m;</span><br><span class="line">    <span class="keyword">write</span>(f[k]);</span><br><span class="line"><span class="keyword">end</span>.</span><br></pre></td></tr></table></figure><br><br></div></div>

<h2 id="正解"><a href="#正解" class="headerlink" title="正解"></a>正解</h2><p>基于递推的方法，打表观察：<br>发现：除了$i=m^a+m-1$外，所有的f[i]=km<br>找出这个规律后直接模拟即可</p>
<div><br><div class="copy"><br>    <a href="/2016/11/04/lydsy-noip-2016-test7/joseph_tmp.pas" title="{plain text}">{plain text}</a><br></div><br><div><br><figure class="highlight delphi"><figcaption><span>joseph_tmp.pas</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">uses</span> math;</span><br><span class="line"><span class="keyword">type</span> int=longint;</span><br><span class="line"><span class="keyword">var</span> </span><br><span class="line">    n,m,k,i,j:int;</span><br><span class="line">    f:<span class="keyword">array</span>[<span class="number">0</span>..<span class="number">1000000</span>] <span class="keyword">of</span> int;</span><br><span class="line"></span><br><span class="line"><span class="keyword">begin</span></span><br><span class="line">    <span class="keyword">read</span>(n,m);</span><br><span class="line">    assign(input,<span class="string">'joseph.in'</span>);reset(input);</span><br><span class="line">    assign(output,<span class="string">'joseph.out'</span>);rewrite(output);</span><br><span class="line">    i:=<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">while</span> i&lt;=n <span class="keyword">do</span> k:=k*m;</span><br><span class="line">    <span class="keyword">write</span>((n-i <span class="keyword">div</span> m) <span class="keyword">div</span> (m-<span class="number">1</span>)*m);</span><br><span class="line">    close(input);close(output);</span><br><span class="line"><span class="keyword">end</span>.</span><br></pre></td></tr></table></figure><br><br></div></div>

<h1 id="T2-密码游戏"><a href="#T2-密码游戏" class="headerlink" title="T2 密码游戏"></a>T2 密码游戏</h1><p>有两个0..m-1的全排列a和b，有n次操作x，每次的结果y=b[a[x]]，之后a排列向前循环一次，即a’[(i+1)%m]=a[i]，每操作m次之后b向前循环一次。<br>现在给定n次操作的x和y，求a和b的初值。如果有多解输出任意一组<br>$2\leq m\leq 26,m^2\leq n\leq 10^5$</p>
<h2 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h2><p>如果$y[i]=y[j]$<br>则$b[(a[(x[i]+i)\%m]+i/m)\%m]=b[(a[(x[j]+j)\%m]+j/m)\%m]$(*)</p>
<p>$(a[(x[i]+i)\%m]+i/m)\%m=a[(x[j]+j)\%m]+j/m)\%m$</p>
<p>$a[(x[i]+i)\%m]-a[(x[j]+j)\%m]\equiv j/m-i/m (\%m)$</p>
<p>这样就得到的若干形如$a[i]-a[j]\equiv k(\%m)$的形式<br>我们可以用带全并查集处理同余方程，然后设根节点为0，递推出所有的a[i]<br>然后在推出(*)推出b即可<br>注意点：由于题意是操作后移动，上述式子中的i代表的是第i+1次操作</p>
<p>题解告诉我们，有效方程个数的期望为$(n-m)(m-1)/m$<br>而$m^2\leq n$，则个数$\geq (m-1)^2\geq m-1$<br>所以可以得到m个节点间的关系（也就是最终合并到一颗树上）</p>
<blockquote>
<p>挖个坑：个数的期望不知道是怎么算的</p>
</blockquote>
<p>注：由于没有大样例，oj又不支持spj，下面的代码仅供参考<br>以及我的草稿</p>
<blockquote>
<p>y[i]=y[j]<br>b[(a[(x[i]+i)%m]+i/m)%m]=b[(a[(x[j]+j)%m]+j/m)%m]<br>a[(x[i]+i)%m]-a[(x[j]+j)%m]=j/m-i/m (%m)<br>=&gt;a[i]-a[j]=k (%m)<br>uf-set<br>a[i]-a[j]=k (i-&gt;j)=k<br>w[x-&gt;p[x]]=(x-p[x])%m<br>union(i,j,k)<br>a[0]=0<br>a[0]-p[a[0]]=w[0] =&gt; p[a[0]]=a[0]-w[0]<br>find<br>    w[par[x]]=par[x]-&gt;rt  w[x]=x-&gt;par[x]<br>    x-&gt;rt=w[x]+w[par[x]]=new w[x]<br>union<br>    x-&gt;y=k  w[x]=x-&gt;par[x]  w[y]=y-&gt;par[y]<br>    par[x]-&gt;par[y] = par[x]-&gt;x + x-&gt;y + y-&gt;par[y] =-w[x]+k+w[y]</p>
</blockquote>
<div><br><div class="copy"><br>    <a href="/2016/11/04/lydsy-noip-2016-test7/password.pas" title="{plain text}">{plain text}</a><br></div><br><div><br><figure class="highlight delphi"><figcaption><span>password.pas</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> int=longint;node=<span class="keyword">record</span> w,nxt:int <span class="keyword">end</span>;</span><br><span class="line"><span class="keyword">var</span></span><br><span class="line">    n,m,sz,i,j,u,v:int;</span><br><span class="line">    lnk:<span class="keyword">array</span>[<span class="number">0</span>..<span class="number">100010</span>] <span class="keyword">of</span> node;</span><br><span class="line">    x,y:<span class="keyword">array</span>[<span class="number">0</span>..<span class="number">100010</span>] <span class="keyword">of</span> int;</span><br><span class="line">    a,b,ptr,par,w:<span class="keyword">array</span>[<span class="number">0</span>..<span class="number">30</span>] <span class="keyword">of</span> int;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">procedure</span> <span class="title">insert</span><span class="params">(i,x:int)</span>;</span></span><br><span class="line"><span class="keyword">begin</span></span><br><span class="line">    inc(sz);lnk[sz].w:=x;</span><br><span class="line">    lnk[sz].nxt:=ptr[i];ptr[i]:=sz;</span><br><span class="line"><span class="keyword">end</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">find</span><span class="params">(x:int)</span>:</span>int;</span><br><span class="line"><span class="keyword">begin</span></span><br><span class="line">    <span class="keyword">if</span> par[x]=x <span class="keyword">then</span> find:=x</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">begin</span></span><br><span class="line">        find:=find(par[x]);</span><br><span class="line">        inc(w[x],w[par[x]]);</span><br><span class="line">        par[x]:=find;</span><br><span class="line">    <span class="keyword">end</span>;</span><br><span class="line"><span class="keyword">end</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">procedure</span> <span class="title">union</span><span class="params">(x,y,k:int)</span>;</span></span><br><span class="line"><span class="keyword">var</span> px,py:int;</span><br><span class="line"><span class="keyword">begin</span></span><br><span class="line">    px:=find(x);py:=find(y);</span><br><span class="line">    <span class="keyword">if</span> px=py <span class="keyword">then</span> <span class="keyword">exit</span>;</span><br><span class="line">    w[px]:=-w[x]+k+w[y];par[px]:=py;</span><br><span class="line"><span class="keyword">end</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">procedure</span> <span class="title">dfs</span><span class="params">(x:int)</span>;</span></span><br><span class="line"><span class="keyword">begin</span></span><br><span class="line">    <span class="keyword">if</span> par[x]=x <span class="keyword">then</span> a[x]:=<span class="number">0</span></span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">begin</span></span><br><span class="line">        <span class="keyword">if</span> a[par[x]]=-<span class="number">1</span> <span class="keyword">then</span> dfs(par[x]);</span><br><span class="line">        a[x]:=(a[par[x]]+w[x])<span class="keyword">mod</span> m;</span><br><span class="line">    <span class="keyword">end</span>;</span><br><span class="line"><span class="keyword">end</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">begin</span></span><br><span class="line">    assign(input,<span class="string">'password.in'</span>);reset(input);</span><br><span class="line">    assign(output,<span class="string">'password.out'</span>);rewrite(output);</span><br><span class="line">    <span class="keyword">read</span>(n,m);</span><br><span class="line">    <span class="keyword">for</span> i:=<span class="number">0</span> <span class="keyword">to</span> n-<span class="number">1</span> <span class="keyword">do</span> <span class="keyword">read</span>(x[i]);</span><br><span class="line">    <span class="keyword">for</span> i:=<span class="number">0</span> <span class="keyword">to</span> n-<span class="number">1</span> <span class="keyword">do</span> <span class="keyword">begin</span> <span class="keyword">read</span>(y[i]);insert(y[i],i) <span class="keyword">end</span>;</span><br><span class="line">    <span class="keyword">for</span> i:=<span class="number">0</span> <span class="keyword">to</span> m-<span class="number">1</span> <span class="keyword">do</span> <span class="keyword">begin</span> par[i]:=i;w[i]:=<span class="number">0</span> <span class="keyword">end</span>;</span><br><span class="line">    <span class="keyword">for</span> j:=<span class="number">0</span> <span class="keyword">to</span> m-<span class="number">1</span> <span class="keyword">do</span> <span class="keyword">begin</span></span><br><span class="line">        i:=ptr[j];u:=lnk[i].w;i:=lnk[i].nxt;</span><br><span class="line">        <span class="keyword">while</span> i&lt;&gt;<span class="number">0</span> <span class="keyword">do</span> <span class="keyword">begin</span></span><br><span class="line">            v:=lnk[i].w;</span><br><span class="line">            union((x[u]+u)<span class="keyword">mod</span> m,(x[v]+v)<span class="keyword">mod</span> m,</span><br><span class="line">                ((v <span class="keyword">div</span> m-u <span class="keyword">div</span> m)<span class="keyword">mod</span> m+m)<span class="keyword">mod</span> m);</span><br><span class="line">            u:=v;i:=lnk[i].nxt;</span><br><span class="line">        <span class="keyword">end</span>;</span><br><span class="line">    <span class="keyword">end</span>;</span><br><span class="line">    fillchar(a,sizeof(a),<span class="number">255</span>);</span><br><span class="line">    <span class="keyword">for</span> i:=<span class="number">0</span> <span class="keyword">to</span> m-<span class="number">1</span> <span class="keyword">do</span> <span class="keyword">if</span> a[i]=-<span class="number">1</span> <span class="keyword">then</span> dfs(i);</span><br><span class="line">    <span class="keyword">for</span> i:=<span class="number">0</span> <span class="keyword">to</span> n-<span class="number">1</span> <span class="keyword">do</span> b[(a[(x[i]+i)<span class="keyword">mod</span> m]+i <span class="keyword">div</span> m)<span class="keyword">mod</span> m]:=y[i];</span><br><span class="line">    <span class="keyword">for</span> i:=<span class="number">0</span> <span class="keyword">to</span> m-<span class="number">1</span> <span class="keyword">do</span> <span class="keyword">write</span>(a[i],<span class="string">' '</span>);writeln;</span><br><span class="line">    <span class="keyword">for</span> i:=<span class="number">0</span> <span class="keyword">to</span> m-<span class="number">1</span> <span class="keyword">do</span> <span class="keyword">write</span>(b[i],<span class="string">' '</span>);</span><br><span class="line">    close(input);close(output);</span><br><span class="line"><span class="keyword">end</span>.</span><br></pre></td></tr></table></figure><br><br></div></div>
]]></content>
    
    <summary type="html">
    
      &lt;blockquote&gt;
&lt;p&gt;订正进度(2/3)&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h1 id=&quot;T1-约瑟夫游戏&quot;&gt;&lt;a href=&quot;#T1-约瑟夫游戏&quot; class=&quot;headerlink&quot; title=&quot;T1 约瑟夫游戏&quot;&gt;&lt;/a&gt;T1 约瑟夫游戏&lt;/h1&gt;&lt;p&gt;大意：定义约瑟夫游戏：个人围成一圈,从 1 号开始依次报数,当报到 m 时,报1、2、…、m-1 的人出局,下一个人接着从 1 开始报,保证(n-1)是(m-1)的倍数。最后剩的一个人获胜。&lt;br&gt;求获胜者的编号&lt;br&gt;$2\leq m \leq n\leq 2^{63}-2$&lt;/p&gt;
    
    </summary>
    
      <category term="Problem Set" scheme="https://cothrax.github.io/categories/Problem-Set/"/>
    
    
      <category term="OI" scheme="https://cothrax.github.io/tags/OI/"/>
    
      <category term="数据结构" scheme="https://cothrax.github.io/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"/>
    
      <category term="并查集" scheme="https://cothrax.github.io/tags/%E5%B9%B6%E6%9F%A5%E9%9B%86/"/>
    
      <category term="DP" scheme="https://cothrax.github.io/tags/DP/"/>
    
      <category term="数论" scheme="https://cothrax.github.io/tags/%E6%95%B0%E8%AE%BA/"/>
    
      <category term="概率期望" scheme="https://cothrax.github.io/tags/%E6%A6%82%E7%8E%87%E6%9C%9F%E6%9C%9B/"/>
    
      <category term="数学" scheme="https://cothrax.github.io/tags/%E6%95%B0%E5%AD%A6/"/>
    
      <category term="打表" scheme="https://cothrax.github.io/tags/%E6%89%93%E8%A1%A8/"/>
    
  </entry>
  
  <entry>
    <title>NOIP十连测 Day 8</title>
    <link href="https://cothrax.github.io/2016/10/30/lydsy-noip-2016-test8/"/>
    <id>https://cothrax.github.io/2016/10/30/lydsy-noip-2016-test8/</id>
    <published>2016-10-30T04:41:39.000Z</published>
    <updated>2016-11-04T08:13:32.216Z</updated>
    
    <content type="html"><![CDATA[<blockquote>
<p>订正进度(3/3)</p>
</blockquote>
<h1 id="P1-神炎皇"><a href="#P1-神炎皇" class="headerlink" title="P1 神炎皇"></a>P1 神炎皇</h1><p>大意：给定n，求满足$a+b\leq n$且$(a+b)|ab$的有序对(a,b)的个数<br>$n\leq 10^{14}$</p>
<a id="more"></a>
<h2 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h2><p>坑爹数论<br>记$g=gcd(a,b),c=a/g,d=b/g$<br>则$(c+d)g|cdg^2$</p>
<blockquote>
<p>定理：若$gcd(c+d)=1$，则$(c+d)|cd$一定不成立</p>
</blockquote>
<p>先yy一下，c和d的约数都不是c+d的约数，那么c+d的质因子拆分中一定包含不是cd的约数的成分。<br>也可以反证：不妨设$k(c+d)=cd,k\in N*$<br>则$kc+kd=(c-k)d+kd$<br>那么$kc=(c-k)d$<br>因为$gcd(c,d)=1$<br>所以$c=c-k,k=d$无解，与假设矛盾</p>
<p>于是式子变成了$(c+d)|g$<br>令$k=c+d$，则$g=kp,p\in N*$，又$gk=k^2p\leq n$，那么$k\leq\sqrt{n}$<br>枚举k，则p有$n/k^2$个，下面要求(c,d)的对数</p>
<blockquote>
<p>根据辗转相减，$gcd(p,q)=gcd(p-q,q),p&gt;q$</p>
</blockquote>
<p>于是$gcd(c,d)=1$与$gcd(c+d,d)=(k,d)=1$一一对应，而(k,d)的对数就是$\varphi(k)$</p>
<p>于是，答案为$\sum_{k=2}^{\lfloor\sqrt{n}\rfloor} \varphi(k)*\lfloor n/k^2\rfloor$</p>
<div><br><div class="copy"><br>    <a href="/2016/10/30/lydsy-noip-2016-test8/uria.pas" title="{plain text}">{plain text}</a><br></div><br><div><br><figure class="highlight delphi"><figcaption><span>uria.pas</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> int=longint;</span><br><span class="line"><span class="keyword">var</span></span><br><span class="line">    n,ans,i,sq:int64;</span><br><span class="line">    phi,p:<span class="keyword">array</span>[<span class="number">0</span>..<span class="number">10000010</span>] <span class="keyword">of</span> int;</span><br><span class="line">    f:<span class="keyword">array</span>[<span class="number">0</span>..<span class="number">10000100</span>] <span class="keyword">of</span> boolean;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">procedure</span> <span class="title">euler</span><span class="params">()</span>;</span></span><br><span class="line"><span class="keyword">var</span> i,j,t,k:int;</span><br><span class="line"><span class="keyword">begin</span></span><br><span class="line">    phi[<span class="number">1</span>]:=<span class="number">1</span>;k:=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> i:=<span class="number">2</span> <span class="keyword">to</span> sq <span class="keyword">do</span> <span class="keyword">begin</span></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> f[i] <span class="keyword">then</span> <span class="keyword">begin</span></span><br><span class="line">            inc(k);p[k]:=i;phi[i]:=i-<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">end</span>;</span><br><span class="line">        j:=<span class="number">1</span>;t:=p[j]*i;</span><br><span class="line">        <span class="keyword">while</span> t&lt;=sq <span class="keyword">do</span> <span class="keyword">begin</span></span><br><span class="line">            f[t]:=true;</span><br><span class="line">            <span class="keyword">if</span> i <span class="keyword">mod</span> p[j]=<span class="number">0</span> <span class="keyword">then</span> <span class="keyword">begin</span></span><br><span class="line">                phi[t]:=p[j]*phi[i];<span class="keyword">break</span></span><br><span class="line">            <span class="keyword">end</span> <span class="keyword">else</span></span><br><span class="line">                phi[t]:=(p[j]-<span class="number">1</span>)*phi[i];</span><br><span class="line">            inc(j);t:=p[j]*i;</span><br><span class="line">        <span class="keyword">end</span>;</span><br><span class="line">    <span class="keyword">end</span>;</span><br><span class="line"><span class="keyword">end</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">begin</span></span><br><span class="line">    <span class="comment">//assign(input,'uria.in');reset(input);</span></span><br><span class="line">    <span class="comment">//assign(output,'uria.out');rewrite(output);</span></span><br><span class="line">    <span class="keyword">read</span>(n);sq:=trunc(sqrt(n));</span><br><span class="line">    foo();halt;</span><br><span class="line">    euler();ans:=<span class="number">0</span>;i:=<span class="number">2</span>;</span><br><span class="line">    <span class="keyword">while</span> i&lt;=sq <span class="keyword">do</span> <span class="keyword">begin</span></span><br><span class="line">        inc(ans,phi[i]*trunc(n/(i*i)));</span><br><span class="line">        inc(i);</span><br><span class="line">    <span class="keyword">end</span>;</span><br><span class="line">    <span class="keyword">write</span>(ans);</span><br><span class="line">    close(input);close(output);</span><br><span class="line"><span class="keyword">end</span>.</span><br></pre></td></tr></table></figure><br><br></div></div>

<h1 id="P2-降雷皇"><a href="#P2-降雷皇" class="headerlink" title="P2 降雷皇"></a>P2 降雷皇</h1><p>大意：给定长度n的序列a，求最长单调不降子序列，以及其方案数<br>$n,a_i\leq 10^5$</p>
<h2 id="题解-1"><a href="#题解-1" class="headerlink" title="题解"></a>题解</h2><p>数据结构优化的dp<br>第一问显然lis，考虑$O(N^2)$的求法</p>
<p>记f[i]为以a[i]结尾的最长lis长度</p>
<span>$f[i]=max_{i&lt;j,a[j]\leq a[i]}\{f[j]+1\}$</span><!-- Has MathJax -->
<p>有另一种思路优化到$O(NlogN)$，但由于第二问的存在，我们考虑数据结构优化<br>可以用树状数组以a[i]为下标，维护f[i]的前缀最大值<br>那么转移时查询[1..a[i]]中的最大的f[j]即可</p>
<p>第二问：<br>记g[i]为f[i]的方案数</p>
<span>$g[i]=\sum_{i&lt;j,a[i]&lt;=a[j],f[i]=f[j]+1}g[j]$</span><!-- Has MathJax -->
<p>这个可以对每以个f[i]维护一颗线段树，以a[i]为下标，维护区间[l,r]内的$\sum g[i]$<br>类似主席树的写法</p>
<p>这样，复杂度为$O(NlogN)$<br>一个sb错误：Line53的查询参数为x-1</p>
<div><br><div class="copy"><br>    <a href="/2016/10/30/lydsy-noip-2016-test8/hamon.pas" title="{plain text}">{plain text}</a><br></div><br><div><br><figure class="highlight delphi"><figcaption><span>hamon.pas</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">uses</span> math;</span><br><span class="line"><span class="keyword">type</span> int=longint;ll=int64;node=<span class="keyword">record</span> lc,rc,w:int <span class="keyword">end</span>;</span><br><span class="line"><span class="keyword">const</span> mx=<span class="number">100000</span>;md=<span class="number">123456789</span>;</span><br><span class="line"><span class="keyword">var</span></span><br><span class="line">    seg:<span class="keyword">array</span>[<span class="number">0</span>..mx*<span class="number">20</span>] <span class="keyword">of</span> node;</span><br><span class="line">    bit,rt,f,g:<span class="keyword">array</span>[<span class="number">0</span>..mx+<span class="number">10</span>] <span class="keyword">of</span> int;</span><br><span class="line">    n,sz,i,tp,x,ans,cnt:int;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">procedure</span> _<span class="title">add</span><span class="params">(x,k:int)</span>;</span></span><br><span class="line"><span class="keyword">begin</span></span><br><span class="line">    <span class="keyword">while</span> x&lt;=mx <span class="keyword">do</span> <span class="keyword">begin</span></span><br><span class="line">        bit[x]:=max(bit[x],k);</span><br><span class="line">        inc(x,x <span class="keyword">and</span> (-x));</span><br><span class="line">    <span class="keyword">end</span>;</span><br><span class="line"><span class="keyword">end</span>;</span><br><span class="line"><span class="function"><span class="keyword">function</span> _<span class="title">query</span><span class="params">(x:int)</span>:</span>int;</span><br><span class="line"><span class="keyword">begin</span></span><br><span class="line">    _query:=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span> x&gt;<span class="number">0</span> <span class="keyword">do</span> <span class="keyword">begin</span></span><br><span class="line">        _query:=max(_query,bit[x]);</span><br><span class="line">        x:=x <span class="keyword">and</span> (x-<span class="number">1</span>);</span><br><span class="line">    <span class="keyword">end</span>;</span><br><span class="line"><span class="keyword">end</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">procedure</span> <span class="title">add</span><span class="params">(<span class="keyword">var</span> i:int;l,r,x,k:int)</span>;</span></span><br><span class="line"><span class="keyword">var</span> mid:int;</span><br><span class="line"><span class="keyword">begin</span></span><br><span class="line">    inc(sz);seg[sz]:=seg[i];i:=sz;</span><br><span class="line">    seg[i].w:=(ll(seg[i].w)+ll(k))<span class="keyword">mod</span> md;</span><br><span class="line">    <span class="keyword">if</span> l=r <span class="keyword">then</span> <span class="keyword">exit</span>;</span><br><span class="line">    mid:=(l+r) <span class="keyword">shr</span> <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">if</span> x&lt;=mid <span class="keyword">then</span> add(seg[i].lc,l,mid,x,k)</span><br><span class="line">    <span class="keyword">else</span> add(seg[i].rc,mid+<span class="number">1</span>,r,x,k);</span><br><span class="line"><span class="keyword">end</span>;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">query</span><span class="params">(i,l,r,k:int)</span>:</span>int;</span><br><span class="line"><span class="keyword">var</span> mid,lc,rc:int;</span><br><span class="line"><span class="keyword">begin</span></span><br><span class="line">    <span class="keyword">if</span> l=r <span class="keyword">then</span> <span class="keyword">exit</span>(seg[i].w);</span><br><span class="line">    mid:=(l+r) <span class="keyword">shr</span> <span class="number">1</span>;</span><br><span class="line">    lc:=seg[i].lc;rc:=seg[i].rc;</span><br><span class="line">    <span class="keyword">if</span> k&lt;=mid <span class="keyword">then</span> query:=query(lc,l,mid,k)</span><br><span class="line">    <span class="keyword">else</span> query:=(ll(seg[lc].w)+ll(query(rc,mid+<span class="number">1</span>,r,k)))<span class="keyword">mod</span> md;</span><br><span class="line"><span class="keyword">end</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">begin</span></span><br><span class="line">    assign(input,<span class="string">'hamon.in'</span>);reset(input);</span><br><span class="line">    assign(output,<span class="string">'hamon.out'</span>);rewrite(output);</span><br><span class="line">    <span class="keyword">read</span>(n,tp);sz:=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> i:=<span class="number">1</span> <span class="keyword">to</span> n <span class="keyword">do</span> <span class="keyword">begin</span></span><br><span class="line">        <span class="keyword">read</span>(x);</span><br><span class="line">        f[i]:=_query(x-<span class="number">1</span>);</span><br><span class="line">        <span class="keyword">if</span> f[i]=<span class="number">0</span> <span class="keyword">then</span> g[i]:=<span class="number">1</span></span><br><span class="line">        <span class="keyword">else</span> g[i]:=query(rt[f[i]],<span class="number">1</span>,n,x-<span class="number">1</span>);</span><br><span class="line">        inc(f[i]);add(rt[f[i]],<span class="number">1</span>,n,x,g[i]);_add(x,f[i]);</span><br><span class="line">    <span class="keyword">end</span>;</span><br><span class="line">    ans:=<span class="number">0</span>;cnt:=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> i:=<span class="number">1</span> <span class="keyword">to</span> n <span class="keyword">do</span> ans:=max(ans,f[i]);</span><br><span class="line">    <span class="keyword">for</span> i:=<span class="number">1</span> <span class="keyword">to</span> n <span class="keyword">do</span></span><br><span class="line">        <span class="keyword">if</span> f[i]=ans <span class="keyword">then</span> cnt:=(cnt+g[i])<span class="keyword">mod</span> md;</span><br><span class="line">    writeln(ans);<span class="keyword">if</span> tp=<span class="number">1</span> <span class="keyword">then</span> <span class="keyword">write</span>(cnt);</span><br><span class="line">    close(input);close(output);</span><br><span class="line"><span class="keyword">end</span>.</span><br></pre></td></tr></table></figure><br><br></div></div>

<h1 id="P3-幻魔皇"><a href="#P3-幻魔皇" class="headerlink" title="P3 幻魔皇"></a>P3 幻魔皇</h1><p>定义斐波那契树：</p>
<ol>
<li>根为白色节点</li>
<li>白色节点有一个黑色子节点</li>
<li>黑色节点有一个黑色子节点和一个白色子节点</li>
</ol>
<p>给定树高n，对于$i\in [1,2n]$求距离为i的白色节点对数，答案对123456789取模<br>$n\leq 5000$</p>
<h2 id="80分题解"><a href="#80分题解" class="headerlink" title="80分题解"></a>80分题解</h2><p>我的思路：$O(N^3)$ DP<br>f[i,j] 高为i的子树到根距离为j的节点数<br>g[i,j] 高为i的子树中距离为j的节点对数</p>
<p>f[i,j]=f[i-1,j-1]+f[i-2,j-2]<br>特判新增的白色节点：f[i,1]+=1</p>
<p>统计到新增的白色节点的部分：g[i,j]=f[i-1,j-2]+f[i-2,j-1]<br>加上原来的：g[i,j]+=g[i-1,j]+g[i-2,j]<br>枚举左右子树i,j：g[i,j+k+3]+=f[i-1,j]*f[i-2,k]</p>
<p>递推n-2次，然后特判白色根节点：g[n-2,j]+=f[n-2,j-1]<br>答案是g[n-2,1..n*2]</p>
<p>复杂度的瓶颈在于枚举左右子树的部分，容易发现这一部分的计算实际上是多项式系数向量的卷积，于是可以用fft优化到$O(N^2logN)$，似乎会被卡常，而且这玩意不在noip范围</p>
<div><br><div class="copy"><br>    <a href="/2016/10/30/lydsy-noip-2016-test8/raviel_80.pas" title="{plain text}">{plain text}</a><br></div><br><div><br><figure class="highlight delphi"><figcaption><span>raviel_80.pas</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> int=longint;ll=int64;</span><br><span class="line"><span class="keyword">const</span></span><br><span class="line">    md=<span class="number">123456789</span>;mx=<span class="number">5000</span>;</span><br><span class="line">    nxt:<span class="keyword">array</span>[<span class="number">0</span>..<span class="number">2</span>] <span class="keyword">of</span> int=(<span class="number">1</span>,<span class="number">2</span>,<span class="number">0</span>);</span><br><span class="line"><span class="keyword">var</span></span><br><span class="line">    f,g:<span class="keyword">array</span>[<span class="number">0</span>..<span class="number">2</span>,-<span class="number">2</span>..mx*<span class="number">2</span>+<span class="number">10</span>] <span class="keyword">of</span> int;</span><br><span class="line">    n,i,j,k,i0,i1,i2:int;</span><br><span class="line"></span><br><span class="line"><span class="keyword">begin</span></span><br><span class="line">    assign(input,<span class="string">'raviel.in'</span>);reset(input);</span><br><span class="line">    assign(output,<span class="string">'raviel.ans'</span>);rewrite(output);</span><br><span class="line">    <span class="keyword">read</span>(n);</span><br><span class="line">    i0:=<span class="number">2</span>;i1:=<span class="number">1</span>;i2:=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> i:=<span class="number">1</span> <span class="keyword">to</span> n-<span class="number">2</span> <span class="keyword">do</span> <span class="keyword">begin</span></span><br><span class="line">        i0:=nxt[i0];i1:=nxt[i1];i2:=nxt[i2];</span><br><span class="line">        <span class="keyword">for</span> j:=<span class="number">1</span> <span class="keyword">to</span> i <span class="keyword">do</span> f[i0,j]:=<span class="number">0</span>;</span><br><span class="line">        <span class="comment">//calc f[i0]</span></span><br><span class="line">        <span class="keyword">for</span> j:=<span class="number">1</span> <span class="keyword">to</span> i <span class="keyword">do</span></span><br><span class="line">            f[i0,j]:=(f[i1,j-<span class="number">1</span>]+f[i2,j-<span class="number">2</span>])<span class="keyword">mod</span> md;</span><br><span class="line">        f[i0,<span class="number">1</span>]:=(f[i0,<span class="number">1</span>]+<span class="number">1</span>)<span class="keyword">mod</span> md;</span><br><span class="line">        <span class="comment">//calc g[i0]</span></span><br><span class="line">        <span class="keyword">for</span> j:=<span class="number">1</span> <span class="keyword">to</span> i*<span class="number">2</span> <span class="keyword">do</span></span><br><span class="line">            g[i0,j]:=(f[i1,j-<span class="number">2</span>]+f[i2,j-<span class="number">1</span>]+g[i1,j]+g[i2,j])<span class="keyword">mod</span> md;</span><br><span class="line">        <span class="keyword">for</span> j:=<span class="number">1</span> <span class="keyword">to</span> i*<span class="number">2</span> <span class="keyword">do</span></span><br><span class="line">            <span class="keyword">for</span> k:=<span class="number">1</span> <span class="keyword">to</span> i*<span class="number">2</span>-j <span class="keyword">do</span></span><br><span class="line">                g[i0,j+k+<span class="number">3</span>]:=(ll(g[i0,j+k+<span class="number">3</span>])+</span><br><span class="line">                    ll(f[i1,j])*ll(f[i2,k]))<span class="keyword">mod</span> md;</span><br><span class="line">    <span class="keyword">end</span>;</span><br><span class="line">    <span class="keyword">for</span> j:=<span class="number">1</span> <span class="keyword">to</span> <span class="number">2</span>*n <span class="keyword">do</span> g[i0,j]:=(g[i0,j]+f[i0,j-<span class="number">1</span>])<span class="keyword">mod</span> md;</span><br><span class="line">    <span class="keyword">for</span> i:=<span class="number">1</span> <span class="keyword">to</span> <span class="number">2</span>*n <span class="keyword">do</span> <span class="keyword">write</span>(g[i0,i],<span class="string">' '</span>);</span><br><span class="line">    close(input);close(output);</span><br><span class="line"><span class="keyword">end</span>.</span><br></pre></td></tr></table></figure><br><br></div></div>

<h2 id="100分题解"><a href="#100分题解" class="headerlink" title="100分题解"></a>100分题解</h2><p>标算：$O(N^2)$<br>考虑到其实每一棵黑色根节点的树都是同构的，不单独考虑树高直接枚举距离<br>可以发现：到黑色节点距离i的白色节点数是斐波那契数f[i]，记$s[i]=\sum_{i=1}^n f[i]$<br>而深度i的子树中的白色节点数为f[i-2]+1（特判根节点），黑色节点数为f[i-1]<br>分两种情况：记u,v为白色节点对</p>
<ol>
<li>lca(u,v)=u或v，那么可以算出lca的范围中的白色节点数s[n-2-i]，对于每个lca，距离为d的节点数为f[j-1]</li>
<li>lca(u,v)=一黑色节点，$O(N^2)$枚举u和v到lca的距离，类似1处理即可</li>
</ol>
<div><br><div class="copy"><br>    <a href="/2016/10/30/lydsy-noip-2016-test8/raviel.pas" title="{plain text}">{plain text}</a><br></div><br><div><br><figure class="highlight delphi"><figcaption><span>raviel.pas</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">uses</span> math;</span><br><span class="line"><span class="keyword">type</span> int=longint;ll=int64;</span><br><span class="line"><span class="keyword">const</span> md=<span class="number">123456789</span>;mx=<span class="number">5000</span>;</span><br><span class="line"><span class="keyword">var</span></span><br><span class="line">    f,s,g:<span class="keyword">array</span>[-<span class="number">1</span>..mx*<span class="number">2</span>+<span class="number">10</span>] <span class="keyword">of</span> int;</span><br><span class="line">    n,i,j:int;</span><br><span class="line"></span><br><span class="line"><span class="keyword">begin</span></span><br><span class="line">    assign(input,<span class="string">'raviel.in'</span>);reset(input);</span><br><span class="line">    assign(output,<span class="string">'raviel.out'</span>);rewrite(output);</span><br><span class="line">    <span class="keyword">read</span>(n);f[<span class="number">1</span>]:=<span class="number">1</span>;s[<span class="number">0</span>]:=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> i:=<span class="number">2</span> <span class="keyword">to</span> n <span class="keyword">do</span> f[i]:=(f[i-<span class="number">1</span>]+f[i-<span class="number">2</span>]) <span class="keyword">mod</span> md;</span><br><span class="line">    <span class="keyword">for</span> i:=<span class="number">1</span> <span class="keyword">to</span> n <span class="keyword">do</span> s[i]:=(s[i-<span class="number">1</span>]+f[i]) <span class="keyword">mod</span> md;</span><br><span class="line">    <span class="keyword">for</span> i:=<span class="number">1</span> <span class="keyword">to</span> n-<span class="number">1</span> <span class="keyword">do</span> g[i]:=ll(s[n-<span class="number">2</span>-i]+<span class="number">1</span>)*ll(f[i-<span class="number">1</span>]) <span class="keyword">mod</span> md;</span><br><span class="line">    f[-<span class="number">1</span>]:=<span class="number">1</span>; <span class="comment">//便于特判根节点</span></span><br><span class="line">    <span class="keyword">for</span> i:=<span class="number">1</span> <span class="keyword">to</span> n-<span class="number">1</span> <span class="keyword">do</span></span><br><span class="line">        <span class="keyword">for</span> j:=<span class="number">1</span> <span class="keyword">to</span> n-<span class="number">1</span> <span class="keyword">do</span></span><br><span class="line">            g[i+j]:=(ll(g[i+j])+(ll(f[i-<span class="number">2</span>])*ll(f[j-<span class="number">1</span>])<span class="keyword">mod</span> md)*</span><br><span class="line">                ll(s[n-<span class="number">1</span>-max(i,j)]))<span class="keyword">mod</span> md;</span><br><span class="line">    <span class="keyword">for</span> i:=<span class="number">1</span> <span class="keyword">to</span> n*<span class="number">2</span> <span class="keyword">do</span> <span class="keyword">write</span>(g[i],<span class="string">' '</span>);</span><br><span class="line">    close(input);close(output);</span><br><span class="line"><span class="keyword">end</span>.</span><br></pre></td></tr></table></figure><br><br></div></div>
]]></content>
    
    <summary type="html">
    
      &lt;blockquote&gt;
&lt;p&gt;订正进度(3/3)&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h1 id=&quot;P1-神炎皇&quot;&gt;&lt;a href=&quot;#P1-神炎皇&quot; class=&quot;headerlink&quot; title=&quot;P1 神炎皇&quot;&gt;&lt;/a&gt;P1 神炎皇&lt;/h1&gt;&lt;p&gt;大意：给定n，求满足$a+b\leq n$且$(a+b)|ab$的有序对(a,b)的个数&lt;br&gt;$n\leq 10^{14}$&lt;/p&gt;
    
    </summary>
    
      <category term="Problem Set" scheme="https://cothrax.github.io/categories/Problem-Set/"/>
    
    
      <category term="OI" scheme="https://cothrax.github.io/tags/OI/"/>
    
      <category term="数据结构" scheme="https://cothrax.github.io/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"/>
    
      <category term="DP" scheme="https://cothrax.github.io/tags/DP/"/>
    
      <category term="树状数组" scheme="https://cothrax.github.io/tags/%E6%A0%91%E7%8A%B6%E6%95%B0%E7%BB%84/"/>
    
      <category term="数论" scheme="https://cothrax.github.io/tags/%E6%95%B0%E8%AE%BA/"/>
    
      <category term="线段树" scheme="https://cothrax.github.io/tags/%E7%BA%BF%E6%AE%B5%E6%A0%91/"/>
    
      <category term="线性DP" scheme="https://cothrax.github.io/tags/%E7%BA%BF%E6%80%A7DP/"/>
    
      <category term="树结构" scheme="https://cothrax.github.io/tags/%E6%A0%91%E7%BB%93%E6%9E%84/"/>
    
      <category term="数学" scheme="https://cothrax.github.io/tags/%E6%95%B0%E5%AD%A6/"/>
    
      <category term="线性筛" scheme="https://cothrax.github.io/tags/%E7%BA%BF%E6%80%A7%E7%AD%9B/"/>
    
      <category term="欧拉函数" scheme="https://cothrax.github.io/tags/%E6%AC%A7%E6%8B%89%E5%87%BD%E6%95%B0/"/>
    
  </entry>
  
  <entry>
    <title>笔记 欧拉函数</title>
    <link href="https://cothrax.github.io/2016/10/30/note-euler-function/"/>
    <id>https://cothrax.github.io/2016/10/30/note-euler-function/</id>
    <published>2016-10-30T01:30:38.000Z</published>
    <updated>2016-11-11T16:08:54.479Z</updated>
    
    <content type="html"><![CDATA[<p>noip前复习数论，怎么感觉是在预习Q(AQ)*</p>
<h1 id="欧拉函数的性质"><a href="#欧拉函数的性质" class="headerlink" title="欧拉函数的性质"></a>欧拉函数的性质</h1><ol>
<li>$p$为素数，$\varphi(p)=p-1$</li>
<li>欧拉定理：若$gcd(a,n)=1$，则$a^{\varphi(n)}\equiv 1(mod\ n)$<br>注：这玩意可以用来证明费马小定理</li>
<li>$p$为素数，$\varphi(p^k)=p^k-p^{k-1}$</li>
<li>若$gcd(p,q)=1$，则$\varphi(pq)=\varphi(p)\varphi(q)$</li>
<li>任意$n\in N*$，$\varphi(n)=\varphi(\prod_i p_i^k)=\prod_i p^{k-1}(p_i-1)=n\prod_i(1-1/p_i)$</li>
<li>对于$n&gt;2$，$2|\varphi(n)$</li>
<li>若$n\ mod\ p=0$，则$\varphi(np)=p\cdot \varphi(n)$</li>
</ol>
<a id="more"></a>
<p>证明可以看：<a href="/2016/10/30/note-euler-function/eluer-funtion.doc" title="欧拉函数及其证明">欧拉函数及其证明</a></p>
<h1 id="求单个-varphi-n"><a href="#求单个-varphi-n" class="headerlink" title="求单个$\varphi(n)$"></a>求单个$\varphi(n)$</h1><p>根据性质5，质因数分解然后暴力即可，复杂度$O(\sqrt{N})$</p>
<figure class="highlight pascal"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">phi</span><span class="params">(n:int)</span>:</span>int;</span><br><span class="line"><span class="keyword">var</span> i:int;</span><br><span class="line"><span class="keyword">begin</span></span><br><span class="line">    phi:=n;</span><br><span class="line">    <span class="keyword">for</span> i:=<span class="number">2</span> <span class="keyword">to</span> ceil(sqrt(n)) <span class="keyword">do</span></span><br><span class="line">        <span class="keyword">if</span> n <span class="keyword">mod</span> i=<span class="number">0</span> <span class="keyword">then</span> <span class="keyword">begin</span></span><br><span class="line">            phi:=phi <span class="keyword">div</span> i*(i-<span class="number">1</span>);</span><br><span class="line">            <span class="keyword">while</span> n <span class="keyword">mod</span> i=<span class="number">0</span> <span class="keyword">do</span> n:=n <span class="keyword">div</span> i;</span><br><span class="line">        <span class="keyword">end</span>;</span><br><span class="line">    <span class="keyword">if</span> n&gt;<span class="number">1</span> <span class="keyword">then</span> phi:=phi <span class="keyword">div</span> n*(n-<span class="number">1</span>);</span><br><span class="line"><span class="keyword">end</span>;</span><br></pre></td></tr></table></figure>
<h1 id="线性筛-varphi-n"><a href="#线性筛-varphi-n" class="headerlink" title="线性筛$\varphi(n)$"></a>线性筛$\varphi(n)$</h1><p>由性质4和7得到，若p为素数，则<br><img src="/2016/10/30/note-euler-function/7350.gif" alt="7350.gif" title=""><br>就是在筛素数时顺便求欧拉函数，线性筛与普通筛的区别：<br>例如，对于合数6会在i=2和i=3被筛两次，而线性筛只会筛i=2一次<br>关键就在line16的那个break<br>当$p[j]|i$时，下一个要被筛的合数$p[j+1]\cdot i$能被表示为$(p[j+1]\cdot i’)\cdot p[j]$，因此它可以被更小的素数$p[j]$筛出，即当循环到合数$p[j+1]\cdot i’$时，再去筛它也不迟<br>这样每个数只会被筛一次，因此复杂度$O(N)$</p>
<figure class="highlight pascal"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">procedure</span> <span class="title">euler</span><span class="params">(n:int)</span>;</span></span><br><span class="line"><span class="keyword">var</span> </span><br><span class="line">    i,j,k:int;</span><br><span class="line">    f:<span class="keyword">array</span>[<span class="number">0</span>..<span class="number">1010</span>] <span class="keyword">of</span> boolean; <span class="comment">//素数标记</span></span><br><span class="line">    p:<span class="keyword">array</span>[<span class="number">0</span>..<span class="number">1010</span>] <span class="keyword">of</span> int; <span class="comment">//素数表，规模为k</span></span><br><span class="line"><span class="keyword">begin</span></span><br><span class="line">    fillchar(f,sizeof(f),false);</span><br><span class="line">    phi[<span class="number">1</span>]:=<span class="number">1</span>;k:=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> i:=<span class="number">2</span> <span class="keyword">to</span> n <span class="keyword">do</span> <span class="keyword">begin</span></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> f[i] <span class="keyword">then</span> </span><br><span class="line">            <span class="keyword">begin</span> inc(k);p[k]:=i;phi[i]:=i-<span class="number">1</span> <span class="keyword">end</span>;</span><br><span class="line">        j:=<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">while</span> i*p[j]&lt;=n <span class="keyword">do</span> <span class="keyword">begin</span></span><br><span class="line">            f[i*p[j]]:=true;</span><br><span class="line">            <span class="keyword">if</span> i <span class="keyword">mod</span> p[j]=<span class="number">0</span> <span class="keyword">then</span> <span class="keyword">begin</span></span><br><span class="line">                phi[i*p[j]]:=phi[i]*p[j];<span class="keyword">break</span></span><br><span class="line">            <span class="keyword">end</span> <span class="keyword">else</span></span><br><span class="line">                phi[i*p[j]]:=phi[i]*(p[j]-<span class="number">1</span>);</span><br><span class="line">            inc(j);</span><br><span class="line">        <span class="keyword">end</span>;</span><br><span class="line">    <span class="keyword">end</span>;</span><br><span class="line"><span class="keyword">end</span>;</span><br></pre></td></tr></table></figure>
<p>一坨pascal代码：<a href="/2016/10/30/note-euler-function/1030.pas" title="1030.pas">1030.pas</a></p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;noip前复习数论，怎么感觉是在预习Q(AQ)*&lt;/p&gt;
&lt;h1 id=&quot;欧拉函数的性质&quot;&gt;&lt;a href=&quot;#欧拉函数的性质&quot; class=&quot;headerlink&quot; title=&quot;欧拉函数的性质&quot;&gt;&lt;/a&gt;欧拉函数的性质&lt;/h1&gt;&lt;ol&gt;
&lt;li&gt;$p$为素数，$\varphi(p)=p-1$&lt;/li&gt;
&lt;li&gt;欧拉定理：若$gcd(a,n)=1$，则$a^{\varphi(n)}\equiv 1(mod\ n)$&lt;br&gt;注：这玩意可以用来证明费马小定理&lt;/li&gt;
&lt;li&gt;$p$为素数，$\varphi(p^k)=p^k-p^{k-1}$&lt;/li&gt;
&lt;li&gt;若$gcd(p,q)=1$，则$\varphi(pq)=\varphi(p)\varphi(q)$&lt;/li&gt;
&lt;li&gt;任意$n\in N*$，$\varphi(n)=\varphi(\prod_i p_i^k)=\prod_i p^{k-1}(p_i-1)=n\prod_i(1-1/p_i)$&lt;/li&gt;
&lt;li&gt;对于$n&amp;gt;2$，$2|\varphi(n)$&lt;/li&gt;
&lt;li&gt;若$n\ mod\ p=0$，则$\varphi(np)=p\cdot \varphi(n)$&lt;/li&gt;
&lt;/ol&gt;
    
    </summary>
    
    
      <category term="数论" scheme="https://cothrax.github.io/tags/%E6%95%B0%E8%AE%BA/"/>
    
      <category term="数学" scheme="https://cothrax.github.io/tags/%E6%95%B0%E5%AD%A6/"/>
    
      <category term="线性筛" scheme="https://cothrax.github.io/tags/%E7%BA%BF%E6%80%A7%E7%AD%9B/"/>
    
      <category term="欧拉函数" scheme="https://cothrax.github.io/tags/%E6%AC%A7%E6%8B%89%E5%87%BD%E6%95%B0/"/>
    
  </entry>
  
  <entry>
    <title>NOIP2016十连测 Day 9</title>
    <link href="https://cothrax.github.io/2016/10/28/lydsy-noip-2016-test9/"/>
    <id>https://cothrax.github.io/2016/10/28/lydsy-noip-2016-test9/</id>
    <published>2016-10-28T15:26:20.000Z</published>
    <updated>2016-11-09T15:14:41.910Z</updated>
    
    <content type="html"><![CDATA[<p>2016-10-28<br>已经挖了好多坑了。。<delete>大flag：noip前填完</delete><br><strong>P3由于过于noip拒绝订正</strong></p>
<blockquote>
<p>订正进度(2/3)</p>
</blockquote>
<h1 id="P1-小P的2048"><a href="#P1-小P的2048" class="headerlink" title="P1 小P的2048"></a>P1 小P的2048</h1><p>大意：2048都玩过吧。。。给定棋盘和操作序列，求得分和有效操作数<br>因为是蛋疼模拟，各种细节就不写了。<br><a id="more"></a></p>
<h2 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h2><p>都说了是模拟<br>不知怎么丢了10分，算了不想改了。。</p>
<div><br><div class="copy"><br>    <a href="/2016/10/28/lydsy-noip-2016-test9/game.pas" title="{plain text}">{plain text}</a><br></div><br><div><br><figure class="highlight delphi"><figcaption><span>game.pas</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&#123;90pts&#125;</span></span><br><span class="line"><span class="keyword">uses</span> math;</span><br><span class="line"><span class="keyword">type</span> int=longint;</span><br><span class="line"><span class="keyword">var</span> </span><br><span class="line">    n,m,d,i,j,k,v,r,amt:int;ans:int64;b:boolean;</span><br><span class="line">    a:<span class="keyword">array</span>[<span class="number">0</span>..<span class="number">10</span>,<span class="number">0</span>..<span class="number">10</span>] <span class="keyword">of</span> int;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">mv</span><span class="params">(x,y,dx,dy:int)</span>:</span>boolean;</span><br><span class="line"><span class="keyword">var</span> lx,ly:int;flg:boolean;</span><br><span class="line"><span class="keyword">begin</span></span><br><span class="line">    lx:=x-dx;ly:=y-dy;mv:=false;flg:=true;</span><br><span class="line">    <span class="keyword">while</span> (min(x,y)&gt;<span class="number">0</span>)<span class="keyword">and</span>(max(x,y)&lt;=n) <span class="keyword">do</span> <span class="keyword">begin</span></span><br><span class="line">        <span class="keyword">if</span> a[x,y]&gt;<span class="number">0</span> <span class="keyword">then</span> <span class="keyword">begin</span></span><br><span class="line">            <span class="keyword">if</span> flg <span class="keyword">and</span> (a[x,y]=a[lx,ly]) <span class="keyword">then</span> <span class="keyword">begin</span></span><br><span class="line">                a[lx,ly]:=a[lx,ly]*<span class="number">2</span>;inc(ans,a[lx,ly]);</span><br><span class="line">                a[x,y]:=<span class="number">0</span>;</span><br><span class="line">                inc(r);mv:=true;flg:=false;</span><br><span class="line">            <span class="keyword">end</span> <span class="keyword">else</span> <span class="keyword">begin</span></span><br><span class="line">                inc(lx,dx);inc(ly,dy);</span><br><span class="line">                a[lx,ly]:=a[x,y];flg:=true;</span><br><span class="line">                <span class="keyword">if</span> (lx&lt;&gt;x)<span class="keyword">or</span>(ly&lt;&gt;y) <span class="keyword">then</span> <span class="keyword">begin</span></span><br><span class="line">                    a[x,y]:=<span class="number">0</span>;mv:=true;</span><br><span class="line">                <span class="keyword">end</span>;</span><br><span class="line">            <span class="keyword">end</span>;</span><br><span class="line">        <span class="keyword">end</span>;</span><br><span class="line">        inc(x,dx);inc(y,dy);</span><br><span class="line">    <span class="keyword">end</span>;</span><br><span class="line">    b:=b <span class="keyword">or</span> mv;</span><br><span class="line"><span class="keyword">end</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">procedure</span> <span class="title">add</span><span class="params">(k,v:int)</span>;</span></span><br><span class="line"><span class="keyword">var</span> i,j,cnt:int;</span><br><span class="line"><span class="keyword">begin</span></span><br><span class="line">    cnt:=<span class="number">0</span>;dec(r);</span><br><span class="line">    <span class="keyword">for</span> i:=<span class="number">1</span> <span class="keyword">to</span> n <span class="keyword">do</span></span><br><span class="line">        <span class="keyword">for</span> j:=<span class="number">1</span> <span class="keyword">to</span> n <span class="keyword">do</span></span><br><span class="line">            <span class="keyword">if</span> a[i,j]=<span class="number">0</span> <span class="keyword">then</span> <span class="keyword">begin</span></span><br><span class="line">                inc(cnt);</span><br><span class="line">                <span class="keyword">if</span> cnt=k <span class="keyword">then</span> <span class="keyword">begin</span> a[i,j]:=v;<span class="keyword">exit</span> <span class="keyword">end</span>;</span><br><span class="line">            <span class="keyword">end</span>;</span><br><span class="line"><span class="keyword">end</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">begin</span></span><br><span class="line">    assign(input,<span class="string">'game.in'</span>);reset(input);</span><br><span class="line">    assign(output,<span class="string">'game.out'</span>);rewrite(output);</span><br><span class="line">    <span class="keyword">read</span>(n,m);r:=n*n-<span class="number">2</span>;ans:=<span class="number">0</span>;amt:=m;</span><br><span class="line">    <span class="keyword">read</span>(i,j,k);a[i,j]:=k;</span><br><span class="line">    <span class="keyword">read</span>(i,j,k);a[i,j]:=k;</span><br><span class="line">    <span class="keyword">for</span> i:=<span class="number">1</span> <span class="keyword">to</span> m <span class="keyword">do</span> <span class="keyword">begin</span></span><br><span class="line">        <span class="keyword">read</span>(d,k,v);b:=false;</span><br><span class="line">        <span class="keyword">case</span> d <span class="keyword">of</span> </span><br><span class="line">            <span class="number">0</span>:<span class="keyword">for</span> j:=<span class="number">1</span> <span class="keyword">to</span> n <span class="keyword">do</span> mv(<span class="number">1</span>,j,<span class="number">1</span>,<span class="number">0</span>);</span><br><span class="line">            <span class="number">1</span>:<span class="keyword">for</span> j:=<span class="number">1</span> <span class="keyword">to</span> n <span class="keyword">do</span> mv(n,j,-<span class="number">1</span>,<span class="number">0</span>);</span><br><span class="line">            <span class="number">2</span>:<span class="keyword">for</span> j:=<span class="number">1</span> <span class="keyword">to</span> n <span class="keyword">do</span> mv(j,<span class="number">1</span>,<span class="number">0</span>,<span class="number">1</span>);</span><br><span class="line">            <span class="number">3</span>:<span class="keyword">for</span> j:=<span class="number">1</span> <span class="keyword">to</span> n <span class="keyword">do</span> mv(j,n,<span class="number">0</span>,-<span class="number">1</span>);</span><br><span class="line">        <span class="keyword">end</span>;</span><br><span class="line">        <span class="keyword">if</span> (r=<span class="number">0</span>) <span class="keyword">or</span> <span class="keyword">not</span> b <span class="keyword">then</span> <span class="keyword">begin</span> amt:=i-<span class="number">1</span>;<span class="keyword">break</span> <span class="keyword">end</span>;</span><br><span class="line">        k:=<span class="number">1</span>+k <span class="keyword">mod</span> r;add(k,v);</span><br><span class="line">    <span class="keyword">end</span>;</span><br><span class="line">    writeln(amt);<span class="keyword">write</span>(ans);</span><br><span class="line">    close(input);close(output);</span><br><span class="line"><span class="keyword">end</span>.</span><br></pre></td></tr></table></figure><br><br></div></div>

<h1 id="P2-小P的单调数列"><a href="#P2-小P的单调数列" class="headerlink" title="P2 小P的单调数列"></a>P2 小P的单调数列</h1><p>定义一个单调数列的价值：所有数的总和<br>定义一个数列的价值：划分为若干极长单调区间后，这些区间价值的平均值，第一个区间必须单调增<br>注：极长单调区间即保证相邻两个区间单调性不同<br>给定长为n的数列$a_i$，求其价值最大的子序列</p>
<h2 id="40分解法"><a href="#40分解法" class="headerlink" title="40分解法"></a>40分解法</h2><p>即对于$a_i$的若干单调子序列和的平均值，求最大值<br>显然想到dp<br>记f[i,j] 为a[1..i]中划分j个单调区间的答案</p>
<ol>
<li>$j\%2=1$<ol>
<li>$a[k]&lt;a[j],f[i,j]=max(f[k,j],f[k,j-1])+a[i]$</li>
<li>$a[k]&gt;a[j],f[i,j]=max(f[k,j-1])+a[i]$</li>
</ol>
</li>
<li>$j\%2=0$ 类似</li>
</ol>
<p>答案为$max(f[i,j]/j)$<br>初始：$f[0,0]=0,f[i,j]=+\infty$<br>复杂度：$O(N^3)$</p>
<div><br><div class="copy"><br>    <a href="/2016/10/28/lydsy-noip-2016-test9/seq.pas" title="{plain text}">{plain text}</a><br></div><br><div><br><figure class="highlight delphi"><figcaption><span>seq.pas</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">uses</span> math;</span><br><span class="line"><span class="keyword">type</span> int=longint;</span><br><span class="line"><span class="keyword">var</span></span><br><span class="line">    f:<span class="keyword">array</span>[<span class="number">0</span>..<span class="number">210</span>,<span class="number">0</span>..<span class="number">210</span>] <span class="keyword">of</span> int64;</span><br><span class="line">    a:<span class="keyword">array</span>[<span class="number">0</span>..<span class="number">210</span>] <span class="keyword">of</span> int64;</span><br><span class="line">    n,i,j,k:int;ans:double;</span><br><span class="line"></span><br><span class="line"><span class="keyword">begin</span></span><br><span class="line">    assign(input,<span class="string">'seq.in'</span>);reset(input);</span><br><span class="line">    assign(output,<span class="string">'seq.ans'</span>);rewrite(output);</span><br><span class="line">    <span class="keyword">read</span>(n);</span><br><span class="line">    <span class="keyword">for</span> i:=<span class="number">1</span> <span class="keyword">to</span> n <span class="keyword">do</span> <span class="keyword">read</span>(a[i]);</span><br><span class="line">    fillchar(f,sizeof(f),<span class="number">192</span>);</span><br><span class="line">    f[<span class="number">0</span>,<span class="number">0</span>]:=<span class="number">0</span>;ans:=<span class="number">0</span>;a[<span class="number">0</span>]:=maxlongint;</span><br><span class="line">    <span class="keyword">for</span> i:=<span class="number">1</span> <span class="keyword">to</span> n <span class="keyword">do</span></span><br><span class="line">    <span class="keyword">for</span> j:=<span class="number">1</span> <span class="keyword">to</span> n <span class="keyword">do</span></span><br><span class="line">    <span class="keyword">for</span> k:=i-<span class="number">1</span> <span class="keyword">downto</span> <span class="number">0</span> <span class="keyword">do</span></span><br><span class="line">        <span class="keyword">if</span> ((a[k]&gt;a[i])xor(j <span class="keyword">and</span> <span class="number">1</span>=<span class="number">1</span>)) <span class="keyword">and</span> (a[k]&lt;&gt;a[i]) <span class="keyword">then</span></span><br><span class="line">            f[i,j]:=max(f[i,j],max(f[k,j],f[k,j-<span class="number">1</span>])+a[i])</span><br><span class="line">        <span class="keyword">else</span> f[i,j]:=max(f[i,j],f[k,j-<span class="number">1</span>]+a[i]);</span><br><span class="line">    <span class="keyword">for</span> i:=<span class="number">1</span> <span class="keyword">to</span> n <span class="keyword">do</span></span><br><span class="line">        <span class="keyword">for</span> j:=<span class="number">1</span> <span class="keyword">to</span> n <span class="keyword">do</span></span><br><span class="line">            ans:=max(ans,f[i,j]/j);</span><br><span class="line">    <span class="keyword">write</span>(ans:<span class="number">0</span>:<span class="number">3</span>);</span><br><span class="line">    close(input);close(output);</span><br><span class="line"><span class="keyword">end</span>.</span><br></pre></td></tr></table></figure><br><br></div></div>

<h2 id="100分解法"><a href="#100分解法" class="headerlink" title="100分解法"></a>100分解法</h2><p>结论是：最优解的单调区间数一定$\leq 2$<br>因为是平均值，如果区间数$\geq 3$，根据比例的性质，去掉其中和最小的那个区间，能得到更优解<br>这么说只有一个区间是更优的，但由于题目要求第一个区间是单调增的，所以会存在两个区间的情况<br>这样对于每个数，求左边的lis和右边的lds，然后枚举分界点找最大值即可<br>然后还要考虑一个单调增区间的情况，即拿整个数列的lis更新答案<br>至于dp可以用树状数组优化，详见<a href="/2016/10/30/lydsy-noip-2016-test8/" title="Test8的P2">Test8的P2</a><br>复杂度$O(NlogN)$</p>
<div><br><div class="copy"><br>    <a href="/2016/10/28/lydsy-noip-2016-test9/seq_.pas" title="{plain text}">{plain text}</a><br></div><br><div><br><figure class="highlight delphi"><figcaption><span>seq_.pas</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">uses</span> math;</span><br><span class="line"><span class="keyword">type</span> int=longint;</span><br><span class="line"><span class="keyword">var</span> </span><br><span class="line">    n,m,i:int;ans:double;</span><br><span class="line">    a:<span class="keyword">array</span>[<span class="number">0</span>..<span class="number">100010</span>,<span class="number">0</span>..<span class="number">1</span>] <span class="keyword">of</span> int;</span><br><span class="line">    b,l:<span class="keyword">array</span>[<span class="number">0</span>..<span class="number">100010</span>] <span class="keyword">of</span> int;</span><br><span class="line">    bit,lis,lds:<span class="keyword">array</span>[<span class="number">0</span>..<span class="number">100010</span>] <span class="keyword">of</span> int64;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">procedure</span> <span class="title">qsort</span><span class="params">(l,r:int)</span>;</span></span><br><span class="line"><span class="keyword">var</span> i,j,x:int;tmp:<span class="keyword">array</span>[<span class="number">0</span>..<span class="number">1</span>] <span class="keyword">of</span> int;</span><br><span class="line"><span class="keyword">begin</span></span><br><span class="line">    i:=l;j:=r;x:=a[random(r-l)+l,<span class="number">0</span>];</span><br><span class="line">    <span class="keyword">repeat</span></span><br><span class="line">        <span class="keyword">while</span> a[i,<span class="number">0</span>]&lt;x <span class="keyword">do</span> inc(i);</span><br><span class="line">        <span class="keyword">while</span> a[j,<span class="number">0</span>]&gt;x <span class="keyword">do</span> dec(j);</span><br><span class="line">        <span class="keyword">if</span> i&lt;=j <span class="keyword">then</span> <span class="keyword">begin</span></span><br><span class="line">            tmp:=a[i];a[i]:=a[j];a[j]:=tmp;</span><br><span class="line">            inc(i);dec(j);</span><br><span class="line">        <span class="keyword">end</span>;</span><br><span class="line">    <span class="keyword">until</span> i&gt;j;</span><br><span class="line">    <span class="keyword">if</span> l&lt;j <span class="keyword">then</span> qsort(l,j);</span><br><span class="line">    <span class="keyword">if</span> i&lt;r <span class="keyword">then</span> qsort(i,r);</span><br><span class="line"><span class="keyword">end</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">query</span><span class="params">(x:int)</span>:</span>int64;</span><br><span class="line"><span class="keyword">begin</span></span><br><span class="line">    query:=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span> x&gt;<span class="number">0</span> <span class="keyword">do</span> <span class="keyword">begin</span></span><br><span class="line">        query:=max(query,bit[x]);</span><br><span class="line">        x:=x <span class="keyword">and</span> (x-<span class="number">1</span>);</span><br><span class="line">    <span class="keyword">end</span>;</span><br><span class="line"><span class="keyword">end</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">procedure</span> <span class="title">add</span><span class="params">(x:int;k:int64)</span>;</span></span><br><span class="line"><span class="keyword">begin</span></span><br><span class="line">    <span class="keyword">while</span> x&lt;=n <span class="keyword">do</span> <span class="keyword">begin</span></span><br><span class="line">        bit[x]:=max(bit[x],k);</span><br><span class="line">        inc(x,x <span class="keyword">and</span> (-x));</span><br><span class="line">    <span class="keyword">end</span>;</span><br><span class="line"><span class="keyword">end</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">begin</span></span><br><span class="line">    assign(input,<span class="string">'seq.in'</span>);reset(input);</span><br><span class="line">    assign(output,<span class="string">'seq.out'</span>);rewrite(output);</span><br><span class="line">    <span class="keyword">read</span>(n);</span><br><span class="line">    <span class="keyword">for</span> i:=<span class="number">1</span> <span class="keyword">to</span> n <span class="keyword">do</span> <span class="keyword">read</span>(a[i,<span class="number">0</span>]);</span><br><span class="line">    <span class="keyword">for</span> i:=<span class="number">1</span> <span class="keyword">to</span> n <span class="keyword">do</span> a[i,<span class="number">1</span>]:=i;</span><br><span class="line">    qsort(<span class="number">1</span>,n);m:=<span class="number">0</span>;l[m]:=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> i:=<span class="number">1</span> <span class="keyword">to</span> n <span class="keyword">do</span> <span class="keyword">begin</span></span><br><span class="line">        <span class="keyword">if</span> a[i,<span class="number">0</span>]&gt;l[m] <span class="keyword">then</span> <span class="keyword">begin</span> inc(m);l[m]:=a[i,<span class="number">0</span>] <span class="keyword">end</span>;</span><br><span class="line">        b[a[i,<span class="number">1</span>]]:=m;</span><br><span class="line">    <span class="keyword">end</span>;</span><br><span class="line">    <span class="comment">//f[i]=max(f[j])+a[i] i&lt;j&amp;&amp;a[i]&lt;=a[j] max(1..a[j]) of f[]</span></span><br><span class="line">    <span class="keyword">for</span> i:=<span class="number">1</span> <span class="keyword">to</span> n <span class="keyword">do</span> <span class="keyword">begin</span></span><br><span class="line">        lis[i]:=query(b[i]-<span class="number">1</span>)+l[b[i]];</span><br><span class="line">        add(b[i],lis[i]);</span><br><span class="line">    <span class="keyword">end</span>;</span><br><span class="line">    fillchar(bit,sizeof(bit),<span class="number">0</span>);</span><br><span class="line">    <span class="keyword">for</span> i:=n <span class="keyword">downto</span> <span class="number">1</span> <span class="keyword">do</span> <span class="keyword">begin</span></span><br><span class="line">        lds[i]:=query(b[i]-<span class="number">1</span>)+l[b[i]];</span><br><span class="line">        add(b[i],lds[i]);</span><br><span class="line">    <span class="keyword">end</span>;</span><br><span class="line">    <span class="keyword">for</span> i:=<span class="number">2</span> <span class="keyword">to</span> n <span class="keyword">do</span> lis[i]:=max(lis[i],lis[i-<span class="number">1</span>]);</span><br><span class="line">    <span class="keyword">for</span> i:=n-<span class="number">1</span> <span class="keyword">downto</span> <span class="number">1</span> <span class="keyword">do</span> lds[i]:=max(lds[i],lds[i+<span class="number">1</span>]);</span><br><span class="line">    ans:=lis[n];</span><br><span class="line">    <span class="keyword">for</span> i:=<span class="number">1</span> <span class="keyword">to</span> n-<span class="number">1</span> <span class="keyword">do</span> ans:=max(ans,(lis[i]+lds[i+<span class="number">1</span>])/<span class="number">2</span>);</span><br><span class="line">    <span class="keyword">write</span>(ans:<span class="number">0</span>:<span class="number">3</span>);</span><br><span class="line">    close(input);close(output);</span><br><span class="line"><span class="keyword">end</span>.</span><br></pre></td></tr></table></figure><br><br></div></div>

<h1 id="P3-小P的生成树"><a href="#P3-小P的生成树" class="headerlink" title="P3 小P的生成树"></a>P3 小P的生成树</h1><p>给定n个节点，m条边的连通的带权无向简单图，边权为向量，求一个生成树，使得树上的边权向量和的模最大。<br>$n\leq 50, m\leq 200$</p>
<h2 id="注"><a href="#注" class="headerlink" title="注"></a>注</h2><blockquote>
<p>涉及计算几何内容，暂不订正</p>
</blockquote>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;2016-10-28&lt;br&gt;已经挖了好多坑了。。&lt;delete&gt;大flag：noip前填完&lt;/delete&gt;&lt;br&gt;&lt;strong&gt;P3由于过于noip拒绝订正&lt;/strong&gt;&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;订正进度(2/3)&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h1 id=&quot;P1-小P的2048&quot;&gt;&lt;a href=&quot;#P1-小P的2048&quot; class=&quot;headerlink&quot; title=&quot;P1 小P的2048&quot;&gt;&lt;/a&gt;P1 小P的2048&lt;/h1&gt;&lt;p&gt;大意：2048都玩过吧。。。给定棋盘和操作序列，求得分和有效操作数&lt;br&gt;因为是蛋疼模拟，各种细节就不写了。&lt;br&gt;
    
    </summary>
    
      <category term="Problem Set" scheme="https://cothrax.github.io/categories/Problem-Set/"/>
    
    
      <category term="OI" scheme="https://cothrax.github.io/tags/OI/"/>
    
      <category term="数据结构" scheme="https://cothrax.github.io/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"/>
    
      <category term="DP" scheme="https://cothrax.github.io/tags/DP/"/>
    
      <category term="树状数组" scheme="https://cothrax.github.io/tags/%E6%A0%91%E7%8A%B6%E6%95%B0%E7%BB%84/"/>
    
      <category term="线性DP" scheme="https://cothrax.github.io/tags/%E7%BA%BF%E6%80%A7DP/"/>
    
  </entry>
  
  <entry>
    <title>NOIP2016十连测 Day 5</title>
    <link href="https://cothrax.github.io/2016/10/28/lydsy-noip-2016-test5/"/>
    <id>https://cothrax.github.io/2016/10/28/lydsy-noip-2016-test5/</id>
    <published>2016-10-28T14:43:14.000Z</published>
    <updated>2016-11-03T15:40:10.063Z</updated>
    
    <content type="html"><![CDATA[<p>跪</p>
<blockquote>
<p>订正进度(2/3)</p>
</blockquote>
<h1 id="P1-Simple"><a href="#P1-Simple" class="headerlink" title="P1 Simple"></a>P1 Simple</h1><p>给定$n,m,q\in N*$，求$[1,q]内，$$\not\exists x,y\in N,c=nx+my$的c的个数<br>共T组询问<br>$n≤10^5,m≤10^9,q≤10^{18},T≤10$</p>
<a id="more"></a>
<h2 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h2><p>从反面入手，求可以表示成$nx+my,n,m\in N$的c的个数<br>根据裴蜀定理，$c=nx+my$有解当且仅当$gcd(n,m)|c$<br>记$g=gcd(n,m)$<br>这样解的范围被缩小到$[1,n/g]$，$n=n/g,m=m/g$，此时n和m互质<br>然后根据数论知识，不能被表示成$nx+my,n,m\in N*$的最大整数为$nm-n-m$</p>
<p>那么考虑$[1,nm]$的数，其中能表示为$ym-xn,y\in[0,n-1]$的数一定满足题意：<br>由扩展欧几里得可知，已知$ym+(-x)n=c$的一组解$(-x,y)$，那么它的所有解为$(-x+t\cdot m,y-t\cdot n)$，其中必定有一个是负数<br>这样枚举[0,n-1]统计即可。</p>
<div><br><div class="copy"><br>    <a href="/2016/10/28/lydsy-noip-2016-test5/simple.pas" title="{plain text}">{plain text}</a><br></div><br><div><br><figure class="highlight delphi"><figcaption><span>simple.pas</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">uses</span> math;</span><br><span class="line"><span class="keyword">type</span> int=longint;</span><br><span class="line"><span class="keyword">var</span> n,m,q,g,l,r,ans:int64;i,j,t:int;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">gcd</span><span class="params">(a,b:int64)</span>:</span>int64;</span><br><span class="line"><span class="keyword">begin</span> <span class="keyword">if</span> b=<span class="number">0</span> <span class="keyword">then</span> gcd:=a <span class="keyword">else</span> gcd:=gcd(b,a <span class="keyword">mod</span> b) <span class="keyword">end</span>;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">cldv</span><span class="params">(n,m:int64)</span>:</span>int64;</span><br><span class="line"><span class="keyword">begin</span></span><br><span class="line">    cldv:=n <span class="keyword">div</span> m;</span><br><span class="line">    <span class="keyword">if</span> n <span class="keyword">mod</span> m&lt;&gt;<span class="number">0</span> <span class="keyword">then</span> inc(cldv);</span><br><span class="line"><span class="keyword">end</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">begin</span></span><br><span class="line">    <span class="comment">//assign(input,'simple.in');reset(input);</span></span><br><span class="line">    <span class="comment">//assign(output,'simple.out');rewrite(output);</span></span><br><span class="line">    <span class="keyword">read</span>(t);</span><br><span class="line">    <span class="keyword">repeat</span></span><br><span class="line">        <span class="keyword">read</span>(n,m,q);g:=gcd(n,m);</span><br><span class="line">        ans:=q;q:=q <span class="keyword">div</span> g;dec(ans,q);</span><br><span class="line">        n:=n <span class="keyword">div</span> g;m:=m <span class="keyword">div</span> g;</span><br><span class="line">        <span class="keyword">for</span> i:=<span class="number">0</span> <span class="keyword">to</span> n-<span class="number">1</span> <span class="keyword">do</span> <span class="keyword">begin</span></span><br><span class="line">            l:=max(<span class="number">1</span>,cldv(i*m-q,n));</span><br><span class="line">            r:=trunc((i*m-<span class="number">1</span>)/n);</span><br><span class="line">            inc(ans,max(r-l+<span class="number">1</span>,<span class="number">0</span>));</span><br><span class="line">        <span class="keyword">end</span>;</span><br><span class="line">        writeln(ans);</span><br><span class="line">        dec(t);</span><br><span class="line">    <span class="keyword">until</span> t=<span class="number">0</span>;</span><br><span class="line">    close(input);close(output);</span><br><span class="line"><span class="keyword">end</span>.</span><br></pre></td></tr></table></figure><br><br></div></div>

<h1 id="P2-Walk"><a href="#P2-Walk" class="headerlink" title="P2 Walk"></a>P2 Walk</h1><p>大意：给定n个节点的树，边长为1，边权为w，定义一条路径的权值为路径上所有边权的最大公约数，对于任意$i\in[1,n]$,求树上所有长度为i的简单路径中权值最大的是多少。</p>
<h2 id="题解-1"><a href="#题解-1" class="headerlink" title="题解"></a>题解</h2><p>大暴力，枚举答案，每次都重新构图，跑树（森林）上最长链<br>一点总结：</p>
<ol>
<li>关于gcd的处理：枚举gcd，那么权为gcd倍数的边都是合法的</li>
<li>关于复杂度的分析：每条边e(u,v)=w只有在枚举值为w的约数时才会被遍历，理论复杂度为$O(N\sqrt{N})$</li>
<li>关于常数<ul>
<li>用链表维护边集，将边权相等的边串起来</li>
<li>用栈维护点集，在加边时将端点入栈</li>
<li>清空临时的边集数组时，由于只有在栈内的点的head值被修改，遍历栈中的点即可</li>
<li>标记数组：当前为第idx次遍历，用flag[u]=idx表示u以被访问，避免每次清空数组</li>
</ul>
</li>
<li>关于树上最长链：之前在学树形dp时用过一种比较复杂的方法，记录一个点的最长链、次长链、链经过的子节点，两次dp得到；更简单的方法见代码</li>
<li>关于一些sb错误<ul>
<li>栈要开2*n</li>
<li>混淆栈中元素和栈下标</li>
</ul>
</li>
</ol>
<div><br><div class="copy"><br>    <a href="/2016/10/28/lydsy-noip-2016-test5/walk.pas" title="{plain text}">{plain text}</a><br></div><br><div><br><figure class="highlight delphi"><figcaption><span>walk.pas</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">uses</span> math;</span><br><span class="line"><span class="keyword">type</span> </span><br><span class="line">    int=longint;</span><br><span class="line">    edge=<span class="keyword">record</span> v,next:int <span class="keyword">end</span>;</span><br><span class="line">    e1=<span class="keyword">record</span> u,v,next:int <span class="keyword">end</span>;</span><br><span class="line"><span class="keyword">var</span> </span><br><span class="line">    g:<span class="keyword">array</span>[<span class="number">0</span>..<span class="number">800010</span>] <span class="keyword">of</span> edge;</span><br><span class="line">    e:<span class="keyword">array</span>[<span class="number">0</span>..<span class="number">400010</span>] <span class="keyword">of</span> e1;</span><br><span class="line">    head,flag,ans:<span class="keyword">array</span>[<span class="number">0</span>..<span class="number">400010</span>] <span class="keyword">of</span> int;</span><br><span class="line">    stk:<span class="keyword">array</span>[<span class="number">0</span>..<span class="number">800010</span>] <span class="keyword">of</span> int;</span><br><span class="line">    ptr:<span class="keyword">array</span>[<span class="number">0</span>..<span class="number">1000010</span>] <span class="keyword">of</span> int;</span><br><span class="line">    sz,k,mx,n,i,j,l,u,v,w,idx,len,t:int;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">procedure</span> <span class="title">add</span><span class="params">(u,v:int)</span>;</span></span><br><span class="line"><span class="keyword">begin</span></span><br><span class="line">    inc(sz);g[sz].v:=v;</span><br><span class="line">    g[sz].next:=head[u];head[u]:=sz;</span><br><span class="line"><span class="keyword">end</span>;</span><br><span class="line"><span class="function"><span class="keyword">procedure</span> _<span class="title">add</span><span class="params">(u,v,w:int)</span>;</span></span><br><span class="line"><span class="keyword">begin</span></span><br><span class="line">    inc(k);e[k].u:=u;e[k].v:=v;</span><br><span class="line">    e[k].next:=ptr[w];ptr[w]:=k;</span><br><span class="line"><span class="keyword">end</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">dfs</span><span class="params">(u:int)</span>:</span>int;</span><br><span class="line"><span class="keyword">var</span> v,i,tmp:int;</span><br><span class="line"><span class="keyword">begin</span></span><br><span class="line">    flag[u]:=idx;i:=head[u];dfs:=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span> i&lt;&gt;<span class="number">0</span> <span class="keyword">do</span> <span class="keyword">begin</span></span><br><span class="line">        v:=g[i].v;</span><br><span class="line">        <span class="keyword">if</span> flag[v]&lt;idx <span class="keyword">then</span> <span class="keyword">begin</span></span><br><span class="line">            tmp:=dfs(v);</span><br><span class="line">            len:=max(len,dfs+tmp+<span class="number">1</span>);</span><br><span class="line">            dfs:=max(dfs,tmp+<span class="number">1</span>);</span><br><span class="line">        <span class="keyword">end</span>;</span><br><span class="line">        i:=g[i].next;</span><br><span class="line">    <span class="keyword">end</span>;</span><br><span class="line"><span class="keyword">end</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">begin</span></span><br><span class="line">    assign(input,<span class="string">'ex_walk3.in'</span>);reset(input);</span><br><span class="line">    assign(output,<span class="string">'walk.out'</span>);rewrite(output);</span><br><span class="line">    <span class="keyword">read</span>(n);k:=<span class="number">0</span>;mx:=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> i:=<span class="number">1</span> <span class="keyword">to</span> n-<span class="number">1</span> <span class="keyword">do</span> <span class="keyword">begin</span></span><br><span class="line">        <span class="keyword">read</span>(u,v,w);_add(u,v,w);mx:=max(mx,w);</span><br><span class="line">    <span class="keyword">end</span>;</span><br><span class="line">    idx:=<span class="number">0</span>;len:=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> i:=<span class="number">1</span> <span class="keyword">to</span> mx <span class="keyword">do</span> <span class="keyword">begin</span></span><br><span class="line">        sz:=<span class="number">0</span>;inc(idx);l:=i;t:=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span> l&lt;=mx <span class="keyword">do</span> <span class="keyword">begin</span></span><br><span class="line">            j:=ptr[l];inc(l,i);</span><br><span class="line">            <span class="keyword">while</span> j&lt;&gt;<span class="number">0</span> <span class="keyword">do</span> <span class="keyword">begin</span></span><br><span class="line">                add(e[j].u,e[j].v);add(e[j].v,e[j].u);</span><br><span class="line">                inc(t,<span class="number">2</span>);stk[t-<span class="number">1</span>]:=e[j].u;stk[t]:=e[j].v;</span><br><span class="line">                j:=e[j].next;</span><br><span class="line">            <span class="keyword">end</span>;</span><br><span class="line">        <span class="keyword">end</span>;</span><br><span class="line">        len:=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> j:=<span class="number">1</span> <span class="keyword">to</span> t <span class="keyword">do</span> <span class="keyword">if</span> flag[stk[j]]&lt;idx <span class="keyword">then</span> dfs(stk[j]);</span><br><span class="line">        <span class="keyword">for</span> j:=<span class="number">1</span> <span class="keyword">to</span> t <span class="keyword">do</span> head[stk[j]]:=<span class="number">0</span>;</span><br><span class="line">        ans[len]:=i;</span><br><span class="line">    <span class="keyword">end</span>;</span><br><span class="line">    <span class="keyword">for</span> i:=n-<span class="number">1</span> <span class="keyword">downto</span> <span class="number">1</span> <span class="keyword">do</span></span><br><span class="line">        ans[i]:=max(ans[i],ans[i+<span class="number">1</span>]);</span><br><span class="line">    <span class="keyword">for</span> i:=<span class="number">1</span> <span class="keyword">to</span> n <span class="keyword">do</span> writeln(ans[i]);</span><br><span class="line">    close(input);close(output);</span><br><span class="line"><span class="keyword">end</span>.</span><br></pre></td></tr></table></figure><br><br></div></div>

<h1 id="P3-Travel"><a href="#P3-Travel" class="headerlink" title="P3 Travel"></a>P3 Travel</h1><blockquote>
<p>挖个坑</p>
</blockquote>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;跪&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;订正进度(2/3)&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h1 id=&quot;P1-Simple&quot;&gt;&lt;a href=&quot;#P1-Simple&quot; class=&quot;headerlink&quot; title=&quot;P1 Simple&quot;&gt;&lt;/a&gt;P1 Simple&lt;/h1&gt;&lt;p&gt;给定$n,m,q\in N*$，求$[1,q]内，$$\not\exists x,y\in N,c=nx+my$的c的个数&lt;br&gt;共T组询问&lt;br&gt;$n≤10^5,m≤10^9,q≤10^{18},T≤10$&lt;/p&gt;
    
    </summary>
    
      <category term="Problem Set" scheme="https://cothrax.github.io/categories/Problem-Set/"/>
    
    
      <category term="OI" scheme="https://cothrax.github.io/tags/OI/"/>
    
      <category term="数据结构" scheme="https://cothrax.github.io/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"/>
    
      <category term="图论" scheme="https://cothrax.github.io/tags/%E5%9B%BE%E8%AE%BA/"/>
    
      <category term="数论" scheme="https://cothrax.github.io/tags/%E6%95%B0%E8%AE%BA/"/>
    
      <category term="树形DP" scheme="https://cothrax.github.io/tags/%E6%A0%91%E5%BD%A2DP/"/>
    
      <category term="链表" scheme="https://cothrax.github.io/tags/%E9%93%BE%E8%A1%A8/"/>
    
      <category term="裴蜀定理" scheme="https://cothrax.github.io/tags/%E8%A3%B4%E8%9C%80%E5%AE%9A%E7%90%86/"/>
    
      <category term="栈" scheme="https://cothrax.github.io/tags/%E6%A0%88/"/>
    
  </entry>
  
  <entry>
    <title>NOIP模拟赛 游戏</title>
    <link href="https://cothrax.github.io/2016/10/16/noip-2009-11-1-2-game/"/>
    <id>https://cothrax.github.io/2016/10/16/noip-2009-11-1-2-game/</id>
    <published>2016-10-16T02:56:41.000Z</published>
    <updated>2016-10-30T06:06:17.165Z</updated>
    
    <content type="html"><![CDATA[<h2 id="描述"><a href="#描述" class="headerlink" title="描述"></a>描述</h2><p>windy学会了一种游戏。<br>对于1到N这N个数字，都有唯一且不同的1到N的数字与之对应。<br>最开始windy把数字按顺序1，2，3，……，N写一排在纸上。<br>然后再在这一排下面写上它们对应的数字。<br>然后又在新的一排下面写上它们对应的数字。<br>如此反复，直到序列再次变为1，2，3，……，N。<br><a id="more"></a><br>如：<br>1 2 3 4 5 6<br>对应的关系为<br>1-&gt;2 2-&gt;3 3-&gt;1 4-&gt;5 5-&gt;4 6-&gt;6<br>windy的操作如下<br>1 2 3 4 5 6<br>2 3 1 5 4 6<br>3 1 2 4 5 6<br>1 2 3 5 4 6<br>2 3 1 4 5 6<br>3 1 2 5 4 6<br>1 2 3 4 5 6<br>这时，我们就有若干排1到N的排列，上例中有7排。<br>现在windy想知道，对于所有可能的对应关系，有多少种可能的排数。 </p>
<h2 id="格式"><a href="#格式" class="headerlink" title="格式"></a>格式</h2><h3 id="输入格式"><a href="#输入格式" class="headerlink" title="输入格式"></a>输入格式</h3><p>输入文件game.in包含一个整数，N。</p>
<h3 id="输出格式"><a href="#输出格式" class="headerlink" title="输出格式"></a>输出格式</h3><p>输出文件game.out包含一个整数，可能的排数。</p>
<h2 id="样例"><a href="#样例" class="headerlink" title="样例"></a>样例</h2><h3 id="样例输入"><a href="#样例输入" class="headerlink" title="样例输入"></a>样例输入</h3><blockquote>
<p>3</p>
</blockquote>
<h3 id="样例输出"><a href="#样例输出" class="headerlink" title="样例输出"></a>样例输出</h3><blockquote>
<p>3</p>
</blockquote>
<h2 id="提示​"><a href="#提示​" class="headerlink" title="提示​"></a>提示​</h2><p>30%的数据，满足 1 &lt;= N &lt;= 10 。<br>100%的数据，满足 1 &lt;= N &lt;= 1000 。 </p>
<h2 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h2><p>规约为：<span>$n\geq\sum_ia_i$</span><!-- Has MathJax -->，求不同的<span>$lcm\{a_i\}$</span><!-- Has MathJax -->的个数<br>先筛素数，然后dp<br>f[i,j]为1..i个素数，和为j的方案数</p>
<div><br><div class="copy"><br>    <a href="/2016/10/16/noip-2009-11-1-2-game/game.pas" title="{plain text}">{plain text}</a><br></div><br><div><br><figure class="highlight delphi"><figcaption><span>game.pas</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> int=longint;</span><br><span class="line"><span class="keyword">var</span> </span><br><span class="line">    p:<span class="keyword">array</span>[<span class="number">0</span>..<span class="number">1010</span>] <span class="keyword">of</span> boolean;</span><br><span class="line">    a:<span class="keyword">array</span>[<span class="number">0</span>..<span class="number">1010</span>] <span class="keyword">of</span> int;</span><br><span class="line">    f:<span class="keyword">array</span>[<span class="number">0</span>..<span class="number">1010</span>] <span class="keyword">of</span> int64;</span><br><span class="line">    n,m,i,j,k:int;ans:int64;</span><br><span class="line"></span><br><span class="line"><span class="keyword">begin</span></span><br><span class="line">    assign(input,<span class="string">'game.in'</span>);reset(input);</span><br><span class="line">    assign(output,<span class="string">'game.out'</span>);rewrite(output);</span><br><span class="line">    <span class="keyword">read</span>(n);m:=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> i:=<span class="number">2</span> <span class="keyword">to</span> n <span class="keyword">do</span></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> p[i] <span class="keyword">then</span> <span class="keyword">begin</span></span><br><span class="line">            inc(m);a[m]:=i;</span><br><span class="line">            j:=i*<span class="number">2</span>;</span><br><span class="line">            <span class="keyword">while</span> j&lt;=n <span class="keyword">do</span> <span class="keyword">begin</span></span><br><span class="line">                p[j]:=true;inc(j,i);</span><br><span class="line">            <span class="keyword">end</span>;</span><br><span class="line">        <span class="keyword">end</span>;</span><br><span class="line">    f[<span class="number">0</span>]:=<span class="number">1</span>;</span><br><span class="line">    <span class="comment">//j-k*a[i]&gt;=0 -&gt; k&lt;=j/a[i]</span></span><br><span class="line">    <span class="keyword">for</span> i:=<span class="number">1</span> <span class="keyword">to</span> m <span class="keyword">do</span></span><br><span class="line">        <span class="keyword">for</span> j:=n <span class="keyword">downto</span> <span class="number">1</span> <span class="keyword">do</span> <span class="keyword">begin</span></span><br><span class="line">            k:=a[i];</span><br><span class="line">            <span class="keyword">while</span> k&lt;=j <span class="keyword">do</span> <span class="keyword">begin</span></span><br><span class="line">                inc(f[j],f[j-k]);k:=k*a[i];</span><br><span class="line">            <span class="keyword">end</span>;</span><br><span class="line">        <span class="keyword">end</span>;</span><br><span class="line">    ans:=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> i:=<span class="number">0</span> <span class="keyword">to</span> n <span class="keyword">do</span> inc(ans,f[i]);</span><br><span class="line">    <span class="keyword">write</span>(ans);</span><br><span class="line">    close(input);close(output);</span><br><span class="line"><span class="keyword">end</span>.</span><br></pre></td></tr></table></figure><br><br></div></div>
]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;描述&quot;&gt;&lt;a href=&quot;#描述&quot; class=&quot;headerlink&quot; title=&quot;描述&quot;&gt;&lt;/a&gt;描述&lt;/h2&gt;&lt;p&gt;windy学会了一种游戏。&lt;br&gt;对于1到N这N个数字，都有唯一且不同的1到N的数字与之对应。&lt;br&gt;最开始windy把数字按顺序1，2，3，……，N写一排在纸上。&lt;br&gt;然后再在这一排下面写上它们对应的数字。&lt;br&gt;然后又在新的一排下面写上它们对应的数字。&lt;br&gt;如此反复，直到序列再次变为1，2，3，……，N。&lt;br&gt;
    
    </summary>
    
      <category term="Problem Set" scheme="https://cothrax.github.io/categories/Problem-Set/"/>
    
    
      <category term="OI" scheme="https://cothrax.github.io/tags/OI/"/>
    
      <category term="DP" scheme="https://cothrax.github.io/tags/DP/"/>
    
      <category term="数论" scheme="https://cothrax.github.io/tags/%E6%95%B0%E8%AE%BA/"/>
    
      <category term="数学" scheme="https://cothrax.github.io/tags/%E6%95%B0%E5%AD%A6/"/>
    
  </entry>
  
  <entry>
    <title>NOIP2016十连测 Day 6</title>
    <link href="https://cothrax.github.io/2016/10/16/lydsy-noip-2016-test6/"/>
    <id>https://cothrax.github.io/2016/10/16/lydsy-noip-2016-test6/</id>
    <published>2016-10-16T02:37:45.000Z</published>
    <updated>2016-11-03T15:40:16.957Z</updated>
    
    <content type="html"><![CDATA[<p>又一场NOIplus模拟赛。<br>第一题同样是暴力，pascal被卡常<br>第三题yy了scc+dfs，忘记判无解的情况，又是捆绑测试，然后爆0</p>
<blockquote>
<p>订正进度(2/3)</p>
</blockquote>
<h1 id="P1-幻想"><a href="#P1-幻想" class="headerlink" title="P1 幻想"></a>P1 幻想</h1><p>大意：（其实是描述的片段）<br>给定一个不小于 2 的整数 k ,按照如下方式生成一个无限长的序列S (下标从 0 开始)。<br>1.初始时序列只有一个元素 S(0) = 0 。<br>2.对于j=1,2,…,k-1分别把当前序列的每个元素都加上j,得到新的k-1个序列。<br>3.把新的k-1个序列依次接在当前序列后面,得到一个长度为当前序列长度 k 倍的序列。<br>4.把这个序列每一项都变成其除以 k 之后的余数,并把这个序列作为新的当前序列。<br>5.执行无穷次操作 2-4。<br>给定l,r，求$\sum_{i=L}^{R}h(i)\times S_i$<br>其中$h(i)=\lfloor\dfrac{(i\% 20000116)^2+i+804}{233}\rfloor$<br>答案对$2^{32}$取模<br>$T≤100 ; 2≤k≤1000 ; 0≤L≤R≤10^16;\sum(R-L)≤10^8$<br>时限2s</p>
<a id="more"></a>
<h2 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h2><p>观察发现S(i)就是i在k进制下，数位和mod k的值，r-l又不是很大，暴力求<br>pascal被卡常<br>附我的草稿</p>
<blockquote>
<p>123 456 789 012 345 678 901 234 567<br>012 120 201 120 201 012 201 012 120</p>
<p>f(i) i mod 3=1=d -&gt; init=d-1<br>bl=ceil(i/k) -&gt; 9 –&gt;<br>ceil(i/k^2)) -&gt; 3 –&gt;<br>ceil(i/k^3)) -&gt; 1 –&gt; 0</p>
<p>19=2*3^2+1*3^0 -&gt; (2+1 -1)%3<br>16=1*3^2+2*3^1+1*3^0 (1+2+1 -1)%3=1<br>O((r-l)*log_k(n)*(k-1))</p>
<p>l-&gt;r ??<br>∑i*3^k -&gt; ∑i*3^k+1 ??</p>
</blockquote>
<div><br><div class="copy"><br>    <a href="/2016/10/16/lydsy-noip-2016-test6/fantasy.pas" title="{plain text}">{plain text}</a><br></div><br><div><br><figure class="highlight delphi"><figcaption><span>fantasy.pas</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&#123;$R-&#125;</span></span><br><span class="line"><span class="keyword">uses</span> math;</span><br><span class="line"><span class="keyword">type</span> int=longint;qw=qword;dw=dword;</span><br><span class="line"><span class="keyword">const</span> z0:qw=<span class="number">20000116</span>;</span><br><span class="line"><span class="keyword">var</span> </span><br><span class="line">    T,i:int;l,r,x:qw;ans,k,cnt:dw;</span><br><span class="line">    nxt:<span class="keyword">array</span>[<span class="number">0</span>..<span class="number">1100</span>] <span class="keyword">of</span> dw;</span><br><span class="line">    f:<span class="keyword">array</span>[<span class="number">0</span>..<span class="number">60</span>] <span class="keyword">of</span> dw;</span><br><span class="line"></span><br><span class="line"><span class="keyword">begin</span></span><br><span class="line">    <span class="comment">//assign(input,'fantasy.in');reset(input);</span></span><br><span class="line">    <span class="comment">//assign(output,'fantasy.out');rewrite(output);</span></span><br><span class="line">    <span class="keyword">read</span>(T);</span><br><span class="line">    <span class="keyword">repeat</span></span><br><span class="line">        <span class="keyword">read</span>(k,l,r);</span><br><span class="line">        fillchar(f,sizeof(f),<span class="number">0</span>);</span><br><span class="line">        x:=l;i:=<span class="number">0</span>;cnt:=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span> x&gt;<span class="number">0</span> <span class="keyword">do</span> <span class="keyword">begin</span></span><br><span class="line">            f[i]:=x <span class="keyword">mod</span> k;x:=x <span class="keyword">div</span> k;cnt:=cnt+f[i];i:=i+<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">end</span>;</span><br><span class="line">        <span class="keyword">for</span> i:=<span class="number">0</span> <span class="keyword">to</span> k-<span class="number">2</span> <span class="keyword">do</span> nxt[i]:=i+<span class="number">1</span>;nxt[k-<span class="number">1</span>]:=<span class="number">0</span>;</span><br><span class="line">        cnt:=cnt <span class="keyword">mod</span> k;</span><br><span class="line">        ans:=qw(cnt)*trunc((sqr(l <span class="keyword">mod</span> z0)+l+<span class="number">804</span>)/<span class="number">233</span>);</span><br><span class="line">        <span class="keyword">if</span> l=r <span class="keyword">then</span> <span class="keyword">exit</span>;x:=l+<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">repeat</span></span><br><span class="line">            f[<span class="number">0</span>]:=f[<span class="number">0</span>]+<span class="number">1</span>;cnt:=nxt[cnt];i:=<span class="number">0</span>;</span><br><span class="line">            <span class="keyword">while</span> f[i]=k <span class="keyword">do</span> <span class="keyword">begin</span></span><br><span class="line">                f[i+<span class="number">1</span>]:=f[i+<span class="number">1</span>]+<span class="number">1</span>;f[i]:=<span class="number">0</span>;i:=i+<span class="number">1</span>;</span><br><span class="line">                cnt:=nxt[cnt];</span><br><span class="line">            <span class="keyword">end</span>;</span><br><span class="line">            ans:=qw(ans)+qw(cnt)*trunc((sqr(x <span class="keyword">mod</span> z0)+x+<span class="number">804</span>)/<span class="number">233</span>);</span><br><span class="line">            x:=x+<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">until</span> x=r+<span class="number">1</span>;</span><br><span class="line">        writeln(ans);</span><br><span class="line">        dec(T);</span><br><span class="line">    <span class="keyword">until</span> T=<span class="number">0</span>;</span><br><span class="line">    <span class="comment">//close(input);close(output);</span></span><br><span class="line"><span class="keyword">end</span>.</span><br></pre></td></tr></table></figure><br><br></div></div>

<h1 id="T3-现实"><a href="#T3-现实" class="headerlink" title="T3 现实"></a>T3 现实</h1><p>大意：给定n个节点、m条边的有向图，求所有图中满足如下条件的点v：删去点v后，图变成dag<br>$n\leq5\times 10^5;m\leq10^6$</p>
<h2 id="水解"><a href="#水解" class="headerlink" title="水解"></a>水解</h2><p>转换一下思路，就是求图中所有简单环的交集。<br>这个可以tarjan找出强连通分量，然后暴力dfs遍历所有环<br>当然是会TLE的</p>
<div><br><div class="copy"><br>    <a href="/2016/10/16/lydsy-noip-2016-test6/reality_che.pas" title="{plain text}">{plain text}</a><br></div><br><div><br><figure class="highlight delphi"><figcaption><span>reality.pas</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">uses</span> math;</span><br><span class="line"><span class="keyword">type</span> </span><br><span class="line">    int=longint;</span><br><span class="line">    edge=<span class="keyword">record</span> v,nxt:int <span class="keyword">end</span>;</span><br><span class="line"><span class="keyword">var</span></span><br><span class="line">    g:<span class="keyword">array</span>[<span class="number">0</span>..<span class="number">1000010</span>] <span class="keyword">of</span> edge;</span><br><span class="line">    head,s,dfn,low,scc,siz,f:<span class="keyword">array</span>[<span class="number">0</span>..<span class="number">500010</span>] <span class="keyword">of</span> int;</span><br><span class="line">    ins<span class="comment">&#123;,vis&#125;</span>:<span class="keyword">array</span>[<span class="number">0</span>..<span class="number">500010</span>] <span class="keyword">of</span> boolean;</span><br><span class="line">    sz,n,m,k,i,t,u,v,cc,tim,cnt,ans:int;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">procedure</span> <span class="title">add</span><span class="params">(u,v:int)</span>;</span></span><br><span class="line"><span class="keyword">begin</span></span><br><span class="line">    inc(sz);g[sz].v:=v;</span><br><span class="line">    g[sz].nxt:=head[u];head[u]:=sz;</span><br><span class="line"><span class="keyword">end</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">procedure</span> <span class="title">tarjan</span><span class="params">(u:int)</span>;</span></span><br><span class="line"><span class="keyword">var</span> i,v:int;</span><br><span class="line"><span class="keyword">begin</span></span><br><span class="line">    inc(tim);dfn[u]:=tim;low[u]:=tim;</span><br><span class="line">    inc(t);s[t]:=u;ins[u]:=true;</span><br><span class="line">    i:=head[u];</span><br><span class="line">    <span class="keyword">while</span> i&lt;&gt;<span class="number">0</span> <span class="keyword">do</span> <span class="keyword">begin</span></span><br><span class="line">        v:=g[i].v;</span><br><span class="line">        <span class="keyword">if</span> dfn[v]=<span class="number">0</span> <span class="keyword">then</span> <span class="keyword">begin</span></span><br><span class="line">            tarjan(v);low[u]:=min(low[v],low[u]);</span><br><span class="line">        <span class="keyword">end</span> <span class="keyword">else</span> <span class="keyword">if</span> ins[v] <span class="keyword">then</span></span><br><span class="line">            low[u]:=min(low[u],dfn[v]);        </span><br><span class="line">        i:=g[i].nxt;</span><br><span class="line">    <span class="keyword">end</span>;</span><br><span class="line">    <span class="keyword">if</span> dfn[u]=low[u] <span class="keyword">then</span> <span class="keyword">begin</span></span><br><span class="line">        inc(cc);siz[cc]:=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span> s[t+<span class="number">1</span>]&lt;&gt;u <span class="keyword">do</span> <span class="keyword">begin</span></span><br><span class="line">            scc[s[t]]:=cc;ins[s[t]]:=false;</span><br><span class="line">            inc(siz[cc]);dec(t);</span><br><span class="line">        <span class="keyword">end</span>;</span><br><span class="line">    <span class="keyword">end</span>;</span><br><span class="line"><span class="keyword">end</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">procedure</span> <span class="title">dfs</span><span class="params">(u:int)</span>;</span></span><br><span class="line"><span class="keyword">var</span> v,i,j:int;</span><br><span class="line"><span class="keyword">begin</span></span><br><span class="line">    inc(t);s[t]:=u;ins[u]:=true;</span><br><span class="line">    i:=head[u];</span><br><span class="line">    <span class="keyword">while</span> i&lt;&gt;<span class="number">0</span> <span class="keyword">do</span> <span class="keyword">begin</span></span><br><span class="line">        v:=g[i].v;</span><br><span class="line">        <span class="keyword">if</span> scc[v]=k <span class="keyword">then</span> <span class="keyword">begin</span></span><br><span class="line">            <span class="keyword">if</span> ins[v] <span class="keyword">then</span> <span class="keyword">begin</span></span><br><span class="line">                inc(cnt);j:=t;</span><br><span class="line">                <span class="keyword">while</span> s[j+<span class="number">1</span>]&lt;&gt;v <span class="keyword">do</span> </span><br><span class="line">                    <span class="keyword">begin</span> inc(f[s[j]]);dec(j) <span class="keyword">end</span>;</span><br><span class="line">            <span class="keyword">end</span> <span class="keyword">else</span> dfs(v);</span><br><span class="line">        <span class="keyword">end</span>;</span><br><span class="line">        i:=g[i].nxt;</span><br><span class="line">    <span class="keyword">end</span>;</span><br><span class="line">    ins[u]:=false;dec(t);</span><br><span class="line"><span class="keyword">end</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">begin</span></span><br><span class="line">    <span class="comment">//assign(input,'reality.in');reset(input);</span></span><br><span class="line">    <span class="comment">//assign(output,'reality.out');rewrite(output);</span></span><br><span class="line">    <span class="keyword">read</span>(n,m);</span><br><span class="line">    <span class="keyword">for</span> i:=<span class="number">1</span> <span class="keyword">to</span> m <span class="keyword">do</span> <span class="keyword">begin</span></span><br><span class="line">        <span class="keyword">read</span>(u,v);add(u,v);</span><br><span class="line">    <span class="keyword">end</span>;</span><br><span class="line">    t:=<span class="number">0</span>;tim:=<span class="number">0</span>;cc:=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> i:=<span class="number">1</span> <span class="keyword">to</span> n <span class="keyword">do</span></span><br><span class="line">        <span class="keyword">if</span> dfn[i]=<span class="number">0</span> <span class="keyword">then</span> tarjan(i);</span><br><span class="line">    k:=-<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span> i:=<span class="number">1</span> <span class="keyword">to</span> cc <span class="keyword">do</span></span><br><span class="line">        <span class="keyword">if</span> siz[i]&gt;<span class="number">1</span> <span class="keyword">then</span> <span class="keyword">begin</span> </span><br><span class="line">            <span class="keyword">if</span> k&lt;&gt;-<span class="number">1</span> <span class="keyword">then</span> <span class="keyword">begin</span> <span class="keyword">write</span>(<span class="number">0</span>);halt <span class="keyword">end</span>;</span><br><span class="line">            k:=i; </span><br><span class="line">        <span class="keyword">end</span>;</span><br><span class="line">    <span class="keyword">if</span> k=-<span class="number">1</span> <span class="keyword">then</span> <span class="keyword">begin</span> </span><br><span class="line">        writeln(n);<span class="keyword">for</span> i:=<span class="number">1</span> <span class="keyword">to</span> n <span class="keyword">do</span> <span class="keyword">write</span>(i,<span class="string">' '</span>);halt;</span><br><span class="line">    <span class="keyword">end</span>;</span><br><span class="line">    <span class="keyword">for</span> i:=<span class="number">1</span> <span class="keyword">to</span> n <span class="keyword">do</span></span><br><span class="line">        <span class="keyword">if</span> scc[i]=k <span class="keyword">then</span> <span class="keyword">begin</span> u:=i;<span class="keyword">break</span> <span class="keyword">end</span>;</span><br><span class="line">    fillchar(s,sizeof(s),<span class="number">0</span>);</span><br><span class="line">    ans:=<span class="number">0</span>;cnt:=<span class="number">0</span>;dfs(u);</span><br><span class="line">    <span class="keyword">for</span> i:=<span class="number">1</span> <span class="keyword">to</span> n <span class="keyword">do</span></span><br><span class="line">        <span class="keyword">if</span> f[i]=cnt <span class="keyword">then</span> <span class="keyword">begin</span> inc(ans);inc(t);s[t]:=i <span class="keyword">end</span>;</span><br><span class="line">    writeln(ans);</span><br><span class="line">    <span class="keyword">for</span> i:=<span class="number">1</span> <span class="keyword">to</span> t <span class="keyword">do</span> <span class="keyword">write</span>(s[i],<span class="string">' '</span>);</span><br><span class="line">    close(input);close(output);</span><br><span class="line"><span class="keyword">end</span>.</span><br></pre></td></tr></table></figure><br><br></div></div>

<h2 id="正解"><a href="#正解" class="headerlink" title="正解"></a>正解</h2><p>dfs找一个环+拓扑排序+dag上dp<br>同水解一样，考虑求环交的点集<br>直接求点集有如下缺陷</p>
<ol>
<li>删掉一个环后，剩下的不一定是dag</li>
<li>无法处理自环</li>
</ol>
<p>于是拆点，把点拆成入点和出点，入点向出点连边，这样点集变成了边集。<br>然后dfs找到一个环，如果找不到说明原来就是dag，特判输出<br>然后把这个环删掉，拓扑排序；如果还有环，说明无解，特判输出<br>破环成链，然后顺次给环上的点编号loc[u]<br>然后dp，考虑两种路径<br><img src="/2016/10/16/lydsy-noip-2016-test6/g.png" alt="g.png" title=""></p>
<ol>
<li>第一种<ol>
<li>求点u，顺着非环边能走到的环上点的最小编号f1[u]</li>
<li>求点u，逆着非环边能走到的环上点的最大编号f2[u]</li>
<li>考虑环上的点u，如果f1[u]&lt;loc[u]则loc[u]&lt;loc[v]的点v都不在环交中；如果loc[u]&lt;f2[u]，则loc[v]&lt;loc[u]的点v都不在环交中</li>
</ol>
</li>
<li>第二种<ol>
<li>求点u，顺着非环边能走到的环上的点的最大编号f3[u]</li>
<li>考虑环上的点u，如果loc[u]&lt;f3[u]，那么编号在(loc[u],f3[u])的点都不在环交中</li>
</ol>
</li>
</ol>
<p>区间修改可以用差分序列<br>一些细节：</p>
<ol>
<li>找环时记录路径上点的入边edg[u]和dfs树上的父节点pre[u]，找到环后回头标记</li>
<li>第一写非递归的拓扑排序（以前都是用dfs的）</li>
<li>在环上，出点u+n与原来的点u是一一对应的（因为记录的是入边）</li>
<li>第一种的两种子情况看似是等价的，但如果只求一种情况是有漏洞的，比如：<img src="/2016/10/16/lydsy-noip-2016-test6/sp.png" alt="sp.png" title="">
图中有两条非环边e1和e2，如果指对a4求f1的话，得到的答案是a2,a3,a4；但实际上a2不在环交中</li>
</ol>
<div><br><div class="copy"><br>    <a href="/2016/10/16/lydsy-noip-2016-test6/reality.pas" title="{plain text}">{plain text}</a><br></div><br><div><br><figure class="highlight delphi"><figcaption><span>reality.pas</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">uses</span> math;</span><br><span class="line"><span class="keyword">const</span> inf=<span class="number">1000000000</span>;</span><br><span class="line"><span class="keyword">type</span> </span><br><span class="line">    int=longint;</span><br><span class="line">    edge=<span class="keyword">record</span> u,v,nxt:int;f:boolean <span class="keyword">end</span>;</span><br><span class="line">    arr=<span class="keyword">array</span>[<span class="number">0</span>..<span class="number">1000010</span>] <span class="keyword">of</span> int;</span><br><span class="line"><span class="keyword">var</span></span><br><span class="line">    g:<span class="keyword">array</span>[<span class="number">0</span>..<span class="number">1500010</span>] <span class="keyword">of</span> edge;</span><br><span class="line">    head,top,pre,edg,flg,loc,cyc,f1,f2,f3,a,ans:arr;</span><br><span class="line">    sz,n,m,i,j,k,u,v,cnt:int;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">procedure</span> <span class="title">add</span><span class="params">(u,v:int)</span>;</span></span><br><span class="line"><span class="keyword">begin</span></span><br><span class="line">    inc(sz);g[sz].u:=u;g[sz].v:=v;g[sz].f:=true;</span><br><span class="line">    g[sz].nxt:=head[u];head[u]:=sz;</span><br><span class="line"><span class="keyword">end</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">dfs</span><span class="params">(u:int)</span>:</span>boolean;</span><br><span class="line"><span class="keyword">var</span> i,v,w:int;</span><br><span class="line"><span class="keyword">begin</span></span><br><span class="line">    flg[u]:=<span class="number">1</span>;i:=head[u];</span><br><span class="line">    <span class="keyword">while</span> i&lt;&gt;<span class="number">0</span> <span class="keyword">do</span> <span class="keyword">begin</span></span><br><span class="line">        v:=g[i].v;</span><br><span class="line">        <span class="keyword">if</span> flg[v]=<span class="number">1</span> <span class="keyword">then</span> <span class="keyword">begin</span></span><br><span class="line">            w:=u;k:=<span class="number">0</span>;</span><br><span class="line">            <span class="keyword">while</span> w&lt;&gt;v <span class="keyword">do</span> <span class="keyword">begin</span></span><br><span class="line">                inc(k);cyc[k]:=w;loc[w]:=k;</span><br><span class="line">                g[edg[w]].f:=false;</span><br><span class="line">                w:=pre[w];</span><br><span class="line">            <span class="keyword">end</span>;</span><br><span class="line">            inc(k);cyc[k]:=v;loc[v]:=k;</span><br><span class="line">            edg[v]:=i;g[i].f:=false;</span><br><span class="line">            <span class="keyword">exit</span>(true);</span><br><span class="line">        <span class="keyword">end</span>;</span><br><span class="line">        <span class="keyword">if</span> flg[v]=<span class="number">0</span> <span class="keyword">then</span> <span class="keyword">begin</span></span><br><span class="line">            pre[v]:=u;edg[v]:=i;</span><br><span class="line">            <span class="keyword">if</span> dfs(v) <span class="keyword">then</span> <span class="keyword">exit</span>(true);</span><br><span class="line">        <span class="keyword">end</span>;</span><br><span class="line">        i:=g[i].nxt;</span><br><span class="line">    <span class="keyword">end</span>;</span><br><span class="line">    flg[u]:=<span class="number">2</span>;dfs:=false;</span><br><span class="line"><span class="keyword">end</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">sort</span><span class="params">()</span>:</span>boolean;</span><br><span class="line"><span class="keyword">var</span> i,u,v,h,t:int;deg:arr;</span><br><span class="line"><span class="keyword">begin</span></span><br><span class="line">    fillchar(deg,sizeof(deg),<span class="number">0</span>);t:=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> i:=<span class="number">1</span> <span class="keyword">to</span> sz <span class="keyword">do</span></span><br><span class="line">        <span class="keyword">if</span> g[i].f <span class="keyword">then</span> inc(deg[g[i].v]);</span><br><span class="line">    <span class="keyword">for</span> i:=<span class="number">1</span> <span class="keyword">to</span> n*<span class="number">2</span> <span class="keyword">do</span></span><br><span class="line">        <span class="keyword">if</span> deg[i]=<span class="number">0</span> <span class="keyword">then</span></span><br><span class="line">            <span class="keyword">begin</span> inc(t);top[t]:=i <span class="keyword">end</span>;</span><br><span class="line">    h:=<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">while</span> h&lt;=t <span class="keyword">do</span> <span class="keyword">begin</span></span><br><span class="line">        u:=top[h];inc(h);i:=head[u];</span><br><span class="line">        <span class="keyword">while</span> i&lt;&gt;<span class="number">0</span> <span class="keyword">do</span> <span class="keyword">begin</span></span><br><span class="line">            <span class="keyword">if</span> g[i].f <span class="keyword">then</span> <span class="keyword">begin</span></span><br><span class="line">                v:=g[i].v;dec(deg[v]);</span><br><span class="line">                <span class="keyword">if</span> deg[v]=<span class="number">0</span> <span class="keyword">then</span> <span class="keyword">begin</span> inc(t);top[t]:=v <span class="keyword">end</span>;</span><br><span class="line">            <span class="keyword">end</span>;</span><br><span class="line">            i:=g[i].nxt;</span><br><span class="line">        <span class="keyword">end</span>;</span><br><span class="line">    <span class="keyword">end</span>;</span><br><span class="line">    sort:=t=n*<span class="number">2</span>;</span><br><span class="line"><span class="keyword">end</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">begin</span></span><br><span class="line">    assign(input,<span class="string">'ex_reality5.in'</span>);reset(input);</span><br><span class="line">    assign(output,<span class="string">'reality.out'</span>);rewrite(output);</span><br><span class="line">    <span class="keyword">read</span>(n,m);</span><br><span class="line">    <span class="keyword">for</span> i:=<span class="number">1</span> <span class="keyword">to</span> n <span class="keyword">do</span> add(i,i+n);</span><br><span class="line">    <span class="keyword">for</span> i:=<span class="number">1</span> <span class="keyword">to</span> m <span class="keyword">do</span> <span class="keyword">begin</span> </span><br><span class="line">        <span class="keyword">read</span>(u,v);add(u+n,v);</span><br><span class="line">    <span class="keyword">end</span>;</span><br><span class="line">    <span class="keyword">for</span> i:=<span class="number">1</span> <span class="keyword">to</span> n*<span class="number">2</span> <span class="keyword">do</span></span><br><span class="line">        <span class="keyword">if</span> (flg[i]=<span class="number">0</span>) <span class="keyword">and</span> dfs(i) <span class="keyword">then</span> <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">if</span> k=<span class="number">0</span> <span class="keyword">then</span> <span class="keyword">begin</span></span><br><span class="line">        writeln(n);</span><br><span class="line">        <span class="keyword">for</span> i:=<span class="number">1</span> <span class="keyword">to</span> n <span class="keyword">do</span> <span class="keyword">write</span>(i,<span class="string">' '</span>);halt;</span><br><span class="line">    <span class="keyword">end</span>;</span><br><span class="line">    <span class="keyword">if</span> <span class="keyword">not</span> sort() <span class="keyword">then</span> <span class="keyword">begin</span> <span class="keyword">write</span>(<span class="number">0</span>);halt <span class="keyword">end</span>;</span><br><span class="line">    filldword(f1,sizeof(f1) <span class="keyword">div</span> <span class="number">4</span>,inf);</span><br><span class="line">    filldword(f3,sizeof(f3) <span class="keyword">div</span> <span class="number">4</span>,inf);</span><br><span class="line">    <span class="keyword">for</span> i:=<span class="number">1</span> <span class="keyword">to</span> n*<span class="number">2</span> <span class="keyword">do</span></span><br><span class="line">        <span class="keyword">if</span> loc[i]&gt;<span class="number">0</span> <span class="keyword">then</span></span><br><span class="line">             <span class="keyword">begin</span> f1[i]:=loc[i];f2[i]:=loc[i];f3[i]:=loc[i] <span class="keyword">end</span>;</span><br><span class="line">    <span class="keyword">for</span> j:=n*<span class="number">2</span> <span class="keyword">downto</span> <span class="number">1</span> <span class="keyword">do</span> <span class="keyword">begin</span></span><br><span class="line">        u:=top[j];i:=head[u];</span><br><span class="line">        <span class="keyword">while</span> i&lt;&gt;<span class="number">0</span> <span class="keyword">do</span> <span class="keyword">begin</span></span><br><span class="line">            v:=g[i].v;</span><br><span class="line">            <span class="keyword">if</span> g[i].f <span class="keyword">then</span> <span class="keyword">begin</span></span><br><span class="line">                f1[u]:=min(f1[u],f1[v]);</span><br><span class="line">                f2[u]:=max(f2[u],f2[v]);</span><br><span class="line">            <span class="keyword">end</span>;</span><br><span class="line">            i:=g[i].nxt;</span><br><span class="line">        <span class="keyword">end</span>;</span><br><span class="line">    <span class="keyword">end</span>;</span><br><span class="line">    <span class="keyword">for</span> j:=<span class="number">1</span> <span class="keyword">to</span> n*<span class="number">2</span> <span class="keyword">do</span> <span class="keyword">begin</span></span><br><span class="line">        u:=top[j];i:=head[u];</span><br><span class="line">        <span class="keyword">while</span> i&lt;&gt;<span class="number">0</span> <span class="keyword">do</span> <span class="keyword">begin</span></span><br><span class="line">            v:=g[i].v;</span><br><span class="line">            <span class="keyword">if</span> g[i].f <span class="keyword">then</span> f3[v]:=min(f3[u],f3[v]);</span><br><span class="line">            i:=g[i].nxt;</span><br><span class="line">        <span class="keyword">end</span>;</span><br><span class="line">    <span class="keyword">end</span>;</span><br><span class="line">    <span class="keyword">for</span> i:=<span class="number">1</span> <span class="keyword">to</span> k <span class="keyword">do</span> <span class="keyword">begin</span></span><br><span class="line">        u:=cyc[i];</span><br><span class="line">        <span class="keyword">if</span> f1[u]&lt;i <span class="keyword">then</span> <span class="keyword">begin</span> inc(a[f1[u]]);dec(a[i]) <span class="keyword">end</span>;</span><br><span class="line">        <span class="keyword">if</span> f2[u]&gt;i <span class="keyword">then</span> <span class="keyword">begin</span> inc(a[<span class="number">1</span>]);dec(a[i]) <span class="keyword">end</span>;</span><br><span class="line">        <span class="keyword">if</span> f3[u]&lt;i <span class="keyword">then</span> inc(a[i]);</span><br><span class="line">    <span class="keyword">end</span>;</span><br><span class="line">    <span class="keyword">for</span> i:=<span class="number">2</span> <span class="keyword">to</span> k <span class="keyword">do</span> inc(a[i],a[i-<span class="number">1</span>]);</span><br><span class="line">    <span class="keyword">for</span> i:=<span class="number">1</span> <span class="keyword">to</span> k <span class="keyword">do</span></span><br><span class="line">        <span class="keyword">if</span> (a[i]=<span class="number">0</span>)<span class="keyword">and</span>(cyc[i]&gt;n) <span class="keyword">then</span> flg[cyc[i]-n]:=-<span class="number">1</span>;</span><br><span class="line">    cnt:=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> i:=<span class="number">1</span> <span class="keyword">to</span> n <span class="keyword">do</span></span><br><span class="line">        <span class="keyword">if</span> flg[i]=-<span class="number">1</span> <span class="keyword">then</span> <span class="keyword">begin</span> inc(cnt);ans[cnt]:=i <span class="keyword">end</span>;</span><br><span class="line">    writeln(cnt);</span><br><span class="line">    <span class="keyword">for</span> i:=<span class="number">1</span> <span class="keyword">to</span> cnt <span class="keyword">do</span> <span class="keyword">write</span>(ans[i],<span class="string">' '</span>);</span><br><span class="line"><span class="keyword">end</span>.</span><br></pre></td></tr></table></figure><br><br></div></div>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;又一场NOIplus模拟赛。&lt;br&gt;第一题同样是暴力，pascal被卡常&lt;br&gt;第三题yy了scc+dfs，忘记判无解的情况，又是捆绑测试，然后爆0&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;订正进度(2/3)&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h1 id=&quot;P1-幻想&quot;&gt;&lt;a href=&quot;#P1-幻想&quot; class=&quot;headerlink&quot; title=&quot;P1 幻想&quot;&gt;&lt;/a&gt;P1 幻想&lt;/h1&gt;&lt;p&gt;大意：（其实是描述的片段）&lt;br&gt;给定一个不小于 2 的整数 k ,按照如下方式生成一个无限长的序列S (下标从 0 开始)。&lt;br&gt;1.初始时序列只有一个元素 S(0) = 0 。&lt;br&gt;2.对于j=1,2,…,k-1分别把当前序列的每个元素都加上j,得到新的k-1个序列。&lt;br&gt;3.把新的k-1个序列依次接在当前序列后面,得到一个长度为当前序列长度 k 倍的序列。&lt;br&gt;4.把这个序列每一项都变成其除以 k 之后的余数,并把这个序列作为新的当前序列。&lt;br&gt;5.执行无穷次操作 2-4。&lt;br&gt;给定l,r，求$\sum_{i=L}^{R}h(i)\times S_i$&lt;br&gt;其中$h(i)=\lfloor\dfrac{(i\% 20000116)^2+i+804}{233}\rfloor$&lt;br&gt;答案对$2^{32}$取模&lt;br&gt;$T≤100 ; 2≤k≤1000 ; 0≤L≤R≤10^16;\sum(R-L)≤10^8$&lt;br&gt;时限2s&lt;/p&gt;
    
    </summary>
    
      <category term="Problem Set" scheme="https://cothrax.github.io/categories/Problem-Set/"/>
    
    
      <category term="OI" scheme="https://cothrax.github.io/tags/OI/"/>
    
      <category term="DP" scheme="https://cothrax.github.io/tags/DP/"/>
    
      <category term="图论" scheme="https://cothrax.github.io/tags/%E5%9B%BE%E8%AE%BA/"/>
    
      <category term="强连通分量" scheme="https://cothrax.github.io/tags/%E5%BC%BA%E8%BF%9E%E9%80%9A%E5%88%86%E9%87%8F/"/>
    
      <category term="DFS" scheme="https://cothrax.github.io/tags/DFS/"/>
    
      <category term="数学" scheme="https://cothrax.github.io/tags/%E6%95%B0%E5%AD%A6/"/>
    
      <category term="拓扑排序" scheme="https://cothrax.github.io/tags/%E6%8B%93%E6%89%91%E6%8E%92%E5%BA%8F/"/>
    
      <category term="拆点" scheme="https://cothrax.github.io/tags/%E6%8B%86%E7%82%B9/"/>
    
  </entry>
  
  <entry>
    <title>NOIP模拟赛 2014-11-2</title>
    <link href="https://cothrax.github.io/2016/10/16/noip-2014-11-2/"/>
    <id>https://cothrax.github.io/2016/10/16/noip-2014-11-2/</id>
    <published>2016-10-16T02:19:57.000Z</published>
    <updated>2016-10-30T06:06:17.418Z</updated>
    
    <content type="html"><![CDATA[<table>
<thead>
<tr>
<th style="text-align:center">题目</th>
<th style="text-align:center">思路</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">disk</td>
<td style="text-align:center">?</td>
</tr>
<tr>
<td style="text-align:center">car</td>
<td style="text-align:center">Hash</td>
</tr>
<tr>
<td style="text-align:center">rollcall</td>
<td style="text-align:center">离线+离散化+线段树</td>
</tr>
</tbody>
</table>
<h1 id="P1-盘子序列"><a href="#P1-盘子序列" class="headerlink" title="P1 盘子序列"></a>P1 盘子序列</h1><p>有 n 个盘子。盘子被生产出来后,被按照某种顺序摞在一起。初始盘堆中如果一<br>个盘子比所有它上面的盘子都大,那么它是安全的,否则它是危险的。称初始盘堆为<br>A,另外有一个开始为空的盘堆 B。为了掩盖失误,生产商会对盘子序列做一些“处<br>理”,每次进行以下操作中的一个:(1)将 A 最上面的盘子放到 B 最上面;(2)将 B 最上<br>面的盘子给你。<br>在得到所有 n 个盘子之后,你需要判断初始盘堆里是否有危险的盘子。<br><a id="more"></a></p>
<h2 id="格式"><a href="#格式" class="headerlink" title="格式"></a>格式</h2><h3 id="输入格式"><a href="#输入格式" class="headerlink" title="输入格式"></a>输入格式</h3><p>输入文件包含多组数据(不超过 10 组)<br>每组数据的第一行为一个整数 n<br>接下来 n 个整数,第 i 个整数表示你收到的第 i 个盘子的大小</p>
<h3 id="输出格式"><a href="#输出格式" class="headerlink" title="输出格式"></a>输出格式</h3><p>对于每组数据,如果存在危险的盘子,输出”J”,否则输出”Y”</p>
<h2 id="样例"><a href="#样例" class="headerlink" title="样例"></a>样例</h2><h3 id="样例输入"><a href="#样例输入" class="headerlink" title="样例输入"></a>样例输入</h3><blockquote>
<p>3<br>2 1 3<br>3<br>3 1 2</p>
</blockquote>
<h3 id="样例输出"><a href="#样例输出" class="headerlink" title="样例输出"></a>样例输出</h3><blockquote>
<p>Y<br>J</p>
</blockquote>
<h2 id="提示​"><a href="#提示​" class="headerlink" title="提示​"></a>提示​</h2><p>20%的数据保证 n&lt;=8<br>80%的数据保证 n&lt;=1,000<br>100%的数据保证 1&lt;=n&lt;=100,000,0&lt;盘子大小&lt;1,000,000,000 且互不相等</p>
<h2 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h2><blockquote>
<p>此坑未填</p>
</blockquote>
<h1 id="P2-四轮车"><a href="#P2-四轮车" class="headerlink" title="P2 四轮车"></a>P2 四轮车</h1><p>在地图上散落着 n 个车轮,小 J 想用它们造一辆车。要求如下:</p>
<ol>
<li>一辆车需要四个车轮,且四个车轮构成一个正方形</li>
<li>车轮不能移动<br>你需要计算有多少种造车的方案(两个方案不同当且仅当所用车轮不全相同,坐<br>标相同的两个车轮视为不同车轮)<!--more-->
</li>
</ol>
<h2 id="格式-1"><a href="#格式-1" class="headerlink" title="格式"></a>格式</h2><h3 id="输入格式-1"><a href="#输入格式-1" class="headerlink" title="输入格式"></a>输入格式</h3><p>第一行一个整数 n<br>接下来 n 行,每行两个整数 x y,表示在(x,y)处有一个车轮</p>
<h3 id="输出格式-1"><a href="#输出格式-1" class="headerlink" title="输出格式"></a>输出格式</h3><p>一行一个整数,表示方案数</p>
<h2 id="样例-1"><a href="#样例-1" class="headerlink" title="样例"></a>样例</h2><h3 id="样例输入-1"><a href="#样例输入-1" class="headerlink" title="样例输入"></a>样例输入</h3><blockquote>
<p>9<br>0 0<br>1 0<br>2 0<br>0 2<br>1 2<br>2 2<br>0 1<br>1 1<br>2 1</p>
</blockquote>
<h3 id="样例输出-1"><a href="#样例输出-1" class="headerlink" title="样例输出"></a>样例输出</h3><blockquote>
<p>6</p>
</blockquote>
<h2 id="提示​-1"><a href="#提示​-1" class="headerlink" title="提示​"></a>提示​</h2><p>30%的数据保证 n ≤ 30<br>100%的数据保证 1 ≤ n ≤ 1000; |x|, |y| &lt;= 20000</p>
<h2 id="题解-1"><a href="#题解-1" class="headerlink" title="题解"></a>题解</h2><p>坐标插入hash，然后$O(N^2)$枚举，根据向量关系算出另外两点，查询hash统计答案。<br>注意点：</p>
<ol>
<li>坐标有重复</li>
<li>坐标可能为负数，慎用qword</li>
</ol>
<div><br><div class="copy"><br>    <a href="/2016/10/16/noip-2014-11-2/car.pas" title="{plain text}">{plain text}</a><br></div><br><div><br><figure class="highlight delphi"><figcaption><span>car.pas</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">uses</span> math;</span><br><span class="line"><span class="keyword">type</span> int=longint;</span><br><span class="line"><span class="keyword">const</span> z=<span class="number">1000003</span>;mx=<span class="number">20000</span>;</span><br><span class="line"><span class="keyword">var</span></span><br><span class="line">    hash,x,y:<span class="keyword">array</span>[<span class="number">0</span>..<span class="number">1010</span>] <span class="keyword">of</span> qword;</span><br><span class="line">    nxt,cnt:<span class="keyword">array</span>[<span class="number">0</span>..<span class="number">1010</span>] <span class="keyword">of</span> int;</span><br><span class="line">    head:<span class="keyword">array</span>[<span class="number">0</span>..z] <span class="keyword">of</span> int;</span><br><span class="line">    n,i,j,k,l,sz,x0,y0:int;dx,dy,ans:qword;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">procedure</span> <span class="title">insert</span><span class="params">(k:qword)</span>;</span></span><br><span class="line"><span class="keyword">var</span> i:int;</span><br><span class="line"><span class="keyword">begin</span></span><br><span class="line">    i:=k <span class="keyword">mod</span> z;</span><br><span class="line">    <span class="keyword">if</span> head[i]=<span class="number">0</span> <span class="keyword">then</span> <span class="keyword">begin</span></span><br><span class="line">        inc(sz);head[i]:=sz;hash[sz]:=k;cnt[sz]:=<span class="number">1</span>;<span class="keyword">exit</span>;</span><br><span class="line">    <span class="keyword">end</span>;</span><br><span class="line">    i:=head[i];</span><br><span class="line">    <span class="keyword">while</span> nxt[i]&lt;&gt;<span class="number">0</span> <span class="keyword">do</span> <span class="keyword">begin</span></span><br><span class="line">        <span class="keyword">if</span> hash[i]=k <span class="keyword">then</span> <span class="keyword">begin</span> inc(cnt[i]);<span class="keyword">exit</span> <span class="keyword">end</span>;</span><br><span class="line">        i:=nxt[i];</span><br><span class="line">    <span class="keyword">end</span>;</span><br><span class="line">    <span class="keyword">if</span> hash[i]=k <span class="keyword">then</span> <span class="keyword">begin</span> inc(cnt[i]);<span class="keyword">exit</span> <span class="keyword">end</span>;</span><br><span class="line">    inc(sz);nxt[i]:=sz;hash[sz]:=k;cnt[sz]:=<span class="number">1</span>;</span><br><span class="line"><span class="keyword">end</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">query</span><span class="params">(k:qword)</span>:</span>int;</span><br><span class="line"><span class="keyword">var</span> i:int;</span><br><span class="line"><span class="keyword">begin</span></span><br><span class="line">    i:=head[k <span class="keyword">mod</span> z];</span><br><span class="line">    <span class="keyword">while</span> i&lt;&gt;<span class="number">0</span> <span class="keyword">do</span> <span class="keyword">begin</span></span><br><span class="line">        <span class="keyword">if</span> hash[i]=k <span class="keyword">then</span> <span class="keyword">exit</span>(i);</span><br><span class="line">        i:=nxt[i];</span><br><span class="line">    <span class="keyword">end</span>;</span><br><span class="line">    query:=-<span class="number">1</span>;</span><br><span class="line"><span class="keyword">end</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">begin</span></span><br><span class="line">    assign(input,<span class="string">'car.in'</span>);reset(input);</span><br><span class="line">    assign(output,<span class="string">'car.out'</span>);rewrite(output);</span><br><span class="line">    <span class="keyword">read</span>(n);sz:=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> i:=<span class="number">1</span> <span class="keyword">to</span> n <span class="keyword">do</span> <span class="keyword">begin</span></span><br><span class="line">        <span class="keyword">read</span>(x0,y0);</span><br><span class="line">        x[i]:=x0+mx;y[i]:=y0+mx;</span><br><span class="line">        insert(x[i]*mx+y[i]);</span><br><span class="line">    <span class="keyword">end</span>;</span><br><span class="line">    ans:=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> i:=<span class="number">1</span> <span class="keyword">to</span> n <span class="keyword">do</span></span><br><span class="line">        <span class="keyword">for</span> j:=i+<span class="number">1</span> <span class="keyword">to</span> n <span class="keyword">do</span> <span class="keyword">begin</span></span><br><span class="line">            dx:=x[i]-x[j];dy:=y[i]-y[j];</span><br><span class="line">            k:=query((x[i]-dy)*mx+y[i]+dx);</span><br><span class="line">            l:=query((x[j]-dy)*mx+y[j]+dx);</span><br><span class="line">            <span class="keyword">if</span> min(k,l)&gt;<span class="number">0</span> <span class="keyword">then</span> inc(ans,min(cnt[k],cnt[l]));</span><br><span class="line">            k:=query((x[i]+dy)*mx+y[i]-dx);</span><br><span class="line">            l:=query((x[j]+dy)*mx+y[j]-dx);</span><br><span class="line">            <span class="keyword">if</span> min(k,l)&gt;<span class="number">0</span> <span class="keyword">then</span> inc(ans,min(cnt[k],cnt[l]));</span><br><span class="line">        <span class="keyword">end</span>;</span><br><span class="line">    <span class="keyword">write</span>(ans <span class="keyword">div</span> <span class="number">4</span>);</span><br><span class="line">    close(input);close(output);</span><br><span class="line"><span class="keyword">end</span>.</span><br></pre></td></tr></table></figure><br><br></div></div>


<h1 id="P3-点名"><a href="#P3-点名" class="headerlink" title="P3 点名"></a>P3 点名</h1><p>在 J 班的体育课上,同学们常常会迟到几分钟,<br>但体育老师的点名却一直很准时。<br>老师只关心同学的身高,他会依次询问当前最高的身高,次高的身高,第三高的身高,<br>等等。在询问的过程中,会不时地有人插进队伍里。你需要回答老师每次的询问。<br><!--more--></p>
<h2 id="格式-2"><a href="#格式-2" class="headerlink" title="格式"></a>格式</h2><h3 id="输入格式-2"><a href="#输入格式-2" class="headerlink" title="输入格式"></a>输入格式</h3><p>第一行两个整数 n m,表示先后有 n 个人进队,老师询问了 m 次<br>第二行 n 个整数,第 i 个数 Ai 表示第 i 个进入队伍的同学的身高为 Ai<br>第三行 m 个整数,第 j 个数 Bj 表示老师在第 Bj 个同学进入队伍后有一次询问</p>
<h3 id="输出格式-2"><a href="#输出格式-2" class="headerlink" title="输出格式"></a>输出格式</h3><p>m 行,每行一个整数,依次表示老师每次询问的答案。数据保证合法</p>
<h2 id="样例-2"><a href="#样例-2" class="headerlink" title="样例"></a>样例</h2><h3 id="样例输入-2"><a href="#样例输入-2" class="headerlink" title="样例输入"></a>样例输入</h3><blockquote>
<p>7 4<br>9 7 2 8 14 1 8<br>1 2 6 6</p>
</blockquote>
<h3 id="样例输出-2"><a href="#样例输出-2" class="headerlink" title="样例输出"></a>样例输出</h3><blockquote>
<p>9<br>9<br>7<br>8</p>
</blockquote>
<h2 id="提示​-2"><a href="#提示​-2" class="headerlink" title="提示​"></a>提示​</h2><p>(9){No.1 = 9}; (9 7){No.2 = 9}; (9 7 2 8 14 1){No.3 = 7; No.4 = 8}<br>40%的数据保证 n ≤ 1000<br>100%的数据保证 1 ≤ m ≤ n ≤ 30000; 0 ≤ Ai ≤ 2^32-1</p>
<h2 id="题解-2"><a href="#题解-2" class="headerlink" title="题解"></a>题解</h2><p>查询序列第k大<br>离线+离散化+线段树<br>注意数据会爆int</p>
<div><br><div class="copy"><br>    <a href="/2016/10/16/noip-2014-11-2/rollcall.pas" title="{plain text}">{plain text}</a><br></div><br><div><br><figure class="highlight delphi"><figcaption><span>rollcall.pas</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> </span><br><span class="line">    int=longint;</span><br><span class="line">    sort=<span class="keyword">array</span>[<span class="number">0</span>..<span class="number">30010</span>,<span class="number">0</span>..<span class="number">1</span>] <span class="keyword">of</span> qword;</span><br><span class="line"><span class="keyword">var</span> </span><br><span class="line">    a,q:sort;</span><br><span class="line">    b,l,ans:<span class="keyword">array</span>[<span class="number">0</span>..<span class="number">30010</span>] <span class="keyword">of</span> qword;</span><br><span class="line">    sgt:<span class="keyword">array</span>[<span class="number">0</span>..<span class="number">120010</span>] <span class="keyword">of</span> int;</span><br><span class="line">    n,m,k,lst,i:int;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">procedure</span> <span class="title">swap</span><span class="params">(<span class="keyword">var</span> a,b:qword)</span>;</span></span><br><span class="line"><span class="keyword">var</span> tmp:qword;</span><br><span class="line"><span class="keyword">begin</span> tmp:=a;a:=b;b:=tmp <span class="keyword">end</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">procedure</span> <span class="title">qsort</span><span class="params">(<span class="keyword">var</span> a:sort;l,r:int)</span>;</span></span><br><span class="line"><span class="keyword">var</span> i,j:int;x:qword;</span><br><span class="line"><span class="keyword">begin</span></span><br><span class="line">    i:=l;j:=r;x:=a[random(r-l)+l,<span class="number">0</span>];</span><br><span class="line">    <span class="keyword">repeat</span></span><br><span class="line">        <span class="keyword">while</span> a[i,<span class="number">0</span>]&lt;x <span class="keyword">do</span> inc(i);</span><br><span class="line">        <span class="keyword">while</span> a[j,<span class="number">0</span>]&gt;x <span class="keyword">do</span> dec(j);</span><br><span class="line">        <span class="keyword">if</span> i&lt;=j <span class="keyword">then</span> <span class="keyword">begin</span></span><br><span class="line">            swap(a[i,<span class="number">0</span>],a[j,<span class="number">0</span>]);swap(a[i,<span class="number">1</span>],a[j,<span class="number">1</span>]);</span><br><span class="line">            inc(i);dec(j);</span><br><span class="line">        <span class="keyword">end</span>;</span><br><span class="line">    <span class="keyword">until</span> i&gt;j;</span><br><span class="line">    <span class="keyword">if</span> i&lt;r <span class="keyword">then</span> qsort(a,i,r);</span><br><span class="line">    <span class="keyword">if</span> l&lt;j <span class="keyword">then</span> qsort(a,l,j);</span><br><span class="line"><span class="keyword">end</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">procedure</span> <span class="title">insert</span><span class="params">(i,b,e,x:int)</span>;</span></span><br><span class="line"><span class="keyword">var</span> l,r,mid:int;</span><br><span class="line"><span class="keyword">begin</span></span><br><span class="line">    <span class="keyword">if</span> b=e <span class="keyword">then</span> <span class="keyword">begin</span> inc(sgt[i]);<span class="keyword">exit</span> <span class="keyword">end</span>;</span><br><span class="line">    l:=i <span class="keyword">shl</span> <span class="number">1</span>;r:=l <span class="keyword">or</span> <span class="number">1</span>;mid:=(b+e) <span class="keyword">shr</span> <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">if</span> x&lt;=mid <span class="keyword">then</span> insert(l,b,mid,x)</span><br><span class="line">    <span class="keyword">else</span> insert(r,mid+<span class="number">1</span>,e,x);</span><br><span class="line">    sgt[i]:=sgt[l]+sgt[r];</span><br><span class="line"><span class="keyword">end</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">query</span><span class="params">(i,b,e,x:int)</span>:</span>int;</span><br><span class="line"><span class="keyword">var</span> mid,l,r:int;</span><br><span class="line"><span class="keyword">begin</span></span><br><span class="line">    <span class="keyword">if</span> b=e <span class="keyword">then</span> <span class="keyword">exit</span>(b);</span><br><span class="line">    l:=i <span class="keyword">shl</span> <span class="number">1</span>;r:=l <span class="keyword">or</span> <span class="number">1</span>;mid:=(b+e) <span class="keyword">shr</span> <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">if</span> sgt[l]&gt;=x <span class="keyword">then</span> query:=query(l,b,mid,x)</span><br><span class="line">    <span class="keyword">else</span> query:=query(r,mid+<span class="number">1</span>,e,x-sgt[l]);</span><br><span class="line"><span class="keyword">end</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">begin</span></span><br><span class="line">    assign(input,<span class="string">'rollcall.in'</span>);reset(input);</span><br><span class="line">    assign(output,<span class="string">'rollcall.out'</span>);rewrite(output);</span><br><span class="line">    <span class="keyword">read</span>(n,m);</span><br><span class="line">    <span class="keyword">for</span> i:=<span class="number">1</span> <span class="keyword">to</span> n <span class="keyword">do</span> <span class="keyword">begin</span> <span class="keyword">read</span>(a[i,<span class="number">0</span>]);a[i,<span class="number">1</span>]:=i <span class="keyword">end</span>;</span><br><span class="line">    <span class="keyword">for</span> i:=<span class="number">1</span> <span class="keyword">to</span> m <span class="keyword">do</span> <span class="keyword">begin</span> <span class="keyword">read</span>(q[i,<span class="number">0</span>]);q[i,<span class="number">1</span>]:=i <span class="keyword">end</span>;</span><br><span class="line">    qsort(a,<span class="number">1</span>,n);qsort(q,<span class="number">1</span>,m);</span><br><span class="line">    k:=<span class="number">0</span>;lst:=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> i:=<span class="number">1</span> <span class="keyword">to</span> n <span class="keyword">do</span> <span class="keyword">begin</span></span><br><span class="line">        <span class="keyword">if</span> a[i,<span class="number">0</span>]&gt;a[lst,<span class="number">0</span>] <span class="keyword">then</span> <span class="keyword">begin</span> </span><br><span class="line">            inc(k);l[k]:=a[i,<span class="number">0</span>];lst:=i;</span><br><span class="line">        <span class="keyword">end</span>;</span><br><span class="line">        b[a[i,<span class="number">1</span>]]:=k;</span><br><span class="line">    <span class="keyword">end</span>;</span><br><span class="line">    k:=<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span> i:=<span class="number">1</span> <span class="keyword">to</span> n <span class="keyword">do</span> <span class="keyword">begin</span></span><br><span class="line">        insert(<span class="number">1</span>,<span class="number">1</span>,n,b[i]);</span><br><span class="line">        <span class="keyword">while</span> q[k,<span class="number">0</span>]=i <span class="keyword">do</span> <span class="keyword">begin</span></span><br><span class="line">            ans[q[k,<span class="number">1</span>]]:=l[query(<span class="number">1</span>,<span class="number">1</span>,n,q[k,<span class="number">1</span>])];inc(k)</span><br><span class="line">        <span class="keyword">end</span>;</span><br><span class="line">    <span class="keyword">end</span>;</span><br><span class="line">    <span class="keyword">for</span> i:=<span class="number">1</span> <span class="keyword">to</span> m <span class="keyword">do</span> writeln(ans[i]);</span><br><span class="line">    close(input);close(output);</span><br><span class="line"><span class="keyword">end</span>.</span><br></pre></td></tr></table></figure><br><br></div></div>
]]></content>
    
    <summary type="html">
    
      &lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th style=&quot;text-align:center&quot;&gt;题目&lt;/th&gt;
&lt;th style=&quot;text-align:center&quot;&gt;思路&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td style=&quot;text-align:center&quot;&gt;disk&lt;/td&gt;
&lt;td style=&quot;text-align:center&quot;&gt;?&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td style=&quot;text-align:center&quot;&gt;car&lt;/td&gt;
&lt;td style=&quot;text-align:center&quot;&gt;Hash&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td style=&quot;text-align:center&quot;&gt;rollcall&lt;/td&gt;
&lt;td style=&quot;text-align:center&quot;&gt;离线+离散化+线段树&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;h1 id=&quot;P1-盘子序列&quot;&gt;&lt;a href=&quot;#P1-盘子序列&quot; class=&quot;headerlink&quot; title=&quot;P1 盘子序列&quot;&gt;&lt;/a&gt;P1 盘子序列&lt;/h1&gt;&lt;p&gt;有 n 个盘子。盘子被生产出来后,被按照某种顺序摞在一起。初始盘堆中如果一&lt;br&gt;个盘子比所有它上面的盘子都大,那么它是安全的,否则它是危险的。称初始盘堆为&lt;br&gt;A,另外有一个开始为空的盘堆 B。为了掩盖失误,生产商会对盘子序列做一些“处&lt;br&gt;理”,每次进行以下操作中的一个:(1)将 A 最上面的盘子放到 B 最上面;(2)将 B 最上&lt;br&gt;面的盘子给你。&lt;br&gt;在得到所有 n 个盘子之后,你需要判断初始盘堆里是否有危险的盘子。&lt;br&gt;
    
    </summary>
    
      <category term="Problem Set" scheme="https://cothrax.github.io/categories/Problem-Set/"/>
    
    
      <category term="OI" scheme="https://cothrax.github.io/tags/OI/"/>
    
      <category term="数据结构" scheme="https://cothrax.github.io/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"/>
    
      <category term="Hash" scheme="https://cothrax.github.io/tags/Hash/"/>
    
      <category term="线段树" scheme="https://cothrax.github.io/tags/%E7%BA%BF%E6%AE%B5%E6%A0%91/"/>
    
      <category term="离线" scheme="https://cothrax.github.io/tags/%E7%A6%BB%E7%BA%BF/"/>
    
      <category term="离散化" scheme="https://cothrax.github.io/tags/%E7%A6%BB%E6%95%A3%E5%8C%96/"/>
    
  </entry>
  
  <entry>
    <title>NOIP2016十连测 Day 4</title>
    <link href="https://cothrax.github.io/2016/10/10/lydsy-noip-2016-test4/"/>
    <id>https://cothrax.github.io/2016/10/10/lydsy-noip-2016-test4/</id>
    <published>2016-10-10T02:31:40.000Z</published>
    <updated>2016-11-03T15:40:00.906Z</updated>
    
    <content type="html"><![CDATA[<p>10-8-2016<br>NOIprofessional</p>
<blockquote>
<p>订正进度(3/3)</p>
</blockquote>
<h1 id="P1-天空龙"><a href="#P1-天空龙" class="headerlink" title="P1 天空龙"></a>P1 天空龙</h1><p>大意：给定a个红色,b个黄色,c个蓝色；现在需要至少x个红色,y个黄色和z个蓝色，可以将两种相同颜色变成另一种颜色，问是否有可行方案</p>
<a id="more"></a>
<h2 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h2><p>水题，$O(1)$统计</p>
<div><br><div class="copy"><br>    <br></div><br><div><br><figure class="highlight delphi"><figcaption><span>orisis.pas</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> int=longint;</span><br><span class="line"><span class="keyword">var</span> </span><br><span class="line">    t,i,pos,neg:int;</span><br><span class="line">    a,b:<span class="keyword">array</span>[<span class="number">0</span>..<span class="number">2</span>] <span class="keyword">of</span> int;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">procedure</span> <span class="title">solv</span><span class="params">(i,j:int)</span>;</span></span><br><span class="line"><span class="keyword">begin</span></span><br><span class="line">    <span class="keyword">if</span> i&gt;j <span class="keyword">then</span> inc(pos,(i-j) <span class="keyword">div</span> <span class="number">2</span>) <span class="keyword">else</span> inc(neg,j-i);</span><br><span class="line"><span class="keyword">end</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">begin</span></span><br><span class="line">    assign(input,<span class="string">'osiris.in'</span>);reset(input);</span><br><span class="line">    assign(output,<span class="string">'osiris.out'</span>);rewrite(output);</span><br><span class="line">    <span class="keyword">read</span>(t);</span><br><span class="line">    <span class="keyword">repeat</span></span><br><span class="line">        <span class="keyword">read</span>(a[<span class="number">0</span>],a[<span class="number">1</span>],a[<span class="number">2</span>],b[<span class="number">0</span>],b[<span class="number">1</span>],b[<span class="number">2</span>]);</span><br><span class="line">        pos:=<span class="number">0</span>;neg:=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> i:=<span class="number">0</span> <span class="keyword">to</span> <span class="number">2</span> <span class="keyword">do</span> solv(a[i],b[i]);</span><br><span class="line">        <span class="keyword">if</span> pos&gt;=neg <span class="keyword">then</span> writeln(<span class="string">'YES'</span>) <span class="keyword">else</span> writeln(<span class="string">'NO'</span>);</span><br><span class="line">        dec(t);</span><br><span class="line">    <span class="keyword">until</span> t=<span class="number">0</span>;</span><br><span class="line">    close(input);close(output);</span><br><span class="line"><span class="keyword">end</span>.</span><br></pre></td></tr></table></figure><br><br></div></div>

<h1 id="P3-巨神兵"><a href="#P3-巨神兵" class="headerlink" title="P3 巨神兵"></a>P3 巨神兵</h1><p>大意：给定n个节点、m条边的有向图，统计其无环子图的个数，子图指任意边集，答案对1000000007取模。<br>（n≤17）</p>
<h2 id="题解-1"><a href="#题解-1" class="headerlink" title="题解"></a>题解</h2><p>状压DP+容斥<br>第一次切容斥题。<br>考察DAG的性质，必定有出度为0的点<br>记f[S]为选取点集S，其中的无环子图数<br>在S的补集中选取点集k，作为出度为0的点，由f[S]转移到f[S∪k]<br>含义为点集S∪k中，点集k的出度为0的dag数<br>根据点集k容斥即可<br>转移：记S指向k的边数为p，则$f[S∪k]+=(-1)^{|k|+1}\cdot p\cdot f[S]$</p>
<div><br><div class="copy"><br>    <a href="/2016/10/10/lydsy-noip-2016-test4/obelisk.pas" title="{plain text}">{plain text}</a><br></div><br><div><br><figure class="highlight delphi"><figcaption><span>obelisk.pas</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> int=longint;</span><br><span class="line"><span class="keyword">const</span> mx=<span class="number">1</span> <span class="keyword">shl</span> <span class="number">17</span>-<span class="number">1</span>;inf:int64=<span class="number">1000000007</span>;</span><br><span class="line"><span class="keyword">var</span></span><br><span class="line">    g:<span class="keyword">array</span>[<span class="number">0</span>..<span class="number">20</span>,<span class="number">0</span>..<span class="number">20</span>] <span class="keyword">of</span> int;</span><br><span class="line">    num,b,a:<span class="keyword">array</span>[<span class="number">0</span>..mx] <span class="keyword">of</span> int;</span><br><span class="line">    f:<span class="keyword">array</span>[<span class="number">0</span>..mx] <span class="keyword">of</span> int64;</span><br><span class="line">    bin:<span class="keyword">array</span>[<span class="number">0</span>..<span class="number">400</span>] <span class="keyword">of</span> int64;</span><br><span class="line">    n,m,t,i,j,k,l,u,v,r:int;</span><br><span class="line"><span class="keyword">begin</span></span><br><span class="line">    assign(input,<span class="string">'obelisk.in'</span>);reset(input);</span><br><span class="line">    assign(output,<span class="string">'obelisk.out'</span>);rewrite(output);</span><br><span class="line">    <span class="keyword">read</span>(n,m);t:=<span class="number">1</span> <span class="keyword">shl</span> n-<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span> i:=<span class="number">1</span> <span class="keyword">to</span> m <span class="keyword">do</span> <span class="keyword">begin</span></span><br><span class="line">        <span class="keyword">read</span>(u,v);g[u,v]:=<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">end</span>;</span><br><span class="line">    bin[<span class="number">0</span>]:=<span class="number">1</span>;num[<span class="number">0</span>]:=-<span class="number">1</span>;f[<span class="number">0</span>]:=<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span> i:=<span class="number">1</span> <span class="keyword">to</span> sqr(n) <span class="keyword">do</span> bin[i]:=bin[i-<span class="number">1</span>]*<span class="number">2</span> <span class="keyword">mod</span> inf;</span><br><span class="line">    <span class="keyword">for</span> i:=<span class="number">1</span> <span class="keyword">to</span> t doa num[i]:=num[i <span class="keyword">and</span>(i-<span class="number">1</span>)]*(-<span class="number">1</span>);</span><br><span class="line">    <span class="keyword">for</span> i:=<span class="number">0</span> <span class="keyword">to</span> t-<span class="number">1</span> <span class="keyword">do</span> <span class="keyword">begin</span></span><br><span class="line">        j:=i;</span><br><span class="line">        <span class="keyword">while</span> j&gt;<span class="number">0</span> <span class="keyword">do</span> <span class="keyword">begin</span></span><br><span class="line">            k:=round(ln(j <span class="keyword">and</span> (-j))/ln(<span class="number">2</span>))+<span class="number">1</span>;</span><br><span class="line">            <span class="keyword">for</span> l:=<span class="number">1</span> <span class="keyword">to</span> n <span class="keyword">do</span> inc(a[bin[l-<span class="number">1</span>]],g[k,l]);</span><br><span class="line">            j:=j <span class="keyword">and</span>(j-<span class="number">1</span>);</span><br><span class="line">        <span class="keyword">end</span>;</span><br><span class="line">        r:=t xor i;j:=r;b[<span class="number">0</span>]:=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">repeat</span></span><br><span class="line">            j:=(j-<span class="number">1</span>)<span class="keyword">and</span> r;k:=j xor r;</span><br><span class="line">            b[k]:=b[k <span class="keyword">and</span>(k-<span class="number">1</span>)]+a[k <span class="keyword">and</span>(-k)];</span><br><span class="line">            f[i <span class="keyword">or</span> k]:=(f[i <span class="keyword">or</span> k]+num[k]*bin[b[k]]*f[i])<span class="keyword">mod</span> inf;</span><br><span class="line">        <span class="keyword">until</span> j=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> l:=<span class="number">1</span> <span class="keyword">to</span> n <span class="keyword">do</span> a[bin[l-<span class="number">1</span>]]:=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">end</span>;</span><br><span class="line">    <span class="keyword">write</span>(f[t]);</span><br><span class="line">    close(input);close(output);</span><br><span class="line"><span class="keyword">end</span>.</span><br></pre></td></tr></table></figure><br><br></div></div>

<h1 id="P3-太阳神"><a href="#P3-太阳神" class="headerlink" title="P3 太阳神"></a>P3 太阳神</h1><p>给定n，求$a,b\in N*$，$a,b\leq n$且$lcm(a,b)&gt;n$的有序对(a,b)的个数，答案对1000000007取模<br>$n\leq 10^10$</p>
<h2 id="题解-2"><a href="#题解-2" class="headerlink" title="题解"></a>题解</h2><p>答案是$\sum_{1\leq a,b\leq n}[lcm(a,b)&gt;n]=n^2-\sum_{1\leq a,b\leq n}[lcm(a,b)\leq n]$</p>
<p>记$d=gcd(a,b),k=n/d$，那么答案为$\sum_{1\leq k\leq n}\sum_{1\leq a,b\leq k}[ab\leq k][gcd(a,b)=1]$</p>
<p>则变形为$f(k)=\sum_{1\leq a,b\leq k}[ab\leq k][gcd(a,b)=1]$</p>
<p>记$f‘(k)=\sum_{1\leq a,b\leq k}[ab=k][gcd(a,b)=1]$</p>
<p>记k的不同质因数个数为$a(k)$，可以用<a href="/2016/10/30/note-euler-function/" title="线性筛">线性筛</a>筛出，则$f’(k)=2^{a(k)}$，然后求$f’(k)$的前缀和得到$f(k)$<br>因为$10^7$内的$a(k)$很小，算f(k)时不用担心炸int的情况。</p>
<p>但$O(N)$是无法通过全部数据的，考虑只筛出$10^7$以内的$f(k)$</p>
<p>其余通过迭代求值：</p>
<p>记$s(k)=\sum_{1\leq a,b\leq n}[ab\leq k]$</p>
<p>显然$f(k)=s(k)-\sum_{1&lt;t}f(k/t^2)$</p>
<p>这样，通过枚举$d$，求出相应的$f(n/d)$来算出答案</p>
<p>并不知道$O(N^{2/3})$的复杂度是怎么算的</p>
<p>小细节：</p>
<ol>
<li>由于对于$[d,\lfloor\dfrac{n}{\lfloor n/d\rfloor} \rfloor]$的$d$，$\lfloor n/d\rfloor $是定值，于是枚举的d只会有$\sqrt(n)$个</li>
<li>大于$10^7$的部分的$f(k)$要存到$g(n/k)$中，因为细节1保证$n/(n/d)$只会被算一次，$f(k)$与$g(n/k)$存在对应关系</li>
</ol>
<blockquote>
<p>听说这玩意叫杜教筛，身为noiper并看不懂tangjz的教程<br>另外留个坑，目前看不懂部分分的题解</p>
</blockquote>
<div><br><div class="copy"><br>    <a href="/2016/10/10/lydsy-noip-2016-test4/ra.pas" title="{plain text}">{plain text}</a><br></div><br><div><br><figure class="highlight delphi"><figcaption><span>ra.pas</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">uses</span> math;</span><br><span class="line"><span class="keyword">type</span> int=longint;ll=int64;</span><br><span class="line"><span class="keyword">const</span> mx=<span class="number">10000000</span>;md=<span class="number">1000000007</span>;</span><br><span class="line"><span class="keyword">var</span> </span><br><span class="line">    f,g,a,p:<span class="keyword">array</span>[<span class="number">0</span>..mx+<span class="number">5</span>] <span class="keyword">of</span> int;</span><br><span class="line">    flg:<span class="keyword">array</span>[<span class="number">0</span>..mx+<span class="number">5</span>] <span class="keyword">of</span> boolean;</span><br><span class="line">    n,i,j,ans:int64;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">procedure</span> <span class="title">siev</span><span class="params">(n:int)</span>;</span></span><br><span class="line"><span class="keyword">var</span> i,j,k,x:int;</span><br><span class="line"><span class="keyword">begin</span></span><br><span class="line">    k:=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> i:=<span class="number">2</span> <span class="keyword">to</span> n <span class="keyword">do</span> <span class="keyword">begin</span></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> flg[i] <span class="keyword">then</span> <span class="keyword">begin</span></span><br><span class="line">            inc(k);p[k]:=i;a[i]:=<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">end</span>;</span><br><span class="line">        j:=<span class="number">1</span>;x:=p[j]*i;</span><br><span class="line">        <span class="keyword">while</span> x&lt;=n <span class="keyword">do</span> <span class="keyword">begin</span></span><br><span class="line">            flg[x]:=true;</span><br><span class="line">            <span class="keyword">if</span> i <span class="keyword">mod</span> p[j]=<span class="number">0</span> <span class="keyword">then</span> </span><br><span class="line">                <span class="keyword">begin</span> a[x]:=a[i];<span class="keyword">break</span> <span class="keyword">end</span>;</span><br><span class="line">            a[x]:=a[i]+<span class="number">1</span>;</span><br><span class="line">            inc(j);x:=p[j]*i;</span><br><span class="line">        <span class="keyword">end</span>;</span><br><span class="line">    <span class="keyword">end</span>;</span><br><span class="line">    f[<span class="number">0</span>]:=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> i:=<span class="number">1</span> <span class="keyword">to</span> n <span class="keyword">do</span></span><br><span class="line">        f[i]:=(f[i-<span class="number">1</span>]+(<span class="number">1</span> <span class="keyword">shl</span> a[i]))<span class="keyword">mod</span> md;</span><br><span class="line"><span class="keyword">end</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">calc</span><span class="params">(x:int64)</span>:</span>int64;</span><br><span class="line"><span class="keyword">var</span> i,y,j:int64;</span><br><span class="line"><span class="keyword">begin</span></span><br><span class="line">    <span class="keyword">if</span> x&lt;=mx <span class="keyword">then</span> <span class="keyword">exit</span>(f[x]);</span><br><span class="line">    y:=trunc(n/x);</span><br><span class="line">    <span class="keyword">if</span> g[y]&lt;&gt;-<span class="number">1</span> <span class="keyword">then</span> <span class="keyword">exit</span>(g[y]);</span><br><span class="line">    g[y]:=<span class="number">0</span>;i:=<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">while</span> i&lt;=x <span class="keyword">do</span> <span class="keyword">begin</span></span><br><span class="line">        j:=trunc(x/trunc(x/i));</span><br><span class="line">        g[y]:=(g[y]+trunc(x/i)*(j-i+<span class="number">1</span>))<span class="keyword">mod</span> md;</span><br><span class="line">        i:=j+<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">end</span>;</span><br><span class="line">    i:=<span class="number">2</span>;</span><br><span class="line">    <span class="keyword">while</span> i*i&lt;=x <span class="keyword">do</span> <span class="keyword">begin</span></span><br><span class="line">        g[y]:=(g[y]-calc(trunc(x/(i*i)))+md)<span class="keyword">mod</span> md;</span><br><span class="line">        inc(i);</span><br><span class="line">    <span class="keyword">end</span>;</span><br><span class="line">    calc:=g[y];</span><br><span class="line"><span class="keyword">end</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">begin</span></span><br><span class="line">    assign(input,<span class="string">'ra.in'</span>);reset(input);</span><br><span class="line">    assign(output,<span class="string">'ra.out'</span>);rewrite(output);</span><br><span class="line">    fillchar(g,sizeof(g),<span class="number">255</span>);</span><br><span class="line">    <span class="keyword">read</span>(n);siev(min(n,mx));i:=<span class="number">1</span>;ans:=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span> i&lt;=n <span class="keyword">do</span> <span class="keyword">begin</span></span><br><span class="line">        j:=trunc(n/trunc(n/i));</span><br><span class="line">        ans:=(ans+calc(trunc(n/i))*(j-i+<span class="number">1</span>))<span class="keyword">mod</span> md;</span><br><span class="line">        i:=j+<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">end</span>;</span><br><span class="line">    n:=n <span class="keyword">mod</span> md;ans:=(n*n-ans+md)<span class="keyword">mod</span> md;</span><br><span class="line">    <span class="keyword">write</span>(ans);</span><br><span class="line">    close(input);close(output);</span><br><span class="line"><span class="keyword">end</span>.</span><br></pre></td></tr></table></figure><br><br></div></div>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;10-8-2016&lt;br&gt;NOIprofessional&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;订正进度(3/3)&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h1 id=&quot;P1-天空龙&quot;&gt;&lt;a href=&quot;#P1-天空龙&quot; class=&quot;headerlink&quot; title=&quot;P1 天空龙&quot;&gt;&lt;/a&gt;P1 天空龙&lt;/h1&gt;&lt;p&gt;大意：给定a个红色,b个黄色,c个蓝色；现在需要至少x个红色,y个黄色和z个蓝色，可以将两种相同颜色变成另一种颜色，问是否有可行方案&lt;/p&gt;
    
    </summary>
    
      <category term="Problem Set" scheme="https://cothrax.github.io/categories/Problem-Set/"/>
    
    
      <category term="OI" scheme="https://cothrax.github.io/tags/OI/"/>
    
      <category term="DP" scheme="https://cothrax.github.io/tags/DP/"/>
    
      <category term="图论" scheme="https://cothrax.github.io/tags/%E5%9B%BE%E8%AE%BA/"/>
    
      <category term="数论" scheme="https://cothrax.github.io/tags/%E6%95%B0%E8%AE%BA/"/>
    
      <category term="状压DP" scheme="https://cothrax.github.io/tags/%E7%8A%B6%E5%8E%8BDP/"/>
    
      <category term="容斥" scheme="https://cothrax.github.io/tags/%E5%AE%B9%E6%96%A5/"/>
    
      <category term="线性筛" scheme="https://cothrax.github.io/tags/%E7%BA%BF%E6%80%A7%E7%AD%9B/"/>
    
  </entry>
  
  <entry>
    <title>NOIP2016十连测 Day 3</title>
    <link href="https://cothrax.github.io/2016/10/09/lydsy-noip-2016-test3/"/>
    <id>https://cothrax.github.io/2016/10/09/lydsy-noip-2016-test3/</id>
    <published>2016-10-09T12:47:52.000Z</published>
    <updated>2016-10-30T06:06:17.077Z</updated>
    
    <content type="html"><![CDATA[<p>10-7-2016<br>白天月考，晚上noip（NOIplus）模拟赛</p>
<h1 id="P1-平均数"><a href="#P1-平均数" class="headerlink" title="P1 平均数"></a>P1 平均数</h1><p>大意：给定一个长度为n的序列，求所有连续子序列的平均值中，第k小的那个值<br>n≤100000,k≤n*(n+1)/2<br><a id="more"></a></p>
<h2 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h2><p>二分答案x，判断序列中平均值小于x的区间个数为k-1<br>将原序列a的值都减去x后，就便成了区间和小于0的区间个数<br>对这个序列做前缀和，答案就变成的前缀数组中的逆序对数<br>然后归并排序求逆序对</p>
<div><br><div class="copy"><br>    <a href="/2016/10/09/lydsy-noip-2016-test3/ave.pas" title="{plain text}">{plain text}</a><br></div><br><div><br><figure class="highlight delphi"><figcaption><span>ave.pas</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">uses</span> math;</span><br><span class="line"><span class="keyword">type</span> int=longint;</span><br><span class="line"><span class="keyword">var</span></span><br><span class="line">    a,b,c:<span class="keyword">array</span>[<span class="number">0</span>..<span class="number">100010</span>] <span class="keyword">of</span> double;</span><br><span class="line">    n,i:int;l,r,mid:double;m,cnt:int64;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">procedure</span> <span class="title">merge</span><span class="params">(l,r:int)</span>;</span></span><br><span class="line"><span class="keyword">var</span> mid,p,q:int;</span><br><span class="line"><span class="keyword">begin</span></span><br><span class="line">    <span class="keyword">if</span> l=r <span class="keyword">then</span> <span class="keyword">exit</span>;</span><br><span class="line">    mid:=(l+r) <span class="keyword">shr</span> <span class="number">1</span>;</span><br><span class="line">    merge(l,mid);merge(mid+<span class="number">1</span>,r);</span><br><span class="line">    p:=l;q:=mid+<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span> i:=l <span class="keyword">to</span> r <span class="keyword">do</span></span><br><span class="line">        <span class="keyword">if</span> (p&gt;mid) <span class="keyword">or</span> ((q&lt;=r) <span class="keyword">and</span> (b[q]&lt;b[p])) <span class="keyword">then</span> <span class="keyword">begin</span></span><br><span class="line">            c[i]:=b[q];inc(cnt,mid-p+<span class="number">1</span>);inc(q)</span><br><span class="line">        <span class="keyword">end</span> <span class="keyword">else</span> <span class="keyword">begin</span></span><br><span class="line">            c[i]:=b[p];inc(p)</span><br><span class="line">        <span class="keyword">end</span>;</span><br><span class="line">    <span class="keyword">for</span> i:=l <span class="keyword">to</span> r <span class="keyword">do</span> b[i]:=c[i];</span><br><span class="line"><span class="keyword">end</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">jud</span><span class="params">(x:double)</span>:</span>boolean;</span><br><span class="line"><span class="keyword">var</span> i:int;</span><br><span class="line"><span class="keyword">begin</span></span><br><span class="line">    b[<span class="number">0</span>]:=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> i:=<span class="number">1</span> <span class="keyword">to</span> n <span class="keyword">do</span> b[i]:=a[i]-x+b[i-<span class="number">1</span>];</span><br><span class="line">    cnt:=<span class="number">0</span>;merge(<span class="number">0</span>,n);jud:=cnt&gt;=m;</span><br><span class="line"><span class="keyword">end</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">begin</span></span><br><span class="line">    <span class="keyword">read</span>(n,m);l:=maxlongint;r:=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> i:=<span class="number">1</span> <span class="keyword">to</span> n <span class="keyword">do</span> <span class="keyword">begin</span></span><br><span class="line">        <span class="keyword">read</span>(a[i]);</span><br><span class="line">        l:=min(a[i],l);r:=max(a[i],r);</span><br><span class="line">    <span class="keyword">end</span>;</span><br><span class="line">    <span class="keyword">while</span> r-l&gt;<span class="number">0.000001</span> <span class="keyword">do</span> <span class="keyword">begin</span></span><br><span class="line">        mid:=(l+r)/<span class="number">2</span>;</span><br><span class="line">        <span class="keyword">if</span> jud(mid) <span class="keyword">then</span> r:=mid <span class="keyword">else</span> l:=mid;</span><br><span class="line">    <span class="keyword">end</span>;</span><br><span class="line">    <span class="keyword">write</span>(l:<span class="number">0</span>:<span class="number">4</span>);</span><br><span class="line"><span class="keyword">end</span>.</span><br></pre></td></tr></table></figure><br><br></div></div>

<h1 id="P2-涂色游戏"><a href="#P2-涂色游戏" class="headerlink" title="P2 涂色游戏"></a>P2 涂色游戏</h1><p>大意：用p中颜色涂n行m列的格子，定义合法方案为：任意相邻两列都出现了至少q种颜色。求合法方案数mod 998244353。<br>n≤100,m≤10^9 ,q≤p≤100</p>
<h2 id="题解-1"><a href="#题解-1" class="headerlink" title="题解"></a>题解</h2><p>统计方案当然是dp，看到m的范围果断矩阵快速幂。<br>然后是一堆恶心的组合数学<br>一些细节：</p>
<ol>
<li>递推矩阵的幂指数是m-1</li>
<li>快速幂要特判矩阵是否为<strong>零矩阵</strong></li>
<li>涉及除法要算逆元，由于模数m是素数，费马小定理得i模m的逆元为$i^{m-2}\% m$，逆元还有一个通用求法$\dfrac{a}{b}\% m=a\% (bm)/b$，但要求$b|a$所以这里不行</li>
<li>涉及三个数乘法时小心溢出</li>
<li>int64常数很大，换成qword会快一些</li>
</ol>
<div><br><div class="copy"><br>    <a href="/2016/10/09/lydsy-noip-2016-test3/color.pas" title="{plain text}">{plain text}</a><br></div><br><div><br><figure class="highlight delphi"><figcaption><span>color.pas</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">uses</span> math;</span><br><span class="line"><span class="keyword">const</span> md:qword=<span class="number">998244353</span>;</span><br><span class="line"><span class="keyword">type</span> </span><br><span class="line">    int=longint;</span><br><span class="line">    mat=<span class="keyword">array</span>[-<span class="number">1</span>..<span class="number">110</span>,-<span class="number">1</span>..<span class="number">110</span>] <span class="keyword">of</span> qword;</span><br><span class="line"><span class="keyword">var</span> </span><br><span class="line">    f,c,a:mat;</span><br><span class="line">    g:<span class="keyword">array</span>[-<span class="number">1</span>..<span class="number">110</span>] <span class="keyword">of</span> qword;</span><br><span class="line">    n,p,q,i,j,k:int;ans,m:qword;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">mul</span><span class="params">(a,b:mat)</span>:</span>mat;</span><br><span class="line"><span class="keyword">var</span> i,j,k:int;</span><br><span class="line"><span class="keyword">begin</span></span><br><span class="line">    fillchar(mul,sizeof(mul),<span class="number">0</span>);</span><br><span class="line">    <span class="keyword">for</span> i:=<span class="number">1</span> <span class="keyword">to</span> p <span class="keyword">do</span></span><br><span class="line">        <span class="keyword">for</span> j:=<span class="number">1</span> <span class="keyword">to</span> p <span class="keyword">do</span></span><br><span class="line">            <span class="keyword">for</span> k:=<span class="number">1</span> <span class="keyword">to</span> p <span class="keyword">do</span></span><br><span class="line">                mul[i,j]:=(mul[i,j]+a[i,k]*b[k,j])<span class="keyword">mod</span> md;</span><br><span class="line"><span class="keyword">end</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">mpow</span><span class="params">(a:mat;k:qword)</span>:</span>mat;</span><br><span class="line"><span class="keyword">var</span> i:int;is0:boolean;</span><br><span class="line"><span class="keyword">begin</span></span><br><span class="line">    fillchar(mpow,sizeof(mpow),<span class="number">0</span>);</span><br><span class="line">    is0:=true;</span><br><span class="line">    <span class="keyword">for</span> i:=<span class="number">1</span> <span class="keyword">to</span> p <span class="keyword">do</span> <span class="keyword">for</span> j:=<span class="number">1</span> <span class="keyword">to</span> p <span class="keyword">do</span> is0:=is0 <span class="keyword">and</span> (a[i,j]=<span class="number">0</span>);</span><br><span class="line">    <span class="keyword">if</span> is0 <span class="keyword">then</span> <span class="keyword">exit</span>;</span><br><span class="line">    <span class="keyword">for</span> i:=<span class="number">1</span> <span class="keyword">to</span> p <span class="keyword">do</span> mpow[i,i]:=<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">while</span> k&gt;<span class="number">0</span> <span class="keyword">do</span> <span class="keyword">begin</span></span><br><span class="line">        <span class="keyword">if</span> k <span class="keyword">and</span> <span class="number">1</span>=<span class="number">1</span> <span class="keyword">then</span> mpow:=mul(mpow,a);</span><br><span class="line">        a:=mul(a,a);k:=k <span class="keyword">shr</span> <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">end</span>;</span><br><span class="line"><span class="keyword">end</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">ipow</span><span class="params">(a,k:qword)</span>:</span>qword;</span><br><span class="line"><span class="keyword">begin</span></span><br><span class="line">    <span class="keyword">if</span> a=<span class="number">0</span> <span class="keyword">then</span> <span class="keyword">exit</span>(<span class="number">0</span>);</span><br><span class="line">    ipow:=<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">while</span> k&gt;<span class="number">0</span> <span class="keyword">do</span> <span class="keyword">begin</span></span><br><span class="line">        <span class="keyword">if</span> k <span class="keyword">and</span> <span class="number">1</span>=<span class="number">1</span> <span class="keyword">then</span> ipow:=ipow*a <span class="keyword">mod</span> md;</span><br><span class="line">        a:=a*a <span class="keyword">mod</span> md;k:=k <span class="keyword">shr</span> <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">end</span>;</span><br><span class="line"><span class="keyword">end</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">begin</span></span><br><span class="line">    <span class="comment">//assign(input,'color.in');reset(input);</span></span><br><span class="line">    <span class="comment">//assign(output,'color.ans');rewrite(output);</span></span><br><span class="line">    <span class="keyword">read</span>(n,m,p,q);</span><br><span class="line">    f[<span class="number">0</span>,<span class="number">0</span>]:=<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span> i:=<span class="number">1</span> <span class="keyword">to</span> n <span class="keyword">do</span></span><br><span class="line">        <span class="keyword">for</span> j:=<span class="number">1</span> <span class="keyword">to</span> p <span class="keyword">do</span></span><br><span class="line">            f[i,j]:=(f[i-<span class="number">1</span>,j-<span class="number">1</span>]*(p-j+<span class="number">1</span>)+f[i-<span class="number">1</span>,j]*j)<span class="keyword">mod</span> md;</span><br><span class="line">    c[<span class="number">0</span>,<span class="number">0</span>]:=<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span> i:=<span class="number">1</span> <span class="keyword">to</span> p <span class="keyword">do</span></span><br><span class="line">        <span class="keyword">for</span> j:=<span class="number">0</span> <span class="keyword">to</span> i <span class="keyword">do</span></span><br><span class="line">            c[i,j]:=(c[i-<span class="number">1</span>,j]+c[i-<span class="number">1</span>,j-<span class="number">1</span>])<span class="keyword">mod</span> md;</span><br><span class="line">    <span class="keyword">for</span> i:=<span class="number">1</span> <span class="keyword">to</span> p <span class="keyword">do</span> g[i]:=f[n,i]*ipow(c[p,i],md-<span class="number">2</span>)<span class="keyword">mod</span> md;</span><br><span class="line">    <span class="keyword">for</span> i:=<span class="number">1</span> <span class="keyword">to</span> p <span class="keyword">do</span></span><br><span class="line">        <span class="keyword">for</span> j:=<span class="number">1</span> <span class="keyword">to</span> p <span class="keyword">do</span></span><br><span class="line">            <span class="keyword">for</span> k:=max(max(i,j),q) <span class="keyword">to</span> min(n,p) <span class="keyword">do</span></span><br><span class="line">                a[i,j]:=(a[i,j]+c[i,i+j-k]*</span><br><span class="line">                    (c[p-i,k-i]*g[j]<span class="keyword">mod</span> md))<span class="keyword">mod</span> md;</span><br><span class="line">    a:=mpow(a,m-<span class="number">1</span>);</span><br><span class="line">    ans:=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> i:=<span class="number">1</span> <span class="keyword">to</span> p <span class="keyword">do</span></span><br><span class="line">        <span class="keyword">for</span> j:=<span class="number">1</span> <span class="keyword">to</span> p <span class="keyword">do</span></span><br><span class="line">            ans:=(ans+a[i,j]*f[n,i])<span class="keyword">mod</span> md;</span><br><span class="line">    <span class="keyword">write</span>(ans);</span><br><span class="line">    <span class="comment">//close(input);close(output);</span></span><br><span class="line"><span class="keyword">end</span>.</span><br></pre></td></tr></table></figure><br><br></div></div>

<h1 id="P3-序列"><a href="#P3-序列" class="headerlink" title="P3 序列"></a>P3 序列</h1><p>大意：<br>给定长度n的序列，有m个询问，每个询问答案为区间[l,r]内不小于k的数的个数。<br>有q次修改，将位置p上的数改成v，对于每次修改后，输出所有询问的答案之和。强制在线<br>n,m,q≤100000,序列中的数(包括修改后的)均为正数且不超过n</p>
<h2 id="题解-2"><a href="#题解-2" class="headerlink" title="题解"></a>题解</h2><p>考虑每个数x对答案的贡献=$x\in [l,r]$且$k≤x$的询问数<br>对于每次单点修改，重新统计该点的答案即可<br>这个用主席树就好<br>将每个询问区间拆成左右两个端点，分别建树<br>对于前缀1..i的线段树，维护落在1..i的端点信息<br>一个线段[l,r]保存 查询值k落在该区间内的端点个数</p>
<p>然后对于序列中的一个数a[i]，它的贡献为：<br>左端点落在1..i的查询数-右端点落在1..i-1的查询数</p>
<p>端点的数据要预处理一下，用链表就可以了</p>
<div><br><div class="copy"><br>    <a href="/2016/10/09/lydsy-noip-2016-test3/seq.pas" title="{plain text}">{plain text}</a><br></div><br><div><br><figure class="highlight delphi"><figcaption><span>seq.pas</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> </span><br><span class="line">    int=longint;</span><br><span class="line">    arr=<span class="keyword">array</span>[<span class="number">0</span>..<span class="number">100010</span>] <span class="keyword">of</span> int;</span><br><span class="line"><span class="keyword">var</span> </span><br><span class="line">    tr:<span class="keyword">array</span>[<span class="number">0</span>..<span class="number">4001000</span>] <span class="keyword">of</span> <span class="keyword">record</span> lc,rc,w:int <span class="keyword">end</span>;</span><br><span class="line">    lk:<span class="keyword">array</span>[<span class="number">0</span>..<span class="number">400010</span>] <span class="keyword">of</span> <span class="keyword">record</span> w,nxt:int <span class="keyword">end</span>;</span><br><span class="line">    cnt:<span class="keyword">array</span>[<span class="number">0</span>..<span class="number">100010</span>] <span class="keyword">of</span> int64;</span><br><span class="line">    a,rt1,rt2,hd1,hd2:arr;</span><br><span class="line">    st,sl,n,m,q,i,j,l0,r0,x:int;ans:int64;</span><br><span class="line">    </span><br><span class="line"><span class="function"><span class="keyword">procedure</span> <span class="title">update</span><span class="params">(<span class="keyword">var</span> i:int;l,r,x:int)</span>;</span></span><br><span class="line"><span class="keyword">var</span> mid:int;</span><br><span class="line"><span class="keyword">begin</span></span><br><span class="line">    inc(st);tr[st]:=tr[i];i:=st;inc(tr[i].w);</span><br><span class="line">    <span class="keyword">if</span> l=r <span class="keyword">then</span> <span class="keyword">exit</span>;</span><br><span class="line">    mid:=(l+r) <span class="keyword">shr</span> <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">if</span> x&lt;=mid <span class="keyword">then</span> update(tr[i].lc,l,mid,x)</span><br><span class="line">    <span class="keyword">else</span> update(tr[i].rc,mid+<span class="number">1</span>,r,x);</span><br><span class="line"><span class="keyword">end</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">query</span><span class="params">(i,l,r,x:int)</span>:</span>int;</span><br><span class="line"><span class="keyword">var</span> mid:int;</span><br><span class="line"><span class="keyword">begin</span></span><br><span class="line">    <span class="keyword">if</span> r&lt;=x <span class="keyword">then</span> <span class="keyword">exit</span>(tr[i].w);</span><br><span class="line">    mid:=(l+r) <span class="keyword">shr</span> <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">if</span> x&lt;=mid <span class="keyword">then</span> query:=query(tr[i].lc,l,mid,x)</span><br><span class="line">    <span class="keyword">else</span> query:=query(tr[i].rc,mid+<span class="number">1</span>,r,x)+tr[tr[i].lc].w;</span><br><span class="line"><span class="keyword">end</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">calc</span><span class="params">(i,x:int)</span>:</span>int;</span><br><span class="line"><span class="keyword">begin</span></span><br><span class="line">    calc:=query(rt1[i],<span class="number">1</span>,n,x)-query(rt2[i],<span class="number">1</span>,n,x);</span><br><span class="line"><span class="keyword">end</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">procedure</span> <span class="title">insert</span><span class="params">(<span class="keyword">var</span> hd:arr;i,x:int)</span>;</span></span><br><span class="line"><span class="keyword">begin</span></span><br><span class="line">    inc(sl);lk[sl].w:=x;</span><br><span class="line">    lk[sl].nxt:=hd[i];hd[i]:=sl;</span><br><span class="line"><span class="keyword">end</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">procedure</span> <span class="title">init</span><span class="params">(<span class="keyword">var</span> hd,rt:arr;j:int)</span>;</span></span><br><span class="line"><span class="keyword">var</span> i:int;</span><br><span class="line"><span class="keyword">begin</span></span><br><span class="line">    rt[j]:=rt[j-<span class="number">1</span>];i:=hd[j];</span><br><span class="line">    <span class="keyword">while</span> i&lt;&gt;<span class="number">0</span> <span class="keyword">do</span> <span class="keyword">begin</span></span><br><span class="line">        update(rt[j],<span class="number">1</span>,n,lk[i].w);i:=lk[i].nxt;</span><br><span class="line">    <span class="keyword">end</span>;</span><br><span class="line"><span class="keyword">end</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">begin</span></span><br><span class="line">    assign(input,<span class="string">'seq.in'</span>);reset(input);</span><br><span class="line">    assign(output,<span class="string">'seq.out'</span>);rewrite(output);</span><br><span class="line">    <span class="keyword">read</span>(n,m,q);sl:=<span class="number">0</span>;st:=<span class="number">0</span>;ans:=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> i:=<span class="number">1</span> <span class="keyword">to</span> n <span class="keyword">do</span> <span class="keyword">read</span>(a[i]);</span><br><span class="line">    <span class="keyword">for</span> i:=<span class="number">1</span> <span class="keyword">to</span> m <span class="keyword">do</span> <span class="keyword">begin</span></span><br><span class="line">        <span class="keyword">read</span>(l0,r0,x);insert(hd1,l0,x);</span><br><span class="line">        <span class="keyword">if</span> r0&lt;n <span class="keyword">then</span> insert(hd2,r0+<span class="number">1</span>,x);</span><br><span class="line">    <span class="keyword">end</span>;</span><br><span class="line">    <span class="keyword">for</span> i:=<span class="number">1</span> <span class="keyword">to</span> n <span class="keyword">do</span> <span class="keyword">begin</span></span><br><span class="line">        init(hd1,rt1,i);init(hd2,rt2,i)</span><br><span class="line">    <span class="keyword">end</span>;</span><br><span class="line">    <span class="keyword">for</span> i:=<span class="number">1</span> <span class="keyword">to</span> n <span class="keyword">do</span> <span class="keyword">begin</span></span><br><span class="line">        cnt[i]:=calc(i,a[i]);inc(ans,cnt[i]);</span><br><span class="line">    <span class="keyword">end</span>;</span><br><span class="line">    <span class="keyword">for</span> i:=<span class="number">1</span> <span class="keyword">to</span> q <span class="keyword">do</span> <span class="keyword">begin</span></span><br><span class="line">        writeln(ans);<span class="keyword">read</span>(j,x);</span><br><span class="line">        j:=j xor ans;x:=x xor ans;</span><br><span class="line">        dec(ans,cnt[j]);cnt[j]:=calc(j,x);inc(ans,cnt[j]);</span><br><span class="line">    <span class="keyword">end</span>;</span><br><span class="line">    <span class="keyword">write</span>(ans);</span><br><span class="line">    close(input);close(output);</span><br><span class="line"><span class="keyword">end</span>.</span><br></pre></td></tr></table></figure><br><br></div></div>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;10-7-2016&lt;br&gt;白天月考，晚上noip（NOIplus）模拟赛&lt;/p&gt;
&lt;h1 id=&quot;P1-平均数&quot;&gt;&lt;a href=&quot;#P1-平均数&quot; class=&quot;headerlink&quot; title=&quot;P1 平均数&quot;&gt;&lt;/a&gt;P1 平均数&lt;/h1&gt;&lt;p&gt;大意：给定一个长度为n的序列，求所有连续子序列的平均值中，第k小的那个值&lt;br&gt;n≤100000,k≤n*(n+1)/2&lt;br&gt;
    
    </summary>
    
      <category term="Problem Set" scheme="https://cothrax.github.io/categories/Problem-Set/"/>
    
    
      <category term="OI" scheme="https://cothrax.github.io/tags/OI/"/>
    
      <category term="数据结构" scheme="https://cothrax.github.io/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"/>
    
      <category term="DP" scheme="https://cothrax.github.io/tags/DP/"/>
    
      <category term="二分答案" scheme="https://cothrax.github.io/tags/%E4%BA%8C%E5%88%86%E7%AD%94%E6%A1%88/"/>
    
      <category term="数论" scheme="https://cothrax.github.io/tags/%E6%95%B0%E8%AE%BA/"/>
    
      <category term="乘法逆元" scheme="https://cothrax.github.io/tags/%E4%B9%98%E6%B3%95%E9%80%86%E5%85%83/"/>
    
      <category term="组合数学" scheme="https://cothrax.github.io/tags/%E7%BB%84%E5%90%88%E6%95%B0%E5%AD%A6/"/>
    
      <category term="数学" scheme="https://cothrax.github.io/tags/%E6%95%B0%E5%AD%A6/"/>
    
      <category term="矩阵" scheme="https://cothrax.github.io/tags/%E7%9F%A9%E9%98%B5/"/>
    
      <category term="分治" scheme="https://cothrax.github.io/tags/%E5%88%86%E6%B2%BB/"/>
    
      <category term="主席树" scheme="https://cothrax.github.io/tags/%E4%B8%BB%E5%B8%AD%E6%A0%91/"/>
    
  </entry>
  
  <entry>
    <title>NOIP模拟赛 2014-10-29</title>
    <link href="https://cothrax.github.io/2016/10/04/noip-2014-10-29/"/>
    <id>https://cothrax.github.io/2016/10/04/noip-2014-10-29/</id>
    <published>2016-10-04T14:48:48.000Z</published>
    <updated>2016-10-30T06:06:17.288Z</updated>
    
    <content type="html"><![CDATA[<p>P2裸的折半枚举没有写</p>
<table>
<thead>
<tr>
<th style="text-align:center">题目</th>
<th style="text-align:center">思路</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">cowids</td>
<td style="text-align:center">DP+回溯</td>
</tr>
<tr>
<td style="text-align:center">senso</td>
<td style="text-align:center">树形DP</td>
</tr>
</tbody>
</table>
<h1 id="P1-奶牛编号"><a href="#P1-奶牛编号" class="headerlink" title="P1 奶牛编号"></a>P1 奶牛编号</h1><p>作为一个神秘的电脑高手，Farmer John 用二进制数字标识他的奶牛。<br>然而，他有点迷信，标识奶牛用的二进制数字，必须只含有K位“1”<br>(1 &lt;= K &lt;= 10)。 当然，每个标识数字的首位必须为“1”。<br>FJ按递增的顺序，安排标识数字，开始是最小可行的标识数字<br>（由“1”组成的一个K位数）。<br>不幸的是，他没有记录下标识数字。请帮他计算，第N个标识数字<br>(1 &lt;= N &lt;= 10^7)。<br><a id="more"></a></p>
<h2 id="格式"><a href="#格式" class="headerlink" title="格式"></a>格式</h2><h3 id="输入格式"><a href="#输入格式" class="headerlink" title="输入格式"></a>输入格式</h3><p>空格隔开的两个整数，N和K。</p>
<h3 id="输出格式"><a href="#输出格式" class="headerlink" title="输出格式"></a>输出格式</h3><p>如题，第N个标识数字</p>
<h2 id="样例"><a href="#样例" class="headerlink" title="样例"></a>样例</h2><h3 id="样例输入"><a href="#样例输入" class="headerlink" title="样例输入"></a>样例输入</h3><blockquote>
<p>7 3</p>
</blockquote>
<h3 id="样例输出"><a href="#样例输出" class="headerlink" title="样例输出"></a>样例输出</h3><blockquote>
<p>10110</p>
</blockquote>
<h2 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h2><p>dp统计方案数，然后回溯找答案<br>懒了不想码了<br><a href="http://haizs.com/simu2014-10-29b/" target="_blank" rel="external">http://haizs.com/simu2014-10-29b/</a></p>
<div><br><div class="copy"><br>    <a href="/2016/10/04/noip-2014-10-29/cowids.cpp" title="{plain text}">{plain text}</a><br></div><br><div><br><figure class="highlight cpp"><figcaption><span>cowids.cpp</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">5e3</span>, INF = <span class="number">1e7</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> n, m, f[N + <span class="number">1</span>][<span class="number">11</span>];</span><br><span class="line"><span class="keyword">bool</span> flag;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Dfs</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> y, <span class="keyword">int</span> step)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (step == <span class="number">0</span>) <span class="keyword">return</span> ;</span><br><span class="line">    <span class="keyword">if</span> (f[step - <span class="number">1</span>][y] &gt;= x) &#123;</span><br><span class="line">        <span class="keyword">if</span> (flag) <span class="built_in">putchar</span>(<span class="string">'0'</span>);</span><br><span class="line">        Dfs(x, y, step - <span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="built_in">putchar</span>(<span class="string">'1'</span>); flag = <span class="number">1</span>;</span><br><span class="line">        Dfs(x - f[step - <span class="number">1</span>][y], y - <span class="number">1</span>, step - <span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> ;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    freopen(<span class="string">"cowids.in"</span>, <span class="string">"r"</span>, <span class="built_in">stdin</span>);</span><br><span class="line">    freopen(<span class="string">"cowids.out"</span>, <span class="string">"w"</span>, <span class="built_in">stdout</span>);</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">"%d%d"</span>, &amp;n, &amp;m);</span><br><span class="line">    <span class="keyword">if</span> (m == <span class="number">1</span>) &#123;</span><br><span class="line">        <span class="built_in">putchar</span>(<span class="string">'1'</span>);</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; n; ++i)</span><br><span class="line">            <span class="built_in">putchar</span>(<span class="string">'0'</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt;= N; ++i)</span><br><span class="line">            f[i][<span class="number">0</span>] = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= N; ++i)</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">1</span>; j &lt;= m; ++j)</span><br><span class="line">                f[i][j] = min(INF, f[i - <span class="number">1</span>][j] + f[i - <span class="number">1</span>][j - <span class="number">1</span>]);</span><br><span class="line">        Dfs(n, m, N);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">puts</span>(<span class="string">""</span>);</span><br><span class="line">    fclose(<span class="built_in">stdin</span>);fclose(<span class="built_in">stdout</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br><br></div></div>

<h1 id="P3-宠物大战"><a href="#P3-宠物大战" class="headerlink" title="P3 宠物大战"></a>P3 宠物大战</h1><p>众所周知，moreD的宠物已经被moreD奴役得体无完肤。这只宠物实在忍无可忍，把自己每天走魔法树的经历告诉了自己的宠物。同时他还说明了自己爬树是多么地慢，以至于moreD每天都残酷地训练他爬树。<br>幸运的是moreD的宠物的宠物不是moreD的宠物，moreD的宠物深知”宠物是用来宠的而不是用来奴役的”这一点，所以moreD的宠物 对待自己的宠物很有爱。所以moreD的宠物与其宠物商量着要推翻moreD的暴政，方法是把moreD告上法庭，就以自己每天被迫爬树来做证据。<br>由于魔法树是树，训练树当然也是树啦。<br>moreD的训练有着GX的文化，每天moreD会把自己的宠物通灵到树的一个端点上，这个通灵点可能与之前的通灵点相同。然后moreD命令他的宠物从这个点开始走，让这只宠物随便访问自己该天之前没有访问过的节点，一直走到该天无路可走，训练才会结束，宠物才可以休息。<br>moreD的宠物每天都会在这棵树上训练，幸运的是他每天走过的训练路径都不同，直到若干天后，所有可能的训练路径都被走遍了。<br>你，作为moreD宠物的宠物，一只被moreD的宠物宠着的宠物，当然想帮moreD的宠物算出他总共走过的路径长度啦。<br><!--more--></p>
<h2 id="格式-1"><a href="#格式-1" class="headerlink" title="格式"></a>格式</h2><h3 id="输入格式-1"><a href="#输入格式-1" class="headerlink" title="输入格式"></a>输入格式</h3><p>第一行包含两个正整数N,M，表示树的点数与边数。<br>接下来M行，每行三个正整数表示Li,bi,ci分别表示树上有一条长度为Li的连接bi,ci两个结点的边。</p>
<h3 id="输出格式-1"><a href="#输出格式-1" class="headerlink" title="输出格式"></a>输出格式</h3><p>仅一行表示答案</p>
<h2 id="样例-1"><a href="#样例-1" class="headerlink" title="样例"></a>样例</h2><h3 id="样例输入-1"><a href="#样例输入-1" class="headerlink" title="样例输入"></a>样例输入</h3><blockquote>
<p>5 4<br>1 2 1<br>1 3 1<br>2 4 2<br>2 5 2</p>
</blockquote>
<h3 id="样例输出-1"><a href="#样例输出-1" class="headerlink" title="样例输出"></a>样例输出</h3><blockquote>
<p>37</p>
</blockquote>
<h2 id="提示​"><a href="#提示​" class="headerlink" title="提示​"></a>提示​</h2><p>【数据范围】<br>对于30%的数据N≤300<br>对于70%的数据N≤3,000<br>对于100%的数据对于所有输入的整数均不大于100,000，输入的树保证连通，无重边，无自环。</p>
<p>可能的训练路径有(1-2-4),(1-2-5),(1-3),(2-4),(2-5),(2-1-3),(3-1-2-4),(3-1-2-5)<br>(4-2-5),(4-2-1-3),(5-2-4),(5-2-1-3)<br>长度依次为3，3，1，2，2，2，4，4，4，4，4，4。和为37.</p>
<h2 id="题解-1"><a href="#题解-1" class="headerlink" title="题解"></a>题解</h2><p>大意：在一棵树上，统计满足从任意一点到达一个叶节点的路径条数<br>树形DP啦，直接做的话各种分类码了半天没码对，如果想看可以去这里：<a href="http://hzwer.com/4888.html" target="_blank" rel="external">http://hzwer.com/4888.html</a><br>标程的思路很神：<br>考虑一条边e(u,v)对答案的贡献<br>一条边被计算的次数是这条边分开的两棵子树中左边的节点数乘右边的叶子数加上右边的节点数乘左边的叶子数。<br>遍历两次统计即可。</p>
<div><br><div class="copy"><br>    <a href="/2016/10/04/noip-2014-10-29/senso.pas" title="{plain text}">{plain text}</a><br></div><br><div><br><figure class="highlight delphi"><figcaption><span>senso.pas</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> </span><br><span class="line">    int=longint;</span><br><span class="line">    edge=<span class="keyword">record</span> v,next:int;w:int64 <span class="keyword">end</span>;</span><br><span class="line"><span class="keyword">var</span></span><br><span class="line">    g:<span class="keyword">array</span>[<span class="number">0</span>..<span class="number">6010</span>] <span class="keyword">of</span> edge;</span><br><span class="line">    head:<span class="keyword">array</span>[<span class="number">0</span>..<span class="number">3010</span>] <span class="keyword">of</span> int;</span><br><span class="line">    lea,cnt:<span class="keyword">array</span>[<span class="number">0</span>..<span class="number">3010</span>] <span class="keyword">of</span> int64;</span><br><span class="line">    n,m,sz,i,u,v,w:int;ans:int64;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">procedure</span> <span class="title">add</span><span class="params">(u,v:int;w:int64)</span>;</span></span><br><span class="line"><span class="keyword">begin</span></span><br><span class="line">    inc(sz);</span><br><span class="line">    g[sz].v:=v;g[sz].w:=w;</span><br><span class="line">    g[sz].next:=head[u];head[u]:=sz;</span><br><span class="line"><span class="keyword">end</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">procedure</span> <span class="title">dfs</span><span class="params">(u,p:int)</span>;</span></span><br><span class="line"><span class="keyword">var</span> i,v:int;</span><br><span class="line"><span class="keyword">begin</span></span><br><span class="line">    lea[u]:=<span class="number">0</span>;cnt[u]:=<span class="number">1</span>;</span><br><span class="line">    i:=head[u];</span><br><span class="line">    <span class="keyword">while</span> i&lt;&gt;<span class="number">0</span> <span class="keyword">do</span> <span class="keyword">begin</span></span><br><span class="line">        v:=g[i].v;</span><br><span class="line">        <span class="keyword">if</span> v&lt;&gt;p <span class="keyword">then</span> <span class="keyword">begin</span></span><br><span class="line">            dfs(v,u);</span><br><span class="line">            inc(cnt[u],cnt[v]);</span><br><span class="line">            inc(lea[u],lea[v]);</span><br><span class="line">        <span class="keyword">end</span>;</span><br><span class="line">        i:=g[i].next;</span><br><span class="line">    <span class="keyword">end</span>;</span><br><span class="line">    <span class="keyword">if</span> lea[u]=<span class="number">0</span> <span class="keyword">then</span> lea[u]:=<span class="number">1</span>;</span><br><span class="line"><span class="keyword">end</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">procedure</span> <span class="title">dp</span><span class="params">(u,p:int)</span>;</span></span><br><span class="line"><span class="keyword">var</span> i,v:int;</span><br><span class="line"><span class="keyword">begin</span></span><br><span class="line">    i:=head[u];</span><br><span class="line">    <span class="keyword">while</span> i&lt;&gt;<span class="number">0</span> <span class="keyword">do</span> <span class="keyword">begin</span></span><br><span class="line">        v:=g[i].v;</span><br><span class="line">        <span class="keyword">if</span> v&lt;&gt;p <span class="keyword">then</span> <span class="keyword">begin</span></span><br><span class="line">            inc(ans,g[i].w*(cnt[v]*(lea[<span class="number">1</span>]-lea[v])+</span><br><span class="line">                lea[v]*(cnt[<span class="number">1</span>]-cnt[v])));</span><br><span class="line">            dp(v,u);</span><br><span class="line">        <span class="keyword">end</span>;</span><br><span class="line">        i:=g[i].next;</span><br><span class="line">    <span class="keyword">end</span>;</span><br><span class="line"><span class="keyword">end</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">begin</span></span><br><span class="line">    assign(input,<span class="string">'senso.in'</span>);reset(input);</span><br><span class="line">    assign(output,<span class="string">'senso.out'</span>);rewrite(output);</span><br><span class="line">    <span class="keyword">read</span>(n,m);</span><br><span class="line">    <span class="keyword">for</span> i:=<span class="number">1</span> <span class="keyword">to</span> m <span class="keyword">do</span> <span class="keyword">begin</span></span><br><span class="line">        <span class="keyword">read</span>(w,u,v);</span><br><span class="line">        add(u,v,w);add(v,u,w);</span><br><span class="line">    <span class="keyword">end</span>;</span><br><span class="line">    dfs(<span class="number">1</span>,<span class="number">0</span>);</span><br><span class="line">    <span class="comment">//for i:=1 to n do writeln(i,'&gt;',cnt[i],' ',lea[i]);</span></span><br><span class="line">    ans:=<span class="number">0</span>;dp(<span class="number">1</span>,<span class="number">0</span>);<span class="keyword">write</span>(ans);</span><br><span class="line">    close(input);close(output);</span><br><span class="line"><span class="keyword">end</span>.</span><br></pre></td></tr></table></figure><br><br></div></div>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;P2裸的折半枚举没有写&lt;/p&gt;
&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th style=&quot;text-align:center&quot;&gt;题目&lt;/th&gt;
&lt;th style=&quot;text-align:center&quot;&gt;思路&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td style=&quot;text-align:center&quot;&gt;cowids&lt;/td&gt;
&lt;td style=&quot;text-align:center&quot;&gt;DP+回溯&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td style=&quot;text-align:center&quot;&gt;senso&lt;/td&gt;
&lt;td style=&quot;text-align:center&quot;&gt;树形DP&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;h1 id=&quot;P1-奶牛编号&quot;&gt;&lt;a href=&quot;#P1-奶牛编号&quot; class=&quot;headerlink&quot; title=&quot;P1 奶牛编号&quot;&gt;&lt;/a&gt;P1 奶牛编号&lt;/h1&gt;&lt;p&gt;作为一个神秘的电脑高手，Farmer John 用二进制数字标识他的奶牛。&lt;br&gt;然而，他有点迷信，标识奶牛用的二进制数字，必须只含有K位“1”&lt;br&gt;(1 &amp;lt;= K &amp;lt;= 10)。 当然，每个标识数字的首位必须为“1”。&lt;br&gt;FJ按递增的顺序，安排标识数字，开始是最小可行的标识数字&lt;br&gt;（由“1”组成的一个K位数）。&lt;br&gt;不幸的是，他没有记录下标识数字。请帮他计算，第N个标识数字&lt;br&gt;(1 &amp;lt;= N &amp;lt;= 10^7)。&lt;br&gt;
    
    </summary>
    
      <category term="Problem Set" scheme="https://cothrax.github.io/categories/Problem-Set/"/>
    
    
      <category term="OI" scheme="https://cothrax.github.io/tags/OI/"/>
    
      <category term="DP" scheme="https://cothrax.github.io/tags/DP/"/>
    
      <category term="图论" scheme="https://cothrax.github.io/tags/%E5%9B%BE%E8%AE%BA/"/>
    
      <category term="树形DP" scheme="https://cothrax.github.io/tags/%E6%A0%91%E5%BD%A2DP/"/>
    
  </entry>
  
  <entry>
    <title>NOIP模拟赛 2014-10-30-2</title>
    <link href="https://cothrax.github.io/2016/10/04/noip-2014-10-30-2/"/>
    <id>https://cothrax.github.io/2016/10/04/noip-2014-10-30-2/</id>
    <published>2016-10-04T14:35:03.000Z</published>
    <updated>2016-10-30T06:06:17.316Z</updated>
    
    <content type="html"><![CDATA[<p>两道几何果断跳过</p>
<table>
<thead>
<tr>
<th style="text-align:center">题目</th>
<th style="text-align:center">思路</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">nmtg</td>
<td style="text-align:center">计数+gcd</td>
</tr>
<tr>
<td style="text-align:center">sdtg</td>
<td style="text-align:center">结论(斐波)+LCA</td>
</tr>
</tbody>
</table>
<h1 id="P2-三角形"><a href="#P2-三角形" class="headerlink" title="P2 三角形"></a>P2 三角形</h1><p>给定一张 N*M 的网格,计算三个点都在网格上的三角形有多少个。三角形三点不能共线。<br><a id="more"></a></p>
<h2 id="格式"><a href="#格式" class="headerlink" title="格式"></a>格式</h2><h3 id="输入格式"><a href="#输入格式" class="headerlink" title="输入格式"></a>输入格式</h3><p>一行两个正整数 N,M。</p>
<h3 id="输出格式"><a href="#输出格式" class="headerlink" title="输出格式"></a>输出格式</h3><p>一行一个整数代表数量。</p>
<h2 id="样例"><a href="#样例" class="headerlink" title="样例"></a>样例</h2><h3 id="样例输入"><a href="#样例输入" class="headerlink" title="样例输入"></a>样例输入</h3><blockquote>
<p>1 1</p>
</blockquote>
<h3 id="样例输出"><a href="#样例输出" class="headerlink" title="样例输出"></a>样例输出</h3><blockquote>
<p>4</p>
</blockquote>
<h2 id="提示​"><a href="#提示​" class="headerlink" title="提示​"></a>提示​</h2><p>对于 10%的数据有 N,M &lt;= 10<br>对于 30%的数据有 N,M &lt;= 100<br>对于 100%的数据有 N,M &lt;= 1000</p>
<h2 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h2><p>下面的n,m指端点数<br>先算出取三个点的方案数即C(nm,3)<br>然后减去行、列、斜着的的共线数<br>关于斜着的：枚举边长i*j，g=gcd(i*j)-1就是(i,j)的线段上的整点数（除端点），g&gt;0的情况下，该线段的贡献为2g(n-i)(m-j)</p>
<div><br><div class="copy"><br>    <a href="/2016/10/04/noip-2014-10-30-2/nmtg.pas" title="{plain text}">{plain text}</a><br></div><br><div><br><figure class="highlight delphi"><figcaption><span>nmtg.pas</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">uses</span> math;</span><br><span class="line"><span class="keyword">type</span> int=longint;ll=int64;</span><br><span class="line"><span class="keyword">var</span>    n,m,i,j,k:int;ans:ll;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">c</span><span class="params">(x:int64)</span>:</span>int64;</span><br><span class="line"><span class="keyword">begin</span></span><br><span class="line">    <span class="keyword">if</span> x&lt;<span class="number">3</span> <span class="keyword">then</span> <span class="keyword">exit</span>(<span class="number">0</span>);</span><br><span class="line">    c:=x*(x-ll(<span class="number">1</span>))*(x-ll(<span class="number">2</span>));</span><br><span class="line"><span class="keyword">end</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">gcd</span><span class="params">(a,b:int)</span>:</span>int;</span><br><span class="line"><span class="keyword">begin</span></span><br><span class="line">    <span class="keyword">if</span> b=<span class="number">0</span> <span class="keyword">then</span> gcd:=a <span class="keyword">else</span> gcd:=gcd(b,a <span class="keyword">mod</span> b);</span><br><span class="line"><span class="keyword">end</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">begin</span></span><br><span class="line">    assign(input,<span class="string">'nmtg.in'</span>);reset(input);</span><br><span class="line">    assign(output,<span class="string">'nmtg.out'</span>);rewrite(output);</span><br><span class="line">    <span class="keyword">read</span>(n,m);</span><br><span class="line">    inc(n);inc(m);</span><br><span class="line">    ans:=(c(n*m)-m*c(n)-n*c(m)) <span class="keyword">div</span> <span class="number">6</span>;</span><br><span class="line">    <span class="keyword">for</span> i:=<span class="number">1</span> <span class="keyword">to</span> n <span class="keyword">do</span></span><br><span class="line">        <span class="keyword">for</span> j:=<span class="number">1</span> <span class="keyword">to</span> m <span class="keyword">do</span> <span class="keyword">begin</span></span><br><span class="line">            k:=gcd(i,j)+<span class="number">1</span>;</span><br><span class="line">            <span class="keyword">if</span> k&lt;=<span class="number">2</span> <span class="keyword">then</span> <span class="keyword">continue</span>;</span><br><span class="line">            dec(ans,(n-i)*(m-j)*(k-<span class="number">2</span>)*<span class="number">2</span>);</span><br><span class="line">        <span class="keyword">end</span>;</span><br><span class="line">    <span class="keyword">write</span>(ans);</span><br><span class="line">    close(input);close(output);</span><br><span class="line"><span class="keyword">end</span>.</span><br></pre></td></tr></table></figure><br><br></div></div>

<h1 id="P3-忧桑三角形"><a href="#P3-忧桑三角形" class="headerlink" title="P3 忧桑三角形"></a>P3 忧桑三角形</h1><p>有一棵树,树上每个点都有点权,现在有以下两个操作:</p>
<ol>
<li>修改某个点的点权</li>
<li>查询点 u 和点 v 构成的简单路径上是否能选出三个点组成三角形<!--more-->
</li>
</ol>
<h2 id="格式-1"><a href="#格式-1" class="headerlink" title="格式"></a>格式</h2><h3 id="输入格式-1"><a href="#输入格式-1" class="headerlink" title="输入格式"></a>输入格式</h3><p>第一行两个整数 N,Q,代表点数和询问数。第二行 N 个整数表示点权。下面 N-1<br>行每行两个整数 a,b 代表 a,b 之间有一条边。下面 Q 行每行 3 个整数 t,a,b:若 t=0,询问(a,b);否则将点 a 的权值修改为 b</p>
<h3 id="输出格式-1"><a href="#输出格式-1" class="headerlink" title="输出格式"></a>输出格式</h3><p>对于每个询问输出 Y 表示能构成三角形,输出 N 表示不能构成三角形</p>
<h2 id="样例-1"><a href="#样例-1" class="headerlink" title="样例"></a>样例</h2><h3 id="样例输入-1"><a href="#样例输入-1" class="headerlink" title="样例输入"></a>样例输入</h3><blockquote>
<p>5 5<br>1 2 3 4 5<br>1 2<br>2 3<br>3 4<br>1 5<br>0 1 3<br>0 4 5<br>1 1 4<br>0 2 5<br>0 2 3</p>
</blockquote>
<h3 id="样例输出-1"><a href="#样例输出-1" class="headerlink" title="样例输出"></a>样例输出</h3><blockquote>
<p>N<br>Y<br>Y<br>N</p>
</blockquote>
<h2 id="提示​-1"><a href="#提示​-1" class="headerlink" title="提示​"></a>提示​</h2><p>对于 30%的数据有 N,Q&lt;= 1000<br>对于 100%的数据有 N,Q&lt;= 10^5,点权范围在 32 位整数范围内</p>
<h2 id="题解-1"><a href="#题解-1" class="headerlink" title="题解"></a>题解</h2><blockquote>
<p>点权范围在 32 位整数范围内</p>
</blockquote>
<p>也就是说，当a和b距离很远时一定能构成三角形<br>考虑构造不能构成三角形的一条链f[i-2]+f[i-1]=f[i]，1,1,2,3,5…，就是斐波那契，当i&gt;50时爆int，所以当dist(a,b)&gt;50时，输出y即可，否则暴力算</p>
<div><br><div class="copy"><br>    <a href="/2016/10/04/noip-2014-10-30-2/sdtg.pas" title="{plain text}">{plain text}</a><br></div><br><div><br><figure class="highlight delphi"><figcaption><span>sdtg.pas</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">uses</span> math;</span><br><span class="line"><span class="keyword">type</span> </span><br><span class="line">    int=longint;ll=int64;</span><br><span class="line">    edge=<span class="keyword">record</span> v,next:int <span class="keyword">end</span>;</span><br><span class="line"><span class="keyword">var</span></span><br><span class="line">    g:<span class="keyword">array</span>[<span class="number">0</span>..<span class="number">200010</span>] <span class="keyword">of</span> edge;</span><br><span class="line">    par:<span class="keyword">array</span>[<span class="number">0</span>..<span class="number">100010</span>,<span class="number">0</span>..<span class="number">20</span>] <span class="keyword">of</span> int;</span><br><span class="line">    a:<span class="keyword">array</span>[<span class="number">0</span>..<span class="number">52</span>] <span class="keyword">of</span> int;</span><br><span class="line">    head,dep,w:<span class="keyword">array</span>[<span class="number">0</span>..<span class="number">100010</span>] <span class="keyword">of</span> int;</span><br><span class="line">    sz,n,m,lg,i,j,d,p,u,v:int;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">procedure</span> <span class="title">add</span><span class="params">(u,v:int)</span>;</span></span><br><span class="line"><span class="keyword">begin</span></span><br><span class="line">    inc(sz);g[sz].v:=v;</span><br><span class="line">    g[sz].next:=head[u];head[u]:=sz;</span><br><span class="line"><span class="keyword">end</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">procedure</span> <span class="title">dfs</span><span class="params">(u,p:int)</span>;</span></span><br><span class="line"><span class="keyword">var</span> v,i:int;</span><br><span class="line"><span class="keyword">begin</span></span><br><span class="line">    par[u,<span class="number">0</span>]:=p;dep[u]:=dep[p]+<span class="number">1</span>;</span><br><span class="line">    i:=head[u];</span><br><span class="line">    <span class="keyword">while</span> i&lt;&gt;<span class="number">0</span> <span class="keyword">do</span> <span class="keyword">begin</span></span><br><span class="line">        v:=g[i].v;</span><br><span class="line">        <span class="keyword">if</span> v&lt;&gt;p <span class="keyword">then</span> dfs(v,u);</span><br><span class="line">        i:=g[i].next;</span><br><span class="line">    <span class="keyword">end</span>;</span><br><span class="line"><span class="keyword">end</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">procedure</span> <span class="title">swap</span><span class="params">(<span class="keyword">var</span> a,b:int)</span>;</span></span><br><span class="line"><span class="keyword">var</span> tmp:int;</span><br><span class="line"><span class="keyword">begin</span> tmp:=a;a:=b;b:=tmp <span class="keyword">end</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">lca</span><span class="params">(u,v:int)</span>:</span>int;</span><br><span class="line"><span class="keyword">var</span> i:int;</span><br><span class="line"><span class="keyword">begin</span></span><br><span class="line">    <span class="keyword">if</span> dep[u]&lt;dep[v] <span class="keyword">then</span> swap(u,v);</span><br><span class="line">    <span class="keyword">for</span> i:=lg <span class="keyword">downto</span> <span class="number">0</span> <span class="keyword">do</span></span><br><span class="line">        <span class="keyword">if</span> dep[par[u,i]]&gt;=dep[v] <span class="keyword">then</span></span><br><span class="line">            u:=par[u,i];</span><br><span class="line">    <span class="keyword">if</span> u=v <span class="keyword">then</span> <span class="keyword">exit</span>(u);</span><br><span class="line">    <span class="keyword">for</span> i:=lg <span class="keyword">downto</span> <span class="number">0</span> <span class="keyword">do</span></span><br><span class="line">        <span class="keyword">if</span> par[u,i]&lt;&gt;par[v,i] <span class="keyword">then</span> <span class="keyword">begin</span></span><br><span class="line">            u:=par[u,i];v:=par[v,i];</span><br><span class="line">        <span class="keyword">end</span>;</span><br><span class="line">    lca:=par[u,<span class="number">0</span>];</span><br><span class="line"><span class="keyword">end</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">procedure</span> <span class="title">qsort</span><span class="params">(l,r:int)</span>;</span></span><br><span class="line"><span class="keyword">var</span> i,j,x:int;</span><br><span class="line"><span class="keyword">begin</span></span><br><span class="line">    i:=l;j:=r;x:=a[random(r-l)+l];</span><br><span class="line">    <span class="keyword">repeat</span></span><br><span class="line">        <span class="keyword">while</span> a[i]&lt;x <span class="keyword">do</span> inc(i);</span><br><span class="line">        <span class="keyword">while</span> a[j]&gt;x <span class="keyword">do</span> dec(j);</span><br><span class="line">        <span class="keyword">if</span> i&lt;=j <span class="keyword">then</span> <span class="keyword">begin</span></span><br><span class="line">            swap(a[i],a[j]);</span><br><span class="line">            inc(i);dec(j);</span><br><span class="line">        <span class="keyword">end</span>;</span><br><span class="line">    <span class="keyword">until</span> i&gt;j;</span><br><span class="line">    <span class="keyword">if</span> i&lt;r <span class="keyword">then</span> qsort(i,r);</span><br><span class="line">    <span class="keyword">if</span> l&lt;j <span class="keyword">then</span> qsort(l,j);</span><br><span class="line"><span class="keyword">end</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">calc</span><span class="params">(u,v,p:int)</span>:</span>char;</span><br><span class="line"><span class="keyword">var</span> i,k:int;</span><br><span class="line"><span class="keyword">begin</span></span><br><span class="line">    k:=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span> u&lt;&gt;p <span class="keyword">do</span> <span class="keyword">begin</span></span><br><span class="line">        inc(k);a[k]:=w[u];u:=par[u,<span class="number">0</span>];</span><br><span class="line">    <span class="keyword">end</span>;</span><br><span class="line">    <span class="keyword">while</span> v&lt;&gt;p <span class="keyword">do</span> <span class="keyword">begin</span></span><br><span class="line">        inc(k);a[k]:=w[v];v:=par[v,<span class="number">0</span>];</span><br><span class="line">    <span class="keyword">end</span>;</span><br><span class="line">    inc(k);a[k]:=w[p];</span><br><span class="line">    qsort(<span class="number">1</span>,k);</span><br><span class="line">    <span class="keyword">for</span> i:=<span class="number">1</span> <span class="keyword">to</span> k-<span class="number">2</span> <span class="keyword">do</span></span><br><span class="line">        <span class="keyword">if</span> ll(a[i])+ll(a[i+<span class="number">1</span>])&gt;ll(a[i+<span class="number">2</span>]) <span class="keyword">then</span> <span class="keyword">exit</span>(<span class="string">'Y'</span>);</span><br><span class="line">    calc:=<span class="string">'N'</span>;</span><br><span class="line"><span class="keyword">end</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">begin</span></span><br><span class="line">    assign(input,<span class="string">'sdtg.in'</span>);reset(input);</span><br><span class="line">    assign(output,<span class="string">'sdtg.out'</span>);rewrite(output);</span><br><span class="line">    <span class="keyword">read</span>(n,m);lg:=floor(ln(n)/ln(<span class="number">2</span>));</span><br><span class="line">    <span class="keyword">for</span> i:=<span class="number">1</span> <span class="keyword">to</span> n <span class="keyword">do</span> <span class="keyword">read</span>(w[i]);</span><br><span class="line">    <span class="keyword">for</span> i:=<span class="number">1</span> <span class="keyword">to</span> n-<span class="number">1</span> <span class="keyword">do</span> <span class="keyword">begin</span></span><br><span class="line">        <span class="keyword">read</span>(u,v);add(u,v);add(v,u);    </span><br><span class="line">    <span class="keyword">end</span>;</span><br><span class="line">    dfs(<span class="number">1</span>,<span class="number">0</span>);</span><br><span class="line">    <span class="keyword">for</span> j:=<span class="number">1</span> <span class="keyword">to</span> lg <span class="keyword">do</span></span><br><span class="line">        <span class="keyword">for</span> i:=<span class="number">1</span> <span class="keyword">to</span> n <span class="keyword">do</span></span><br><span class="line">            par[i,j]:=par[par[i,j-<span class="number">1</span>],j-<span class="number">1</span>];</span><br><span class="line">    <span class="keyword">for</span> i:=<span class="number">1</span> <span class="keyword">to</span> m <span class="keyword">do</span> <span class="keyword">begin</span></span><br><span class="line">        <span class="keyword">read</span>(j,u,v);</span><br><span class="line">        <span class="keyword">if</span> j=<span class="number">0</span> <span class="keyword">then</span> <span class="keyword">begin</span></span><br><span class="line">            p:=lca(u,v);</span><br><span class="line">            d:=dep[u]+dep[v]-<span class="number">2</span>*dep[p];</span><br><span class="line">            <span class="keyword">if</span> d&gt;<span class="number">52</span> <span class="keyword">then</span> writeln(<span class="string">'Y'</span>)</span><br><span class="line">            <span class="keyword">else</span> writeln(calc(u,v,p));</span><br><span class="line">        <span class="keyword">end</span> <span class="keyword">else</span> w[u]:=v;</span><br><span class="line">    <span class="keyword">end</span>;</span><br><span class="line">    close(input);close(output);</span><br><span class="line"><span class="keyword">end</span>.</span><br></pre></td></tr></table></figure><br><br></div></div>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;两道几何果断跳过&lt;/p&gt;
&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th style=&quot;text-align:center&quot;&gt;题目&lt;/th&gt;
&lt;th style=&quot;text-align:center&quot;&gt;思路&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td style=&quot;text-align:center&quot;&gt;nmtg&lt;/td&gt;
&lt;td style=&quot;text-align:center&quot;&gt;计数+gcd&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td style=&quot;text-align:center&quot;&gt;sdtg&lt;/td&gt;
&lt;td style=&quot;text-align:center&quot;&gt;结论(斐波)+LCA&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;h1 id=&quot;P2-三角形&quot;&gt;&lt;a href=&quot;#P2-三角形&quot; class=&quot;headerlink&quot; title=&quot;P2 三角形&quot;&gt;&lt;/a&gt;P2 三角形&lt;/h1&gt;&lt;p&gt;给定一张 N*M 的网格,计算三个点都在网格上的三角形有多少个。三角形三点不能共线。&lt;br&gt;
    
    </summary>
    
      <category term="Problem Set" scheme="https://cothrax.github.io/categories/Problem-Set/"/>
    
    
      <category term="OI" scheme="https://cothrax.github.io/tags/OI/"/>
    
      <category term="图论" scheme="https://cothrax.github.io/tags/%E5%9B%BE%E8%AE%BA/"/>
    
      <category term="数论" scheme="https://cothrax.github.io/tags/%E6%95%B0%E8%AE%BA/"/>
    
      <category term="组合数学" scheme="https://cothrax.github.io/tags/%E7%BB%84%E5%90%88%E6%95%B0%E5%AD%A6/"/>
    
      <category term="LCA" scheme="https://cothrax.github.io/tags/LCA/"/>
    
      <category term="数学" scheme="https://cothrax.github.io/tags/%E6%95%B0%E5%AD%A6/"/>
    
  </entry>
  
  <entry>
    <title>NOIP模拟赛 2014-10-31-1</title>
    <link href="https://cothrax.github.io/2016/10/04/noip-2014-10-31-1/"/>
    <id>https://cothrax.github.io/2016/10/04/noip-2014-10-31-1/</id>
    <published>2016-10-04T14:20:01.000Z</published>
    <updated>2016-10-30T06:06:17.341Z</updated>
    
    <content type="html"><![CDATA[<table>
<thead>
<tr>
<th style="text-align:center">题目</th>
<th style="text-align:center">思路</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">and</td>
<td style="text-align:center">位运算+贪心</td>
</tr>
<tr>
<td style="text-align:center">elephant</td>
<td style="text-align:center">概率期望+DP</td>
</tr>
<tr>
<td style="text-align:center">move</td>
<td style="text-align:center">分层图最短路</td>
</tr>
<tr>
<td style="text-align:center">meteorite</td>
<td style="text-align:center">带权并查集</td>
</tr>
</tbody>
</table>
<h1 id="P1-“与”"><a href="#P1-“与”" class="headerlink" title="P1 “与”"></a>P1 “与”</h1><p>给你一个长度为n的序列A，请你求出一对Ai，Aj（<span>$1&le;i&lt;j&le;n$</span><!-- Has MathJax -->）使Ai“与”Aj最大。<br>Ps：“与”表示位运算and，在c++中表示为&amp;。</p>
<a id="more"></a>
<h2 id="格式"><a href="#格式" class="headerlink" title="格式"></a>格式</h2><h3 id="输入格式"><a href="#输入格式" class="headerlink" title="输入格式"></a>输入格式</h3><p>第一行为n。接下来n行，一行一个数字表示Ai。</p>
<h3 id="输出格式"><a href="#输出格式" class="headerlink" title="输出格式"></a>输出格式</h3><p>输出最大的Ai“与”Aj的结果。</p>
<h2 id="样例"><a href="#样例" class="headerlink" title="样例"></a>样例</h2><h3 id="样例输入"><a href="#样例输入" class="headerlink" title="样例输入"></a>样例输入</h3><blockquote>
<p>3<br>8<br>10<br>2</p>
</blockquote>
<h3 id="样例输出"><a href="#样例输出" class="headerlink" title="样例输出"></a>样例输出</h3><blockquote>
<p>8</p>
</blockquote>
<h2 id="提示​"><a href="#提示​" class="headerlink" title="提示​"></a>提示​</h2><p>样例解释：<br>8 and 10 = 8<br>8 and 2 = 0<br>10 and 2 = 2<br>数据范围：<br>20%的数据保证n&lt;=5000<br>100%的数据保证 n&lt;=3*10^5，0&lt;=Ai&lt;=10^9</p>
<h2 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h2><p>从高位到低位逐个考虑即可，如果第i位有≥2个数是1，就要取这一位</p>
<div><br><div class="copy"><br>    <br></div><br><div><br><figure class="highlight delphi"><figcaption><span>add.pas</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> int=longint;</span><br><span class="line"><span class="keyword">var</span> </span><br><span class="line">    n,i,p,j,ans:int;</span><br><span class="line">    cnt:<span class="keyword">array</span>[<span class="number">0</span>..<span class="number">40</span>] <span class="keyword">of</span> int;</span><br><span class="line">    a:<span class="keyword">array</span>[<span class="number">0</span>..<span class="number">300010</span>] <span class="keyword">of</span> int;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">procedure</span> <span class="title">calc</span><span class="params">(x:int)</span>;</span></span><br><span class="line"><span class="keyword">var</span> i:int;</span><br><span class="line"><span class="keyword">begin</span></span><br><span class="line">    <span class="keyword">for</span> i:=<span class="number">0</span> <span class="keyword">to</span> <span class="number">30</span> <span class="keyword">do</span></span><br><span class="line">        <span class="keyword">if</span> ((x <span class="keyword">shr</span> i) <span class="keyword">and</span> <span class="number">1</span>)=<span class="number">1</span> <span class="keyword">then</span> inc(cnt[i]);</span><br><span class="line"><span class="keyword">end</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">begin</span></span><br><span class="line">    assign(input,<span class="string">'and.in'</span>);reset(input);</span><br><span class="line">    assign(output,<span class="string">'and.out'</span>);rewrite(output);</span><br><span class="line">    <span class="keyword">read</span>(n);</span><br><span class="line">    <span class="keyword">for</span> i:=<span class="number">1</span> <span class="keyword">to</span> n <span class="keyword">do</span> <span class="keyword">read</span>(a[i]);</span><br><span class="line">    ans:=<span class="number">0</span>;p:=<span class="number">31</span>;</span><br><span class="line">    <span class="keyword">while</span> true <span class="keyword">do</span> <span class="keyword">begin</span></span><br><span class="line">        fillchar(cnt,sizeof(cnt),<span class="number">0</span>);</span><br><span class="line">        <span class="keyword">for</span> i:=<span class="number">1</span> <span class="keyword">to</span> n <span class="keyword">do</span></span><br><span class="line">            <span class="keyword">if</span> (ans <span class="keyword">and</span> a[i])=ans <span class="keyword">then</span> calc(a[i]);</span><br><span class="line">        <span class="comment">//for i:=0 to 31 do write(cnt[i]:3);writeln;</span></span><br><span class="line">        j:=-<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span> i:=p <span class="keyword">downto</span> <span class="number">0</span> <span class="keyword">do</span></span><br><span class="line">            <span class="keyword">if</span> cnt[i]&gt;=<span class="number">2</span> <span class="keyword">then</span> <span class="keyword">begin</span></span><br><span class="line">                ans:=ans <span class="keyword">or</span> (<span class="number">1</span> <span class="keyword">shl</span> i);</span><br><span class="line">                j:=i-<span class="number">1</span>;<span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">end</span>;</span><br><span class="line">        <span class="keyword">if</span> j=-<span class="number">1</span> <span class="keyword">then</span> <span class="keyword">break</span>;</span><br><span class="line">        p:=j;</span><br><span class="line">    <span class="keyword">end</span>;</span><br><span class="line">    <span class="keyword">write</span>(ans);</span><br><span class="line">    close(input);close(output);</span><br><span class="line"><span class="keyword">end</span>.</span><br></pre></td></tr></table></figure><br><br></div></div>

<h1 id="P2-小象涂色"><a href="#P2-小象涂色" class="headerlink" title="P2 小象涂色"></a>P2 小象涂色</h1><p>小象喜欢为箱子涂色。小象现在有c种颜色，编号为0~c-1；还有n个箱子，编号为1~n，最开始每个箱子的颜色为1。小象涂色时喜欢遵循灵感：它将箱子按编号排成一排，每次涂色时，它随机选择[L，R]这个区间里的一些箱子（不选看做选0个），为之涂上随机一种颜色。若一个颜色为a的箱子被涂上b色，那么这个箱子的颜色会变成（a*b）mod c。请问在k次涂色后，所有箱子颜色的编号和期望为多少？</p>
<!--more-->
<h2 id="格式-1"><a href="#格式-1" class="headerlink" title="格式"></a>格式</h2><h3 id="输入格式-1"><a href="#输入格式-1" class="headerlink" title="输入格式"></a>输入格式</h3><p>第一行为T，表示有T组测试数据。<br>对于每组数据，第一行为三个整数n,c,k。<br>接下来k行，每行两个整数Li，Ri，表示第i个操作的L和R。</p>
<h3 id="输出格式-1"><a href="#输出格式-1" class="headerlink" title="输出格式"></a>输出格式</h3><p>对于每组测试数据，输出所有箱子颜色编号和的期望值，结果保留9位小数。</p>
<h2 id="样例-1"><a href="#样例-1" class="headerlink" title="样例"></a>样例</h2><h3 id="样例输入-1"><a href="#样例输入-1" class="headerlink" title="样例输入"></a>样例输入</h3><blockquote>
<p>3<br>3 2 2<br>2 2<br>1 3<br>1 3 1<br>1 1<br>5 2 2<br>3 4<br>2 4</p>
</blockquote>
<h3 id="样例输出-1"><a href="#样例输出-1" class="headerlink" title="样例输出"></a>样例输出</h3><blockquote>
<p>2.062500000<br>1.000000000<br>3.875000000</p>
</blockquote>
<h2 id="提示​-1"><a href="#提示​-1" class="headerlink" title="提示​"></a>提示​</h2><p>数据范围：<br>40%的数据1 &lt;= T &lt;= 5，1 &lt;= n, k &lt;= 15，2 &lt;= c &lt;= 20<br>100%的数据满足1 &lt;= T &lt;= 10，1 &lt;= n, k &lt;= 50，2 &lt;= c &lt;= 100，1 &lt;= Li &lt;= Ri &lt;= n</p>
<h2 id="题解-1"><a href="#题解-1" class="headerlink" title="题解"></a>题解</h2><p>看到概率期望就头疼。。。<br>求期望的话，可以先求概率<br>一次染色中，一个箱子被染色的概率为1/2，染成颜色i的概率为1/c<br>记f[i,j]为一个箱子染i次，染成颜色j的概率<br>DP：<br>$f[i+1,j]+=f[i,j]/2$<br>$f[i+1,(j*p)\%c]+=f[i,j]/2/c$<br>初始：$f[0,1]=1$<br>答案：$\sum_{i=1}^{n}\sum_{j=0}^{c-1}f[a[i],j]*j$<br>其中a[i]是箱子i被染色的次数，可以差分求，也可以暴力</p>
<div><br><div class="copy"><br>    <a href="/2016/10/04/noip-2014-10-31-1/elephant.pas" title="{plain text}">{plain text}</a><br></div><br><div><br><figure class="highlight delphi"><figcaption><span>elephant.pas</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> int=longint;</span><br><span class="line"><span class="keyword">const</span> eps=<span class="number">0.00000000001</span>;</span><br><span class="line"><span class="keyword">var</span> </span><br><span class="line">    f:<span class="keyword">array</span>[<span class="number">0</span>..<span class="number">55</span>,<span class="number">0</span>..<span class="number">110</span>] <span class="keyword">of</span> double;</span><br><span class="line">    a:<span class="keyword">array</span>[<span class="number">0</span>..<span class="number">55</span>] <span class="keyword">of</span> int;</span><br><span class="line">    t,n,m,k,i,j,p,l,r:int;ans,cur:double;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">procedure</span> <span class="title">incd</span><span class="params">(<span class="keyword">var</span> a:double;b:double)</span>;</span></span><br><span class="line"><span class="keyword">begin</span> a:=a+b <span class="keyword">end</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">begin</span></span><br><span class="line">    assign(input,<span class="string">'elephant.in'</span>);reset(input);</span><br><span class="line">        assign(output,<span class="string">'elephant.out'</span>);rewrite(output);</span><br><span class="line">    <span class="keyword">read</span>(t);</span><br><span class="line">    <span class="keyword">repeat</span></span><br><span class="line">        <span class="keyword">read</span>(n,m,k);</span><br><span class="line">        fillchar(a,sizeof(a),<span class="number">0</span>);</span><br><span class="line">        <span class="keyword">for</span> i:=<span class="number">1</span> <span class="keyword">to</span> k <span class="keyword">do</span> <span class="keyword">begin</span></span><br><span class="line">            <span class="keyword">read</span>(l,r);</span><br><span class="line">            inc(a[l]);dec(a[r+<span class="number">1</span>]);</span><br><span class="line">        <span class="keyword">end</span>;</span><br><span class="line">        <span class="keyword">for</span> i:=<span class="number">1</span> <span class="keyword">to</span> n <span class="keyword">do</span> inc(a[i],a[i-<span class="number">1</span>]);</span><br><span class="line">        <span class="comment">//dp</span></span><br><span class="line">        fillchar(f,sizeof(f),<span class="number">0</span>);</span><br><span class="line">        f[<span class="number">0</span>,<span class="number">1</span>]:=<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span> i:=<span class="number">0</span> <span class="keyword">to</span> k <span class="keyword">do</span></span><br><span class="line">            <span class="keyword">for</span> j:=<span class="number">0</span> <span class="keyword">to</span> m-<span class="number">1</span> <span class="keyword">do</span></span><br><span class="line">                <span class="keyword">if</span> f[i,j]&gt;eps <span class="keyword">then</span> <span class="keyword">begin</span></span><br><span class="line">                    incd(f[i+<span class="number">1</span>,j],f[i,j]/<span class="number">2</span>);</span><br><span class="line">                    <span class="keyword">for</span> p:=<span class="number">0</span> <span class="keyword">to</span> m-<span class="number">1</span> <span class="keyword">do</span> </span><br><span class="line">                        incd(f[i+<span class="number">1</span>,(j*p) <span class="keyword">mod</span> m],f[i,j]/<span class="number">2</span>/m);</span><br><span class="line">                <span class="keyword">end</span>;</span><br><span class="line">        <span class="comment">//calc</span></span><br><span class="line">        ans:=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> i:=<span class="number">1</span> <span class="keyword">to</span> n <span class="keyword">do</span> <span class="keyword">begin</span></span><br><span class="line">            cur:=<span class="number">0</span>;</span><br><span class="line">            <span class="keyword">for</span> j:=<span class="number">0</span> <span class="keyword">to</span> m-<span class="number">1</span> <span class="keyword">do</span></span><br><span class="line">                incd(cur,f[a[i],j]*j);</span><br><span class="line">            incd(ans,cur);</span><br><span class="line">        <span class="keyword">end</span>;</span><br><span class="line">        writeln(ans:<span class="number">0</span>:<span class="number">9</span>);</span><br><span class="line">        dec(t);</span><br><span class="line">    <span class="keyword">until</span> t=<span class="number">0</span>;</span><br><span class="line">    close(input);close(output);</span><br><span class="line"><span class="keyword">end</span>.</span><br></pre></td></tr></table></figure><br><br></div></div>

<h1 id="P3-行动！行动！"><a href="#P3-行动！行动！" class="headerlink" title="P3 行动！行动！"></a>P3 行动！行动！</h1><p>大CX国的大兵Jack接到一项任务：敌方占领了n座城市（编号0~n-1），有些城市之间有双向道路相连。Jack需要空降在一个城市S，并徒步沿那些道路移动到T城市。虽然Jack每从一个城市到另一个城市都会受伤流血，但大CX国毕竟有着“过硬”的军事实力，它不仅已经算出Jack在每条道路上会损失的血量，还给Jack提供了k个“简易急救包”，一个包可以让Jack在一条路上的流血量为0。Jack想知道自己最少会流多少血，不过他毕竟是无脑的大兵，需要你的帮助。<br><!--more--></p>
<h2 id="格式-2"><a href="#格式-2" class="headerlink" title="格式"></a>格式</h2><h3 id="输入格式-2"><a href="#输入格式-2" class="headerlink" title="输入格式"></a>输入格式</h3><p>第一行有三个整数n,m,k，分别表示城市数，道路数和急救包个数。<br>第二行有两个整数，S,T。分别表示Jack空降到的城市编号和最终要到的城市。<br>接下来有m行，每行三个整数a,b,c，表示城市a与城市b之间有一条双向道路。</p>
<h3 id="输出格式-2"><a href="#输出格式-2" class="headerlink" title="输出格式"></a>输出格式</h3><p>Jack最少要流的血量。</p>
<h2 id="样例-2"><a href="#样例-2" class="headerlink" title="样例"></a>样例</h2><h3 id="样例输入-2"><a href="#样例输入-2" class="headerlink" title="样例输入"></a>样例输入</h3><blockquote>
<p>5 6 1<br>0 3<br>3 4 5<br>0 1 5<br>0 2 100<br>1 2 5<br>2 4 5<br>2 4 3</p>
</blockquote>
<h3 id="样例输出-2"><a href="#样例输出-2" class="headerlink" title="样例输出"></a>样例输出</h3><blockquote>
<p>8</p>
</blockquote>
<h2 id="提示​-2"><a href="#提示​-2" class="headerlink" title="提示​"></a>提示​</h2><p>对于30%的数据,2&lt;=n&lt;=50,1&lt;=m&lt;=300,k=0;<br>对于50%的数据,2&lt;=n&lt;=600,1&lt;=m&lt;=6000,0&lt;=k&lt;=1;<br>对于100%的数据,2&lt;=n&lt;=10000,1&lt;=m&lt;=50000,0&lt;=k&lt;=10.</p>
<h2 id="题解-2"><a href="#题解-2" class="headerlink" title="题解"></a>题解</h2><p>分层图最短路，建图后heap+dijkstra</p>
<div><br><div class="copy"><br>    <a href="/2016/10/04/noip-2014-10-31-1/move.pas" title="{plain text}">{plain text}</a><br></div><br><div><br><figure class="highlight delphi"><figcaption><span>move.pas</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> </span><br><span class="line">    int=longint;</span><br><span class="line">    edge=<span class="keyword">record</span> v,w,next:int <span class="keyword">end</span>;</span><br><span class="line"><span class="keyword">const</span> inf=<span class="number">1000000000</span>;</span><br><span class="line"><span class="keyword">var</span></span><br><span class="line">    g:<span class="keyword">array</span>[<span class="number">0</span>..<span class="number">2200010</span>] <span class="keyword">of</span> edge;</span><br><span class="line">    head,l,d:<span class="keyword">array</span>[<span class="number">0</span>..<span class="number">110010</span>] <span class="keyword">of</span> int;</span><br><span class="line">    h:<span class="keyword">array</span>[<span class="number">0</span>..<span class="number">110010</span>,<span class="number">0</span>..<span class="number">1</span>] <span class="keyword">of</span> int;</span><br><span class="line">    n,m,k,sz,hs,u,v,w,s,t,i,j:int;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">procedure</span> <span class="title">add</span><span class="params">(u,v,w:int)</span>;</span></span><br><span class="line"><span class="keyword">begin</span></span><br><span class="line">    inc(sz);g[sz].v:=v;g[sz].w:=w;</span><br><span class="line">    g[sz].next:=head[u];head[u]:=sz;</span><br><span class="line"><span class="keyword">end</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">procedure</span> <span class="title">swap</span><span class="params">(i,j:int)</span>;</span></span><br><span class="line"><span class="keyword">var</span> tmp:int;</span><br><span class="line"><span class="keyword">begin</span></span><br><span class="line">    l[h[i,<span class="number">1</span>]]:=j;l[h[j,<span class="number">1</span>]]:=i;</span><br><span class="line">    tmp:=h[i,<span class="number">0</span>];h[i,<span class="number">0</span>]:=h[j,<span class="number">0</span>];h[j,<span class="number">0</span>]:=tmp;</span><br><span class="line">    tmp:=h[i,<span class="number">1</span>];h[i,<span class="number">1</span>]:=h[j,<span class="number">1</span>];h[j,<span class="number">1</span>]:=tmp;</span><br><span class="line"><span class="keyword">end</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">procedure</span> <span class="title">hfy</span><span class="params">(i:int)</span>;</span></span><br><span class="line"><span class="keyword">var</span> l,r,s:int;</span><br><span class="line"><span class="keyword">begin</span></span><br><span class="line">    l:=i <span class="keyword">shl</span> <span class="number">1</span>;r:=l <span class="keyword">or</span> <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">if</span> (l&lt;=hs) <span class="keyword">and</span> (h[l,<span class="number">0</span>]&lt;h[i,<span class="number">0</span>]) <span class="keyword">then</span> s:=l <span class="keyword">else</span> s:=i;</span><br><span class="line">    <span class="keyword">if</span> (r&lt;=hs) <span class="keyword">and</span> (h[r,<span class="number">0</span>]&lt;h[s,<span class="number">0</span>]) <span class="keyword">then</span> s:=r;</span><br><span class="line">    <span class="keyword">if</span> i&lt;&gt;s <span class="keyword">then</span> <span class="keyword">begin</span></span><br><span class="line">        swap(i,s);hfy(s);</span><br><span class="line">    <span class="keyword">end</span>;</span><br><span class="line"><span class="keyword">end</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">procedure</span> <span class="title">ext</span><span class="params">()</span>;</span></span><br><span class="line"><span class="keyword">begin</span></span><br><span class="line">    swap(<span class="number">1</span>,hs);dec(hs);hfy(<span class="number">1</span>);</span><br><span class="line"><span class="keyword">end</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">procedure</span> <span class="title">red</span><span class="params">(i,k:int)</span>;</span></span><br><span class="line"><span class="keyword">begin</span></span><br><span class="line">    h[i,<span class="number">0</span>]:=k;</span><br><span class="line">    <span class="keyword">while</span> (i&gt;<span class="number">1</span>) <span class="keyword">and</span> (h[i,<span class="number">0</span>]&lt;h[i <span class="keyword">shr</span> <span class="number">1</span>,<span class="number">0</span>]) <span class="keyword">do</span> <span class="keyword">begin</span></span><br><span class="line">        swap(i,i <span class="keyword">shr</span> <span class="number">1</span>);i:=i <span class="keyword">shr</span> <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">end</span>;</span><br><span class="line"><span class="keyword">end</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">procedure</span> <span class="title">ins</span><span class="params">(x,k:int)</span>;</span></span><br><span class="line"><span class="keyword">begin</span></span><br><span class="line">    inc(hs);l[x]:=hs;</span><br><span class="line">    h[hs,<span class="number">1</span>]:=x;h[hs,<span class="number">0</span>]:=inf;red(hs,k);</span><br><span class="line"><span class="keyword">end</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">procedure</span> <span class="title">dij</span><span class="params">()</span>;</span></span><br><span class="line"><span class="keyword">var</span> i,u,v:int;</span><br><span class="line"><span class="keyword">begin</span></span><br><span class="line">    hs:=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> i:=<span class="number">1</span> <span class="keyword">to</span> n*(k+<span class="number">1</span>) <span class="keyword">do</span></span><br><span class="line">        <span class="keyword">if</span> i=s <span class="keyword">then</span> ins(i,<span class="number">0</span>) <span class="keyword">else</span> ins(i,inf);</span><br><span class="line">    <span class="keyword">while</span> hs&gt;<span class="number">0</span> <span class="keyword">do</span> <span class="keyword">begin</span></span><br><span class="line">        u:=h[<span class="number">1</span>,<span class="number">1</span>];d[u]:=h[<span class="number">1</span>,<span class="number">0</span>];ext;</span><br><span class="line">        <span class="comment">//writeln('&gt;',u,' ',d[u]);</span></span><br><span class="line">        i:=head[u];</span><br><span class="line">        <span class="keyword">while</span> i&lt;&gt;<span class="number">0</span> <span class="keyword">do</span> <span class="keyword">begin</span></span><br><span class="line">            v:=g[i].v;</span><br><span class="line">            <span class="keyword">if</span> h[l[v],<span class="number">0</span>]&gt;d[u]+g[i].w <span class="keyword">then</span> </span><br><span class="line">                red(l[v],d[u]+g[i].w);</span><br><span class="line">            i:=g[i].next;</span><br><span class="line">        <span class="keyword">end</span>;</span><br><span class="line">    <span class="keyword">end</span>;</span><br><span class="line"><span class="keyword">end</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">begin</span></span><br><span class="line">    assign(input,<span class="string">'move.in'</span>);reset(input);</span><br><span class="line">    assign(output,<span class="string">'move.out'</span>);rewrite(output);</span><br><span class="line">    <span class="keyword">read</span>(n,m,k,s,t);inc(s);inc(t);</span><br><span class="line">    <span class="keyword">for</span> i:=<span class="number">1</span> <span class="keyword">to</span> m <span class="keyword">do</span> <span class="keyword">begin</span></span><br><span class="line">        <span class="keyword">read</span>(u,v,w);inc(u);inc(v);</span><br><span class="line">        add(u,v,w);add(v,u,w);</span><br><span class="line">        <span class="keyword">for</span> j:=<span class="number">1</span> <span class="keyword">to</span> k <span class="keyword">do</span> <span class="keyword">begin</span></span><br><span class="line">            add(u+j*n,v+j*n,w);add(u+(j-<span class="number">1</span>)*n,v+j*n,<span class="number">0</span>);</span><br><span class="line">            add(v+j*n,u+j*n,w);add(v+(j-<span class="number">1</span>)*n,u+j*n,<span class="number">0</span>);</span><br><span class="line">        <span class="keyword">end</span>;</span><br><span class="line">    <span class="keyword">end</span>;</span><br><span class="line">    dij();</span><br><span class="line">    <span class="keyword">write</span>(d[t+k*n]);</span><br><span class="line">    close(input);close(output);</span><br><span class="line"><span class="keyword">end</span>.</span><br></pre></td></tr></table></figure><br><br></div></div>


<h1 id="P4-Hzwer的陨石"><a href="#P4-Hzwer的陨石" class="headerlink" title="P4 Hzwer的陨石"></a>P4 Hzwer的陨石</h1><p>经过不懈的努力，Hzwer召唤了很多陨石。已知Hzwer的地图上共有n个区域，且一开始的时候第i个陨石掉在了第i个区域。有电力喷射背包的ndsf很自豪，他认为搬陨石很容易，所以他将一些区域的陨石全搬到了另外一些区域。<br>在ndsf愉快的搬运过程中，Hzwer想知道一些陨石的信息。对于Hzwer询问的每个陨石i，你必须告诉他，在当前这个时候，i号陨石在所在区域x、x区域共有的陨石数y、以及i号陨石被搬运的次数z。<br><!--more--></p>
<h2 id="格式-3"><a href="#格式-3" class="headerlink" title="格式"></a>格式</h2><h3 id="输入格式-3"><a href="#输入格式-3" class="headerlink" title="输入格式"></a>输入格式</h3><p>输入的第一行是一个正整数T。表示有多少组输入数据。<br>接下来共有T组数据，对于每组数据，第一行包含两个整数：N和Q。<br>接下来Q行，每行表示一次搬运或一次询问，格式如下：<br>T A B：表示搬运，即将所有在A号球所在地区的陨石都搬到B号球所在地区去。<br>Q A：悟空想知道Ａ号陨石的x，y，z。</p>
<h3 id="输出格式-3"><a href="#输出格式-3" class="headerlink" title="输出格式"></a>输出格式</h3><p>对于第ｉ组数据，第一行输出“Case i：”接下来输出每一个询问操作的x，y，z，每一个询问操作的答案占一行。每组数据之间没有空行。</p>
<h2 id="样例-3"><a href="#样例-3" class="headerlink" title="样例"></a>样例</h2><h3 id="样例输入-3"><a href="#样例输入-3" class="headerlink" title="样例输入"></a>样例输入</h3><blockquote>
<p>2<br>3 3<br>T 1 2<br>T 3 2<br>Q 2<br>3 4<br>T 1 2<br>Q 1<br>T 1 3<br>Q 1</p>
</blockquote>
<h3 id="样例输出-3"><a href="#样例输出-3" class="headerlink" title="样例输出"></a>样例输出</h3><blockquote>
<p>Case 1：<br>2 3 0<br>Case 2：<br>2 2 1<br>3 3 2</p>
</blockquote>
<h2 id="提示​-3"><a href="#提示​-3" class="headerlink" title="提示​"></a>提示​</h2><p>数据范围：<br>20%的数据保证：0≤T≤20，2＜N＜＝100，2＜Q＜＝100。<br>100%的数据保证：0≤T≤100，2＜N＜＝10000，2＜Q＜＝10000。<br>对于所有数据保证搬运操作中AB在Ｎ的范围内且所在区域不相同。</p>
<h2 id="题解-3"><a href="#题解-3" class="headerlink" title="题解"></a>题解</h2><p>带权并查集，用向量关系表示节点与父节点的移动次数差，区域编号就是根的编号，至于个数随便加加就好了</p>
<div><br><div class="copy"><br>    <a href="/2016/10/04/noip-2014-10-31-1/meteorite.pas" title="{plain text}">{plain text}</a><br></div><br><div><br><figure class="highlight delphi"><figcaption><span>meteorite.pas</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> int=longint;</span><br><span class="line"><span class="keyword">var</span> </span><br><span class="line">    par,w,s:<span class="keyword">array</span>[<span class="number">0</span>..<span class="number">10010</span>] <span class="keyword">of</span> int;</span><br><span class="line">    t,n,m,i,j,x,y:int;c:char;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">find</span><span class="params">(x:int)</span>:</span>int;</span><br><span class="line"><span class="keyword">begin</span></span><br><span class="line">    <span class="keyword">if</span> par[x]=x <span class="keyword">then</span> find:=x</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">begin</span></span><br><span class="line">        find:=find(par[x]);</span><br><span class="line">        inc(w[x],w[par[x]]);</span><br><span class="line">        par[x]:=find;</span><br><span class="line">    <span class="keyword">end</span>;</span><br><span class="line"><span class="keyword">end</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">procedure</span> <span class="title">union</span><span class="params">(x,y:int)</span>;</span> <span class="comment">//x-&gt;y</span></span><br><span class="line"><span class="keyword">begin</span></span><br><span class="line">    x:=find(x);y:=find(y);</span><br><span class="line">    par[x]:=y;inc(s[y],s[x]);</span><br><span class="line">    inc(w[x]);w[x]:=w[y]-w[x];</span><br><span class="line"><span class="keyword">end</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">procedure</span> <span class="title">query</span><span class="params">(x:int)</span>;</span></span><br><span class="line"><span class="keyword">begin</span></span><br><span class="line">    y:=find(x);writeln(y,<span class="string">' '</span>,s[y],<span class="string">' '</span>,w[y]-w[x]);</span><br><span class="line"><span class="keyword">end</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">begin</span></span><br><span class="line">    assign(input,<span class="string">'meteorite.in'</span>);reset(input);</span><br><span class="line">    assign(output,<span class="string">'meteorite.out'</span>);rewrite(output);</span><br><span class="line">    readln(t);</span><br><span class="line">    <span class="keyword">for</span> j:=<span class="number">1</span> <span class="keyword">to</span> t <span class="keyword">do</span> <span class="keyword">begin</span></span><br><span class="line">        readln(n,m);</span><br><span class="line">        <span class="keyword">for</span> i:=<span class="number">1</span> <span class="keyword">to</span> n <span class="keyword">do</span> <span class="keyword">begin</span> </span><br><span class="line">            par[i]:=i;w[i]:=<span class="number">0</span>;s[i]:=<span class="number">1</span></span><br><span class="line">        <span class="keyword">end</span>;</span><br><span class="line">        writeln(<span class="string">'Case '</span>,j,<span class="string">': '</span>);</span><br><span class="line">        <span class="keyword">for</span> i:=<span class="number">1</span> <span class="keyword">to</span> m <span class="keyword">do</span> <span class="keyword">begin</span></span><br><span class="line">            <span class="keyword">read</span>(c);</span><br><span class="line">            <span class="keyword">case</span> c <span class="keyword">of</span> </span><br><span class="line">                <span class="string">'T'</span>:<span class="keyword">begin</span> readln(x,y);union(x,y) <span class="keyword">end</span>;</span><br><span class="line">                <span class="string">'Q'</span>:<span class="keyword">begin</span> readln(x);query(x) <span class="keyword">end</span>;</span><br><span class="line">            <span class="keyword">end</span>;</span><br><span class="line">        <span class="keyword">end</span>;</span><br><span class="line">    <span class="keyword">end</span>;</span><br><span class="line">    close(input);close(output);</span><br><span class="line"><span class="keyword">end</span>.</span><br></pre></td></tr></table></figure><br><br></div></div>
]]></content>
    
    <summary type="html">
    
      &lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th style=&quot;text-align:center&quot;&gt;题目&lt;/th&gt;
&lt;th style=&quot;text-align:center&quot;&gt;思路&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td style=&quot;text-align:center&quot;&gt;and&lt;/td&gt;
&lt;td style=&quot;text-align:center&quot;&gt;位运算+贪心&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td style=&quot;text-align:center&quot;&gt;elephant&lt;/td&gt;
&lt;td style=&quot;text-align:center&quot;&gt;概率期望+DP&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td style=&quot;text-align:center&quot;&gt;move&lt;/td&gt;
&lt;td style=&quot;text-align:center&quot;&gt;分层图最短路&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td style=&quot;text-align:center&quot;&gt;meteorite&lt;/td&gt;
&lt;td style=&quot;text-align:center&quot;&gt;带权并查集&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;h1 id=&quot;P1-“与”&quot;&gt;&lt;a href=&quot;#P1-“与”&quot; class=&quot;headerlink&quot; title=&quot;P1 “与”&quot;&gt;&lt;/a&gt;P1 “与”&lt;/h1&gt;&lt;p&gt;给你一个长度为n的序列A，请你求出一对Ai，Aj（&lt;span&gt;$1&amp;le;i&amp;lt;j&amp;le;n$&lt;/span&gt;&lt;!-- Has MathJax --&gt;）使Ai“与”Aj最大。&lt;br&gt;Ps：“与”表示位运算and，在c++中表示为&amp;amp;。&lt;/p&gt;
    
    </summary>
    
      <category term="Problem Set" scheme="https://cothrax.github.io/categories/Problem-Set/"/>
    
    
      <category term="OI" scheme="https://cothrax.github.io/tags/OI/"/>
    
      <category term="数据结构" scheme="https://cothrax.github.io/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"/>
    
      <category term="并查集" scheme="https://cothrax.github.io/tags/%E5%B9%B6%E6%9F%A5%E9%9B%86/"/>
    
      <category term="DP" scheme="https://cothrax.github.io/tags/DP/"/>
    
      <category term="图论" scheme="https://cothrax.github.io/tags/%E5%9B%BE%E8%AE%BA/"/>
    
      <category term="最短路" scheme="https://cothrax.github.io/tags/%E6%9C%80%E7%9F%AD%E8%B7%AF/"/>
    
      <category term="贪心" scheme="https://cothrax.github.io/tags/%E8%B4%AA%E5%BF%83/"/>
    
      <category term="概率期望" scheme="https://cothrax.github.io/tags/%E6%A6%82%E7%8E%87%E6%9C%9F%E6%9C%9B/"/>
    
      <category term="位运算" scheme="https://cothrax.github.io/tags/%E4%BD%8D%E8%BF%90%E7%AE%97/"/>
    
      <category term="数学" scheme="https://cothrax.github.io/tags/%E6%95%B0%E5%AD%A6/"/>
    
      <category term="分层图" scheme="https://cothrax.github.io/tags/%E5%88%86%E5%B1%82%E5%9B%BE/"/>
    
  </entry>
  
  <entry>
    <title>NOIP模拟赛 graph</title>
    <link href="https://cothrax.github.io/2016/10/04/noip-2014-10-30-1-graph/"/>
    <id>https://cothrax.github.io/2016/10/04/noip-2014-10-30-1-graph/</id>
    <published>2016-10-04T14:00:22.000Z</published>
    <updated>2016-10-30T06:06:17.294Z</updated>
    
    <content type="html"><![CDATA[<p>这份模拟赛的后2题都在前面的比赛中出现过了。</p>
<h2 id="描述"><a href="#描述" class="headerlink" title="描述"></a>描述</h2><p>给出 N 个点，M 条边的有向图，对于每个点 v，求 A(v) 表示从点 v 出发，能到达的编号最大的点。<br><a id="more"></a></p>
<h2 id="格式"><a href="#格式" class="headerlink" title="格式"></a>格式</h2><h3 id="输入格式"><a href="#输入格式" class="headerlink" title="输入格式"></a>输入格式</h3><p>第 1 行，2 个整数 N,M。 接下来 M 行，每行 2 个整数 Ui,Vi，表示边 ⟨Ui,Vi⟩。点用 1,2,…,N 编号。</p>
<h3 id="输出格式"><a href="#输出格式" class="headerlink" title="输出格式"></a>输出格式</h3><p>N 个整数 A(1),A(2),…,A(N)。</p>
<h2 id="样例"><a href="#样例" class="headerlink" title="样例"></a>样例</h2><h3 id="样例输入"><a href="#样例输入" class="headerlink" title="样例输入"></a>样例输入</h3><blockquote>
<p>4 3<br>1 2<br>2 4<br>4 3</p>
</blockquote>
<h3 id="样例输出"><a href="#样例输出" class="headerlink" title="样例输出"></a>样例输出</h3><blockquote>
<p>4 4 3 4</p>
</blockquote>
<h2 id="提示​"><a href="#提示​" class="headerlink" title="提示​"></a>提示​</h2><p>对于 60% 的数据，1 ≤ N,K ≤ 10^3<br>对于 100% 的数据，1 ≤ N,M ≤ 10^5。</p>
<h2 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h2><p>标程是强连通分量+DAG+DP<br>其实乱搞就可以了，参见noip提高的最优贸易那题<br>在转置图上，类似spfa进行松弛即可：<br>对于转置边e(v,u)，如果A(v)&gt;A(u)，那么更新A(u)，且u入队</p>
<div><br><div class="copy"><br>    <a href="/2016/10/04/noip-2014-10-30-1-graph/graph.pas" title="{plain text}">{plain text}</a><br></div><br><div><br><figure class="highlight delphi"><figcaption><span>graph.pas</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> </span><br><span class="line">    int=longint;</span><br><span class="line">    edge=<span class="keyword">record</span> u,next:int <span class="keyword">end</span>;</span><br><span class="line"><span class="keyword">var</span> </span><br><span class="line">    g:<span class="keyword">array</span>[<span class="number">0</span>..<span class="number">100010</span>] <span class="keyword">of</span> edge;</span><br><span class="line">    head,w,q:<span class="keyword">array</span>[<span class="number">0</span>..<span class="number">100010</span>] <span class="keyword">of</span> int;</span><br><span class="line">    inq:<span class="keyword">array</span>[<span class="number">0</span>..<span class="number">100010</span>] <span class="keyword">of</span> boolean;</span><br><span class="line">    n,m,i,v,u,sz,h,t:int;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">procedure</span> <span class="title">add</span><span class="params">(v,u:int)</span>;</span></span><br><span class="line"><span class="keyword">begin</span></span><br><span class="line">    inc(sz);g[sz].u:=u;</span><br><span class="line">    g[sz].next:=head[v];head[v]:=sz;</span><br><span class="line"><span class="keyword">end</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">begin</span></span><br><span class="line">    assign(input,<span class="string">'graph.in'</span>);reset(input);</span><br><span class="line">    assign(output,<span class="string">'graph.out'</span>);rewrite(output);</span><br><span class="line">    <span class="keyword">read</span>(n,m);sz:=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> i:=<span class="number">1</span> <span class="keyword">to</span> m <span class="keyword">do</span> <span class="keyword">begin</span></span><br><span class="line">        <span class="keyword">read</span>(v,u);add(u,v);</span><br><span class="line">    <span class="keyword">end</span>;</span><br><span class="line">    h:=<span class="number">1</span>;t:=n+<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span> i:=<span class="number">1</span> <span class="keyword">to</span> n <span class="keyword">do</span> <span class="keyword">begin</span></span><br><span class="line">        w[i]:=i;q[i]:=n-i+<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">end</span>;</span><br><span class="line">    fillchar(inq,sizeof(inq),true);</span><br><span class="line">    <span class="keyword">while</span> h&lt;&gt;t <span class="keyword">do</span> <span class="keyword">begin</span></span><br><span class="line">        v:=q[h];inq[v]:=false;<span class="comment">//writeln(v);</span></span><br><span class="line">        inc(h);<span class="keyword">if</span> h&gt;<span class="number">100010</span> <span class="keyword">then</span> h:=<span class="number">0</span>;</span><br><span class="line">        i:=head[v];</span><br><span class="line">        <span class="keyword">while</span> i&lt;&gt;<span class="number">0</span> <span class="keyword">do</span> <span class="keyword">begin</span></span><br><span class="line">            u:=g[i].u;</span><br><span class="line">            <span class="keyword">if</span> w[u]&lt;w[v] <span class="keyword">then</span> <span class="keyword">begin</span></span><br><span class="line">                w[u]:=w[v];<span class="comment">//writeln(v,'-&gt;',u);</span></span><br><span class="line">                <span class="keyword">if</span> <span class="keyword">not</span> inq[u] <span class="keyword">then</span> <span class="keyword">begin</span></span><br><span class="line">                    q[t]:=u;inq[u]:=true;</span><br><span class="line">                    inc(t);<span class="keyword">if</span> t&gt;<span class="number">100010</span> <span class="keyword">then</span> t:=<span class="number">0</span>;</span><br><span class="line">                <span class="keyword">end</span>;</span><br><span class="line">            <span class="keyword">end</span>;</span><br><span class="line">            i:=g[i].next;</span><br><span class="line">        <span class="keyword">end</span>;</span><br><span class="line">    <span class="keyword">end</span>;</span><br><span class="line">    <span class="keyword">for</span> i:=<span class="number">1</span> <span class="keyword">to</span> n <span class="keyword">do</span> <span class="keyword">write</span>(w[i],<span class="string">' '</span>);</span><br><span class="line">    close(input);close(output);</span><br><span class="line"><span class="keyword">end</span>.</span><br></pre></td></tr></table></figure><br><br></div></div>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;这份模拟赛的后2题都在前面的比赛中出现过了。&lt;/p&gt;
&lt;h2 id=&quot;描述&quot;&gt;&lt;a href=&quot;#描述&quot; class=&quot;headerlink&quot; title=&quot;描述&quot;&gt;&lt;/a&gt;描述&lt;/h2&gt;&lt;p&gt;给出 N 个点，M 条边的有向图，对于每个点 v，求 A(v) 表示从点 v 出发，能到达的编号最大的点。&lt;br&gt;
    
    </summary>
    
      <category term="Problem Set" scheme="https://cothrax.github.io/categories/Problem-Set/"/>
    
    
      <category term="OI" scheme="https://cothrax.github.io/tags/OI/"/>
    
      <category term="图论" scheme="https://cothrax.github.io/tags/%E5%9B%BE%E8%AE%BA/"/>
    
  </entry>
  
  <entry>
    <title>NOIP2016十连测 Day 2</title>
    <link href="https://cothrax.github.io/2016/10/03/lydsy-noip-2016-test2/"/>
    <id>https://cothrax.github.io/2016/10/03/lydsy-noip-2016-test2/</id>
    <published>2016-10-03T01:42:00.000Z</published>
    <updated>2016-10-30T06:06:17.059Z</updated>
    
    <content type="html"><![CDATA[<p>160滚粗，T1很db地写了hash，T2没想到二分而暴力询问，inf开的不够大又丢了20分，T3完全不会，暴力20分</p>
<h1 id="T1-Divisors"><a href="#T1-Divisors" class="headerlink" title="T1 Divisors"></a>T1 Divisors</h1><p>大意：给定m个不同的正整数 <span>$a_1,a_2,...,a_m$</span><!-- Has MathJax -->，对$[0,m]$内每一个k计算：在区间$[1,n]$里有多少正整数是a中恰好k个数的约数。<br>$m≤200;n,a_i≤10^9$ 。<br><a id="more"></a></p>
<h2 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h2><p>计算每个$a_i$在$[1,n]$内的约数，然后去重计数即可。我sb的用了hash，其实qsort+for就好。</p>
<div><br><div class="copy"><br>    <a href="/2016/10/03/lydsy-noip-2016-test2/div.pas" title="{plain text}">{plain text}</a><br></div><br><div><br><figure class="highlight delphi"><figcaption><span>div.pas</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">uses</span> math;</span><br><span class="line"><span class="keyword">type</span> int=longint;</span><br><span class="line"><span class="keyword">const</span> md=<span class="number">1001003</span>;</span><br><span class="line"><span class="keyword">var</span></span><br><span class="line">    a,ans:<span class="keyword">array</span>[<span class="number">0</span>..<span class="number">210</span>] <span class="keyword">of</span> int;</span><br><span class="line">    h,next,cnt:<span class="keyword">array</span>[<span class="number">0</span>..<span class="number">10000000</span>] <span class="keyword">of</span> int;</span><br><span class="line">    head:<span class="keyword">array</span>[<span class="number">0</span>..md] <span class="keyword">of</span> int;</span><br><span class="line">    sz,n,m,i,tot:int;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">procedure</span> <span class="title">insert</span><span class="params">(x:int)</span>;</span></span><br><span class="line"><span class="keyword">var</span> i,j:int;</span><br><span class="line"><span class="keyword">begin</span></span><br><span class="line">    j:=x <span class="keyword">mod</span> md;</span><br><span class="line">    <span class="keyword">if</span> head[j]=<span class="number">0</span> <span class="keyword">then</span> <span class="keyword">begin</span></span><br><span class="line">        inc(sz);head[j]:=sz;</span><br><span class="line">        h[sz]:=x;cnt[sz]:=<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">exit</span>;</span><br><span class="line">    <span class="keyword">end</span>;</span><br><span class="line">    i:=head[j];</span><br><span class="line">    <span class="keyword">while</span> next[i]&lt;&gt;<span class="number">0</span> <span class="keyword">do</span> <span class="keyword">begin</span></span><br><span class="line">        <span class="keyword">if</span> h[i]=x <span class="keyword">then</span> <span class="keyword">begin</span> inc(cnt[i]);<span class="keyword">exit</span> <span class="keyword">end</span>;</span><br><span class="line">        i:=next[i];</span><br><span class="line">    <span class="keyword">end</span>;</span><br><span class="line">    <span class="keyword">if</span> h[i]=x <span class="keyword">then</span> <span class="keyword">begin</span> inc(cnt[i]);<span class="keyword">exit</span> <span class="keyword">end</span>;</span><br><span class="line">    inc(sz);next[i]:=sz;</span><br><span class="line">    h[sz]:=x;cnt[sz]:=<span class="number">1</span>;</span><br><span class="line"><span class="keyword">end</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">procedure</span> <span class="title">calc</span><span class="params">(x:int)</span>;</span></span><br><span class="line"><span class="keyword">var</span> i:int;</span><br><span class="line"><span class="keyword">begin</span></span><br><span class="line">    <span class="keyword">for</span> i:=<span class="number">1</span> <span class="keyword">to</span> trunc(sqrt(x)) <span class="keyword">do</span></span><br><span class="line">        <span class="keyword">if</span> x <span class="keyword">mod</span> i=<span class="number">0</span> <span class="keyword">then</span> <span class="keyword">begin</span></span><br><span class="line">            insert(i);</span><br><span class="line">            <span class="keyword">if</span> i&lt;&gt;x <span class="keyword">div</span> i <span class="keyword">then</span> insert(x <span class="keyword">div</span> i);</span><br><span class="line">        <span class="keyword">end</span>;</span><br><span class="line"><span class="keyword">end</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">begin</span></span><br><span class="line">    <span class="comment">//assign(input,'div.in');reset(input);</span></span><br><span class="line">    <span class="comment">//assign(output,'div.out');rewrite(output);</span></span><br><span class="line">    <span class="keyword">read</span>(n,m);</span><br><span class="line">    sz:=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> i:=<span class="number">1</span> <span class="keyword">to</span> m <span class="keyword">do</span> <span class="keyword">read</span>(a[i]);</span><br><span class="line">    <span class="keyword">for</span> i:=<span class="number">1</span> <span class="keyword">to</span> m <span class="keyword">do</span> calc(a[i]);</span><br><span class="line">    tot:=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> i:=<span class="number">1</span> <span class="keyword">to</span> sz <span class="keyword">do</span> </span><br><span class="line">        <span class="keyword">if</span> h[i]&lt;=n <span class="keyword">then</span> <span class="keyword">begin</span></span><br><span class="line">            inc(tot);</span><br><span class="line">            <span class="keyword">if</span> cnt[i]&lt;=m <span class="keyword">then</span> inc(ans[cnt[i]]);</span><br><span class="line">        <span class="keyword">end</span>;</span><br><span class="line">    writeln(n-tot);</span><br><span class="line">    <span class="keyword">for</span> i:=<span class="number">1</span> <span class="keyword">to</span> m <span class="keyword">do</span> writeln(ans[i]);</span><br><span class="line">    <span class="comment">//close(input);close(output);</span></span><br><span class="line"><span class="keyword">end</span>.</span><br></pre></td></tr></table></figure><br><br></div></div>

<h1 id="T2-Market"><a href="#T2-Market" class="headerlink" title="T2 Market"></a>T2 Market</h1><p>给定n个物品，每个物品可以不选或选一个，第i个物品的价格为ci,价值为vi,出现时间为ti。有m个询问，每次询问在出现时间不超过Ti的所有物品中选若干件,总花费不超过Mi的情况下,被选择物品的价值和的最大值是多少。<br>$n≤300,m≤100000;c_i,M_i≤10^9,v_i≤300$</p>
<!--more-->
<h2 id="题解-1"><a href="#题解-1" class="headerlink" title="题解"></a>题解</h2><p>先将物品qsort升序<br>首先想到01背包，但c和M太大无法承受。<br>考虑到vi很小：记f[i,j]为1..i件物品选出j的价值和的最小花费<br>$O(N^3)$，空间刚好足够<br>对于一个询问的答案就是：<br>算出在Ti时间内所能购买的物品范围[1,x]<br>答案就是满足$f[x,j]≤Mi$的最大j<br>暴力处理询问的话依然会TLE<br>于是二分：<br>记g[x,j]为f[x,j…]的最小值，这样g[x]就是单调增的<br>答案就是满足$g[x,j]≤Mi$的最大j</p>
<div><br><div class="copy"><br>    <a href="/2016/10/03/lydsy-noip-2016-test2/market.pas" title="{plain text}">{plain text}</a><br></div><br><div><br><figure class="highlight delphi"><figcaption><span>market.pas</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">uses</span> math;</span><br><span class="line"><span class="keyword">type</span> int=longint;</span><br><span class="line"><span class="keyword">const</span> inf=<span class="number">1000000010</span>;</span><br><span class="line"><span class="keyword">var</span></span><br><span class="line">    v,t,c,sum:<span class="keyword">array</span>[<span class="number">0</span>..<span class="number">310</span>] <span class="keyword">of</span> int;</span><br><span class="line">    f:<span class="keyword">array</span>[<span class="number">0</span>..<span class="number">310</span>,<span class="number">0</span>..<span class="number">90010</span>] <span class="keyword">of</span> int;</span><br><span class="line">    n,m,i:int;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">procedure</span> <span class="title">swap</span><span class="params">(<span class="keyword">var</span> a,b:int)</span>;</span></span><br><span class="line"><span class="keyword">var</span> tmp:int;</span><br><span class="line"><span class="keyword">begin</span> tmp:=a;a:=b;b:=tmp <span class="keyword">end</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">procedure</span> <span class="title">qsort</span><span class="params">(l,r:int)</span>;</span></span><br><span class="line"><span class="keyword">var</span> i,j,x:int;</span><br><span class="line"><span class="keyword">begin</span></span><br><span class="line">    i:=l;j:=r;x:=t[random(r-l)+l];</span><br><span class="line">    <span class="keyword">repeat</span></span><br><span class="line">        <span class="keyword">while</span> t[i]&lt;x <span class="keyword">do</span> inc(i);</span><br><span class="line">        <span class="keyword">while</span> t[j]&gt;x <span class="keyword">do</span> dec(j);</span><br><span class="line">        <span class="keyword">if</span> i&lt;=j <span class="keyword">then</span> <span class="keyword">begin</span></span><br><span class="line">            swap(t[i],t[j]);swap(v[i],v[j]);swap(c[i],c[j]);</span><br><span class="line">            inc(i);dec(j);</span><br><span class="line">        <span class="keyword">end</span>;</span><br><span class="line">    <span class="keyword">until</span> i&gt;j;</span><br><span class="line">    <span class="keyword">if</span> i&lt;r <span class="keyword">then</span> qsort(i,r);</span><br><span class="line">    <span class="keyword">if</span> l&lt;j <span class="keyword">then</span> qsort(l,j);</span><br><span class="line"><span class="keyword">end</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">procedure</span> <span class="title">dp</span><span class="params">()</span>;</span></span><br><span class="line"><span class="keyword">var</span> i,j:int;</span><br><span class="line"><span class="keyword">begin</span></span><br><span class="line">    sum[<span class="number">0</span>]:=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> i:=<span class="number">1</span> <span class="keyword">to</span> n <span class="keyword">do</span> sum[i]:=sum[i-<span class="number">1</span>]+v[i];</span><br><span class="line">    filldword(f,sizeof(f) <span class="keyword">div</span> <span class="number">4</span>,inf);</span><br><span class="line">    f[<span class="number">0</span>,<span class="number">0</span>]:=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> i:=<span class="number">1</span> <span class="keyword">to</span> n <span class="keyword">do</span></span><br><span class="line">        <span class="keyword">for</span> j:=<span class="number">0</span> <span class="keyword">to</span> sum[i] <span class="keyword">do</span> <span class="keyword">begin</span></span><br><span class="line">            f[i,j]:=f[i-<span class="number">1</span>,j];</span><br><span class="line">            <span class="keyword">if</span> j&gt;=v[i] <span class="keyword">then</span> </span><br><span class="line">                f[i,j]:=min(f[i,j],f[i-<span class="number">1</span>,j-v[i]]+c[i]);</span><br><span class="line">        <span class="keyword">end</span>;</span><br><span class="line">    <span class="keyword">for</span> i:=<span class="number">1</span> <span class="keyword">to</span> n <span class="keyword">do</span></span><br><span class="line">        <span class="keyword">for</span> j:=sum[i]-<span class="number">1</span> <span class="keyword">downto</span> <span class="number">0</span> <span class="keyword">do</span></span><br><span class="line">            f[i,j]:=min(f[i,j],f[i,j+<span class="number">1</span>]);</span><br><span class="line"><span class="keyword">end</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">calc</span><span class="params">()</span>:</span>int;</span><br><span class="line"><span class="keyword">var</span> l,r,mid,x,t0,m0:int;</span><br><span class="line"><span class="keyword">begin</span></span><br><span class="line">    <span class="keyword">read</span>(t0,m0);</span><br><span class="line">    l:=<span class="number">1</span>;r:=n;x:=-<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">while</span> l&lt;=r <span class="keyword">do</span> <span class="keyword">begin</span></span><br><span class="line">        mid:=(l+r) <span class="keyword">shr</span> <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">if</span> t[mid]&lt;=t0 <span class="keyword">then</span> <span class="keyword">begin</span> x:=mid;l:=mid+<span class="number">1</span> <span class="keyword">end</span></span><br><span class="line">        <span class="keyword">else</span> r:=mid-<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">end</span>;</span><br><span class="line">    <span class="keyword">if</span> x=-<span class="number">1</span> <span class="keyword">then</span> <span class="keyword">exit</span>(<span class="number">0</span>);</span><br><span class="line">    l:=<span class="number">0</span>;r:=sum[x];calc:=<span class="number">0</span>;</span><br><span class="line">    <span class="comment">//max_v&#123;f[x,v]&lt;=m0&#125;</span></span><br><span class="line">    <span class="keyword">while</span> l&lt;=r <span class="keyword">do</span> <span class="keyword">begin</span></span><br><span class="line">        mid:=(l+r) <span class="keyword">shr</span> <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">if</span> f[x,mid]&lt;=m0 <span class="keyword">then</span> <span class="keyword">begin</span> calc:=mid;l:=mid+<span class="number">1</span> <span class="keyword">end</span></span><br><span class="line">        <span class="keyword">else</span> r:=mid-<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">end</span>;</span><br><span class="line"><span class="keyword">end</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">begin</span></span><br><span class="line">    <span class="comment">//assign(input,'market.in');reset(input);</span></span><br><span class="line">    <span class="comment">//assign(output,'market.ans');rewrite(output);</span></span><br><span class="line">    <span class="keyword">read</span>(n,m);</span><br><span class="line">    <span class="keyword">for</span> i:=<span class="number">1</span> <span class="keyword">to</span> n <span class="keyword">do</span> <span class="keyword">read</span>(c[i],v[i],t[i]);</span><br><span class="line">    qsort(<span class="number">1</span>,n);dp();</span><br><span class="line">    <span class="keyword">for</span> i:=<span class="number">1</span> <span class="keyword">to</span> m <span class="keyword">do</span> writeln(calc());</span><br><span class="line">    <span class="comment">//close(input);close(output);</span></span><br><span class="line"><span class="keyword">end</span>.</span><br></pre></td></tr></table></figure><br><br></div></div>

<h1 id="T3-Dash-Speed"><a href="#T3-Dash-Speed" class="headerlink" title="T3 Dash Speed"></a>T3 Dash Speed</h1><p>给定一棵有n个点的树,每条边有承受区间[li,ri]。m次询问,每次给定一个值speed,求一条最长的链,使得上面所有边的承受区间都包括speed。</p>
<h2 id="题解-2"><a href="#题解-2" class="headerlink" title="题解"></a>题解</h2><p>树剖+线段树+并查集+分治，std都破100行了，如果我写不是要300+吗<br>来欣赏一下std吧</p>
<div><br><div class="copy"><br>    <a href="/2016/10/03/lydsy-noip-2016-test2/speed.cpp" title="{plain text}">{plain text}</a><br></div><br><div><br><figure class="highlight cpp"><figcaption><span>speed.cpp</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N=<span class="number">70010</span>,M=N*<span class="number">20</span>;</span><br><span class="line"><span class="keyword">int</span> n,m,i,g[N],v[N&lt;&lt;<span class="number">1</span>],nxt[N&lt;&lt;<span class="number">1</span>],ed,cur,ans[N];</span><br><span class="line"><span class="keyword">int</span> size[N],f[N],d[N],son[N],top[N];</span><br><span class="line"><span class="keyword">int</span> fa[N],dep[N],A[N],B[N];</span><br><span class="line"><span class="keyword">int</span> G[<span class="number">262150</span>],V[M],W[M],NXT[M],ED;</span><br><span class="line"><span class="keyword">struct</span> E&#123;<span class="keyword">int</span> t,x,y;E()&#123;&#125;E(<span class="keyword">int</span> <span class="keyword">_t</span>,<span class="keyword">int</span> _x,<span class="keyword">int</span> _y)&#123;t=<span class="keyword">_t</span>,x=_x,y=_y;&#125;&#125;q[N&lt;&lt;<span class="number">2</span>];</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">add</span><span class="params">(<span class="keyword">int</span> x,<span class="keyword">int</span> y)</span></span>&#123;v[++ed]=y;nxt[ed]=g[x];g[x]=ed;&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">dfs</span><span class="params">(<span class="keyword">int</span> x)</span></span>&#123;</span><br><span class="line">    size[x]=<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=g[x];i;i=nxt[i])<span class="keyword">if</span>(v[i]!=f[x])&#123;</span><br><span class="line">        f[v[i]]=x,d[v[i]]=d[x]+<span class="number">1</span>;</span><br><span class="line">        dfs(v[i]),size[x]+=size[v[i]];</span><br><span class="line">        <span class="keyword">if</span>(size[v[i]]&gt;size[son[x]])son[x]=v[i];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">dfs2</span><span class="params">(<span class="keyword">int</span> x,<span class="keyword">int</span> y)</span></span>&#123;</span><br><span class="line">    top[x]=y;</span><br><span class="line">    <span class="keyword">if</span>(son[x])dfs2(son[x],y);</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=g[x];i;i=nxt[i])<span class="keyword">if</span>(v[i]!=son[x]&amp;&amp;v[i]!=f[x])dfs2(v[i],v[i]);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">lca</span><span class="params">(<span class="keyword">int</span> x,<span class="keyword">int</span> y)</span></span>&#123;</span><br><span class="line">    <span class="keyword">for</span>(;top[x]!=top[y];x=f[top[x]])<span class="keyword">if</span>(d[top[x]]&lt;d[top[y]])swap(x,y);</span><br><span class="line">    <span class="keyword">return</span> d[x]&lt;d[y]?x:y;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">dis</span><span class="params">(<span class="keyword">int</span> x,<span class="keyword">int</span> y)</span></span>&#123;<span class="keyword">return</span> d[x]+d[y]<span class="number">-2</span>*d[lca(x,y)];&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">F</span><span class="params">(<span class="keyword">int</span> x)</span></span>&#123;<span class="keyword">return</span> fa[x]==x?x:F(fa[x]);&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">merge</span><span class="params">(<span class="keyword">int</span> x,<span class="keyword">int</span> y,<span class="keyword">int</span>&amp;ret)</span></span>&#123;</span><br><span class="line">    x=F(x),y=F(y);</span><br><span class="line">    <span class="keyword">int</span> u,v,t=<span class="number">-1</span>,tmp;</span><br><span class="line">    tmp=dis(A[x],B[x]);</span><br><span class="line">    <span class="keyword">if</span>(tmp&gt;t)t=tmp,u=A[x],v=B[x];</span><br><span class="line">    tmp=dis(A[x],A[y]);</span><br><span class="line">    <span class="keyword">if</span>(tmp&gt;t)t=tmp,u=A[x],v=A[y];</span><br><span class="line">    tmp=dis(A[x],B[y]);</span><br><span class="line">    <span class="keyword">if</span>(tmp&gt;t)t=tmp,u=A[x],v=B[y];</span><br><span class="line">    tmp=dis(B[x],A[y]);</span><br><span class="line">    <span class="keyword">if</span>(tmp&gt;t)t=tmp,u=B[x],v=A[y];</span><br><span class="line">    tmp=dis(B[x],B[y]);</span><br><span class="line">    <span class="keyword">if</span>(tmp&gt;t)t=tmp,u=B[x],v=B[y];</span><br><span class="line">    tmp=dis(A[y],B[y]);</span><br><span class="line">    <span class="keyword">if</span>(tmp&gt;t)t=tmp,u=A[y],v=B[y];</span><br><span class="line">    <span class="keyword">if</span>(ret&lt;t)ret=t;</span><br><span class="line">    <span class="keyword">if</span>(dep[x]==dep[y])&#123;</span><br><span class="line">        dep[x]++;</span><br><span class="line">        q[++cur]=E(<span class="number">0</span>,x,<span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(dep[x]&lt;dep[y])swap(x,y);</span><br><span class="line">    q[++cur]=E(<span class="number">1</span>,y,<span class="number">0</span>);</span><br><span class="line">    q[++cur]=E(<span class="number">2</span>,x,A[x]);</span><br><span class="line">    q[++cur]=E(<span class="number">3</span>,x,B[x]);</span><br><span class="line">    fa[y]=x,A[x]=u,B[x]=v;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">retrace</span><span class="params">(<span class="keyword">int</span> t)</span></span>&#123;</span><br><span class="line">    <span class="keyword">while</span>(cur&gt;t)&#123;</span><br><span class="line">        <span class="keyword">if</span>(!q[cur].t)dep[q[cur].x]--;</span><br><span class="line">        <span class="keyword">if</span>(q[cur].t==<span class="number">1</span>)fa[q[cur].x]=q[cur].x;</span><br><span class="line">        <span class="keyword">if</span>(q[cur].t==<span class="number">2</span>)A[q[cur].x]=q[cur].y;</span><br><span class="line">        <span class="keyword">if</span>(q[cur].t==<span class="number">3</span>)B[q[cur].x]=q[cur].y;</span><br><span class="line">        cur--;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">ins</span><span class="params">(<span class="keyword">int</span> x,<span class="keyword">int</span> a,<span class="keyword">int</span> b,<span class="keyword">int</span> c,<span class="keyword">int</span> d,<span class="keyword">int</span> p,<span class="keyword">int</span> q)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(c&lt;=a&amp;&amp;b&lt;=d)&#123;</span><br><span class="line">        V[++ED]=p;</span><br><span class="line">        W[ED]=q;</span><br><span class="line">        NXT[ED]=G[x];</span><br><span class="line">        G[x]=ED;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">int</span> mid=(a+b)&gt;&gt;<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">if</span>(c&lt;=mid)ins(x&lt;&lt;<span class="number">1</span>,a,mid,c,d,p,q);</span><br><span class="line">    <span class="keyword">if</span>(d&gt;mid)ins(x&lt;&lt;<span class="number">1</span>|<span class="number">1</span>,mid+<span class="number">1</span>,b,c,d,p,q);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">solve</span><span class="params">(<span class="keyword">int</span> x,<span class="keyword">int</span> a,<span class="keyword">int</span> b,<span class="keyword">int</span> ret)</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> pos=cur;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=G[x];i;i=NXT[i])merge(V[i],W[i],ret);</span><br><span class="line">    <span class="keyword">if</span>(a==b)&#123;</span><br><span class="line">        ans[a]=ret;</span><br><span class="line">        retrace(pos);</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">int</span> mid=(a+b)&gt;&gt;<span class="number">1</span>;</span><br><span class="line">    solve(x&lt;&lt;<span class="number">1</span>,a,mid,ret);</span><br><span class="line">    solve(x&lt;&lt;<span class="number">1</span>|<span class="number">1</span>,mid+<span class="number">1</span>,b,ret);</span><br><span class="line">    retrace(pos);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    freopen(<span class="string">"speed.in"</span>,<span class="string">"r"</span>,<span class="built_in">stdin</span>);freopen(<span class="string">"speed.out"</span>,<span class="string">"w"</span>,<span class="built_in">stdout</span>);</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">"%d%d"</span>,&amp;n,&amp;m);</span><br><span class="line">    <span class="keyword">for</span>(i=<span class="number">1</span>;i&lt;n;i++)&#123;</span><br><span class="line">        <span class="keyword">int</span> x,y,l,r;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">"%d%d%d%d"</span>,&amp;x,&amp;y,&amp;l,&amp;r);</span><br><span class="line">        add(x,y),add(y,x);</span><br><span class="line">        ins(<span class="number">1</span>,<span class="number">1</span>,n,l,r,x,y);</span><br><span class="line">    &#125;</span><br><span class="line">    dfs(<span class="number">1</span>);dfs2(<span class="number">1</span>,<span class="number">1</span>);</span><br><span class="line">    <span class="keyword">for</span>(i=<span class="number">1</span>;i&lt;=n;i++)fa[i]=A[i]=B[i]=i;</span><br><span class="line">    solve(<span class="number">1</span>,<span class="number">1</span>,n,<span class="number">0</span>);</span><br><span class="line">    <span class="keyword">while</span>(m--)<span class="built_in">scanf</span>(<span class="string">"%d"</span>,&amp;i),<span class="built_in">printf</span>(<span class="string">"%d\n"</span>,ans[i]);</span><br><span class="line">    fclose(<span class="built_in">stdin</span>);fclose(<span class="built_in">stdout</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br><br></div></div>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;160滚粗，T1很db地写了hash，T2没想到二分而暴力询问，inf开的不够大又丢了20分，T3完全不会，暴力20分&lt;/p&gt;
&lt;h1 id=&quot;T1-Divisors&quot;&gt;&lt;a href=&quot;#T1-Divisors&quot; class=&quot;headerlink&quot; title=&quot;T1 Divisors&quot;&gt;&lt;/a&gt;T1 Divisors&lt;/h1&gt;&lt;p&gt;大意：给定m个不同的正整数 &lt;span&gt;$a_1,a_2,...,a_m$&lt;/span&gt;&lt;!-- Has MathJax --&gt;，对$[0,m]$内每一个k计算：在区间$[1,n]$里有多少正整数是a中恰好k个数的约数。&lt;br&gt;$m≤200;n,a_i≤10^9$ 。&lt;br&gt;
    
    </summary>
    
      <category term="Problem Set" scheme="https://cothrax.github.io/categories/Problem-Set/"/>
    
    
      <category term="OI" scheme="https://cothrax.github.io/tags/OI/"/>
    
      <category term="数据结构" scheme="https://cothrax.github.io/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"/>
    
      <category term="并查集" scheme="https://cothrax.github.io/tags/%E5%B9%B6%E6%9F%A5%E9%9B%86/"/>
    
      <category term="DP" scheme="https://cothrax.github.io/tags/DP/"/>
    
      <category term="二分答案" scheme="https://cothrax.github.io/tags/%E4%BA%8C%E5%88%86%E7%AD%94%E6%A1%88/"/>
    
      <category term="图论" scheme="https://cothrax.github.io/tags/%E5%9B%BE%E8%AE%BA/"/>
    
      <category term="Hash" scheme="https://cothrax.github.io/tags/Hash/"/>
    
      <category term="数论" scheme="https://cothrax.github.io/tags/%E6%95%B0%E8%AE%BA/"/>
    
      <category term="背包" scheme="https://cothrax.github.io/tags/%E8%83%8C%E5%8C%85/"/>
    
      <category term="线段树" scheme="https://cothrax.github.io/tags/%E7%BA%BF%E6%AE%B5%E6%A0%91/"/>
    
      <category term="树链剖分" scheme="https://cothrax.github.io/tags/%E6%A0%91%E9%93%BE%E5%89%96%E5%88%86/"/>
    
      <category term="分治" scheme="https://cothrax.github.io/tags/%E5%88%86%E6%B2%BB/"/>
    
  </entry>
  
</feed>
