<?xml version="1.0" encoding="utf-8"?>
<search>
  
  
    
    <entry>
      <title><![CDATA[The End.]]></title>
      <url>https://cothrax.github.io/2016/12/24/the-end/</url>
      <content type="html"><![CDATA[<p>这次真的结束了，NOIP2016{ruby 跪烂|被草}，310分不忍直视，在JS勉强混个一等。<br><strong>不到一年的OI时光</strong>，从第一个hello world、第一场contest、第一篇blog，直至第一场NOIP，然后就结束了。<br>毕竟已经高二了，大概APIO、CTSC、NOI都是遥不可及的梦想吧。</p>
<blockquote>
<p>还没长大就老了。</p>
</blockquote>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[bzoj-2400 Spoj 839 Optimal Marks]]></title>
      <url>https://cothrax.github.io/2016/12/23/bzoj-2400/</url>
      <content type="html"><![CDATA[<p>定义无向图中的一条边的值为：这条边连接的两个点的值的异或值。<br>定义一个无向图的值为：这个无向图所有边的值的和。<br>给你一个有n个结点m条边的无向图。其中的一些点的值是给定的，而其余的点的值由你决定（但要求均为非负数），使得这个无向图的值最小。在无向图的值最小的前提下，使得无向图中所有点的值的和最小。<br>n&lt;=500，m&lt;=2000<br><a id="more"></a></p>
<h2 id="链接"><a href="#链接" class="headerlink" title="链接"></a>链接</h2><p><a href="http://www.lydsy.com/JudgeOnline/problem.php?id=2400" target="_blank" rel="external">bzoj-2400</a><br><a href="/2016/12/23/bzoj-2400/graph.cpp" title="graph.cpp">graph.cpp</a></p>
<h2 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h2><p>首先看到xor，显然要按位处理，这样每个点的值就变成了0或者1<br>设源汇s和t</p>
<ol>
<li>点v与s连通表示v的值为0</li>
<li>点v与t连通表示v的值为1</li>
</ol>
<p>xor意味着，只有当两边值不同时才会对答案产生贡献，也就是s集和t集的交界，要最小化答案，这符合最小割的定义<br>那么建图：</p>
<ol>
<li>对于确定的点v，如果v=0与s连边，v=1则与t连边</li>
<li>原图中的其他边直接加进去即可</li>
</ol>
<p>然后跑一次最大流就是第一问的答案<br>再考虑最小化点权和，当出现$u(\in s)\to x\to v(\in t)$时，最大流方案不唯一，此时把x放进s集是更优的，即割边$x\to v$更优，那么只要从t反向dfs，能dfs到的点即值为1的点，割$x\to v$会阻止dfs访问x节点</p>
<p>还有一种思路很神：<a href="http://blog.csdn.net/u012288458/article/details/50720724" target="_blank" rel="external">oxer</a></p>
<h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><p>```c++ graph.cpp</p>
<p>#include<algorithm></algorithm></p>
<p>#include<cstdio></cstdio></p>
<p>#include<cstring></cstring></p>
<p>#include<cmath></cmath></p>
<p>#define ll long long<br>using namespace std;<br>const int N=510,M=2010,INF=1E8;<br>struct edge{int v,cap,nxt;}g[M*100];<br>int head[N],sz=1;<br>void _add(int u,int v,int cap){<br>    g[++sz].v=v;g[sz].cap=cap;<br>    g[sz].nxt=head[u];head[u]=sz;<br>}<br>void add(int u,int v,int cap)<br>{_add(u,v,cap);_add(v,u,0);}</p>
<p>int q[N],d[N];<br>bool bfs(int s,int dest){<br>    fill(d,d+N,INF);<br>    d[s]=0;q[0]=s;int u,v;<br>    for(int h=0,t=1;h!=t;h=(h+1)%N)<br>        for(int i=head[u=q[h]];i;i=g[i].nxt)<br>            if(g[i].cap&amp;&amp;d[v=g[i].v]==INF)<br>                d[v]=d[u]+1,q[t++]=v,t%=N;<br>    return d[dest]!=INF;<br>}<br>int dfs(int u,int t,int f){<br>    if(u==t)return f;<br>    int ret=0,v;<br>    for(int i=head[u];i;i=g[i].nxt)<br>        if(d[v=g[i].v]==d[u]+1){<br>            int lim=dfs(v,t,min(f-ret,g[i].cap));<br>            g[i].cap-=lim;g[i^1].cap+=lim;ret+=lim;<br>            if(f==ret)return ret;<br>        }<br>    return ret;<br>}<br>int mf(int s,int t){<br>    int ret=0;<br>    while(bfs(s,t))ret+=dfs(s,t,INF);<br>    return ret;<br>}<br>int n,m,a[N],seg[M][2];<br>void init(int s,int t,int x){<br>    fill(head,head+N,0);sz=1;<br>    for(int i=1;i&lt;=n;i++)<br>        if(a[i]&gt;=0){<br>            if(a[i]&amp;(1&lt;&lt;x))add(i,t,INF);<br>            else add(s,i,INF);<br>        }<br>    for(int i=0;i&lt;m;i++){<br>        add(seg[i][0],seg[i][1],1);<br>        add(seg[i][1],seg[i][0],1);<br>    }<br>}<br>int vis[N];<br>int dfs(int u){<br>    int ret=1,v;vis[u]=1;<br>    for(int i=head[u];i;i=g[i].nxt)<br>        if(g[i^1].cap&amp;&amp;!vis[v=g[i].v])ret+=dfs(v);<br>    return ret;<br>}<br>int main(){<br>    freopen(“in”,”r”,stdin);freopen(“out”,”w”,stdout);<br>    scanf(“%d %d\n”,&amp;n,&amp;m);int tmp=0;<br>    for(int i=1;i&lt;=n;i++)scanf(“%d\n”,&amp;a[i]),tmp=max(tmp,a[i]);<br>    for(int i=0;i&lt;m;i++)scanf(“%d %d\n”,&amp;seg[i][0],&amp;seg[i][1]);<br>    int lim=log2(tmp)+1,s=n+1,t=s+1;<br>    ll sumE=0,sumV=0,b=1;<br>    for(int i=0;i&lt;lim;i++,b&lt;&lt;=1){<br>        init(s,t,i);<br>        sumE+=((ll)mf(s,t))<em>b;<br>        fill(vis,vis+N,0);<br>        sumV+=((ll)(dfs(t)-1))</em>b;<br>    }<br>    printf(“%lld\n%lld”,sumE,sumV);<br>}<br>```</p>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[【网络流24题】最长递增子序列问题]]></title>
      <url>https://cothrax.github.io/2016/12/23/flow24-alis/</url>
      <content type="html"><![CDATA[<p>给定正整数序列x1,….. , xn  。</p>
<ol>
<li>计算其最长递增子序列的长度s。</li>
<li>计算从给定的序列中最多可取出多少个长度为s的递增子序列。</li>
<li>如果允许在取出的序列中多次使用x1和xn，则从给定序列中最多可取出多少个长<br>度为s的递增子序列，如果可以取无限个则输出-1</li>
</ol>
<a id="more"></a>
<h2 id="链接"><a href="#链接" class="headerlink" title="链接"></a>链接</h2><a href="/2016/12/23/flow24-alis/alis.cpp" title="alis.cpp">alis.cpp</a>
<h2 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h2><p>黑书例题<br>第一问dp求f[i]以i开头的lis，用树状数组优化，或者直接暴力<br>第二问，拆点，根据f[i]分层建图，然后最大流即可<br>第三问就是把第二问建的图中，把1和n对应的那条边容量改成+∞，然后在跑一次最大流<br>lis=1时输出-1<br>lis=2且a[1]&lt;=a[n]时输出-1</p>
<h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><p>```c++ alis.cpp</p>
<p>#include<algorithm></algorithm></p>
<p>#include<cstdio><br>using namespace std;<br>const int N=1010,INF=1E7;<br>int n,lis=0,a[N],f[N];<br>namespace bit{<br>    const int M=1.1E5;int v[M];<br>    void add(int x,int k){<br>        for(;x<m;x+=x&(-x))v[x]=max(v[x],k); }="" int="" ask(int="" x){="" ret="0;" for(;x;x="x&(x-1))ret=max(ret,v[x]);" return="" ret;="" void="" dp(){="" using="" namespace="" bit;="" f[i]="" max-len="" begin_with_a[i]="" (j="">i&amp;&amp;a[j]&gt;a[i])<br>    for(int i=n-1;i&gt;=0;i–){<br>        add(M-a[i],f[i]=ask(M-a[i])+1);<br>        lis=max(lis,f[i]);<br>    }<br>}<br>struct edge{int v,cap,nxt;}g[N*10];<br>int head[N],sz=1;<br>void _add(int u,int v,int cap){<br>    g[++sz].v=v;g[sz].cap=cap;<br>    g[sz].nxt=head[u];head[u]=sz;<br>}<br>void add(int u,int v,int cap)<br>{_add(u,v,cap);_add(v,u,0);}<br>int q[N],d[N];<br>bool bfs(int s,int dest){<br>    fill(d,d+N,INF);d[s]=0;q[0]=s;int u,v;<br>    for(int h=0,t=1;h!=t;h=(h+1)%N)<br>        for(int i=head[u=q[h]];i;i=g[i].nxt)<br>            if(g[i].cap&amp;&amp;d[v=g[i].v]==INF)<br>                d[v]=d[u]+1,q[t++]=v,t%=N;<br>    return d[dest]!=INF;<br>}<br>int dfs(int u,int t,int f){<br>    if(u==t)return f;<br>    int ret=0,v;<br>    for(int i=head[u];i;i=g[i].nxt)<br>        if(d[v=g[i].v]==d[u]+1){<br>            int tmp=dfs(v,t,min(f-ret,g[i].cap));<br>            g[i].cap-=tmp;g[i^1].cap+=tmp;ret+=tmp;<br>            if(f==ret)return ret;<br>        }<br>    return ret;<br>}<br>int mf(int s,int t){<br>    int ret=0;<br>    while(bfs(s,t))ret+=dfs(s,t,INF);<br>    return ret;<br>}<br>void init(int s,int t){<br>    fill(head,head+N,0);<br>    for(int i=0;i&lt;n;i++)<br>        for(int j=i+1;j&lt;n;j++)<br>            if(a[i]&lt;=a[j]&amp;&amp;f[i]==f[j]+1)add(i+n,j,INF);<br>    for(int i=0;i&lt;n;i++)add(i,i+n,1);<br>    for(int i=0;i&lt;n;i++){<br>        if(f[i]==1)add(i+n,t,INF);<br>        if(f[i]==lis)add(s,i,INF);<br>    }<br>}</m;x+=x&(-x))v[x]=max(v[x],k);></cstdio></p>
<p>int main(){<br>    freopen(“in”,”r”,stdin);freopen(“out”,”w”,stdout);<br>    scanf(“%d\n”,&amp;n);<br>    for(int i=0;i&lt;n;i++)scanf(“%d”,&amp;a[i]);<br>    dp();printf(“%d\n”,lis);<br>    int s=n<em>2,t=s+1;<br>    init(s,t);<br>    printf(“%d\n”,mf(s,t));<br>    if(lis==1||lis==2&amp;&amp;a[0]&lt;=a[n-1])printf(“-1”);<br>    else{<br>        init(s,t);add(0,n,INF);add(n-1,2</em>n-1,INF);<br>        printf(“%d”,mf(s,t));<br>    }<br>    return 0;<br>}<br>```</p>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[【网络流24题】最长k可重区间集问题]]></title>
      <url>https://cothrax.github.io/2016/12/23/flow24-interv/</url>
      <content type="html"><![CDATA[<p>给定实直线L上n个开区间组成的集合I，和一个正整数k，试设计一个算法，从开区<br>间集合I 中选取出开区间集合S属于I，使得在实直线L的任何一点x，S 中包含点x 的开区间个数不超过k，且$\sum|z|,z\in S$，达到最大。这样的集合S称为开区间集合I的最长k可重区间集。<br>$\sum|z|$属于S称为最长k可重区间集的长度。<br>对于给定的开区间集合I和正整数k，计算开区间集合I的最长k可重区间集的长度。<br><a id="more"></a></p>
<h2 id="链接"><a href="#链接" class="headerlink" title="链接"></a>链接</h2><p><a href="http://hzwer.com/5842.html" target="_blank" rel="external">hzwer</a><br><a href="/2016/12/23/flow24-interv/interv.cpp" title="interv.cpp">interv.cpp</a></p>
<h2 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h2><p>最大权不相交路径<br>任意点x处重合区间数不超过k，则将一些不相交的区间接起来看做一条路径，那么问题就变成了取权值和最大的k条路径<br>引用题解：</p>
<blockquote>
<p>离散化所有区间的端点，把每个端点看做一个顶点，建立附加源S汇T。</p>
<ol>
<li>从S到顶点1（最左边顶点）连接一条容量为K，费用为0的有向边。</li>
<li>从顶点2N（最右边顶点）到T连接一条容量为K，费用为0的有向边。</li>
<li>从顶点i到顶点i+1(i+1&lt;=2N)，连接一条容量为无穷大，费用为0的有向边。</li>
<li>对于每个区间[a,b]，从a对应的顶点i到b对应的顶点j连接一条容量为1，费用为区间长度的有向边。</li>
</ol>
</blockquote>
<h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><p>```c++ interv.cpp</p>
<p>#include<cstring></cstring></p>
<p>#include<algorithm></algorithm></p>
<p>#include<cstdio><br>using namespace std;<br>const int N=1000,INF=1E7;<br>struct edge{int v,w,cap,nxt;}g[N*10];<br>int head[N],sz=1;<br>void _add(int u,int v,int cap,int w){<br>    g[++sz].v=v;g[sz].w=w;g[sz].cap=cap;<br>    g[sz].nxt=head[u];head[u]=sz;<br>}<br>void add(int u,int v,int cap,int w)<br>{_add(u,v,cap,w);_add(v,u,0,-w);}</cstdio></p>
<p>int q[N],d[N],pre[N];bool inq[N];<br>bool spfa(int s,int dest){<br>    fill(d,d+N,-INF);<br>    fill(inq,inq+N,0);<br>    fill(pre,pre+N,0);<br>    d[s]=0;inq[s]=1;q[0]=s;int u,v;<br>    for(int h=0,t=1;h!=t;inq[q[h]]=0,h=(h+1)%N)<br>        for(int i=head[u=q[h]];i;i=g[i].nxt)<br>            if(g[i].cap&amp;&amp;d[v=g[i].v]<d[u]+g[i].w){ d[v]="d[u]+g[i].w;pre[v]=i;" if(!inq[v])q[t++]="v,inq[v]=1,t%=N;" }="" return="" d[dest]!="-INF;" int="" mcf(int="" s,int="" t){="" ret="0,f=0;" while(spfa(s,t)){="" x="INF,y=0;" for(int="" i="pre[t];i;i=pre[g[i^1].v])" f+="x;ret+=x*y;" g[i].cap-="x,g[i^1].cap+=x;" ret;="" main(){="" freopen("in","r",stdin);freopen("out","w",stdout);="" n,k,vtx[n],l[n],r[n];="" scanf("%d="" %d\n",&n,&k);="" %d\n",&l[i],&r[i]);="" vtx[i]="l[i];vtx[i+n]=r[i];" sort(vtx,vtx+2*n);="" m="0,loc[(int)1E5];//[0,m]" loc[vtx[0]]="0;" if(vtx[i]="">vtx[m])<br>            vtx[++m]=vtx[i],loc[vtx[m]]=m;<br>    for(int i=0;i&lt;m;i++)add(i,i+1,INF,0);<br>    for(int i=0;i&lt;n;i++)<br>        add(loc[l[i]],loc[r[i]],1,r[i]-l[i]);<br>    int s=m+1,t=m+2;<br>    add(s,0,k,0);add(m,t,k,0);<br>    printf(“%d”,mcf(s,t));<br>    return 0;<br>}<br>```</d[u]+g[i].w){></p>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[bzoj-3598 【FJ2014集训】XWW的难题]]></title>
      <url>https://cothrax.github.io/2016/12/23/bzoj-3698/</url>
      <content type="html"><![CDATA[<p>XWW给你出了这么一个难题：XWW给你一个N*N的正实数矩阵A，满足XWW性。<br>称一个N*N的矩阵满足XWW性当且仅当：（1）A[N][N]=0；（2）矩阵中每行的最后一个元素等于该行前N-1个数的和；（3）矩阵中每列的最后一个元素等于该列前N-1个数的和。<br>现在你要给A中的数进行取整操作（可以是上取整或者下取整），使得最后的A矩阵仍然满足XWW性。同时XWW还要求A中的元素之和尽量大。<br>N≤100<br><a id="more"></a></p>
<h2 id="链接"><a href="#链接" class="headerlink" title="链接"></a>链接</h2><p><a href="http://www.lydsy.com/JudgeOnline/problem.php?id=3698" target="_blank" rel="external">bzoj-3698</a><br><a href="/2016/12/23/bzoj-3698/3698.cpp" title="3698.cpp">3698.cpp</a></p>
<h2 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h2><p>上下界最大流<br>建模：</p>
<ol>
<li>设超级源汇s和t，节点l(i)表示第i行，节点c(i)表示第i列</li>
<li>s-&gt;l(i)，容量为[floor(a[i][n]),ceil(a[i][n])]</li>
<li>r(i)-&gt;t，容量为[floor(a[n][i]),ceil(a[n][i])]</li>
<li>l(i)-&gt;r(j)，容量为[floor(a[i][j]),ceil(a[i][j])]</li>
</ol>
<p>关于如何将上下界最大流规约为普通流：<br>设边e下界为b(e)，上界为c(e)，伪流f’(e)=f(e)-b(e)<br>流量守恒：<br>$\sum_{e\in in(v)}[f’(e)+b(e)]=\sum_{e\in out(v)}[f’(e)+b(e)]$</p>
<p>则$\sum_{e\in in(v)}f’(e)=\sum_{e\in out(v)}f’(e)+[\sum_{e\in in(v)}b(e)-\sum_{e\in out(v)}b(e)]$</p>
<p>记$m(v)=\sum_{e\in in(v)}b(e)-\sum_{e\in out(v)}b(e)$</p>
<p>在原图上跑伪流f’，即把边e的容量变为c(e)-b(e)<br>为保证流量守恒，设附加源汇s’和t’<br>如果m(v)&gt;0，s’-&gt;v，容量m(v)<br>如果m(v)<0，v->t’，容量-m(v)<br>将超级源汇当做普通节点：t-&gt;s，容量∞<br>先从s’到t’跑最大流，如果从s’出发的边全部满载，则存在可行流以满足所有下界<br>然后从s到t跑最大流f，f即上下界最大流的答案</0，v-></p>
<h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><p>```c++ 3698.cpp</p>
<p>#include<algorithm></algorithm></p>
<p>#include<cstdio></cstdio></p>
<p>#include<cmath><br>using namespace std;<br>const int N=105,M=N<em>N,INF=1E7,EPS=1E-7;<br>struct edge{int v,cap,nxt;} g[M</em>10];<br>int head[M],sz=1;<br>void _add(int u,int v,int cap){<br>    g[++sz].v=v;g[sz].cap=cap;<br>    g[sz].nxt=head[u];head[u]=sz;<br>}<br>void add(int u,int v,int cap)<br>{_add(u,v,cap);_add(v,u,0);}</cmath></p>
<p>double a[N][N];int r[M],n,s,t,S,T,sum=0;<br>bool jud(double n){return abs(n-(int)n)<eps;} void="" init(){="" s="2*n+1,t=s+1,S=t+1,T=S+1;" fill(r,r+m,0);="" for(int="" i="1;i<n;i++){" if(!jud(a[i][n]))add(s,i,1);="" if(!jud(a[n][i]))add(i+n,t,1);="" r[s]-="(int)a[i][n];r[i]+=(int)a[i][n];" r[t]+="(int)a[n][i];r[i+n]-=(int)a[n][i];" j="1;j<n;j++){" if(!jud(a[i][j]))add(i,j+n,1);="" r[i]-="(int)a[i][j];r[j+n]+=(int)a[i][j];" }="" add(t,s,inf);="" if(r[i]="">0)add(S,i,r[i]),sum+=r[i];<br>        else add(i,T,-r[i]);<br>}</eps;}></p>
<p>int q[M],d[M];<br>bool bfs(int s,int dest){<br>    fill(d,d+M,INF);<br>    d[s]=0;q[0]=s;int u,v;<br>    for(int h=0,t=1;h!=t;h=(h+1)%M)<br>        for(int i=head[u=q[h]];i;i=g[i].nxt)<br>            if(g[i].cap&amp;&amp;d[v=g[i].v]==INF)<br>                {d[v]=d[u]+1;q[t++]=v;t%=M;}<br>    return d[dest]!=INF;<br>}<br>int dfs(int u,int t,int f){<br>    if(u==t)return f;<br>    int ret=0;int v;<br>    for(int i=head[u];i;i=g[i].nxt)<br>        if(d[v=g[i].v]==d[u]+1){<br>            int tmp=dfs(v,t,min(f-ret,g[i].cap));<br>            g[i].cap-=tmp;g[i^1].cap+=tmp;ret+=tmp;<br>            if(f==ret)return f;<br>        }<br>    if(!ret)d[u]=INF;<br>    return ret;<br>}<br>int mf(int s,int t){<br>    int ret=0;<br>    while(bfs(s,t))ret+=dfs(s,t,INF);<br>    return ret;<br>}</p>
<p>int main(){<br>    freopen(“in”,”r”,stdin);<br>    scanf(“%d\n”,&amp;n);<br>    for(int i=1;i&lt;=n;i++)<br>        for(int j=1;j&lt;=n;j++)scanf(“%lf”,&amp;a[i][j]);<br>    init();<br>    if(mf(S,T)&lt;sum)printf(“No”);<br>    else printf(“%d”,mf(s,t)*3);<br>    return 0;<br>}<br>```</p>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[bzoj-1877 [SDOI2009]晨跑]]></title>
      <url>https://cothrax.github.io/2016/12/23/bzoj-1877/</url>
      <content type="html"><![CDATA[<p> 现在给出一张学校附近的地图，这张地图中包含N个十字路口和M条街道，Elaxia只能从 一个十字路口跑向另外一个十字路口，街道之间只在十字路口处相交。Elaxia每天从寝室出发 跑到学校，保证寝室编号为1，学校编号为N。 Elaxia的晨跑计划是按周期（包含若干天）进行的，由于他不喜欢走重复的路线，所以 在一个周期内，每天的晨跑路线都不会相交（在十字路口处），寝室和学校不算十字路 口。Elaxia耐力不太好，他希望在一个周期内跑的路程尽量短，但是又希望训练周期包含的天 数尽量长。 除了练空手道，Elaxia其他时间都花在了学习和找MM上面，所有他想请你帮忙为他设计 一套满足他要求的晨跑计划。<br>N ≤ 200，M ≤ 20000<br><a id="more"></a></p>
<h2 id="链接"><a href="#链接" class="headerlink" title="链接"></a>链接</h2><p><a href="http://www.lydsy.com/JudgeOnline/problem.php?id=1877" target="_blank" rel="external">bzoj-1877</a><br><a href="/2016/12/23/bzoj-1877/1877.cpp" title="1877.cpp">1877.cpp</a></p>
<h2 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h2><p>裸的最小费用最大流。<br>每条边费用为它的长度，容量为1，然后从s到t跑费用流即可。</p>
<h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><p>```c++ 1877.cpp</p>
<p>#include<cstdio></cstdio></p>
<p>#include<cstring></cstring></p>
<p>#include<algorithm><br>using namespace std;<br>const int N=410,INF=1e7;<br>struct edge{int v,w,cap,nxt;} g[N*N];<br>int head[N],sz=1,n,m;<br>void _add(int u,int v,int w,int cap){<br>    g[++sz].v=v;g[sz].cap=cap;g[sz].w=w;<br>    g[sz].nxt=head[u];head[u]=sz;<br>}<br>void add(int u,int v,int w,int cap)<br>{_add(u,v,w,cap);_add(v,u,-w,0);}</algorithm></p>
<p>int d[N],q[N],pre[N];bool inq[N];<br>bool spfa(int s,int dest){<br>    fill(d,d+2<em>n+1,INF);d[s]=0;<br>    fill(inq,inq+2</em>n+1,0);inq[s]=1;<br>    fill(pre,pre+2<em>n+1,0);<br>    q[0]=s;int u,v;<br>    for(int h=0,t=1;h!=t;inq[q[h]]=0,h=(h+1)%N)<br>        for(int i=head[u=q[h]];i;i=g[i].nxt)<br>            if(g[i].cap&amp;&amp;d[v=g[i].v]&gt;d[u]+g[i].w){<br>                d[v]=d[u]+g[i].w;pre[v]=i;<br>                if(!inq[v])q[t++]=v,inq[v]=1,t%=N;<br>            }<br>    return d[dest]!=INF;<br>}<br>void mcf(int s,int t){<br>    int f=0,ret=0;<br>    while(spfa(s,t)){<br>        int x=INF,y=0;<br>        for(int i=pre[t];i;i=pre[g[i^1].v])<br>            x=min(x,g[i].cap),y+=g[i].w;<br>        f+=x;ret+=x</em>y;<br>        for(int i=pre[t];i;i=pre[g[i^1].v])<br>            g[i].cap-=x,g[i^1].cap+=x;<br>    }<br>    printf(“%d %d”,f,ret);<br>}<br>int main(){<br>    freopen(“in”,”r”,stdin);<br>    scanf(“%d %d\n”,&amp;n,&amp;m);int u,v,w;<br>    for(int i=1;i&lt;=n;i++)add(i,i+n,0,1);<br>    for(int i=0;i&lt;m;i++)<br>        scanf(“%d %d %d\n”,&amp;u,&amp;v,&amp;w),add(u+n,v,w,1);<br>    mcf(1+n,n);<br>}<br>```</p>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[bzoj-1500 [NOI2005]维修数列]]></title>
      <url>https://cothrax.github.io/2016/12/18/bzoj-1500/</url>
      <content type="html"><![CDATA[<p><img src="http://www.lydsy.com/JudgeOnline/images/1500_1.jpg" alt=""><br>Limit:<br>M≤20000<br>任何时刻数列中最多含有500000个数，数列中任何一个数字均在[-1000,1000]内。<br>插入的数字总数不超过4000000个，输入文件大小不超过20MBytes。<br><a id="more"></a></p>
<h2 id="链接"><a href="#链接" class="headerlink" title="链接"></a>链接</h2><p><a href="http://www.lydsy.com/JudgeOnline/problem.php?id=1500" target="_blank" rel="external">bzoj-1500</a><br><a href="/2016/12/18/bzoj-1500/1500.cpp" title="1500.cpp">1500.cpp</a></p>
<h2 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h2><p>Splay模板题<br>关于max-sum，由于Splay的中序序列即该序列：</p>
<ol>
<li>lmx[x]子树x中序序列的最大前缀和</li>
<li>rmx[x]子树x中序序列的最大前缀和</li>
<li>sub[x]子树x中序序列的最大子段和</li>
</ol>
<p>更新见upd函数<br>summary</p>
<ol>
<li>下标，注意splay中虚拟节点的左端点占一位</li>
<li>翻转时要维护max-sum</li>
<li>内存回收：开一个stack</li>
<li>初始值：lmx[0]=rmx[0]=0,sub[0]=-INF</li>
<li>max-sum子段不为空，因此make-same中当w[x]为负时，sub[x]=max(w[x],sum[x])，而lmx[x]=rmx[x]=max(0,sum[x])</li>
<li>维护make-same标记时，由于涉及权值修改，要判断t!=0</li>
</ol>
<h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><p>```c++ 1500.cpp</p>
<p>#include<algorithm></algorithm></p>
<p>#include<cstdio></cstdio></p>
<p>#include<cstring></cstring></p>
<p>#define L(x) c[x][0]</p>
<p>#define R(x) c[x][1]<br>using namespace std;<br>namespace spt{<br>    const int N=5e5+10,INF=1e7;<br>    int c[N][2],par[N],siz[N]={0},sz=0,rt=1;<br>    int sub[N],lmx[N],rmx[N],w[N],sum[N];<br>    bool rev[N],tag[N];<br>    int loc[N],a[N];<br>    namespace mem{<br>        int stk[N<em>2],t=N;<br>        void init(){for(int i=0;i&lt;N;i++)stk[i]=N-i;}<br>        inline int ext(){return stk[–t];}<br>        inline void ins(int x){stk[t++]=x;}<br>        inline void rec(int x){<br>            if(!x)return;<br>            ins(x);rec(L(x));rec(R(x));<br>            L(x)=R(x)=par[x]=tag[x]=rev[x]=0;<br>        }<br>    }<br>    void upd(int x){<br>        siz[x]=siz[L(x)]+siz[R(x)]+1;<br>        sum[x]=sum[L(x)]+sum[R(x)]+w[x];<br>        lmx[x]=max(lmx[L(x)],sum[L(x)]+lmx[R(x)]+w[x]);<br>        rmx[x]=max(rmx[R(x)],sum[R(x)]+rmx[L(x)]+w[x]);<br>        sub[x]=max(max(sub[L(x)],sub[R(x)]),lmx[R(x)]+rmx[L(x)]+w[x]);<br>    }<br>    void pushdn(int x){<br>        for(int i=0;i&lt;2&amp;&amp;rev[x];i++){<br>            int t=c[x][i];rev[t]^=1;<br>            swap(L(t),R(t));swap(lmx[t],rmx[t]);<br>        }<br>        for(int i=0;i&lt;2&amp;&amp;tag[x];i++){<br>            int t=c[x][i];if(!t)continue;<br>            w[t]=w[x];tag[t]=1;<br>            lmx[t]=rmx[t]=max(0,sum[t]=w[t]</em>siz[t]);<br>            sub[t]=max(sum[t],w[t]);<br>        }rev[x]=tag[x]=0;<br>    }<br>    void rotate(int x,int &amp;k){<br>        int y=par[x],z=par[y],l=c[y][0]!=x,r=l^1;<br>        if(y==k)k=x;else c[z][c[z][0]!=y]=x;<br>        par[c[x][r]]=y;par[y]=x;par[x]=z;<br>        c[y][l]=c[x][r];c[x][r]=y;<br>        upd(y);upd(x);<br>    }<br>    void splay(int x,int &amp;k){<br>        while(x!=k){<br>            int y=par[x],z=par[y];<br>            if(y!=k){<br>                if(L(y)==x^L(z)==y)rotate(x,k);<br>                else rotate(y,k);<br>            }rotate(x,k);<br>        }<br>    }<br>    int find(int x,int rk){<br>        pushdn(x);<br>        if(siz[L(x)]+1==rk)return x;<br>        else if(siz[L(x)]&gt;=rk)return find(L(x),rk);<br>        else return find(R(x),rk-siz[L(x)]-1);<br>    }<br>    void build(int l,int r,int p){<br>        if(l&gt;r)return;<br>        int mid=(l+r)&gt;&gt;1,x=loc[mid];<br>        if(l==r){<br>            par[x]=loc[p];c[loc[p]][l&gt;p]=x;<br>            w[x]=a[l];upd(x);<br>            return;<br>        }<br>        build(l,mid-1,mid);build(mid+1,r,mid);<br>        par[x]=loc[p];c[loc[p]][mid&gt;p]=x;<br>        w[x]=a[mid];upd(x);<br>    }<br>    int split(int l,int r){<br>        int x=find(rt,l),y=find(rt,r+2);<br>        splay(x,rt);splay(y,R(rt));<br>        return L(y);<br>    }<br>    namespace opt{<br>        void init(int n){<br>            mem::init();<br>            for(int i=1;i&lt;=n;i++)scanf(“%d”,&amp;a[i]);<br>            for(int i=0;i&lt;=n+1;i++)loc[i]=mem::ext();<br>            sub[0]=a[0]=a[n+1]=-INF;<br>            rt=loc[(n+1)&gt;&gt;1];build(0,n+1,n+2);<br>        }<br>        void rever(int l,int r){<br>            int x=split(l,r);<br>            if(tag[x])return;<br>            rev[x]^=1;<br>            swap(L(x),R(x));swap(lmx[x],rmx[x]);<br>            upd(par[x]);upd(rt);<br>        }<br>        int query(int l,int r){<br>            int x=split(l,r);<br>            return sum[x];<br>        }<br>        void del(int l,int r){<br>            int x=split(l,r);<br>            L(par[x])=0;upd(par[x]);upd(rt);<br>            mem::rec(x);<br>        }<br>        void modify(int l,int r,int k){<br>            int x=split(l,r);tag[x]=1;w[x]=k;<br>            lmx[x]=rmx[x]=max(0,sum[x]=w[x]*siz[x]);<br>            sub[x]=max(sum[x],w[x]);<br>            upd(par[x]);upd(rt);<br>        }<br>        void ins(int l,int tot){<br>            for(int i=0;i&lt;tot;i++)scanf(“%d “,&amp;a[i]);<br>            for(int i=0;i&lt;tot;i++)loc[i]=mem::ext();<br>            split(l+1,l);<br>            loc[tot]=R(rt);build(0,tot-1,tot);<br>            upd(loc[tot]);upd(rt);<br>        }<br>        int get(){return sub[rt];}<br>    }<br>}<br>int main(){<br>    using namespace spt::opt;<br>    freopen(“in”,”r”,stdin);freopen(“out”,”w”,stdout);<br>    int n,m;scanf(“%d %d\n”,&amp;n,&amp;m);<br>    init(n);<br>    for(int i=0;i&lt;m;i++){<br>        char s[10];int p,t,k;<br>        scanf(“%s”,s);<br>        if(s[2]!=’X’)scanf(“%d %d”,&amp;p,&amp;t);<br>        if(s[2]==’K’)scanf(“%d”,&amp;k);<br>        switch(s[0]){<br>            case’I’:ins(p,t);break;<br>            case’D’:del(p,p+t-1);break;<br>            case’R’:rever(p,p+t-1);break;<br>            case’G’:printf(“%d\n”,query(p,p+t-1));break;<br>            default:<br>                switch(s[2]){<br>                    case’K’:modify(p,p+t-1,k);break;<br>                    case’X’:printf(“%d\n”,get());break;<br>                }break;<br>        }<br>    }<br>    return 0;<br>}<br>```</p>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[bzoj-3173 [Tjoi2013]最长上升子序列]]></title>
      <url>https://cothrax.github.io/2016/12/18/bzoj-3173/</url>
      <content type="html"><![CDATA[<p>给定一个序列，初始为空。现在我们将1到N的数字插入到序列中，每次将一个数字插入到一个特定的位置x_i。每插入一个数字，我们都想知道此时最长上升子序列长度是多少？<br>n&lt;=100000<br><a id="more"></a></p>
<h2 id="链接"><a href="#链接" class="headerlink" title="链接"></a>链接</h2><p><a href="http://www.lydsy.com/JudgeOnline/problem.php?id=3173" target="_blank" rel="external">bzoj-3173</a><br><a href="/2016/12/18/bzoj-3173/3173.cpp" title="3173.cpp">3173.cpp</a></p>
<h2 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h2><p>由于是从小到大插入，记f[i]为以i结尾的lis<br>那么f[i]=f[前x_i个数]的最大值+1<br>于是用treap维护该数列：</p>
<ol>
<li>该序列为treap的中序遍历，并维护子树的f[i]最大值</li>
<li>每次查询rank&lt;x_i的f[i]的最大值</li>
<li>插入i时，先找到rank=x_i+1的点，然后将i作为前驱插入</li>
</ol>
<p>attention:<br>ins等函数中&amp;x是引用，调用时要用c[x][0]而不是l</p>
<h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><p>```c++ 3173.cpp</p>
<p>#include<algorithm></algorithm></p>
<p>#include<cstdio></cstdio></p>
<p>#include<cstdlib></cstdlib></p>
<p>#define L(x) c[x][0]</p>
<p>#define R(x) c[x][1]<br>using namespace std;<br>const int N=1e5+10;<br>namespace treap{<br>    int rnd[N]={0},siz[N]={0},c[N][2],sz=0,rt;<br>    int w[N],sub[N]={0},ans=0;<br>    int upd(int &amp;x){<br>        siz[x]=siz[L(x)]+siz[R(x)]+1;<br>        sub[x]=max(max(sub[L(x)],sub[R(x)]),w[x]);<br>        ans=max(ans,sub[x]);<br>    }<br>    int rotate(int &amp;x,int l){<br>        int r=l^1,y=c[x][l];<br>        c[x][l]=c[y][r];c[y][r]=x;<br>        upd(x);upd(y);x=y;<br>    }<br>    int query(int &amp;x,int rk){<br>        if(!rk||!x)return 0;<br>        if(siz[L(x)]&gt;=rk)return query(L(x),rk);<br>        if(siz[L(x)]<rk){ int="" ret="query(R(x),rk-siz[L(x)]-1);" return="" max(ret,max(sub[l(x)],w[x]));="" }="" void="" add(int="" &x,int="" val,int="" l){="" if(!x){="" x="++sz;w[sz]=val;upd(sz);" rnd[sz]="rand();return;" add(c[x][l],val,l);upd(x);="" if(rnd[c[x][l]]="">rnd[x])rotate(x,l);<br>    }<br>    void ins(int &amp;x,int rk,int val){<br>        if(siz[rt]+1==rk){add(rt,val,1);return;}<br>        if(siz[L(x)]+1==rk){<br>            add(L(x),val,1);upd(x);<br>            if(rnd[L(x)]&gt;rnd[x])rotate(x,0);<br>        }else if(siz[L(x)]&gt;=rk)ins(L(x),rk,val);<br>         else ins(R(x),rk-siz[L(x)]-1,val);<br>        upd(x);<br>    }<br>    void walk(int x,int dep){<br>        if(!x)return;<br>        walk(L(x),dep+1);<br>        for(int i=0;i&lt;dep;i++)printf(“    “);<br>        printf(“%d:%d(%d)\n”,x,w[x],siz[x]);<br>        walk(R(x),dep+1);<br>    }<br>}<br>int main(){<br>    using namespace treap;<br>    srand(12345632);<br>    freopen(“in”,”r”,stdin);freopen(“out”,”w”,stdout);<br>    int n,x;scanf(“%d”,&amp;n);<br>    for(int i=0;i&lt;n;i++){<br>        int x;scanf(“%d”,&amp;x);<br>        ins(rt,x+1,query(rt,x)+1);<br>        printf(“%d\n”,ans);<br>    }<br>}<br>```</rk){></p>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[bzoj-3506 [Cqoi2014]排序机械臂]]></title>
      <url>https://cothrax.github.io/2016/12/18/bzoj-3506/</url>
      <content type="html"><![CDATA[<p>给定一个长n的数列，有n次操作，第i次为：<br>找到i..n中最小的数，记它的下标为k，翻转区间[i,k]<br>并输出k值<br>n≤100000</p>
<a id="more"></a>
<h2 id="链接"><a href="#链接" class="headerlink" title="链接"></a>链接</h2><p><a href="http://www.lydsy.com/JudgeOnline/problem.php?id=3506" target="_blank" rel="external">bzoj-3506</a><br><a href="/2016/12/18/bzoj-3506/3506.cpp" title="3506.cpp">3506.cpp</a></p>
<h2 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h2><p>splay维护序列</p>
<ol>
<li>在建树时维护个点所在下标，将数列sort一下，升序处理</li>
<li>对于第i个数，下标为loc[i]，从loc[i]向上直到根节点压进一个栈，然后从上到下pushdown一遍，再遍历一遍统计loc[i]的rank</li>
<li>然后splay翻转[1,rank]即可</li>
</ol>
<h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><p>```c++ 3506.cpp</p>
<p>#include<algorithm></algorithm></p>
<p>#include<cstdio></cstdio></p>
<p>#define P pair<int,int></int,int></p>
<p>#define mkp(x,y) make_pair(x,y)<br>using namespace std;<br>const int N=100010;<br>namespace splay_tree{<br>    int c[N][2],w[N],par[N],siz[N],sz=0,rt=1,loc[N],a[N];<br>    bool rev[N];<br>    void upd(int x){siz[x]=siz[c[x][0]]+siz[c[x][1]]+1;}<br>    void pushdn(int x){<br>        for(int i=0;i<2&&rev[x];i++){ int="" t="c[x][i];rev[t]^=1;" swap(c[t][0],c[t][1]);="" }rev[x]="0;" }="" void="" rotate(int="" x,int="" &k){="" y="par[x],z=par[y],l=c[y][0]==x?0:1,r=l^1;" if(y="=k)k=x;else" c[z][c[z][0]="=y?0:1]=x;" par[c[x][r]]="y;par[y]=x;par[x]=z;" c[y][l]="c[x][r];c[x][r]=y;" upd(y);upd(x);="" splay(int="" while(x!="k){" if(y!="k){" if(c[y][0]="=x^c[z][0]==y)rotate(x,k);" else="" rotate(y,k);="" }rotate(x,k);="" find(int="" rk){="" pushdn(x);="" l="c[x][0],r=c[x][1];" if(siz[l]+1="=rk)return" x;="" if(siz[l]="">=rk)return find(l,rk);<br>        else return find(r,rk-siz[l]-1);<br>    }<br>    int rever(int st,int k){<br>        int q[N],t=0;<br>        for(int x=k;x;x=par[x])q[t++]=x;<br>        for(int i=t-1;i&gt;=0;i–)pushdn(q[i]);<br>        int rk=siz[c[k][0]];<br>        for(int i=1;i<t;i++){ int="" x="q[i],l=c[x][0],r=c[x][1];" if(q[i-1]="=r)rk+=siz[l]+1;" }="" splay(x,rt);splay(y,c[rt][1]);="" return="" rk;="" void="" build(int="" l,int="" r,int="" p){="" if(l="">r)return;<br>        if(l==r){<br>            loc[l]=++sz;<br>            par[sz]=loc[p];c[loc[p]][l<p?0:1]=sz; w[sz]="a[l];siz[sz]=1;upd(sz);" return;="" }="" int="" mid="(l+r)">&gt;1,x=loc[mid]=++sz;<br>        build(l,mid-1,mid);build(mid+1,r,mid);<br>        par[x]=loc[p];c[loc[p]][mid&lt;p?0:1]=x;<br>        w[x]=a[mid];siz[x]=1;upd(x);<br>    }<br>}<br>int main(){<br>    using namespace splay_tree;<br>    //freopen(“in”,”r”,stdin);freopen(“out”,”w”,stdout);<br>    int n;scanf(“%d”,&amp;n);<br>    for(int i=1;i&lt;=n;i++)scanf(“%d”,&amp;a[i]);<br>    build(0,n+1,n+2);<br>    P b[N];<br>    for(int i=1;i&lt;=n;i++)b[i-1]=mkp(a[i],i);<br>    sort(b,b+n);<br>    for(int i=0;i&lt;n;i++)<br>        printf(“%d “,rever(i+1,loc[b[i].second]));<br>}<br>```</p?0:1]=sz;></t;i++){></2&&rev[x];i++){></p>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[bzoj-3223 Tyvj 1729 文艺平衡树]]></title>
      <url>https://cothrax.github.io/2016/12/18/bzoj-3223/</url>
      <content type="html"><![CDATA[<p>维护长n一个数列$a_n$，初始为$a_i=i$，支持m次区间翻转，输出翻转后的结果<br>N,M&lt;=100000<br><a id="more"></a></p>
<h2 id="链接"><a href="#链接" class="headerlink" title="链接"></a>链接</h2><p><a href="http://www.lydsy.com/JudgeOnline/problem.php?id=3223" target="_blank" rel="external">bzoj-3223</a><br><a href="/2016/12/18/bzoj-3223/3223.cpp" title="3223.cpp">3223.cpp</a></p>
<h2 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h2><p>splay即可<br>见：</p>
<ol>
<li><a href="https://oi.men.ci/splay-notes-1/" target="_blank" rel="external">Splay 学习笔记（一）</a></li>
<li><a href="https://oi.men.ci/splay-notes-2/" target="_blank" rel="external">Splay 学习笔记（二）</a></li>
</ol>
<p>静态数组的写法是跟黄学长学的</p>
<h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><p>```c++ 3223.cpp</p>
<p>#include<algorithm></algorithm></p>
<p>#include<cstdio><br>using namespace std;<br>const int N=100010;<br>//splay::begin<br>int c[N][2],siz[N],par[N],rt;bool flg[N];<br>void upd(int x){siz[x]=siz[c[x][0]]+siz[c[x][1]]+1;}<br>void pushdn(int x){<br>    if(!flg[x])return;<br>    swap(c[x][0],c[x][1]);<br>    int l=c[x][0],r=c[x][1];<br>    flg[l]^=1;flg[r]^=1;flg[x]=0;<br>}<br>void rotate(int x,int &amp;k){<br>    int y=par[x],z=par[y],l=c[y][0]==x?0:1,r=l^1;<br>    if(y==k)k=x;else c[z][c[z][0]==y?0:1]=x;<br>    par[x]=z;par[y]=x;par[c[x][r]]=y;<br>    c[y][l]=c[x][r];c[x][r]=y;<br>    upd(y);upd(x);<br>}<br>int rank(int x,int rk){<br>    pushdn(x);int l=c[x][0],r=c[x][1];<br>    if(siz[l]+1==rk)return x;<br>    else if(siz[l]&gt;=rk)return rank(l,rk);<br>    else return rank(r,rk-siz[l]-1); //bug: r,not l<br>}<br>int find(int rk){return rank(rt,rk);}<br>void splay(int x,int &amp;k){<br>    while(x!=k){<br>        int y=par[x],z=par[y];<br>        if(y!=k){<br>            if(c[y][0]==x^c[z][0]==y)rotate(x,k);<br>            else rotate(y,k);<br>        }rotate(x,k); //bug:rotate,not splay<br>    }<br>}<br>void build(int l,int r,int p){<br>    if(l&gt;r)return;<br>    if(l==r){<br>        par[l]=p;siz[l]=1;c[p][l<p?0:1]=l; return;="" }="" int="" mid="(l+r)">&gt;1;<br>    build(l,mid-1,mid);build(mid+1,r,mid);<br>    par[mid]=p;upd(mid);c[p][mid<p?0:1]=mid; }="" void="" rev(int="" l,int="" r){="" int="" x="find(l),y=find(r+2);" splay(x,rt);splay(y,c[rt][1]);="" flg[c[y][0]]^="1;" walk(int="" x,int="" lim){="" if(!x)return;pushdn(x);="" walk(c[x][0],lim);="" if(x!="lim&&x!=1)printf("%d" ",x-1);="" walk(c[x][1],lim);="" splay::end="" main(){="" freopen("in","r",stdin);freopen("out","w",stdout);="" n,m,l,r;scanf("%d="" %d\n",&n,&m);="" rt="(n+3)">&gt;1;build(1,n+2,0);<br>    for(int i=0;i&lt;m;i++)<br>        scanf(“%d %d\n”,&amp;l,&amp;r),rev(l,r);<br>    walk(rt,n+2);<br>    return 0;<br>}<br>```</p?0:1]=mid;></p?0:1]=l;></cstdio></p>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[bzoj-1503 [NOI2004]郁闷的出纳员]]></title>
      <url>https://cothrax.github.io/2016/12/18/bzoj-1503/</url>
      <content type="html"><![CDATA[<p>维护一个集合，支持如下操作：</p>
<ol>
<li>I_k 插入一个数k</li>
<li>A_k 将集合中的所有数加k</li>
<li>S_k 将集合中的所有数减k</li>
<li>F_k 查询第k大的数</li>
</ol>
<p>给定下界min，S_k之后会删除集合中值小于min的数，如果I_k插入的数值小于k会被立刻删除。</p>
<a id="more"></a>
<h2 id="链接"><a href="#链接" class="headerlink" title="链接"></a>链接</h2><p><a href="http://www.lydsy.com/JudgeOnline/problem.php?id=1503" target="_blank" rel="external">bzoj-1503</a><br><a href="/2016/12/18/bzoj-1503/1503.cpp" title="1503.cpp">1503.cpp</a></p>
<h2 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h2><p>平衡树+全局表示即可</p>
<h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><p>Treap<br>```c++ 1503.cpp</p>
<p>#include<algorithm></algorithm></p>
<p>#include<cstdio></cstdio></p>
<p>#include<cstdlib><br>using namespace std;<br>const int N=100010;<br>int dlt=0,sz=0;<br>struct node{int l,r,w,rnd,cnt,s;}t[N];<br>void upd(int &amp;k){t[k].s=t[t[k].l].s+t[t[k].r].s+t[k].cnt;}<br>void lturn(int &amp;k){<br>    int p=t[k].r;t[k].r=t[p].l;t[p].l=k;<br>    t[p].s=t[k].s;upd(k);k=p;<br>}<br>void rturn(int &amp;k){<br>    int p=t[k].l;t[k].l=t[p].r;t[p].r=k;<br>    t[p].s=t[k].s;upd(k);k=p;<br>}<br>void ins(int &amp;k,int x){<br>    if(!k)t[k=++sz].rnd=rand(),t[k].w=x,t[k].cnt=t[k].s=1;<br>    else if(x<t[k].w){ ins(t[k].l,x);upd(k);="" if(t[k].rnd<t[t[k].l].rnd)rturn(k);="" }else="" if(x="">t[k].w){<br>        ins(t[k].r,x);upd(k);<br>        if(t[k].rnd<t[t[k].r].rnd)lturn(k); }else{t[k].cnt++;upd(k);}="" }="" int="" del(int="" &k,int="" x){="" if(!k)return="" 0;="" if(t[k].w<x){="" ret="t[t[k].l].s+t[k].cnt;k=t[k].r;" ret+="del(k,x);upd(k);return" ret;="" }else{="" kth(int="" -1;="" tmp="t[k].s-t[t[k].l].s;" if(t[t[k].r].s="">=x)return kth(t[k].r,x);<br>    else if(tmp<x) return="" kth(t[k].l,x-tmp);="" else="" t[k].w+dlt;="" }="" void="" print(int="" &k,int="" dep){="" if(!k)return;="" print(t[k].l,dep+1);="" for(int="" i="0;i<dep;i++)printf("" ");="" printf("t[%d]="%d(%d/%d)%d\n",k,t[k].w,t[k].cnt," t[k].s,t[k].rnd="" 1000000);="" print(t[k].r,dep+1);="" int="" main(){="" freopen("in","r",stdin);freopen("out","w",stdout);="" srand(102458);="" n,m,ans="0,rt=0;" scanf("%d="" %d\n",&n,&m);="" char="" c;int="" x;scanf("%c="" %d\n",&c,&x);="" switch(c){="" case="" 'i':if(x="">=m)ins(rt,x-dlt);break;<br>            case ‘A’:dlt+=x;break;<br>            case ‘S’:dlt-=x,ans+=del(rt,m-dlt);break;<br>            case ‘F’:printf(“%d\n”,kth(rt,x));break;<br>        }<br>    }<br>    printf(“%d”,ans);<br>    return 0;<br>}<br>```</x)></t[t[k].r].rnd)lturn(k);></t[k].w){></cstdlib></p>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[bzoj-1588 [HNOI2002]营业额统计]]></title>
      <url>https://cothrax.github.io/2016/12/18/bzoj-1588/</url>
      <content type="html"><![CDATA[<p>Tiger最近被公司升任为营业部经理，他上任后接受公司交给的第一项任务便是统计并分析公司成立以来的营业情况。<br>Tiger拿出了公司的账本，账本上记录了公司成立以来每天的营业额。分析营业情况是一项相当复杂的工作。由于节假日，大减价或者是其他情况的时候，营业额会出现一定的波动，当然一定的波动是能够接受的，但是在某些时候营业额突变得很高或是很低，这就证明公司此时的经营状况出现了问题。经济管理学上定义了一种最小波动值来衡量这种情况： 该天的最小波动值 当最小波动值越大时，就说明营业情况越不稳定。<br>而分析整个公司的从成立到现在营业情况是否稳定，只需要把每一天的最小波动值加起来就可以了。你的任务就是编写一个程序帮助Tiger来计算这一个值。 第一天的最小波动值为第一天的营业额。<br><a id="more"></a></p>
<h2 id="链接"><a href="#链接" class="headerlink" title="链接"></a>链接</h2><p><a href="http://www.lydsy.com/JudgeOnline/problem.php?id=1588" target="_blank" rel="external">bzoj-1588</a><br><a href="/2016/12/18/bzoj-1588/1588.cpp" title="1588.cpp">1588.cpp</a><br><a href="/2016/12/18/bzoj-1588/1588_lnk.cpp" title="1588_lnk.cpp">1588_lnk.cpp</a></p>
<h2 id="在线-Treap"><a href="#在线-Treap" class="headerlink" title="在线-Treap"></a>在线-Treap</h2><h3 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h3><p>维护treap，找前/后驱取最小值即可。</p>
<h3 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h3><p>```c++ 1588.cpp</p>
<p>#include<algorithm></algorithm></p>
<p>#include<cstdio></cstdio></p>
<p>#include<cstdlib><br>using namespace std;<br>const int N=50010,INF=1E8;<br>struct treap{<br>    int sz;<br>    struct node{int l,r,w,rnd;}t[N];<br>    treap(){sz=0;srand(20001106);}<br>    void lturn(int &amp;k)<br>    {int p=t[k].r;t[k].r=t[p].l;t[p].l=k;k=p;}<br>    void rturn(int &amp;k)<br>    {int p=t[k].l;t[k].l=t[p].r;t[p].r=k;k=p;}<br>    void ins(int &amp;k,int x){<br>        if(!k)t[k=++sz].w=x,t[k].rnd=rand();<br>        else if(t[k].w&gt;x){<br>            ins(t[k].l,x);<br>            if(t[k].rnd<t[t[k].l].rnd)rturn(k); }else="" if(t[k].w<x){="" ins(t[k].r,x);="" if(t[k].rnd<t[t[k].r].rnd)lturn(k);="" };="" }="" int="" _max(int="" &k)="" {if(!t[k].r)return="" t[k].w;return="" _max(t[k].r);}="" _min(int="" {if(!t[k].l)return="" _min(t[k].l);}="" succ(int="" &k,int="" x){="" if(!k)return="" inf;="" if(t[k].w<x)return="" succ(t[k].r,x);="" if((!t[k].l)||_max(t[k].l)<x)return="" t[k].w;="" return="" succ(t[k].l,x);="" prev(int="" -inf;="" if(t[k].w="">x)return prev(t[k].l,x);<br>        if((!t[k].r)||_min(t[k].r)&gt;x)return t[k].w;<br>        return prev(t[k].r,x);<br>    }<br>    void print(int &amp;k,int dep){<br>        if(!k)return;<br>        print(t[k].l,dep+1);<br>        for(int i=0;i&lt;dep;i++)printf(“    “);<br>        printf(“[%d]=%d(%d/%d)%d\n”,k,t[k].w,t[k].cnt,t[k].s,<br>            (int)t[k].rnd/1000000);<br>        print(t[k].r,dep+1);<br>    }<br>}dat;<br>int main(){<br>    freopen(“in”,”r”,stdin);<br>    int n,x,ans,rt=0;<br>    scanf(“%d\n%d\n”,&amp;n,&amp;ans);<br>    dat.ins(rt,ans);<br>    for(int i=1;i&lt;n;i++){<br>        scanf(“%d\n”,&amp;x);<br>        ans+=min(dat.succ(rt,x)-x,x-dat.prev(rt,x));<br>        dat.ins(rt,x);<br>    }<br>    printf(“%d”,ans);<br>    return 0;<br>}</t[t[k].l].rnd)rturn(k);></cstdlib></p>
<pre><code>
## 离线-链表
### 题解
类似某年noip的开车旅行那题的预处理
升序sort，链表链起来
逆着原始的顺序逐个处理，用左右指针得到该点的答案，然后把这个点从链表中删掉

### 代码
```c++ 1588_lnk.cpp
#include&lt;algorithm&gt;
#include&lt;cstdio&gt;
#define P pair&lt;int,int&gt;
#define mkp(x,y) make_pair(x,y)
#define fir first
#define sec second
using namespace std;
const int N=50010,INF=1E8;
int main(){
    //freopen(&quot;in&quot;,&quot;r&quot;,stdin);
    int n,x,ans;P a[N];
    scanf(&quot;%d&quot;,&amp;n);
    for(int i=0;i&lt;n;i++)scanf(&quot;%d&quot;,&amp;x),a[i]=mkp(x,i);
    ans=a[0].fir;sort(a,a+n);
    int l[N],r[N],loc[N];
    for(int i=0;i&lt;n;i++)loc[a[i].sec]=i;
    for(int i=0;i&lt;n;i++)l[i]=i-1,r[i]=i+1;
    l[0]=n+1;a[n].fir=INF;a[n+1].fir=-INF;
    for(int i=n-1;i&gt;0;i--){
        int j=loc[i];
        ans+=min(a[j].fir-a[l[j]].fir,a[r[j]].fir-a[j].fir);
        r[l[j]]=r[j];l[r[j]]=l[j];
    }
    printf(&quot;%d&quot;,ans);
    return 0;
}
</code></pre>]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[bzoj-1026 [SCOI2009]windy数]]></title>
      <url>https://cothrax.github.io/2016/12/10/bzoj-1026/</url>
      <content type="html"><![CDATA[<p>windy定义了一种windy数。不含前导零且相邻两个数字之差至少为2的正整数被称为windy数。 windy想知道，<br>在A和B之间，包括A和B，总共有多少个windy数？<br>100%的数据，满足 1 &lt;= A &lt;= B &lt;= 2000000000 。<br><a id="more"></a></p>
<h2 id="链接"><a href="#链接" class="headerlink" title="链接"></a>链接</h2><p><a href="http://www.lydsy.com/JudgeOnline/problem.php?id=1026" target="_blank" rel="external">bzoj-1026</a><br><a href="/2016/12/10/bzoj-1026/1026.cpp" title="1026.cpp">1026.cpp</a></p>
<h2 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h2><p>数位DP入门题<br>推荐<a href="http://wenku.baidu.com/link?url=swqfY1eyFBIywbtd6_WrQnBpIKFVzHysq4KHbC99UfWCvzPJH5k15tj2bVUEqIAWSqmomKYOWemQztBbRl2uEogZd4mO6g7yxL6D2XCgXUq" target="_blank" rel="external">初探数位dp</a>和刘聪的论文《浅谈数位统计类问题》<br>关于本题：<br>记f[i][j]为有i位、最高位为j的所有数中的windy数个数<br>$f[i][j]+=f[i-1][k],|j-k|\geq 2$</p>
<p>关于前导0，由于形如01…这类数是不包含在内的f[i][0]，因为1-0&lt;2的<br>因此可以先统计不含前导0的情况，即最高位k不统计f[k][0]<br>然后考虑含前导0的数，枚举$x&lt;k$，即有k-x位前导0，则将$\sum_{i=1}^{9}f[x][i]$加入答案<br>这个还可以用前缀和优化一下</p>
<h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><p>```c++ 1026.cpp</p>
<p>#include<algorithm></algorithm></p>
<p>#include<cstdio></cstdio></p>
<p>#include<string.h></string.h></p>
<p>#include<cmath></cmath></p>
<p>#define ll long long<br>using namespace std;<br>const int N=12;<br>ll f[N][N],sum[N];<br>void dp(int n){<br>    fill(f[0],f[0]+N,(ll)1);<br>    for(int i=1;i<n;i++) for(int="" j="0;j<10;j++)" k="0;k<10;k++)" if(abs(k-j)="">=2)f[i][j]+=f[i-1][k];<br>    for(int i=0;i<n;i++) for(int="" j="1;j<10;j++)sum[i]+=f[i][j];" i="1;i<n;i++)sum[i]+=sum[i-1];" }="" ll="" calc(ll="" n){="" ret="0;int" a[n],k="0;" while(n)a[k++]="n%10,n/=10;a[k]=20;">=0;i–){<br>        for(int j=0;j<a[i];j++) if(abs(a[i+1]-j)="">=2)ret+=f[i][j];<br>        if(abs(a[i+1]-a[i])&lt;2)break;<br>    }<br>    return ret-f[k-1][0]+sum[k-2];<br>}<br>int main(){<br>    //freopen(“in”,”r”,stdin);freopen(“out”,”w”,stdout);<br>    ll a,b;<br>    scanf(“%lld %lld”,&amp;a,&amp;b);<br>    dp((int)log10(b)+2);<br>    printf(“%lld”,calc(b+1)-calc(a));<br>    return 0;<br>}<br>```</a[i];j++)></n;i++)></n;i++)></p>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[bzoj-1833 [ZJOI2010]数字计数]]></title>
      <url>https://cothrax.github.io/2016/12/10/bzoj-1833/</url>
      <content type="html"><![CDATA[<p>给定两个正整数a和b，求在[a,b]中的所有整数中，每个数码(digit)各出现了多少次。<br>100%的数据中，a&lt;=b&lt;=10^12。<br><a id="more"></a></p>
<h2 id="链接"><a href="#链接" class="headerlink" title="链接"></a>链接</h2><p><a href="http://www.lydsy.com/JudgeOnline/problem.php?id=1833" target="_blank" rel="external">bzoj-1833</a><br><a href="/2016/12/10/bzoj-1833/1833.cpp" title="1833.cpp">1833.cpp</a></p>
<h2 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h2><p>很像pj的某题<br>数位dp<br>记f[i][j][k]为有i位、最高位为j的数中k出现的次数<br>sum[i][k]为i位数中k出现的次数<br>$f[i][j][k]+=sum[i-1][k]+[j=k]*10^{i-1}$<br>然后处理一下前导0，类似<a href="/2016/12/10/bzoj-1026/" title="bzoj-1026 [SCOI2009]windy数">bzoj-1026 [SCOI2009]windy数</a><br>然后就是套路的从高到低枚举数位统计即可<br>bug:</p>
<ol>
<li>log10写成log2（。。。）</li>
<li>没有注意$10^i$</li>
</ol>
<h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><p>```c++ 1833.cpp</p>
<p>#include<algorithm></algorithm></p>
<p>#include<cstdio></cstdio></p>
<p>#include<cmath></cmath></p>
<p>#define ll long long<br>using namespace std;<br>const int N=16;<br>ll f[N][N][N],sum[N][N],amt[N][N],b[N]={1};<br>void dp(int n){<br>    for(int i=1;i<n;i++)b[i]=b[i-1]*10; for(int="" i="0;i<10;i++)f[0][i][i]=1,sum[0][i]=1;" j="0;j<10;j++)" k="0;k<10;k++)" f[i][j][k]="sum[i-1][k]+(j==k?1:0)*b[i]," sum[i][k]+="f[i][j][k];" amt[i][k]+="f[i][j][k];" amt[i][j]+="amt[i-1][j];" }="" ll="" calc(ll="" n,int="" x){="" tmp="n;" int="" a[n],k="0,cnt=0;ll" ret="0;" while(n)a[k++]="n%10,n/=10;">=0;i–){<br>        for(int j=(i==k-1?1:0);j&lt;a[i];j++)<br>            ret+=f[i][j][x]+cnt*b[i];<br>        cnt+=(a[i]==x)?1:0;<br>    }<br>    return ret+amt[k-2][x];<br>}<br>int main(){<br>    //freopen(“in”,”r”,stdin);freopen(“out”,”w”,stdout);<br>    ll a,b;scanf(“%lld %lld”,&amp;a,&amp;b);<br>    dp((int)log10(b)+2);<br>    for(int i=0;i&lt;10;i++){<br>        printf(“%lld”,calc(b+1,i)-calc(a,i));<br>        if(i&lt;9)printf(“ “);<br>    }<br>    //fclose(stdin);fclose(stdout);<br>    return 0;<br>}<br>```</n;i++)b[i]=b[i-1]*10;></p>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[bzoj-2595 [WC2008] 游览计划]]></title>
      <url>https://cothrax.github.io/2016/12/09/bzoj-2595/</url>
      <content type="html"><![CDATA[<p>从未来过绍兴的小 D 有幸参加了 Winter Camp 2008,他被这座历史名城的秀丽风景所吸引,强烈要求游览绍兴及其周边的所有景点。<br>主办者将绍兴划分为 N 行 M 列(N×M)个方块,如下图(8×8):</p>
<table>
<thead>
<tr>
<th style="text-align:center">.</th>
<th style="text-align:center">.</th>
<th style="text-align:center">.</th>
<th style="text-align:center">.</th>
<th style="text-align:center">.</th>
<th style="text-align:center">.</th>
<th style="text-align:center">.</th>
<th style="text-align:center">.</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">.</td>
<td style="text-align:center">.</td>
<td style="text-align:center">.</td>
<td style="text-align:center">.</td>
<td style="text-align:center">沈园</td>
<td style="text-align:center">.</td>
<td style="text-align:center">.</td>
<td style="text-align:center">.</td>
</tr>
<tr>
<td style="text-align:center">.</td>
<td style="text-align:center">.</td>
<td style="text-align:center">.</td>
<td style="text-align:center">.</td>
<td style="text-align:center">八字桥</td>
<td style="text-align:center">.</td>
<td style="text-align:center">.</td>
<td style="text-align:center">.</td>
</tr>
<tr>
<td style="text-align:center">.</td>
<td style="text-align:center">.</td>
<td style="text-align:center">.</td>
<td style="text-align:center">周恩来故居</td>
<td style="text-align:center">.</td>
<td style="text-align:center">.</td>
<td style="text-align:center">.</td>
<td style="text-align:center">东湖</td>
</tr>
<tr>
<td style="text-align:center">.</td>
<td style="text-align:center">.</td>
<td style="text-align:center">.</td>
<td style="text-align:center">.</td>
<td style="text-align:center">.</td>
<td style="text-align:center">.</td>
<td style="text-align:center">.</td>
<td style="text-align:center">.</td>
</tr>
<tr>
<td style="text-align:center">.</td>
<td style="text-align:center">.</td>
<td style="text-align:center">.</td>
<td style="text-align:center">.</td>
<td style="text-align:center">.</td>
<td style="text-align:center">大禹陵</td>
<td style="text-align:center">.</td>
<td style="text-align:center">.</td>
</tr>
<tr>
<td style="text-align:center">.</td>
<td style="text-align:center">兰亭</td>
<td style="text-align:center">.</td>
<td style="text-align:center">.</td>
<td style="text-align:center">.</td>
<td style="text-align:center">.</td>
<td style="text-align:center">.</td>
<td style="text-align:center">.</td>
</tr>
<tr>
<td style="text-align:center">鉴湖</td>
<td style="text-align:center">.</td>
<td style="text-align:center">.</td>
<td style="text-align:center">.</td>
<td style="text-align:center">.</td>
<td style="text-align:center">.</td>
<td style="text-align:center">.</td>
<td style="text-align:center">.</td>
</tr>
</tbody>
</table>
<p>景点含于方块内,且一个方块至多有一个景点。无景点的方块视为路。<br>为了保证安全与便利,主办方依据路况和治安状况,在非景点的一些方块内安排不同数量的志愿者;在景点内聘请导游(导游不是志愿者)。<br>在选择旅游方案时,保证任意两个景点之间,存在一条路径,在这条路径所经过的每一个方块都有志愿者或者该方块为景点。既能满足选手们游览的需要,又能够让志愿者的总数最少。<br><a id="more"></a></p>
<table>
<thead>
<tr>
<th style="text-align:center">1</th>
<th style="text-align:center">4</th>
<th style="text-align:center">1</th>
<th style="text-align:center">3</th>
<th style="text-align:center">4</th>
<th style="text-align:center">2</th>
<th style="text-align:center">4</th>
<th style="text-align:center">1</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">4</td>
<td style="text-align:center">3</td>
<td style="text-align:center">1</td>
<td style="text-align:center">2</td>
<td style="text-align:center">沈园</td>
<td style="text-align:center">1</td>
<td style="text-align:center">2</td>
<td style="text-align:center">3</td>
</tr>
<tr>
<td style="text-align:center">3</td>
<td style="text-align:center">2</td>
<td style="text-align:center">1</td>
<td style="text-align:center">3</td>
<td style="text-align:center">八字桥</td>
<td style="text-align:center">3</td>
<td style="text-align:center">1</td>
<td style="text-align:center">2</td>
</tr>
<tr>
<td style="text-align:center">2</td>
<td style="text-align:center">6</td>
<td style="text-align:center">5</td>
<td style="text-align:center">周恩来故居</td>
<td style="text-align:center"><font color="red">2</font></td>
<td style="text-align:center">4</td>
<td style="text-align:center"><font color="red">1</font></td>
<td style="text-align:center">东湖</td>
</tr>
<tr>
<td style="text-align:center">5</td>
<td style="text-align:center">1</td>
<td style="text-align:center">2</td>
<td style="text-align:center"><font color="red">1</font></td>
<td style="text-align:center"><font color="red">3</font></td>
<td style="text-align:center"><font color="red">4</font></td>
<td style="text-align:center"><font color="red">2</font></td>
<td style="text-align:center">5</td>
</tr>
<tr>
<td style="text-align:center">5</td>
<td style="text-align:center"><font color="red">1</font></td>
<td style="text-align:center"><font color="red">3</font></td>
<td style="text-align:center"><font color="red">1</font></td>
<td style="text-align:center">5</td>
<td style="text-align:center">大禹陵</td>
<td style="text-align:center">1</td>
<td style="text-align:center">4</td>
</tr>
<tr>
<td style="text-align:center">5</td>
<td style="text-align:center">兰亭</td>
<td style="text-align:center">6</td>
<td style="text-align:center">1</td>
<td style="text-align:center">4</td>
<td style="text-align:center">5</td>
<td style="text-align:center">3</td>
<td style="text-align:center">4</td>
</tr>
<tr>
<td style="text-align:center">鉴湖</td>
<td style="text-align:center"><font color="red">2</font></td>
<td style="text-align:center">2</td>
<td style="text-align:center">2</td>
<td style="text-align:center">3</td>
<td style="text-align:center">4</td>
<td style="text-align:center">1</td>
<td style="text-align:center">1</td>
</tr>
</tbody>
</table>
<p>例如,在上面的例子中,在每个没有景点的方块中填入一个数字,表示控制该方块最少需要的志愿者数目:</p>
<p>图中用深色标出的方块区域就是一种可行的志愿者安排方案,一共需要 20名志愿者。由图可见,两个相邻的景点是直接(有景点内的路)连通的(如沈园和八字桥)。<br>现在,希望你能够帮助主办方找到一种最好的安排方案。</p>
<p>$n,m,k\leq 10$</p>
<h2 id="链接"><a href="#链接" class="headerlink" title="链接"></a>链接</h2><p><a href="http://www.lydsy.com/JudgeOnline/problem.php?id=2595" target="_blank" rel="external">bzoj-2595</a><br><a href="/2016/12/09/bzoj-2595/2595.cpp" title="2595.cpp">2595.cpp</a></p>
<h2 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h2><p>斯坦纳树，即经过定点的最小生成树，换句话说，就是在生成树的过程中允许新增一些点来最小化代价<br>首先可以给格子(x,y)编号x*m+y<br>景点数≤10，可以状压dp解决<br>记f[i][s] 为生成树根为i，连通状态至少为s的最小代价，其中s(x)表示i是否与第x个景点连通<br>初始状态：记sp[i]为第i个景点，则$f[sp[i]][2^i]=0$<br>然后转移：<br>$f[i][s]=min(f[i][s]+f[i][s-t]-a[i]),t\in s$<br>$f[i][s]=min(f[j][s]+a[i]),\exists e(j\to i)$</p>
<p>前一个直接枚举子集（手贱把枚举子集码成了枚举lowbit,wa一次）<br>至于后一个，由于这个方程的转移中有环，但最优解的转移一定是拓扑的，所以用多源点的spfa解决<br>dp之后任意$f[sp[i]][2^k-1]$都是最优答案<br>至于输出方案，用pre[i][s]记录f[i][s]是由哪个状态转移过来的，dfs一下即可</p>
<h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><p>```c++ 2595.cpp</p>
<p>#include<algorithm></algorithm></p>
<p>#include<cstdio></cstdio></p>
<p>#define P pair<int,int></int,int></p>
<p>#define mkp(x,y) make_pair(x,y)</p>
<p>#define ll long long<br>using namespace std;<br>const int N=11,Z=N<em>N</em>2;const ll INF=10E16;<br>int n,m,nm,l;ll a[N<em>N];<br>inline int p(int x,int y){return x</em>m+y;}</p>
<p>P pre[N<em>N][1&lt;&lt;N];ll f[N</em>N][1&lt;<n]; const="" int="" x[4]="{0,1,0,-1},Y[4]={1,0,-1,0};" q[z],h,t;bool="" inq[z];="" void="" spfa(int="" i){="" for(;h!="t;inq[q[h]]=0,h=(h+1)%Z)" for(int="" j="0;j<4;j++){" u="q[h],x=u/m+X[j],y=u%m+Y[j],v=p(x,y);" if(x<0||y<0||x="">=n||y&gt;=m)continue;<br>            if(f[v][i]&gt;f[u][i]+a[v]){<br>                f[v][i]=f[u][i]+a[v];pre[v][i]=mkp(u,i);<br>                if(!inq[v])q[t++]=v,inq[v]=1,t%=Z;<br>            }<br>        }<br>}</n];></p>
<p>bool flg[Z];<br>void dfs(int i,int j){<br>    if(f[i][j]==INF||i==-1||j==0)return;<br>    flg[i]=1;int x,y;<br>    dfs(x=pre[i][j].first,y=pre[i][j].second);<br>    if(x==i)dfs(x,y^j);<br>}</p>
<p>int main(){<br>    //freopen(“in”,”r”,stdin);freopen(“out”,”w”,stdout);<br>    scanf(“%d %d”,&amp;n,&amp;m);nm=n*m;<br>    int sp[N],k=0;bool mk[Z];<br>    fill(mk,mk+Z,0);<br>    for(int i=0;i<n;i++) for(int="" j="0;j<m;j++){" scanf("%lld",&a[p(i,j)]);="" if(!a[p(i,j)])sp[k++]="p(i,j),mk[p(i,j)]=1;" }="" l="1<<k;" i="0;i<nm;i++){" fill(f[i],f[i]+l+1,inf);="" fill(pre[i],pre[i]+l+1,mkp(-1,0));="" fill(inq,inq+z,0);="" ll="" tmp;h="t=0;" s="i;s;s=i&(s-1))" if(f[j][i]="">(tmp=f[j][s]+f[j][i^s]-a[j]))<br>                    f[j][i]=tmp,pre[j][i]=mkp(j,s);<br>            if(f[j][i]!=INF)q[t++]=j,inq[j]=1,t%=Z;<br>        }spfa(i);<br>    }<br>    printf(“%lld\n”,f[sp[0]][l-1]);dfs(sp[0],l-1);<br>    for(int i=0;i&lt;n;i++){<br>        for(int j=0;j&lt;m;j++)<br>            if(mk[p(i,j)])printf(“x”);<br>            else if(flg[p(i,j)])printf(“o”);<br>            else printf(“_”);<br>        printf(“\n”);<br>    }<br>    return 0;<br>}<br>```</n;i++)></p>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[bzoj-2004 [HNOI2010]Bus 公交线路]]></title>
      <url>https://cothrax.github.io/2016/12/09/bzoj-2004/</url>
      <content type="html"><![CDATA[<p>小Z所在的城市有N个公交车站，排列在一条长(N-1)km的直线上，从左到右依次编号为1到N，相邻公交车站间的距<br>离均为1km。 作为公交车线路的规划者，小Z调查了市民的需求，决定按下述规则设计线路：</p>
<ol>
<li>设共K辆公交车，则1到K号站作为始发站，N-K+1到N号台作为终点站。</li>
<li>每个车站必须被一辆且仅一辆公交车经过（始发站和<br>终点站也算被经过）。 </li>
<li>公交车只能从编号较小的站台驶往编号较大的站台。 </li>
<li>一辆公交车经过的相邻两个站台间距离不得超过Pkm</li>
</ol>
<p>在最终设计线路之前，小Z想知道有多少种满足要求的方案。由于答案可能很大，你只<br>需求出答案对30031取模的结果。</p>
<span>$N\leq 10^9,1&lt;P\leq 10,K&lt;N,2&lt;K\leq P$</span><!-- Has MathJax -->
<a id="more"></a>
<h2 id="链接"><a href="#链接" class="headerlink" title="链接"></a>链接</h2><p><a href="http://www.lydsy.com/JudgeOnline/problem.php?id=2004" target="_blank" rel="external">bzoj-2004</a><br><a href="/2016/12/09/bzoj-2004/2004.cpp" title="2004.cpp">2004.cpp</a></p>
<h2 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h2><p>状压dp+矩阵快速幂<br>直接状压+矩乘$O(2^{3P}logN)$是会T的<br>实际上最低位不是1、1的个数!=k的状态都是无效的<br>预处理有效状态，再构造矩阵就好</p>
<h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><p>```c++ 2004.cpp</p>
<p>#include<algorithm></algorithm></p>
<p>#include<cstdio></cstdio></p>
<p>#include<string.h><br>using namespace std;<br>const int N=200,M=2050,Z=30031;<br>int n,k,p,m,t=0,cnt[M],a[M],loc[M];<br>struct mat{<br>    int v[N][N];<br>    mat(){memset(v,0,sizeof(v));}<br>    friend mat operator<em>(mat a,mat b){<br>        mat ret;<br>        for(int i=0;i&lt;t;i++)<br>            for(int j=0;j&lt;t;j++)<br>                for(int k=0;k&lt;t;k++)<br>                    ret.v[i][j]+=a.v[i][k]</em>b.v[k][j],<br>                    ret.v[i][j]%=Z;<br>        return ret;<br>    }<br>    friend mat operator^(mat a,int n){<br>        mat ret;<br>        for(int i=0;i<t;i++)ret.v[i][i]=1; for(;n;n="">&gt;=1,a=a<em>a)if(n&amp;1)ret=ret</em>a;<br>        return ret;<br>    }<br>}f;<br>int main(){<br>    //freopen(“in”,”r”,stdin);<br>    scanf(“%d %d %d”,&amp;n,&amp;k,&amp;p);m=1&lt;<p; for(int="" i="1;i<m;i++)cnt[i]=cnt[i&(i-1)]+1;" if(cnt[i]="=k&&(i&1))loc[i]=t,a[t++]=i;" else="" loc[i]="N-1;" printf("%d\n",t);="" int="" x="a[i];" f.v[loc[(x<<1)&(m-1)|1]][i]="1;" if(x="">&gt;(p-1))continue;<br>        for(int j=1;j&lt;m;j&lt;&lt;=1)f.v[loc[(x&lt;&lt;1)^j|1]][i]=1;<br>    }<br>    int st=loc[(1&lt;&lt;k)-1];<br>    printf(“%d”,(f^(n-k)).v[st][st]);<br>    return 0;<br>}<br>```</p;></t;i++)ret.v[i][i]=1;></string.h></p>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[bzoj-1097 [POI2007]旅游景点atr]]></title>
      <url>https://cothrax.github.io/2016/12/09/bzoj-1097/</url>
      <content type="html"><![CDATA[<p>大意：给定n个节点，m条边的带权无向图，要最小化这样一条路径的代价：</p>
<ol>
<li>从点1出发</li>
<li>经过点2..k+1，顺序有一定的要求</li>
<li>终点为n</li>
</ol>
<p>$n\leq 20000,m\leq 200000,k\leq 20$</p>
<a id="more"></a>
<h2 id="链接"><a href="#链接" class="headerlink" title="链接"></a>链接</h2><p><a href="http://hzwer.com/4742.html" target="_blank" rel="external">hzwer</a><br><a href="/2016/12/09/bzoj-1097/atr.cpp" title="atr.cpp">atr.cpp</a></p>
<h2 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h2><p>先处理1..k+1及n之间的最短路<br>然后状压dp，记f[s][i]为状态为s，s(x)表示第x个点是否已经经过，i为这条路径终点<br>转移直接枚举补集中的点即可</p>
<h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><p>```c++ atr.cpp</p>
<p>#include<algorithm></algorithm></p>
<p>#include<cstdio></cstdio></p>
<p>#include<queue></queue></p>
<p>#include<string.h></string.h></p>
<p>#define P pair<int,int></int,int></p>
<p>#define mkp(x,y) make_pair(x,y)<br>using namespace std;<br>const int N=20010,M=400010,K=25,L=1&lt;<21,inf=10e8; struct="" edge{int="" v,w,nxt;}="" g[m];="" int="" head[n],d[n],a[k][k],f[l][k],bf[k],af[k],b[k];="" n,m,k,t,l,sz="0;" bool="" flg[n];="" void="" _add(int="" u,int="" v,int="" w)="" {g[++sz]="{v,w,head[u]};head[u]=sz;};" add(int="" {_add(u,v,w);_add(v,u,w);}="" dij(int="" s){="" priority_queue<p,vector<p="">,greater<p> &gt;q;<br>    fill(d,d+n+1,INF);fill(flg,flg+n+1,false);<br>    d[s]=0;q.push(mkp(0,s));<br>    while(!q.empty()){<br>        int u=q.top().second,v;q.pop();<br>        if(flg[u])continue;flg[u]=true;<br>        for(int i=head[u];i;i=g[i].nxt)<br>            if(d[u]+g[i].w&lt;d[v=g[i].v])<br>                d[v]=d[u]+g[i].w,q.push(mkp(d[v],v));<br>    }<br>    for(int i=1;i&lt;=k+1;i++)a[s][i]=d[i];<br>    a[s][0]=d[n];<br>}<br>inline bool jud(int x,int i)<br>{return (x&amp;bf[i])==bf[i]&amp;&amp;(x&amp;af[i])==0;}</p>
<p>int main(){<br>    //freopen(“atr9b.in”,”r”,stdin);freopen(“out”,”w”,stdout);<br>    scanf(“%d %d %d\n”,&amp;n,&amp;m,&amp;k);<br>    int u,v,w;l=1&lt;&lt;k;b[2]=1;<br>    for(int i=3;i&lt;=k+1;i++)b[i]=b[i-1]&lt;&lt;1;<br>    for(int i=0;i&lt;m;i++)<br>        scanf(“%d %d %d\n”,&amp;u,&amp;v,&amp;w),add(u,v,w);<br>    for(int i=2;i&lt;=k+1;i++)dij(i);<br>    scanf(“%d\n”,&amp;t);<br>    for(int i=0;i&lt;t;i++){<br>        scanf(“%d %d\n”,&amp;u,&amp;v);<br>        bf[v]|=b[u];af[u]|=b[v];<br>    }<br>    for(int i=0;i&lt;l;i++)<br>        for(int j=2;j&lt;=k+1;j++)f[i][j]=INF;<br>    for(int i=2;i&lt;=k+1;i++)<br>        if(!bf[i])f[b[i]][i]=a[i][1]/<em>,printf(“%d, “,i)</em>/;<br>    for(int i=0;i&lt;l;i++)<br>        for(int j=2;j&lt;=k+1;j++)if(f[i][j]!=INF)<br>            for(int p=2;p&lt;=k+1;p++)if(!(i&amp;b[p])&amp;&amp;jud(i,p))<br>                f[i|b[p]][p]=min(f[i|b[p]][p],f[i][j]+a[j][p]);<br>    int ans=INF;<br>    for(int i=2;i&lt;=k+1;i++)ans=min(ans,f[l-1][i]+a[i][0]);<br>    printf(“%d”,ans);<br>    //fclose(stdin);fclose(stdout);<br>    return 0;<br>}<br>```</p>
</21,inf=10e8;></p>]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[bzoj-2734 [HNOI2012]集合选数]]></title>
      <url>https://cothrax.github.io/2016/12/09/bzoj-2734/</url>
      <content type="html"><![CDATA[<p>约束条件：若x在集合s中，则2x和3x不能在该集合中。<br>对于任意一个正整数 n≤100000，如何求出{1, 2,…, n} 的满足上述约束条件的子集的个数（只需输出对 1,000,000,001 取模的结果）。<br>n≤20</p>
<a id="more"></a>
<h2 id="链接"><a href="#链接" class="headerlink" title="链接"></a>链接</h2><p><a href="http://www.lydsy.com/JudgeOnline/problem.php?id=1013" target="_blank" rel="external">bzoj-2734</a><br><a href="/2016/12/09/bzoj-2734/2734.cpp" title="2734.cpp">2734.cpp</a></p>
<h2 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h2><p>基于状压dp的想法题<br>详见：<a href="http://hzwer.com/5149.html" target="_blank" rel="external">hzwer</a></p>
<h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><p>```c++ 2734.cpp</p>
<p>#include<cstdio></cstdio></p>
<p>#include<algorithm></algorithm></p>
<p>#include<string.h></string.h></p>
<p>#define ll long long<br>using namespace std;<br>const int N=100050,K=20,Z=1E9+1;<br>int n,m=0,b[K]={1},h[1&lt;&lt;K],f[K][1&lt;&lt;K];<br>bool flg[N];<br>int calc(int x){<br>    int cnt=0,a[K];memset(a,0,sizeof(a));<br>    for(int i=x;i&lt;=n;i<em>=2,cnt++)<br>        for(int j=i;j&lt;=n;j</em>=3)<br>            a[cnt+1]++,flg[j]=true;<br>    for(int i=1;i&lt;=cnt;i++)fill(f[i],f[i]+b[a[i]],0);<br>    f[0][0]=1;<br>    for(int i=0;i&lt;=cnt;i++)<br>        for(int j=0;h[j]&lt;b[a[i]]&amp;&amp;j&lt;m;j++)if(f[i][j])<br>            for(int k=0;h[k]&lt;b[a[i+1]]&amp;&amp;k&lt;m;k++)<br>                if(!(h[k]&amp;(h[k]&lt;&lt;1))&amp;&amp;!(h[k]&amp;h[j]))<br>                    f[i+1][k]=((ll)f[i+1][k]+(ll)f[i][j])%Z;<br>    int ret=0;<br>    for(int i=0;h[i]&lt;b[a[cnt]]&amp;&amp;i&lt;m;i++)<br>        ret=((ll)ret+(ll)f[cnt][i])%Z;<br>    return ret;<br>}<br>int main(){<br>    //freopen(“in”,”r”,stdin);<br>    scanf(“%d”,&amp;n);int ans=1;<br>    for(int i=1;i&lt;K;i++)b[i]=b[i-1]&lt;&lt;1;<br>    for(int i=0;i&lt;1&lt;&lt;K;i++)if(!(i&amp;(i&lt;&lt;1)))h[m++]=i;<br>    for(int i=1;i&lt;=n;i++)if(!flg[i])ans=((ll)ans*(ll)calc(i))%Z;<br>    printf(“%d”,ans);<br>    return 0;<br>}<br>```</p>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[bzoj-2964 分裂]]></title>
      <url>https://cothrax.github.io/2016/12/09/bzoj-2064/</url>
      <content type="html"><![CDATA[<p> 中国历史上上分分和和次数非常多。。通读中国历史的WJMZBMR表示毫无压力。 同时经常搞OI的他把这个变成了一个数学模型。 假设中国的国土总和是不变的。 每个国家都可以用他的国土面积代替， 又两种可能，一种是两个国家合并为1个，那么新国家的面积为两者之和。 一种是一个国家分裂为2个，那么2个新国家的面积之和为原国家的面积。 WJMZBMR现在知道了很遥远的过去中国的状态，又知道了中国现在的状态，想知道至少要几次操作（分裂和合并各算一次操作），能让中国从当时状态到达现在的状态。<br>$n1,n2\leq 10$<br><a id="more"></a></p>
<h2 id="链接"><a href="#链接" class="headerlink" title="链接"></a>链接</h2><p><a href="http://hzwer.com/2001.html" target="_blank" rel="external">hzwer</a><br><a href="/2016/12/09/bzoj-2064/2064.cpp" title="2064.cpp">2064.cpp</a></p>
<h2 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h2><p>基于状压dp的想法题<br>见：<a href="http://www.cnblogs.com/xkui/p/4540093.html" target="_blank" rel="external">神犇的blog</a></p>
<h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><p>```c++ 2064.cpp</p>
<p>#include<algorithm></algorithm></p>
<p>#include<cstdio><br>using namespace std;<br>const int N=25,M=1&lt;&lt;21;<br>int n=0,m,a[N],b[N]={1},s[M],f[M];<br>int main(){<br>    scanf(“%d”,&amp;n);<br>    for(int i=0;i&lt;n;i++)scanf(“%d”,&amp;a[i]);<br>    int x;scanf(“%d”,&amp;x);n+=x;m=1&lt;&lt;n;<br>    for(int i=n-x;i&lt;n;i++)scanf(“%d”,&amp;a[i]),a[i]<em>=-1;<br>    for(int i=1;i&lt;n;i++)b[i]=b[i-1]&lt;&lt;1;<br>    for(int i=0;i&lt;n;i++)s[b[i]]=a[i];<br>    for(int i=0;i&lt;m;i++)s[i]=s[i&amp;(i-1)]+s[i&amp;(-i)];<br>    for(int i=1;i&lt;m;i++){<br>        for(int j=0;j&lt;n;j++)if(i&amp;b[j])<br>            f[i]=max(f[i^b[j]],f[i]);<br>        if(!s[i])f[i]++;<br>    }<br>    printf(“%d”,n-2</em>f[m-1]);<br>    return 0;<br>}<br>```</cstdio></p>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[begin-1501 [Usaco2006]玉米田]]></title>
      <url>https://cothrax.github.io/2016/12/09/begin-1501/</url>
      <content type="html"><![CDATA[<p>农民 John 购买了一处肥沃的矩形牧场，分成M*N(1 &lt;= M &lt;= 12; 1 &lt;= N &lt;= 12)个<br>格子。他想在那里的一些格子中种植美味的玉米。遗憾的是，有些格子区域的土地是贫瘠的，<br>不能耕种。<br>精明的 FJ 知道奶牛们进食时不喜欢和别的牛相邻，所以一旦在一个格子中种植玉米，那么<br>他就不会在相邻的格子中种植，即没有两个被选中的格子拥有公共边。他还没有最终确定哪些<br>格子要选择种植玉米。<br>作为一个思想开明的人，农民 John 希望考虑所有可行的选择格子种植方案。由于太开明，<br>他还考虑一个格子都不选择的种植方案！请帮助农民 John 确定种植方案总数。</p>
<a id="more"></a>
<h2 id="链接"><a href="#链接" class="headerlink" title="链接"></a>链接</h2><p><a href="http://begin.lydsy.com/JudgeOnline/problem.php?id=1501" target="_blank" rel="external">begin-1501</a><br><a href="/2016/12/09/begin-1501/b1501.cpp" title="b1501.cpp">b1501.cpp</a></p>
<h2 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h2><p>逐行状压，<a href="/2016/12/03/bzoj-1087/" title="king">king</a>那题的弱化版</p>
<h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><p>```c++ b1501.cpp</p>
<p>#include<algorithm></algorithm></p>
<p>#include<cstdio><br>using namespace std;<br>const int N=13,M=1&lt;&lt;N,Z=100000000;<br>int n,m,l,a[N],f[N][M];<br>bool flg[M],mat[M][M];</cstdio></p>
<p>int main(){<br>    freopen(“in”,”r”,stdin);<br>    freopen(“out”,”w”,stdout);<br>    scanf(“%d %d\n”,&amp;n,&amp;m);l=1&lt;&lt;m;int x;<br>    for(int i=1;i&lt;=n;i++)<br>        for(int j=0;j&lt;m;j++)scanf(“%d”,&amp;x),a[i]|=((x^1)&lt;&lt;j);<br>    //for(int i=1;i&lt;=n;i++)printf(“%d:%d\n”,i,a[i]);<br>    for(int i=0;i&lt;l;i++)<br>        if(!(i&amp;(i&lt;&lt;1)))flg[i]=true;<br>    for(int i=0;i&lt;l;i++)<br>        for(int j=0;j&lt;l;j++)<br>            if(!(i&amp;j))mat[i][j]=true;<br>    for(int i=0;i&lt;l;i++)if(flg[i]&amp;&amp;!(i&amp;a[1]))f[1][i]=1;<br>    for(int i=1;i&lt;n;i++)<br>        for(int p=0;p&lt;l;p++)if(flg[p]&amp;&amp;!(p&amp;a[i])&amp;&amp;f[i][p])<br>            for(int q=0;q&lt;l;q++)if(flg[q]&amp;&amp;!(q&amp;a[i+1])&amp;&amp;mat[p][q])<br>                f[i+1][q]=(f[i][p]+f[i+1][q])%Z;<br>    int ans=0;<br>    for(int i=0;i&lt;l;i++)ans=(ans+f[n][i])%Z;<br>    printf(“%d”,ans);<br>    return 0;<br>}<br>```</p>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[begin-1504 [Usaco2008]混乱的奶牛]]></title>
      <url>https://cothrax.github.io/2016/12/09/begin-1504/</url>
      <content type="html"><![CDATA[<p>混乱的奶牛 [Don Piele, 2007] Farmer John的N(4 &lt;= N &lt;= 16)头奶牛中的每一头都有一个唯一的编号S_i (1 &lt;= S_i &lt;= 25,000). 奶牛为她们的编号感到骄傲, 所以每一头奶牛都把她的编号刻在一个金牌上, 并且把金牌挂在她们宽大的脖子上. 奶牛们对在挤奶的时候被排成一支”混乱”的队伍非常反感. 如果一个队伍里任意两头相邻的奶牛的编号相差超过K (1 &lt;= K &lt;= 3400), 它就被称为是混乱的. 比如说，当N = 6, K = 1时, 1, 3, 5, 2, 6, 4 就是一支”混乱”的队伍, 但是 1, 3, 6, 5, 2, 4 不是(因为5和6只相差1). 那么, 有多少种能够使奶牛排成”混乱”的队伍的方案呢?<br><a id="more"></a></p>
<h2 id="链接"><a href="#链接" class="headerlink" title="链接"></a>链接</h2><p><a href="http://begin.lydsy.com/JudgeOnline/problem.php?id=1504" target="_blank" rel="external">入门OJ-1504</a><br><a href="/2016/12/09/begin-1504/b1504.cpp" title="b1504.cpp">b1504.cpp</a></p>
<h2 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h2><p>状压dp，记f[i][s]为选择状态为s，末尾的牛编号为i的方案数<br>枚举补集中的点转移即可</p>
<h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><p>```c++ b1504.cpp</p>
<p>#include<algorithm></algorithm></p>
<p>#include<cstdio></cstdio></p>
<p>#include<cmath></cmath></p>
<p>#define ll long long<br>using namespace std;<br>const int N=17,M=1&lt;<n; int="" a[n],n,m,k;="" ll="" f[n][m];="" main(){="" freopen("in","r",stdin);="" scanf("%d="" %d\n",&n,&k);m="1<<n;" for(int="" i="0;i<n;i++)scanf("%d\n",&a[i]);" j="0;j<n;j++)if(i&(1<<j)&&f[j][i])" r="(m-1)^i;r;r=r&(r-1)){" p="round(log(r&(-r))/log(2));" if(abs(a[p]-a[j])="">k)f[p][i|(1&lt;&lt;p)]+=f[j][i];<br>            }<br>    ll ans=0;<br>    for(int i=0;i&lt;n;i++)ans+=f[i][m-1];<br>    printf(“%lld”,ans);<br>}<br>```</n;></p>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[bzoj-3653 谈笑风生]]></title>
      <url>https://cothrax.github.io/2016/12/03/bzoj-3653/</url>
      <content type="html"><![CDATA[<p>大意：给定一个n个节点的树，有m次查询<br>查询(a,k)为：点b与点a距离不超过k，且a和b均为c的祖先的无序对(a,b,c)的个数<br>n,m&lt;=300000<br><a id="more"></a></p>
<h2 id="链接"><a href="#链接" class="headerlink" title="链接"></a>链接</h2><p><a href="http://hzwer.com/5444.html" target="_blank" rel="external">hzwer</a><br><a href="/2016/12/03/bzoj-3653/3653.cpp" title="3653.cpp">3653.cpp</a></p>
<h2 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h2><p>siz[u]为u的子树大小，dep[u]为u的深度（dep[1]=0)<br>对(a,b,c)分类讨论：</p>
<ol>
<li>若b在a的子树外，则c可以为a的子树内的任意点，答案为$(siz[a]-1)*min(dep[a],k)$</li>
<li>若b在a的子树中，则c必须在b的子树中，此时答案就是$\sum_{b\in a}{siz[b]-1}$，<br>求出dfs序，用主席树维护siz和即可</li>
</ol>
<h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><p>```c++ 3653.cpp</p>
<p>#include<algorithm></algorithm></p>
<p>#include<cstdio><br>//#define D<br>using namespace std;<br>const int N=300010,M=300010;<br>struct edge{int v,nxt;} g[N*2];<br>int head[N],loc[N],seq[N],dep[N]={-1},siz[N],n,m,sz=0,k=0;<br>void add(int u,int v)<br>{g[++sz]={v,head[u]};head[u]=sz;}<br>void dfs(int u,int p){<br>    loc[u]=++k;seq[k]=u;dep[u]=dep[p]+1;siz[u]=1;int v;<br>    for(int i=head[u];i;i=g[i].nxt)<br>        if((v=g[i].v)!=p)dfs(v,u),siz[u]+=siz[v];<br>}</cstdio></p>
<p>struct node{int l,r,w;} seg[N*20];<br>int rt[N],p=0;<br>void ins(int &amp;i,int l,int r,int x,int k){<br>    if(!k)return;seg[++p]=seg[i];i=p;seg[i].w+=k;<br>    if(l==r)return;int mid=(l+r)&gt;&gt;1;<br>    if(x&lt;=mid)ins(seg[i].l,l,mid,x,k);<br>    else ins(seg[i].r,mid+1,r,x,k);<br>}<br>int ask(int i,int l,int r,int x){<br>    if(l==r)return seg[i].w;<br>    int mid=(l+r)&gt;&gt;1;<br>    if(x&lt;=mid)return ask(seg[i].l,l,mid,x);<br>    else return ask(seg[i].r,mid+1,r,x)+seg[seg[i].l].w;<br>}<br>int query(int l,int r,int x)<br>{return ask(rt[r],0,n,x)-ask(rt[l-1],0,n,x);}</p>
<p>int main(){<br>    //freopen(“in”,”r”,stdin);<br>    //freopen(“out”,”w”,stdout);<br>    scanf(“%d %d\n”,&amp;n,&amp;m);int u,v;<br>    for(int i=0;i&lt;n-1;i++)<br>        scanf(“%d %d\n”,&amp;u,&amp;v),add(u,v),add(v,u);<br>    dfs(1,0);<br>    for(int i=1;i&lt;=n;i++){<br>        rt[i]=rt[i-1];<br>        ins(rt[i],0,n,dep[seq[i]],siz[seq[i]]-1);<br>    }<br>    for(int i=0;i&lt;m;i++){<br>        scanf(“%d %d\n”,&amp;u,&amp;v);<br>        int a1=min(dep[u],v)*(siz[u]-1);<br>        int a2=query(loc[u],loc[u]+siz[u]-1,v+dep[u])-siz[u]+1;<br>        printf(“%d\n”,a1+a2);<br>    }<br>    return 0;<br>}<br>```</p>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[bzoj-1103 [POI2007]大都市]]></title>
      <url>https://cothrax.github.io/2016/12/03/bzoj-1103/</url>
      <content type="html"><![CDATA[<p>大意：给定n个节点的树，有m次查询，其间有修改操作</p>
<ol>
<li>修改操作：标记某一条边</li>
<li>查询操作：点u到点1的路径上未标记的边数</li>
</ol>
<p>n,m&lt;= 300000</p>
<a id="more"></a>
<h2 id="链接"><a href="#链接" class="headerlink" title="链接"></a>链接</h2><p><a href="http://www.lydsy.com/JudgeOnline/problem.php?id=1103" target="_blank" rel="external">bzoj-1013</a><br><a href="/2016/12/03/bzoj-1103/1103.cpp" title="1103.cpp">1103.cpp</a></p>
<h2 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h2><p>考虑修改p对查询q有影响，当且仅当q的p的子树中<br>用树状数组维护dfs序，差分修改即可</p>
<h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><p>```c++ 1103.cpp</p>
<p>#include<algorithm></algorithm></p>
<p>#include<cstdio><br>//#define DEBUG<br>using namespace std;<br>const int N=250010,M=250010;<br>struct edge{int v,nxt;} g[N*2];<br>int head[N],d[N]={-1},siz[N],loc[N],bit[N],par[N];<br>int n,m,sz=0,k=0;<br>void add(int u,int v)<br>{g[++sz]={v,head[u]};head[u]=sz;}<br>void upd(int x,int k)<br>{while(x&amp;&amp;x&lt;=n)bit[x]+=k,x+=x&amp;(-x);}<br>int sum(int x)<br>{int ret=0;while(x)ret+=bit[x],x-=x&amp;(-x);return ret;}</cstdio></p>
<p>void dfs(int u,int p){<br>    loc[u]=++k;d[u]=d[p]+1;siz[u]=1;par[u]=p;int v;<br>    for(int i=head[u];i;i=g[i].nxt)<br>        if((v=g[i].v)!=p)dfs(v,u),siz[u]+=siz[v];<br>}<br>int main(){<br>    /<em>freopen(“in”,”r”,stdin);<br>    freopen(“out”,”w”,stdout);</em>/<br>    scanf(“%d\n”,&amp;n);<br>    int u,v,cnt=0;char c;<br>    for(int i=0;i&lt;n-1;i++)<br>        scanf(“%d %d\n”,&amp;u,&amp;v),add(u,v),add(v,u);<br>    dfs(1,0);scanf(“%d”,&amp;m);<br>    while(cnt&lt;m){<br>        scanf(“%c “,&amp;c);<br>        switch(c){<br>            case ‘W’:{<br>                scanf(“%d\n”,&amp;u);cnt++;<br>                printf(“%d\n”,d[u]-sum(loc[u]));<br>            };break;<br>            case ‘A’:{<br>                scanf(“%d %d\n”,&amp;u,&amp;v);<br>                if(par[u]==v)swap(u,v);<br>                upd(loc[v],1);upd(loc[v]+siz[v],-1);<br>            };break;<br>        }<br>    }<br>    return 0;<br>}<br>```</p>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[bzoj-1087 [SCOI2005]互不侵犯King]]></title>
      <url>https://cothrax.github.io/2016/12/03/bzoj-1087/</url>
      <content type="html"><![CDATA[<p>在N×N的棋盘里面放K个国王，使他们互不攻击，共有多少种摆放方案。国王能攻击到它上下左右，以及左上<br>左下右上右下八个方向上附近的各一个格子，共8个格子。<br>1 &lt;=N&lt;=9,0&lt;=K&lt;=N*N</p>
<a id="more"></a>
<h2 id="链接"><a href="#链接" class="headerlink" title="链接"></a>链接</h2><p><a href="http://www.lydsy.com/JudgeOnline/problem.php?id=1087" target="_blank" rel="external">bzoj-1013</a><br><a href="/2016/12/03/bzoj-1087/1087.cpp" title="1087.cpp">1087.cpp</a></p>
<h2 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h2><p>逐行做状压dp<br>f[i,j,s]为第i行状态为s，当前已放j个国王的方案数<br>预处理有效状态和有效转移</p>
<h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><p>```c++ 1087.cpp</p>
<p>#include<algorithm></algorithm></p>
<p>#include<cstdio></cstdio></p>
<p>#define ll long long<br>using namespace std;<br>const int N=10,M=1&lt;<n; int="" n,m,k,cnt[m];="" ll="" f[n][n*n][m];="" bool="" flg[m],mat[m][m];="" jud(int="" x,int="" y)="" {return="" ((x<<1|x|x="">&gt;1)&amp;y)==0;}<br>int main(){<br>    //freopen(“in”,”r”,stdin);<br>    //freopen(“out”,”w”,stdout);<br>    scanf(“%d %d\n”,&amp;n,&amp;k);m=1&lt;<n; for(int="" i="1;i<m;i++)cnt[i]=cnt[i&(i-1)]+1;" if(!(i&(i="">&gt;1)))flg[i]=true;<br>    for(int i=0;i&lt;m;i++)if(flg[i])<br>        for(int j=0;j&lt;m;j++)if(flg[j])mat[i][j]=jud(i,j);<br>    for(int i=0;i&lt;m;i++)if(flg[i])f[1][cnt[i]][i]=1;<br>    for(int i=1;i&lt;n;i++)<br>        for(int p=0;p&lt;m;p++)if(flg[p])<br>            for(int q=0;q&lt;m;q++)if(flg[q]&amp;&amp;mat[p][q])<br>                for(int j=cnt[p];j+cnt[q]&lt;=k;j++)<br>                    f[i+1][j+cnt[q]][q]+=f[i][j][p];<br>    ll ans=0;<br>    for(int j=0;j&lt;m;j++)ans+=f[n][k][j];<br>    printf(“%lld”,ans);<br>    return 0;<br>}<br>```</n;></n;></p>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[bzoj-1012 [JSOI2008]最大数]]></title>
      <url>https://cothrax.github.io/2016/12/03/bzoj-1012/</url>
      <content type="html"><![CDATA[<p>大意：维护一个数列，支持：</p>
<ol>
<li>向末尾插入一个数</li>
<li>查询长l的后缀的最大值<a id="more"></a>
</li>
</ol>
<h2 id="链接"><a href="#链接" class="headerlink" title="链接"></a>链接</h2><p><a href="http://www.lydsy.com/JudgeOnline/problem.php?id=1013" target="_blank" rel="external">bzoj-1012</a><br><a href="/2016/12/03/bzoj-1012/1012.cpp" title="1012.cpp">1012.cpp</a></p>
<h2 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h2><p>维护后缀最大值的序列，注意到这个序列是单调增的，用一个单调栈维护即可<br>查询时可以以编号为索引二分，或者用并查集维护</p>
<h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><p>```c++ 1012.cpp</p>
<p>#include<cstdio></cstdio></p>
<p>#include<algorithm><br>using namespace std;<br>const int N=200010;<br>int stk[N],idx[N],n,m,t;<br>void ins(int x,int k){<br>    while(t&gt;0&amp;&amp;stk[t]<k)t--; stk[++t]="k;idx[t]=x;" }="" int="" bin(int="" x){="" max_i{idx[i]="">=x}<br>    int l=1,r=t,ans=t;<br>    while(l&lt;=r){<br>        int mid=(l+r)/2;<br>        if(idx[mid]&gt;=x)ans=mid,r=mid-1;<br>        else l=mid+1;<br>    }<br>    return stk[ans];<br>}<br>int main(){<br>    //freopen(“in”,”r”,stdin);freopen(“out”,”w”,stdout);<br>    scanf(“%d %d\n”,&amp;n,&amp;m);<br>    int lst=0,sz=0;t=0;<br>    for(int i=0;i&lt;n;i++){<br>        int x;char c;<br>        scanf(“%c %d\n”,&amp;c,&amp;x);<br>        switch(c){<br>            case ‘A’:ins(++sz,(x+lst)%m);break;<br>            case ‘Q’:printf(“%d\n”,lst=bin(sz-x+1));break;<br>        }<br>    }<br>    return 0;<br>}<br>```</k)t--;></algorithm></p>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[bzoj-1013 [JSOI2008]球形空间产生器]]></title>
      <url>https://cothrax.github.io/2016/12/03/bzoj-1013/</url>
      <content type="html"><![CDATA[<p>大意：给定n维空间内的n+1个坐标，求这些坐标确定的球的球心<br>n≤10<br><a id="more"></a></p>
<h2 id="链接"><a href="#链接" class="headerlink" title="链接"></a>链接</h2><p><a href="http://www.lydsy.com/JudgeOnline/problem.php?id=1013" target="_blank" rel="external">bzoj-1013</a><br><a href="/2016/12/03/bzoj-1013/1013.cpp" title="1013.cpp">1013.cpp</a></p>
<h2 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h2><p>列方程组，然后高斯消元即可<br>如相邻两个方程：<br>$\sum{(x_i-a_i)^2}=r^2$<br>$\sum{(x_i-b_i)^2}=r^2$<br>相减得到<br>$\sum{2(a_i-b_i)x_i}=\sum{a_i^2}-\sum{b_i^2}$</p>
<h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><p>```c++ 1013.cpp</p>
<p>#include<algorithm></algorithm></p>
<p>#include<cstdio></cstdio></p>
<p>#include<cmath><br>//#define D<br>using namespace std;<br>const int N=15;const double EPS=10E-4;<br>int n;double a[N][N];<br>void solv(){<br>    for(int i=1;i&lt;=n;i++){<br>        int p=i;<br>        for(int j=i+1;j&lt;=n;j++)<br>            if(a[p][i]&lt;a[j][i])p=j;<br>        swap(a[p],a[i]);<br>        for(int j=i+1;j&lt;=n+1;j++)a[i][j]/=a[i][i];<br>        for(int j=1;j&lt;=n;j++)if(j!=i)<br>            for(int k=i+1;k&lt;=n+1;k++)<br>                a[j][k]-=a[j][i]<em>a[i][k];<br>    }<br>}<br>int main(){<br>    freopen(“in”,”r”,stdin);<br>    scanf(“%d\n”,&amp;n);<br>    for(int i=1;i&lt;=n+1;i++)<br>        for(int j=1;j&lt;=n;j++){<br>            scanf(“%lf”,&amp;a[i][j]);<br>            a[i][n+1]+=a[i][j]</em>a[i][j];<br>            a[i][j]*=2;<br>        }<br>    for(int i=1;i&lt;=n;i++)<br>        for(int j=1;j&lt;=n+1;j++)<br>            a[i][j]-=a[i+1][j];<br>    solv();<br>    for(int i=1;i&lt;=n;i++){<br>        double x=a[i][n+1];<br>        printf(“%0.3lf”,(abs(x)&lt;EPS)?0:x);<br>        if(i&lt;n)printf(“ “);<br>    }<br>    return 0;<br>}<br>```</cmath></p>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[bzoj-1001 狼抓兔子]]></title>
      <url>https://cothrax.github.io/2016/12/03/bzoj-1001/</url>
      <content type="html"><![CDATA[<p>大意：给定一个n*m的网格状带权图，求从(1,1)到(n,m)的最小割<br>n,m≤1000<br><a id="more"></a></p>
<h2 id="链接"><a href="#链接" class="headerlink" title="链接"></a>链接</h2><p><a href="http://www.lydsy.com/JudgeOnline/problem.php?id=1001" target="_blank" rel="external">bzoj-1001</a><br><a href="/2016/12/03/bzoj-1001/1001.cpp" title="1001.cpp">1001.cpp</a><br><a href="/2016/12/03/bzoj-1001/1001_spf.cpp" title="1001_spf.cpp">1001_spf.cpp</a></p>
<h2 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h2><p>果断跑dinic，然后tle<br>由于网格是平面图，平面图上的最小割可以转化为对偶图上的最小环<br>由于给定起点和终点，可以连接起终点得到一条边，计算不穿过这条边的对偶图的最短路即可。<br>详见：<a href="/2016/12/03/bzoj-1001/冬令营论文演示文稿.ppt" title="周冬《两极相通——浅析最大—最小定理在信息学竞赛中的应用》">周冬《两极相通——浅析最大—最小定理在信息学竞赛中的应用》</a></p>
<h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><p>dinic<br>```c++ 1001.cpp</p>
<p>#include<cstdio></cstdio></p>
<p>#include<algorithm></algorithm></p>
<p>#include<string.h><br>//#define DEBUG<br>using namespace std;<br>const int N=1010,INF=10e7;<br>struct edge{int v,nxt,c;} g[N<em>N</em>12];<br>int n,m,sz,head[N<em>N],q[N</em>N],dep[N<em>N];<br>inline void _add(int u,int v,int c)<br>{g[++sz]={v,head[u],c};head[u]=sz;}<br>inline void add(int u,int v,int c)<br>{_add(u,v,c);_add(v,u,0);_add(v,u,c);_add(u,v,0);}<br>inline int p(int x,int y){return x</em>m+y;}</string.h></p>
<p>bool bfs(int s,int t0){<br>    memset(dep,-1,sizeof(dep));<br>    int u,v;q[0]=s;dep[s]=0;<br>    for(int h=0,t=1;h&lt;t;h++)<br>        for(int i=head[u=q[h]];i;i=g[i].nxt)<br>            if(dep[v=g[i].v]==-1&amp;&amp;g[i].c)<br>                q[t++]=v,dep[v]=dep[u]+1;<br>    return dep[t0]!=-1;<br>}<br>int dfs(int u,int t,int f){<br>    if(u==t)return f;<br>    int ret=0,v;<br>    for(int i=head[u];i;i=g[i].nxt)<br>        if(dep[v=g[i].v]==dep[u]+1){<br>            int tmp=dfs(v,t,min(f-ret,g[i].c));<br>            g[i].c-=tmp;g[i^1].c+=tmp;ret+=tmp;<br>            if(ret==f)return ret;<br>        }<br>    return ret;<br>}<br>int maxflow(int s,int t)<br>{int ret=0;while(bfs(s,t))ret+=dfs(s,t,INF);return ret;}</p>
<p>int main(){<br>    //freopen(“1001.in”,”r”,stdin);<br>    //freopen(“1001.ans”,”w”,stdout);<br>    scanf(“%d%d”,&amp;n,&amp;m);sz=1;int w;<br>    for(int i=0;i&lt;n;i++)<br>        for(int j=0;j&lt;m-1;j++)<br>            scanf(“%d”,&amp;w),add(p(i,j),p(i,j+1),w);<br>    for(int i=0;i&lt;n-1;i++)<br>        for(int j=0;j&lt;m;j++)<br>            scanf(“%d”,&amp;w),add(p(i,j),p(i+1,j),w);<br>    for(int i=0;i&lt;n-1;i++)<br>        for(int j=0;j&lt;m-1;j++)<br>            scanf(“%d”,&amp;w),add(p(i,j),p(i+1,j+1),w);<br>    printf(“%d”,maxflow(p(0,0),p(n-1,m-1)));<br>    return 0;<br>}</p>
<pre><code>最短路
```c++ 1001_spf.cpp
#include&lt;cstdio&gt;
#include&lt;iostream&gt;
#include&lt;string.h&gt;
#include&lt;algorithm&gt;
using namespace std;
const int N=1000*1000*2,INF=1000000000;
struct edge{int v,w,nxt;} g[N*3];
int n,m,S,T,sz=0,head[N],q[N],d[N];
bool inq[N]={false};
inline void _add(int u,int v,int w)
{g[++sz]={v,w,head[u]};head[u]=sz;}
inline void add(int u,int v,int w)
{_add(u,v,w);_add(v,u,w);}
inline int p(int x,int y,int z){
    if(x&lt;0||y&gt;m-2)return S;
    if(x&gt;n-2||y&lt;0)return T;
    return x*m*2+y*2+z;
}
int spfa(){
    fill(d,d+N,INF);int u,v;q[0]=S;inq[S]=true;d[S]=0;
    for(int h=0,t=1;h!=t;inq[q[h]]=false,h=(h+1)%N)
        for(int i=head[u=q[h]];i;i=g[i].nxt)
            if(d[v=g[i].v]&gt;d[u]+g[i].w){
                d[v]=d[u]+g[i].w;
                if(!inq[v]){q[t++]=v;t%=N;inq[v]=true;}
            }
    return d[T];
}
int main(){
    //freopen(&quot;1001.in&quot;,&quot;r&quot;,stdin);
    //freopen(&quot;1001.out&quot;,&quot;w&quot;,stdout);
    scanf(&quot;%d%d&quot;,&amp;n,&amp;m);
    int w;S=n*m*2,T=n*m*2+1;
    for(int i=0;i&lt;n;i++)
        for(int j=0;j&lt;m-1;j++)
            scanf(&quot;%d&quot;,&amp;w),add(p(i-1,j,1),p(i,j,0),w);
    for(int i=0;i&lt;n-1;i++)
        for(int j=0;j&lt;m;j++)
            scanf(&quot;%d&quot;,&amp;w),add(p(i,j-1,0),p(i,j,1),w);
    for(int i=0;i&lt;n-1;i++)
        for(int j=0;j&lt;m-1;j++)
            scanf(&quot;%d&quot;,&amp;w),add(p(i,j,0),p(i,j,1),w);
    printf(&quot;%d&quot;,spfa());
    return 0;
}
</code></pre>]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[NOIP2016 填坑]]></title>
      <url>https://cothrax.github.io/2016/11/24/noip-2016/</url>
      <content type="html"><![CDATA[<p>第一次也是倒数第二次noip就这么跪了，也是第一次站在一定高度上正视自己的平庸<br>首先，考前有两道概率题没订正，默默地立了个flag：noip不考期望，结果d1t3方程没调出来、暴力都没来得及写。<br>其次，以一个蒟蒻的思维能力偏偏碰上了一场难度偏高的noip，考前还在复习树剖、主席树模板，各种数据结构学傻，然而没有融入自己的思考。<br>最后，作为第一次noip，暴力分没有拿满也是很遗憾的<br>虽说是afo了，但善始善终，把坑填完。<br><a id="more"></a></p>
<h1 id="链接"><a href="#链接" class="headerlink" title="链接"></a>链接</h1><ul>
<li><a href="/2016/11/24/noip-2016/toy.pas" title="toy.pas">toy.pas</a></li>
<li><a href="/2016/11/24/noip-2016/running.pas" title="running.pas">running.pas</a></li>
<li><a href="/2016/11/24/noip-2016/classroom.pas" title="classroom.pas">classroom.pas</a></li>
<li><a href="/2016/11/24/noip-2016/problem.pas" title="problem.pas">problem.pas</a></li>
<li><a href="/2016/11/24/noip-2016/earthworm.pas" title="earthworm.pas">earthworm.pas</a></li>
<li>angrybirds<ul>
<li><a href="/2016/11/24/noip-2016/angrybirds.pas" title="angrybirds.pas">angrybirds.pas</a></li>
<li><a href="/2016/11/24/noip-2016/angrybirds.cpp" title="angrybirds.cpp">angrybirds.cpp</a>
</li>
</ul>
</li>
</ul>
<h1 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h1><p>两个T1是原来的，其余都是订正后的</p>
<h2 id="D1T1-玩具谜题"><a href="#D1T1-玩具谜题" class="headerlink" title="D1T1 玩具谜题"></a>D1T1 玩具谜题</h2><p>没什么好说的</p>
<blockquote>
<p>mogician/mengbier比较亮，noip药丸的征兆</p>
</blockquote>
<p>```delphi toy.pas<br>type int=longint;<br>var<br>    n,m,i,j,k,cur:int;<br>    s:ansistring;<br>    dir:array[0..100010] of int;<br>    a:array[0..100010] of ansistring;</p>
<p>begin<br>    //assign(input,’toy.in’);reset(input);<br>    //assign(output,’toy.out’);rewrite(output);<br>    readln(n,m);<br>    for i:=0 to n-1 do begin<br>        readln(s);j:=pos(‘ ‘,s);<br>        val(copy(s,1,j-1),dir[i]);//d=0 inside;d=1 outside<br>        a[i]:=copy(s,j+1,length(s)-j);<br>    end;<br>    cur:=0;<br>    for i:=1 to m do begin<br>        read(j,k); //j=0 left;j=1 right<br>        if (j=0)xor(dir[cur]=0) then cur:=(cur+k)mod n<br>        else cur:=((cur-k)mod n+n)mod n;<br>    end;<br>    write(a[cur]);<br>    //close(input);close(output);<br>end.</p>
<pre><code>
## D1T2 天天爱跑步
可以树剖做，也有线性的做法
把一条路径s-&gt;t从lca拆成两半，记tim=dep[s]-dep[lca]
1. 前一半上的点u要被观察到，需满足w[u]=tim-(dep[u]-dep[lca])，即w[u]+dep[u]为定值=dep[s]
2. 后一半，同理s[u]-dep[u]为定值=dep[s]-dep[lca]*2

树剖之后，考虑前一半，差分处理所有询问，即在s处标记插入权值dep[s]，在lca[s]处删除dep[s]（这个可以用链表实现），然后顺序遍历树链上的点u，遍历过程中用cnt[x]记录权值x的计数，检查u处的标记来更新cnt，再cnt[w[u]+dep[u]加到u的答案中即可
后一半同理

线性做法可以用dfs序+子树和实现，离线处理询问
还可以直接在树上做，合并权值线段树

```delphi
type
    int=longint;
    edge=record v,nxt:int end;
    node=record v,k,nxt:int end;
    arr=array[0..300010] of int;
var
    g:array[0..600010] of edge;
    lnk:array[0..2400010] of node;
    head,w,lca,par,s,t,_s,_t,ans,
    pre,dep,loc,seg,son,top,siz:arr;
    cnt:array[-900010..900010] of int;
    n,m,k,sz,sl,i,u,v:int;

procedure add(u,v:int);
begin
    inc(sz);g[sz].v:=v;
    g[sz].nxt:=head[u];head[u]:=sz;
end;

function find(x:int):int;
begin
    if par[x]=x then find:=x
    else begin
        par[x]:=find(par[x]);
        find:=par[x];
    end;
end;

procedure union(x,y:int);
begin
    x:=find(x);y:=find(y);
    par[x]:=y;
end;

procedure ins(var ptr:arr;u,v,k:int);
begin
    inc(sl);lnk[sl].v:=v;lnk[sl].k:=k;
    lnk[sl].nxt:=ptr[u];ptr[u]:=sl;
end;

procedure calc(var ptr:arr;u:int);
var i,v:int;
begin
    i:=ptr[u];
    while i&lt;&gt;0 do begin
        v:=lnk[i].v;
        if dep[v]&lt;&gt;0 then lca[lnk[i].k]:=find(v);
        i:=lnk[i].nxt;
    end;
end;

procedure dfs1(u,p:int);
var v,i:int;
begin
    pre[u]:=p;dep[u]:=dep[p]+1;siz[u]:=1;son[u]:=0;
    i:=head[u];
    while i&lt;&gt;0 do begin
        v:=g[i].v;
        if dep[v]=0 then begin
            dfs1(v,u);
            if siz[v]&gt;siz[son[u]] then son[u]:=v;
            inc(siz[u],siz[v]);
        end;
        i:=g[i].nxt;
    end;
    calc(s,u);calc(t,u);if p&lt;&gt;0 then union(u,p);
end;

procedure dfs2(u:int);
var i,v:int;
begin
    inc(k);loc[u]:=k;seg[k]:=u;
    if u=son[pre[u]] then top[u]:=top[pre[u]] else top[u]:=u;
    if son[u]&lt;&gt;0 then dfs2(son[u]);
    i:=head[u];
    while i&lt;&gt;0 do begin
        v:=g[i].v;
        if (v&lt;&gt;son[u])and(v&lt;&gt;pre[u]) then dfs2(v);
        i:=g[i].nxt;
    end;
end;

procedure swap(var a,b:int);
var tmp:int;
begin tmp:=a;a:=b;b:=tmp end;

procedure modify(u,v,x:int);
var p:^int;
begin
    while true do begin
        if dep[u]&lt;dep[v] then swap(u,v);
        if top[u]=top[v] then break;
        if dep[top[u]]&gt;dep[top[v]] then p:=@u else p:=@v;
        ins(_t,loc[p^]+1,0,x);
        ins(_s,loc[top[p^]],0,x);
        p^:=pre[top[p^]];
    end;
    ins(_s,loc[v],0,x);ins(_t,loc[u]+1,0,x);
end;

procedure solv(var ptr:arr;x:int);
var u,v,i,j,tmp:int;
begin
    for u:=1 to n do begin
        i:=ptr[u];if x=0 then tmp:=dep[u];
        while i&lt;&gt;0 do begin
            if x=1 then begin
                v:=lca[lnk[i].k];tmp:=dep[lnk[i].v]-2*dep[v];
                if tmp=w[v] then dec(ans[v]);
            end;
            modify(u,lca[lnk[i].k],tmp);
            i:=lnk[i].nxt;
        end;
    end;
    for i:=1 to n do begin
        j:=_s[i];
        while j&lt;&gt;0 do begin
            inc(cnt[lnk[j].k]);j:=lnk[j].nxt;
        end;
        j:=_t[i];
        while j&lt;&gt;0 do begin
            dec(cnt[lnk[j].k]);j:=lnk[j].nxt;
        end;
        inc(ans[seg[i]],cnt[w[seg[i]]]);
    end;
end;

begin
    read(n,m);sz:=0;sl:=0;
    for i:=1 to n-1 do begin
        read(u,v);add(u,v);add(v,u);
    end;
    for i:=1 to n do read(w[i]);
    for i:=1 to m do begin
        read(u,v);ins(s,u,v,i);ins(t,v,u,i);
    end;
    for i:=1 to n do par[i]:=i;
    dfs1(1,0);k:=0;dfs2(1);
    for i:=1 to n do inc(w[i],dep[i]);
    solv(s,0);
    fillchar(_s,sizeof(_s),0);
    fillchar(_t,sizeof(_t),0);
    fillchar(cnt,sizeof(cnt),0);
    for i:=1 to n do dec(w[i],dep[i]*2);
    solv(t,1);
    for i:=1 to n do write(ans[i],&#39; &#39;);
end.
</code></pre><h2 id="D1T3-换教室"><a href="#D1T3-换教室" class="headerlink" title="D1T3 换教室"></a>D1T3 换教室</h2><p>先floyd $O(N^3)$求最短路，然后dp就好了<br>记f[i,j,0/1] 1..i的教室申请j次，第i次有没有申请（0/1）的最小期望值<br>然后分4类讨论转移即可</p>
<blockquote>
<p>对期望的线性性质理解很肤浅，转移写错</p>
</blockquote>
<p>```delphi classroom.pas<br>uses math;<br>type int=longint;<br>const inf=1000000000;<br>var<br>    g:array[0..310,0..310] of int;<br>    c,d:array[0..2010] of int;<br>    a:array[0..2010] of double;<br>    f:array[0..2010,0..2010,0..1] of double;<br>    n,m,p,q,u,v,w,i,j,k:int;x,y,z,ans:double;</p>
<p>begin<br>    //assign(input,’classroom.in’);reset(input);<br>    //assign(output,’classroom.out’);rewrite(output);<br>    read(n,m,p,q);<br>    filldword(g,sizeof(g)shr 2,inf);<br>    for i:=1 to n do read(c[i]);<br>    for i:=1 to n do read(d[i]);<br>    for i:=1 to n do read(a[i]);<br>    for i:=1 to q do begin<br>        read(u,v,w);<br>        g[u,v]:=min(g[u,v],w);g[v,u]:=g[u,v];<br>    end;<br>    for k:=1 to p do<br>        for i:=1 to p do<br>            for j:=1 to p do<br>                g[i,j]:=min(g[i,j],g[i,k]+g[k,j]);<br>    for i:=1 to p do g[i,i]:=0;<br>    for i:=1 to p do g[0,i]:=0;<br>    f[0,0,0]:=0;<br>    for i:=1 to n do<br>        for j:=i+1 to m do<br>            begin f[i,j,0]:=inf;f[i,j,1]:=inf end;<br>    for i:=1 to n do begin<br>        x:=a[i-1]<em>g[d[i-1],c[i]]+(1-a[i-1])</em>g[c[i-1],c[i]];<br>        y:=a[i]<em>g[c[i-1],d[i]]+(1-a[i])</em>g[c[i-1],c[i]];<br>        z:=a[i]<em>(a[i-1]</em>g[d[i-1],d[i]]+(1-a[i-1])<em>g[c[i-1],d[i]])+(1-a[i])</em>x;<br>        f[i,0,0]:=f[i-1,0,0]+g[c[i-1],c[i]];<br>        //writeln(i,’::’,x:0:3,’ ‘,y:0:3,’ ‘,z:0:3);<br>        f[i,0,1]:=inf;<br>        for j:=1 to min(i,m) do begin<br>            f[i,j,0]:=min(f[i-1,j,0]+g[c[i-1],c[i]],f[i-1,j,1]+x);<br>            f[i,j,1]:=min(f[i-1,j-1,0]+y,f[i-1,j-1,1]+z);<br>        end;<br>    end;<br>    ans:=inf;<br>    for i:=0 to min(n,m) do ans:=min(ans,min(f[n,i,0],f[n,i,1]));<br>    write(ans:0:2);<br>end.</p>
<pre><code>
## D2T1 组合数问题
k是全局的
$O(N^2)$求出模k下的所有组合数，然后二维前缀和即可
&gt;还好

```delphi problem.pas
uses math;
type int=longint;
var
    t,k,mxn,mxm,ans,i,j:int;
    q:array[0..10010,0..1] of int;
    c,f:array[-1..2010,-1..2010] of int;
begin
    //assign(input,&#39;problem.in&#39;);reset(input);
    //assign(output,&#39;problem.out&#39;);rewrite(output);
    read(t,k);mxn:=0;mxm:=0;
    for i:=1 to t do begin
        read(q[i,0],q[i,1]);
        mxn:=max(mxn,q[i,0]);mxm:=max(mxm,q[i,1]);
    end;
    c[0,0]:=1;if k=1 then f[0,0]:=1;
    for i:=1 to mxn do
        for j:=0 to min(mxm,i) do begin
            c[i,j]:=(c[i-1,j]+c[i-1,j-1])mod k;
            if c[i,j]=0 then f[i,j]:=1;
        end;
    for i:=0 to mxn do
        for j:=1 to mxm do
            f[i,j]:=f[i,j]+f[i,j-1];
    for i:=1 to t do begin
        ans:=0;
        for j:=0 to q[i,0] do
            ans:=ans+f[j,q[i,1]];
        writeln(ans);
    end;
    //close(input);close(output);
end.
</code></pre><h2 id="D2T2-蚯蚓"><a href="#D2T2-蚯蚓" class="headerlink" title="D2T2 蚯蚓"></a>D2T2 蚯蚓</h2><p>注意到存在增量q，意味着第i次切下来的新蚯蚓一定不会比当前第i-1次切出的长<br>三个队列维护即可</p>
<blockquote>
<p>没多想，手写堆+全局表示<br>我直接p=u/v然后用p算，ccf千万别卡精度。。好慌</p>
</blockquote>
<p>```delphi earthworm.pas<br>uses math;<br>type int=longint;ll=int64;<br>var<br>    q:array[0..2,0..7500010] of ll;<br>    h,t:array[0..2] of int;<br>    n,m,t0,i:int;u,v,q0,dt,tmp,x,y:ll;</p>
<p>function ext():ll;<br>var i,j:int;<br>begin<br>    j:=-1;<br>    for i:=0 to 2 do<br>        if (h[i]&lt;=t[i])and((j=-1)<br>            or(q[j,h[j]]&lt;q[i,h[i]])) then j:=i;<br>    ext:=q[j,h[j]];inc(h[j]);//writeln(j,’::’,ext);<br>end;</p>
<p>procedure qsort(l,r:int);<br>var i,j:int;x,tmp:ll;<br>begin<br>    i:=l;j:=r;x:=q[0,random(r-l)+l];<br>    repeat<br>        while q[0,i]&gt;x do inc(i);<br>        while q[0,j]<x do="" dec(j);="" if="" i<="j" then="" begin="" tmp:="q[0,i];q[0,i]:=q[0,j];q[0,j]:=tmp;" inc(i);dec(j);="" end;="" until="" i="">j;<br>    if i&lt;r then qsort(i,r);<br>    if l&lt;j then qsort(l,j);<br>end;</x></p>
<p>begin<br>    //assign(input,’earthworm.in’);reset(input);<br>    //assign(output,’earthworm.out’);rewrite(output);<br>    read(n,m,q0,u,v,t0);<br>    for i:=1 to n do read(q[0,i]);<br>    qsort(1,n);<br>    //for i:=1 to n do write(q[0,i],’ ‘);writeln;<br>    h[0]:=1;h[1]:=1;h[2]:=1;t[0]:=n;dt:=0;<br>    for i:=1 to m do begin<br>        tmp:=ext()+dt;x:=trunc(tmp*u/v);y:=tmp-x;inc(dt,q0);<br>        //writeln(tmp,’ ‘,x,’ ‘,y,’&gt;&gt;’,dt);<br>        inc(t[1]);inc(t[2]);q[1,t[1]]:=x-dt;q[2,t[2]]:=y-dt;<br>        if i mod t0=0 then write(tmp,’ ‘);<br>    end;<br>    writeln;<br>    for i:=1 to n+m do begin<br>        tmp:=ext()+dt;<br>        if i mod t0=0 then write(tmp,’ ‘);<br>    end;<br>    //close(input);close(output);<br>end.</p>
<pre><code>
## D2T3 愤怒的小鸟
状压DP
记s[i,j]为以第i个和第j个猪确定的抛物线能消灭的猪的集合
然后$O(2^n)$做DP，每次转移是$O(N^2)$的

&gt;d1之后，知乎上有一个dalao立了个flag:d2t3是搜索。
然后我想都没想直接搜然后还写错了。。

```delphi angrybirds.pas
uses math;
type int=longint;
const eps=0.000001;
var 
    t,n,m,i,j,k:int;
    x,y:array[0..20] of double;
    s:array[0..20,0..20] of int;
    f:array[0..1 shl 18+10] of int;

function calc(u,v:int):int;
var a,b,p:double;i:int;
begin
    p:=x[u]/x[v];
    if abs(x[u]-x[v])&lt;eps then exit(0);
    a:=(y[u]-y[v]*p)/(sqr(x[u])-sqr(x[v])*p);
    b:=(y[u]-a*sqr(x[u]))/x[u];
    if (a&gt;0)or(abs(a)&lt;eps) then exit(0);
    calc:=0;
    for i:=0 to n-1 do
        if abs(y[i]-(a*sqr(x[i])+b*x[i]))&lt;eps then
            calc:=calc or (1 shl i);
end;

begin
    //assign(input,&#39;angrybirds.in&#39;);reset(input);
    //assign(output,&#39;angrybirds.out&#39;);rewrite(output);
    read(t);
    repeat
        read(n,m);m:=1 shl n-1;
        for i:=0 to n-1 do read(x[i],y[i]);
        for i:=0 to n-1 do
            for j:=i+1 to n-1 do s[i,j]:=calc(i,j);
        for i:=0 to n-1 do s[i,i]:=1 shl i
        f[0]:=0;
        for i:=1 to m do begin
            j:=i;f[i]:=maxlongint;
            for j:=0 to n-1 do if i and(1 shl j)&gt;0 then
                for k:=j to n-1 do if i and(1 shl k)&gt;0 then
                    f[i]:=min(f[i],f[i xor(i and s[j,k])]+1);
        end;
        writeln(f[m]);
        dec(t);
    until t=0;
    //close(input);close(output);
end.
</code></pre><p>还有$O(N2^N)$的做法，因为编号最小的猪一定要被删掉，枚举包含该猪的集合转移<br>```cpp angrybirds.cpp</p>
<p>#include<algorithm></algorithm></p>
<p>#include<cstdio></cstdio></p>
<p>#include<cmath><br>using namespace std;<br>const int N=20,M=1&lt;<20; const="" double="" eps="0.000001;" int="" n,m,t,h[n*n],s[n][n*n],f[m]="{0};" x[n],y[n];="" calc(int="" u,int="" v){="" a,b,p;="" p="x[u]/x[v];" if(abs(x[u]-x[v])<eps)return="" 0;="" a="(y[u]-y[v]*p)/(x[u]*x[u]-x[v]*x[v]*p);" b="(y[u]-a*x[u]*x[u])/x[u];" if(a="">-eps)return 0;<br>    int ret=0;<br>    for(int i=0;i<n;i++) if(abs(y[i]-(a*x[i]*x[i]+b*x[i]))<eps)ret|="1<<i;" return="" ret;="" }="" int="" main(){="" freopen("angrybirds.in","r",stdin);="" freopen("angrybirds.out","w",stdout);="" scanf("%d",&t);="" while(t--){="" scanf("%d%d",&n,&m);m="(1<<n)-1;" for(int="" i="0;i<n;i++)scanf("%lf%lf",&x[i],&y[i]);" k="0;" j="i+1;j<n;j++)h[k++]=calc(i,j);" sort(h,h+k);int="" lst="0;" if(h[i]="=0)continue;" else="" if="" (lst="=0||h[i]!=h[lst-1])h[lst++]=h[i];" cnt[n]="{0};">0;j=j&amp;(j-1)){<br>                int p=round(log(j&amp;(-j))/log(2));<br>                s[p][cnt[p]++]=h[i];<br>            }<br>        for(int i=1;i&lt;=m;i++){<br>            int p=round(log(i&amp;(-i))/log(2));<br>            f[i]=f[i^(1&lt;&lt;p)]+1;<br>            for(int j=0;j&lt;cnt[p];j++)<br>                f[i]=min(f[i],f[i^(i&amp;s[p][j])]+1);<br>        }<br>        printf(“%d\n”,f[m]);<br>    }<br>    //fclose(stdin);fclose(stdout);<br>    return 0;<br>}</n;i++)></20;></cmath></p>
<p>```</p>
<h1 id="写在后面"><a href="#写在后面" class="headerlink" title="写在后面"></a>写在后面</h1><p>以上即一个智障选手的noip<br>还有3天分数就出来了<br>要结束了<br>我的青春</p>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[XJOI NOIP2016提高组冲剌题1]]></title>
      <url>https://cothrax.github.io/2016/11/12/xjoi-noip-2016-test1/</url>
      <content type="html"><![CDATA[<p>在大学军的OJ上找点题练手，出题人果然比BZOJ的十连测良心。。</p>
<h1 id="T1-挖金矿"><a href="#T1-挖金矿" class="headerlink" title="T1 挖金矿"></a>T1 挖金矿</h1><p>大意：给定n×m的矩阵，在每一行选长为$k(1\leq k\leq m)$的前缀，要最大化所选数的平均值<br>$n\times m\leq 10^5,1\leq a[i,j]\leq 10^9$<br><a id="more"></a></p>
<h2 id="链接"><a href="#链接" class="headerlink" title="链接"></a>链接</h2><p><a href="http://www.hzxjhs.com:83/contest/622/problem/1" target="_blank" rel="external">XJOI</a><br><a href="/2016/11/12/xjoi-noip-2016-test1/gold.pas" title="gold.pas">gold.pas</a></p>
<h2 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h2><p>关于平均值的题目：</p>
<ol>
<li>二分统计逆序对：<a href="/2016/10/09/lydsy-noip-2016-test3/" title="十连测Test3-T1">十连测Test3-T1</a></li>
<li>二分判负环：<a href="/2016/08/30/雅礼中学2015模拟赛-Day3/" title="雅礼2015-T2">雅礼2015-T2</a></li>
</ol>
<p>考虑二分答案$x\in [0,\sum a[i,j]]$</p>
<p>将矩阵中的所有数减去x后，将每一列前缀和的最大值加起来</p>
<p>即$sum=\sum_{i=1}^n max_{1\leq k\leq h}(\sum_{j=1}^k a[i,j])$</p>
<p>如果$sum\geq 0$，那么x合法</p>
<p>细节：题中没有给出n,m的范围，用链表处理</p>
<h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><p>```delphi gold.pas<br>uses math;<br>type int=longint;node=record w,nxt:int end;<br>const eps=0.000001;inf:double=100000000000;<br>var<br>    lnk:array[0..100010] of node;<br>    head,tail:array[0..100010] of int;<br>    n,m,sz,i,j,x:int;l,r,mid,ans:double;</p>
<p>procedure insert(i,x:int);<br>begin<br>    inc(sz);lnk[sz].w:=x;<br>    if head[i]=0 then begin head[i]:=sz;tail[i]:=sz end<br>    else begin lnk[tail[i]].nxt:=sz;tail[i]:=sz end;<br>end;</p>
<p>function jud(x:double):boolean;<br>var sum,cur,ans:double;i,j:int;<br>begin<br>    sum:=0;<br>    for i:=1 to n do begin<br>        j:=head[i];cur:=0;ans:=-inf;<br>        while j&lt;&gt;0 do begin<br>            cur:=cur+int64(lnk[j].w)-x;<br>            ans:=max(ans,cur);<br>            j:=lnk[j].nxt;<br>        end;<br>        sum:=sum+ans;<br>    end;<br>    jud:=sum&gt;=0;<br>end;</p>
<p>begin<br>    //assign(input,’gold.in’);reset(input);<br>    //assign(output,’gold.out’);rewrite(output);<br>    read(n,m);sz:=0;<br>    l:=0;r:=0;<br>    for i:=1 to n do<br>        for j:=1 to m do begin<br>            read(x);insert(i,x);r:=r+x;<br>        end;<br>    while r-l&gt;eps do begin<br>        mid:=(l+r)/2;<br>        if jud(mid) then begin ans:=mid;l:=mid end<br>        else r:=mid;<br>    end;<br>    write(ans:0:4);<br>    //close(input);close(output);<br>end.</p>
<pre><code>
# T2 道路规划
大意：给定1..n的两个全排列a和b，一上一下排成一行，把a和b中对应的数字用直线连起来，定义点集S：该集合中的任意两个数对应的连线相交。求S的最大规模
如图：
<img src="/2016/11/12/xjoi-noip-2016-test1/g.png" alt="g.png" title="">

## 链接
[XJOI](http://www.hzxjhs.com:83/contest/622/problem/2)
<a href="/2016/11/12/xjoi-noip-2016-test1/road.pas" title="road.pas">road.pas</a>

## 题解
记la[i]为i在a中的下标，lb[i]为i在b中的下标
因为如果i和j的线相交，那么必然有$(la[i]-la[j])(lb[i]-lb[j])&lt;0$
以lb[a[i]]作为i的权值，就规约为了LDS
可以二分或用树状数组优化到$O(NlogN)$

## 代码
```delphi road.pas
uses math;
type int=longint;
var 
    n,i,j:int;
    a,b,f,bit:array[0..100010] of int;

procedure add(x,k:int);
begin
    while x&lt;=n do begin
        bit[x]:=max(bit[x],k);
        x:=x+x and (-x);
    end;
end;

function query(x:int):int;
begin
    query:=0;
    while x&gt;0 do begin
        query:=max(query,bit[x]);
        x:=x and (x-1);
    end;
end;

begin
    //assign(input,&#39;road.in&#39;);reset(input);
    //assign(output,&#39;road.out&#39;);rewrite(output);
    read(n);
    for i:=1 to n do begin read(j);a[j]:=i end;
    for i:=1 to n do begin read(j);b[a[j]]:=i end;
    for i:=1 to n do begin
        f[i]:=query(n-b[i]+1)+1;  //i-&gt;n-i+1
        add(n-b[i]+1,f[i]);
    end;
    for i:=2 to n do f[i]:=max(f[i],f[i-1]);
    write(f[n]);
    //close(input);close(output);
end.
</code></pre><h1 id="T3-排队"><a href="#T3-排队" class="headerlink" title="T3 排队"></a>T3 排队</h1><p>题意很崎岖，自己去看链接吧</p>
<h2 id="链接-1"><a href="#链接-1" class="headerlink" title="链接"></a>链接</h2><p><a href="http://www.hzxjhs.com:83/contest/622/problem/3" target="_blank" rel="external">XJOI</a><br><a href="/2016/11/12/xjoi-noip-2016-test1/queue.pas" title="queue.pas">queue.pas</a><br><a href="/2016/11/12/xjoi-noip-2016-test1/queue_tmp.pas" title="queue_tmp.pas">queue_tmp.pas</a></p>
<h2 id="题解-1"><a href="#题解-1" class="headerlink" title="题解"></a>题解</h2><p>可以先按儿子升序的顺序dfs整棵树，其<strong>post-dfs序</strong>就是所有点的优先级，记一个点u在post-dfs序中的下标为f[u]，即一个人进来一定会选取可用点集中f值最小的点。<br>可以用一个<strong>小根堆</strong>维护可用的（空的）(f[u],u)的值对<br>这样对于操作1，直接暴力从堆中取x个最优值即可，输出值即最后一次取出的值。<br>然后对于操作2，先说说标算的方法吧<br>显然取出点x只会对x到根的路径上的点产生影响，而路径上被占用的点一定是连续的一段，影响就是将这一段下移一格，记这一段最上面的点为u，u就会空出，将它插入堆中即可。输出值为dep[x]-dep[u]，dep表示深度<br>至于怎么找u，<strong>倍增</strong>处理即可</p>
<p>然而由于没有考虑到占用的点是连续的这个性质，身为一个蒟蒻写了180+的<strong>dfs序+树状数组+线段树</strong></p>
<blockquote>
<p>Too young too naive</p>
</blockquote>
<p>bug:注意堆中值对的顺序</p>
<h2 id="代码-1"><a href="#代码-1" class="headerlink" title="代码"></a>代码</h2><p>标算解法<br>```delphi queue.pas<br>type int=longint;edge=record v,nxt:int end;<br>var<br>    g:array[0..200010] of edge;<br>    head,stk,f,dep:array[0..100010] of int;<br>    par:array[0..100010,0..20] of int;<br>    hp:array[0..150010,0..1] of int;<br>    flg:array[0..100010] of boolean;<br>    n,m,sz,hs,k,lg,op,i,j,u,v,t:int;</p>
<p>procedure add(u,v:int);<br>begin<br>    inc(sz);g[sz].v:=v;<br>    g[sz].nxt:=head[u];head[u]:=sz;<br>end;</p>
<p>procedure qsort(l,r:int);<br>var i,j,x,tmp:int;<br>begin<br>    if l&gt;=r then exit;<br>    i:=l;j:=r;x:=stk[random(r-l)+l];<br>    repeat<br>        while stk[i]<x do="" inc(i);="" while="" stk[j]="">x do dec(j);<br>        if i&lt;=j then begin<br>            tmp:=stk[i];stk[i]:=stk[j];stk[j]:=tmp;<br>            inc(i);dec(j);<br>        end;<br>    until i&gt;j;<br>    if i&lt;r then qsort(i,r);<br>    if l&lt;j then qsort(l,j);<br>end;</x></p>
<p>procedure dfs(u,p:int);<br>var i,v,h:int;<br>begin<br>    par[u,0]:=p;dep[u]:=dep[p]+1;<br>    i:=head[u];h:=t+1;<br>    while i&lt;&gt;0 do begin<br>        v:=g[i].v;<br>        if v&lt;&gt;p then begin inc(t);stk[t]:=v end;<br>        i:=g[i].nxt;<br>    end;<br>    qsort(h,t);<br>    for i:=h to t do dfs(stk[i],u);<br>    inc(k);f[u]:=k;t:=h-1;<br>end;</p>
<p>//begin heap<br>procedure hfy(i:int);<br>var l,r,s:int;tmp:array[0..1] of int;<br>begin<br>    l:=i shl 1;r:=l or 1;<br>    if (l&lt;=hs) and (hp[l,0]<hp[i,0]) then="" s:="l" else="" if="" (r<="hs)" and="" (hp[r,0]<hp[s,0])="" s<="">i then begin<br>        tmp:=hp[s];hp[s]:=hp[i];hp[i]:=tmp;hfy(s);<br>    end;<br>end;<br>function ext():int;<br>begin<br>    ext:=hp[1,1];hp[1]:=hp[hs];dec(hs);hfy(1);<br>end;<br>procedure ins(w,k:int);<br>var i:int;tmp:array[0..1] of int;<br>begin<br>    inc(hs);hp[hs,0]:=w;hp[hs,1]:=k;i:=hs;<br>    while (i&gt;1) and (hp[i,0]&lt;hp[i shr 1,0]) do begin<br>        tmp:=hp[i];hp[i]:=hp[i shr 1];hp[i shr 1]:=tmp;<br>        i:=i shr 1;<br>    end;<br>end;<br>//end heap</hp[i,0])></p>
<p>procedure op1(x:int);<br>var i:int;<br>begin<br>    for i:=1 to x do begin<br>        u:=ext();flg[u]:=true;<br>    end;<br>    writeln(u);<br>end;</p>
<p>procedure op2(u:int);<br>var i,v:int;<br>begin<br>    v:=u;<br>    for i:=lg downto 0 do<br>        if flg[par[v,i]] then v:=par[v,i];<br>    flg[v]:=false;ins(f[v],v);<br>    writeln(dep[u]-dep[v]);<br>end;</p>
<p>begin<br>    read(n,m);sz:=0;lg:=trunc(ln(n)/ln(2));<br>    for i:=1 to n-1 do begin<br>        read(u,v);add(u,v);add(v,u);<br>    end;<br>    k:=0;t:=0;dfs(1,1);<br>    for i:=1 to lg do<br>        for j:=1 to n do par[j,i]:=par[par[j,i-1],i-1];<br>    hs:=0;<br>    for i:=1 to n do ins(f[i],i);<br>    fillchar(flg,sizeof(flg),false);<br>    for i:=1 to m do begin<br>        read(op,u);<br>        case op of 1:op1(u);2:op2(u) end;<br>    end;<br>end.</p>
<pre><code>巨长的sb解法
```delphi queue.pas
type int=longint;edge=record v,nxt:int end;
var
    g:array[0..200010] of edge;
    head,stk,f,bit,lp,rp,par:array[0..100010] of int;
    seg,tag:array[0..400010] of int;
    hp:array[0..150010,0..1] of int;
    n,m,sz,hs,k,cnt,op,i,u,v,t:int;

procedure add(u,v:int);
begin
    inc(sz);g[sz].v:=v;
    g[sz].nxt:=head[u];head[u]:=sz;
end;

procedure swap(var a,b:int);
var tmp:int;
begin tmp:=a;a:=b;b:=tmp end;

procedure qsort(l,r:int);
var i,j,x:int;
begin
    if l&gt;=r then exit;
    i:=l;j:=r;x:=stk[random(r-l)+l];
    repeat
        while stk[i]&lt;x do inc(i);
        while stk[j]&gt;x do dec(j);
        if i&lt;=j then begin
            swap(stk[i],stk[j]);inc(i);dec(j);
        end;
    until i&gt;j;
    if i&lt;r then qsort(i,r);
    if l&lt;j then qsort(l,j);
end;

procedure dfs(u,p:int);
var i,v,h:int;
begin
    par[u]:=p;i:=head[u];h:=t+1;inc(cnt);lp[u]:=cnt;
    while i&lt;&gt;0 do begin
        v:=g[i].v;
        if v&lt;&gt;p then begin inc(t);stk[t]:=v end;
        i:=g[i].nxt;
    end;
    qsort(h,t);
    for i:=h to t do dfs(stk[i],u);
    inc(k);f[u]:=k;t:=h-1;rp[u]:=cnt;
end;

//begin heap
procedure hfy(i:int);
var l,r,s:int;
begin
    l:=i shl 1;r:=l or 1;
    if (l&lt;=hs) and (hp[l,0]&lt;hp[i,0]) then s:=l else s:=i;
    if (r&lt;=hs) and (hp[r,0]&lt;hp[s,0]) then s:=r;
    if s&lt;&gt;i then begin
        swap(hp[s,0],hp[i,0]);swap(hp[s,1],hp[i,1]);
        hfy(s);
    end;
end;
function ext():int;
begin
    ext:=hp[1,1];hp[1]:=hp[hs];dec(hs);hfy(1);
end;
procedure ins(w,k:int);
var i,p:int;
begin
    inc(hs);hp[hs,0]:=w;hp[hs,1]:=k;
    i:=hs;p:=i shr 1;
    while (i&gt;1) and (hp[i,0]&lt;hp[p,0]) do begin
        swap(hp[i,0],hp[p,0]);swap(hp[i,1],hp[p,1]);
        i:=p;p:=p shr 1;
    end;
end;
//end heap

//begin bit
procedure _add(x,k:int);
begin
    if x=0 then exit;
    while x&lt;=n do begin
        inc(bit[x],k);inc(x,x and (-x));
    end;
end;
function ask(x:int):int;
begin
    ask:=0;
    while x&gt;0 do begin
        inc(ask,bit[x]);x:=x and (x-1);
    end;
end;
//end bit

//seg-tree begin
procedure pushdown(i,b,e:int);
begin
    if b&lt;e then begin 
        seg[i shl 1]:=tag[i];tag[i shl 1]:=tag[i];
        seg[i shl 1 or 1]:=tag[i];tag[i shl 1 or 1]:=tag[i];
    end;
    tag[i]:=-1;
end;
procedure modify(i,b,e,l,r,k:int);
var mid:int;
begin
    if (b&gt;e) or (e&lt;l) or (r&lt;b) then exit;
    if (l&lt;=b) and (e&lt;=r) then begin
        seg[i]:=k;tag[i]:=k;exit;
    end;
    if tag[i]&lt;&gt;-1 then pushdown(i,b,e);
    mid:=(b+e) shr 1;seg[i]:=k;
    modify(i shl 1,b,mid,l,r,k);
    modify(i shl 1 or 1,mid+1,e,l,r,k);
end;
function query(i,b,e,x:int):int;
var mid:int;
begin
    if b=e then exit(seg[i]);
    if tag[i]&lt;&gt;-1 then pushdown(i,b,e);
    mid:=(b+e) shr 1;
    if x&lt;=mid then query:=query(i shl 1,b,mid,x)
    else query:=query(i shl 1 or 1,mid+1,e,x);
end;
//seg-tree end

//op begin
procedure op1(x:int);
var i,u:int;
begin
    for i:=1 to x do begin
        u:=ext();
        _add(lp[u],1);_add(rp[u]+1,-1);
        modify(1,1,n,lp[u],rp[u],u);
    end;
    writeln(u);
end;
procedure op2(x:int);
var u,v,i:int;
begin
    writeln(ask(lp[x])-1); //bug: 这写在前面
    u:=query(1,1,n,lp[x]);ins(f[u],u); //bug: 记得ins
    _add(lp[u],-1);_add(rp[u]+1,1);
    i:=head[u];
    while i&lt;&gt;0 do begin
        v:=g[i].v;
        if v&lt;&gt;par[u] then modify(1,1,n,lp[v],rp[v],v);
        i:=g[i].nxt;
    end;
end;
//op end

begin
    read(n,m);sz:=0;
    for i:=1 to n-1 do begin
        read(u,v);add(u,v);add(v,u);
    end;
    cnt:=0;k:=0;t:=0;dfs(1,0);hs:=0;
    for i:=1 to n do ins(f[i],i);
    fillchar(tag,sizeof(tag),255);
    for i:=1 to m do begin
        read(op,u);
        case op of 1:op1(u);2:op2(u) end;
    end;
end.
</code></pre>]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[NOIP2016 模板整理和复习]]></title>
      <url>https://cothrax.github.io/2016/11/11/noip-2016-review-template/</url>
      <content type="html"><![CDATA[<p>noip前复习一些不熟悉的模板<br>在历时4个月的刷题过程中，有些算法一带而过，之写过一两次或者年代久远或者理解肤浅，需要在考前复习。<br><a id="more"></a></p>
<h2 id="Todo-List"><a href="#Todo-List" class="headerlink" title="Todo List"></a>Todo List</h2><ol>
<li><del>字符串类</del><ol>
<li><del>KMP</del></li>
<li><del>BKDRhash等</del></li>
<li><del>双Hash、rabin-karp</del></li>
</ol>
</li>
<li><del>高斯消元</del></li>
<li><del>dp类</del><ol>
<li><del>斜率优化</del></li>
<li><del>单调队列优化多重背包</del></li>
</ol>
</li>
<li><del>图论类</del><ol>
<li><del>Dinic流、二分图最大匹配</del></li>
<li><del>差分约束</del></li>
<li><del>非递归拓扑排序</del></li>
<li><del>割点/边、点双连通、边双连通</del></li>
<li><del>tarjan求lca</del></li>
<li><del>树剖</del></li>
</ol>
</li>
<li><del>数据结构类</del><ol>
<li><del>莫队</del></li>
<li><del>分块</del></li>
<li><del>Treap</del></li>
</ol>
</li>
<li>博弈论：SG函数</li>
<li>双向BFS</li>
<li><del>康托展开</del> 全排列相关</li>
</ol>
<h2 id="字符串类"><a href="#字符串类" class="headerlink" title="字符串类"></a>字符串类</h2><h3 id="KMP"><a href="#KMP" class="headerlink" title="KMP"></a>KMP</h3><p>前缀匹配后缀，参见matrix67的讲解<br>```delphi kmp.pas<br>type int=longint;<br>procedure kmp(var a,b:ansistring);<br>var<br>    i,j,n,m:int;<br>    p:array[0..100010] of int;<br>begin<br>    n:=length(a);m:=length(b);<br>    j:=0;p[1]:=0;<br>    for i:=2 to m do begin<br>        while (j&gt;0) and (b[i]&lt;&gt;b[j+1]) do j:=p[j];<br>        if b[i]=b[j+1] then inc(j);<br>        p[i]:=j;<br>    end;<br>    j:=0;<br>    for i:=1 to n do begin<br>        while (j&gt;0) and (a[i]&lt;&gt;b[j+1]) do j:=p[j];<br>        if a[i]=b[j+1] then inc(j);<br>        if j=m then begin<br>            writeln(i-m+1); //match<br>            j:=p[j];<br>        end;<br>    end;<br>end;</p>
<pre><code>相关神题：
1. 应用匹配思想的dp：<a href="/2016/08/28/雅礼中学2015模拟赛-prefix/" title="雅礼2015 prefix">雅礼2015 prefix</a>
2. 广义匹配：<a href="/2016/08/28/JSOI2016-提高1班-Day3-message/" title="josi2016 message">josi2016 message</a>

### 字符串Hash
#### Rabin-Karp类Hash
通过进制展开得到Hash

$h(s)=\sum_{i=1}^{len(s)}p^{n-i}*s[i]$

化成递推式就是：$h(s[1,i])=h(s[1,i-1])*p+s[i]$

$O(N)$处理出s的前缀hash值，可以$O(1)$得到任意一段区间的hash值

$h(s[l,r])=h(s[1,r)-h(s[1,l-1])*p^{r-l+1}$

一道双hash题：<a href="/2016/08/17/JSOI2016-提高1班-Day2/" title="josi t2 drunk">josi t2 drunk</a>
这里贴片段
```delphi drunk.pas
type int=longint;
const
    q:array[0..1] of int=(1000019,100000007);
    p:array[0..1] of int=(1009,133);
var
    s:ansistring;
    pn,f:array[0..1,0..100010] of int64;

function hash(l,r,j:int):int64; //[l,r]的hash
begin
    hash:=((f[j,r]-f[j,l-1]*pn[j,r-l+1])mod q[j]+q[j])mod q[j];
end;

procedure init(); //预处理前缀hash
var i,j,n:int;
begin
    n:=length(s);
    for i:=0 to 1 do begin f[i,0]:=0;pn[i,0]:=1 end;
    for i:=1 to n do
        for j:=0 to 1 do begin
            pn[j,i]:=pn[j,i-1]*p[j] mod q[i];
            f[j,i]:=(f[j,i-1]*p[j]+ord(s[i])) mod q[i];
        end;
end;
</code></pre><h4 id="BKDRhash"><a href="#BKDRhash" class="headerlink" title="BKDRhash"></a>BKDRhash</h4><p>```delphi string_hash<br>function bkdr(var s:string):dword;<br>var i:int;<br>begin<br>    bkdr:=0;<br>    for i:=1 to length(s) do<br>        bkdr:=(bkdr*p+ord(s[i])) and not (15 shl 7);<br>end;</p>
<pre><code>## DP类
### 单调队列优化多重背包
原来的方程：$f[i,j]=max(f[i-1,j-k\*c[i]+k\*v[i])$

记$j=b+a\*v[i]$，代入得：

$f[i,j]=max(f[i-1,b+(a-k)\*c[i]]-(a-k)\*v[i]+a\*v[i])$

即分离出具有单调性的部分，记$k=a-k$：

$f[i,j]=max(f[i-1,b+k\*c[i]]-k\*v[i])+a\*v[i],a-k\leq a[i]$

然后可以根据剩余系b分别做单调队列
题目见此：<a href="/2016/08/20/JSOI2016-提高2班-单调队列及动规优化/" title="t2 war">t2 war</a>
```delphi war.pas
d:=0;
for i:=1 to n do begin
    d:=min(m,d+c[i]*a[i]); //当前最大总体积
    for j:=0 to c[i]-1 do begin //枚举剩余系b
        h:=1;t:=0;k:=0;
        while j+c[i]*k&lt;=d do begin //枚举系数
            while (h&lt;=t) and (q[t,0]&lt;=f[j+c[i]*k]-v[i]*k) do dec(t);
            inc(t);q[t,1]:=k;q[t,0]:=f[j+c[i]*k]-v[i]*k; //max()中维护的值入队
            while (h&lt;=t) and (k-q[h,1]&gt;a[i]) do inc(h); //超出数量限制出队
            f[j+c[i]*k]:=max(f[j+c[i]*k],q[h,0]+k*v[i]);
            inc(k);
        end;
    end;
end;
</code></pre><h3 id="斜率优化"><a href="#斜率优化" class="headerlink" title="斜率优化"></a>斜率优化</h3><p>具体题目，以及推<del>倒</del>导细节见：<a href="/2016/08/29/JSOI2016-提高1班-Day3-separate/" title="[JSOI2016] 提高1班 Day3 separate">[JSOI2016] 提高1班 Day3 separate</a></p>
<p><strong>简要的思路：</strong><br>原方程：$f[i,j]=min(f[i-1,k-1]+(a[k]-a[j])^2)$</p>
<p>记：$x[i]=a[i],y[i]=f[i-1,j-1]+a[i]^2$</p>
<p>推得：$g(k,t)\leq 2a[j],k&gt;t$(*)，则k优于t</p>
<p><strong>新的认识：</strong></p>
<ol>
<li>根据式(*)，若$t=q[h],k=q[h+1]$，则从头出队，因为此时$g(k,t)$已经小于$a[i]$，<strong>a是单调递增的</strong>，k不可能再成为最优解</li>
<li>然后是从尾出队，这个单调队列维护的实际上是一个<strong>上凸的凸包</strong>，因为根据式(*)，我们希望<strong>斜率尽量小</strong><br>那么记$k=q[t-1],t=q[t],l$为新插入的点，如果$g(k,t)&gt;g(t,l)$，那么此时直接将l接到队尾<strong>破坏了上凸的性质</strong>，因此t出队。也可以理解成由于g(t,l)一定优于g(k,t)，那么t不再可能成为最优解</li>
</ol>
<p><strong>核心代码</strong>：（出入队条件很长很丑，可以写成函数但会增大常数）</p>
<p>```delphi glope.pas<br>for i:=1 to n do f[1,i]:=sqr(a[i]);<br>for i:=2 to m do begin<br>    h:=0;t:=0;q[h]:=i-1;<br>    for j:=i to n do begin //f[i,j]当j&lt;i时不合法<br>        x[j]:=a[j];<br>        y[j]:=f[i-1,j-1]+sqr(a[j]);<br>        //g(j,q[t])&lt;=g(q[t],q[t-1])<br>        while (h&lt;t) and ((y[j]-y[q[t]])<em>(x[q[t]]-x[q[t]-1])<br>            &lt;=(y[q[t]]-y[q[t]-1])</em>(x[j]-x[q[t]])) do dec(t);<br>        inc(t);q[t]:=j;<br>        //g(q[h],q[h+1])&lt;=2<em>a[i]<br>        while (h&lt;t) and ((y[q[h]]-y[q[h+1]])<br>            &lt;=2</em>a[i]*(x[q[h]]-x[q[h+1]])) do inc(h);<br>        f[i,j]:=f[i-1,q[h]-1]+sqr(a[q[h]]-a[j]);<br>    end;<br>end;</p>
<pre><code>
## 图论类
### Dinic最大流
这玩意noip不考吧，费用流到现在还不会orz
注意点
1. 邻接表从下标2开始存，这样的话方便用`i xor 1`找到反向边
2. 这种dinic写法应用了一个优化：一次dfs找出多条增广路，因此不需要iter数组

```delphi dinic.pas
uses math;
const mxn=100010;mxm=100010;inf=maxlongint;
type
    int=longint;
    edge=record v,w,nxt:int end;
var
    g:array[0..mxm*2] of edge;
    head,d:array[0..mxn] of int;
    n,m,sz:int;

procedure add(u,v,w:int);
begin
    inc(sz);g[sz].v:=v;
    g[sz].nxt:=head[u];head[u]:=sz;
end;

function bfs(s,t0:int):boolean;
var
    q:array[0..mxn] of int;
    h,t,i,u,v:int;
begin
    fillchar(d,sizeof(d),255);
    h:=1;t:=2;q[h]:=s;d[s]:=0;
    while h&lt;&gt;t do begin
        u:=q[h];inc(h);i:=head[u];
        while i&lt;&gt;0 do begin
            v:=g[i].v;
            if (g[i].w&gt;0)and(d[v]=-1) then
                begin d[v]:=d[u]+1;q[t]:=v;inc(t) end;
            i:=g[i].nxt;
        end;
    end;
    bfs:=d[t0]&lt;&gt;-1;
end;

function dfs(u,t,f:int):int;
var tmp,v,i:int;
begin
    if u=t then exit(f);
    i:=head[u];dfs:=0;
    while i&lt;&gt;0 do begin
        v:=g[i].v;
        if (g[i].w&gt;0)and(d[v]=d[u]+1) then begin //&gt;0的条件不要忘
            tmp:=dfs(v,t,min(g[i].w,f-dfs));
            dec(g[i].w,tmp);inc(g[i xor 1].w,tmp);inc(dfs,tmp);
            if dfs=f then exit(f);
        end;
        i:=g[i].nxt;
    end;
    if dfs=0 then d[u]:=-1;
end;

function maxflow(s,t:int):int;
begin
    maxflow:=0;
    while bfs(s,t) do inc(maxflow,dfs(s,t,inf));
end;

begin end.
</code></pre><h3 id="非递归拓扑排序"><a href="#非递归拓扑排序" class="headerlink" title="非递归拓扑排序"></a>非递归拓扑排序</h3><p>topo返回值表示是否是dag</p>
<p>```delphi topo.pas<br>function topo():boolean;<br>var<br>    i,v,u,h,t:int;<br>    deg,q:array[0..mxn] of int;<br>begin<br>    fillchar(deg,sizeof(deg),0);<br>    for i:=1 to sz do inc(deg[g[i].v]);<br>    h:=1;t:=0;<br>    for i:=1 to n do<br>        if deg[i]=0 then begin inc(t);q[t]:=i end;<br>    while h&lt;=t do begin<br>        u:=q[h];inc(h);i:=head[u];<br>        while i&lt;&gt;0 do begin<br>            v:=g[i].v;dec(deg[v]);<br>            if deg[v]=0 then begin inc(t);q[t]:=v end;<br>            i:=g[i].nxt;<br>        end;<br>    end;<br>    topo:=t=n;<br>end;</p>
<pre><code>### 差分约束
规约为最短路即可，可以先想最短路：从u-&gt;v有权为w的边，那么$d[v]\geq d[u]+w$
然后将所有不等式变形成这个形式，建图即可。
如果求某两个变量差的最小值，则要用最长路解决
这类题目做的很少，<a href="/2016/07/25/Luogu-P1993-小K的农场/" title="[Luogu] P1993 小K的农场">[Luogu] P1993 小K的农场</a>
&gt;留一个坑：http://www.cppblog.com/menjitianya/archive/2015/11/19/212292.html

### tarjan-lca
离线+链表+并查集+dfs
链接：[1939: [usaco2008 Oct]Pasture Walking 牧场旅行](http://begin.lydsy.com/JudgeOnline/problem.php?id=1939)
当然这题完全可以在线倍增/树剖
```delphi 1939.pas
type
    int=longint;
    edge=record v,w,nxt:int end;
    node=record k,v,nxt:int end;
var
    g:array[0..2010] of edge;
    lnk:array[0..2010] of node;
    head,ptr,d,par,ans:array[0..1010] of int;
    q:array[0..1010,0..1] of int;
    vis:array[0..1010] of boolean;
    n,m,sz,sl,i,u,v,w:int;

procedure add(u,v,w:int);
begin
    inc(sz);g[sz].v:=v;g[sz].w:=w;
    g[sz].nxt:=head[u];head[u]:=sz;
end;

procedure ins(k,u,v:int);
begin
    inc(sl);lnk[sl].k:=k;lnk[sl].v:=v;
    lnk[sl].nxt:=ptr[u];ptr[u]:=sl;
end;

function find(x:int):int;
begin
    if par[x]=x then find:=x
    else begin
        par[x]:=find(par[x]);
        find:=par[x];
    end;
end;

procedure union(x,y:int);
begin
    x:=find(x);y:=find(y);par[y]:=x;
end;

procedure dfs(u,p:int);
var i,v,lca:int;
begin
    vis[u]:=true;i:=head[u];
    while i&lt;&gt;0 do begin
        v:=g[i].v;
        if v&lt;&gt;p then begin
            d[v]:=d[u]+g[i].w;dfs(v,u);union(u,v);
        end;
        i:=g[i].nxt;
    end;
    i:=ptr[u];
    while i&lt;&gt;0 do begin
        v:=lnk[i].v;
        if vis[v] then begin
            lca:=find(v);
            ans[lnk[i].k]:=d[v]+d[u]-2*d[lca];
        end;
        i:=lnk[i].nxt;
    end;
end;

begin
    read(n,m);sz:=0;sl:=0;
    for i:=1 to n-1 do begin
        read(u,v,w);add(u,v,w);add(v,u,w);
    end;
    for i:=1 to m do begin
        read(q[i,0],q[i,1]);
        ins(i,q[i,0],q[i,1]);ins(i,q[i,1],q[i,0]);
    end;
    for i:=1 to n do par[i]:=i;
    dfs(1,0);
    for i:=1 to m do writeln(ans[i]);
end.
</code></pre><h3 id="tarjan-连通分量"><a href="#tarjan-连通分量" class="headerlink" title="tarjan-连通分量"></a>tarjan-连通分量</h3><p><strong>强连通分量</strong><br>```delphi scc.pas<br>procedure tarjan(u:int);<br>var i,v:int;<br>begin<br>    inc(tim);dfn[u]:=tim;low[u]:=tim;<br>    inc(t);stk[t]:=u;ins[u]:=true;<br>    i:=head[u];<br>    while i&lt;&gt;0 do begin<br>        v:=g[i].v;<br>        if dfn[v]=0 then begin<br>            tarjan(v);low[u]:=min(low[u],low[v])<br>        end else if ins[v] then<br>            low[u]:=min(low[u],dfn[v]);<br>        i:=g[i].nxt;<br>    end;<br>    if dfn[u]=low[u] then begin<br>        inc(cc);<br>        while stk[t+1]&lt;&gt;u do begin<br>            scc[stk[t]]:=cc;ins[stk[t]]:=false;dec(t); //bug:记得标记ins<br>        end;<br>    end;<br>end;</p>
<pre><code>**边双连通分量**：与scc一致
**点双连通分量**：由于一个点可能被包含在多个分量中，因此在`tarjan(v)`后如果`low[v]&gt;=dfn[u]`，立刻处理v这个分量，注意u也包含在该分量内，但不能退栈。见<a href="/2016/08/16/POJ-P2942/" title="[POJ] P2942 Knights of the Round Table">[POJ] P2942 Knights of the Round Table</a>

## 数据结构类
### 莫队
这其实不算数据结构吧，只是一类数据结构题的一种偷懒的解法罢了
写过一次：<a href="/2016/09/08/NOIP模拟赛-2014-7-18/" title="p1-harem">p1-harem</a>

其核心思想是离线处理区间统计问题，要求统计量具有这种性质：
能在$O(1)$内由区间$[l,r]$的答案得到$[l\pm 1,r\pm 1]$的答案

区间的排序方法是：按$\sqrt{n}$分块，第一关键字为所在块编号，第二关键字为右端点
复杂度：
- 同一块内
   1. 由于按块编号排序，左端点每次变化$O(\sqrt{N})$，则总复杂度$O(N\sqrt{N})$
   2. 右端点顺序排列，因此为$O(N)$，而总共$\sqrt{N}$块，总复杂度$O(N\sqrt{N})$。
- 跨块的复杂度也类似，是同阶的

注意点：区间初始为$l=1,r=0$，注意端点

上面那题的核心代码

```delphi mo.pas
type int=longint;
var
    n,m,k:int;
    q:array[0..100010,0..3] of int; //[编号,l,r,所在块]
    ans,a:array[0..100010] of int;

function com(i,j:int):boolean; //i&lt;j
begin
    com:=(q[i,3]&lt;q[j,3]) or ((q[i,3]=q[j,3]) and (q[i,2]&lt;q[j,2]));
end;

procedure qsort(l,r:int); //用com函数排序，略
procedure update(x,i:int); //相关更新操作，略

procedure init();
var i:int;
begin
    {...data input}
    read(n);k:=trunc(sqrt(n)); //n=询问数,k=块的大小
    for i:=1 to n do begin
        read(q[i,1],q[i,2]);q[i,0]:=i;
        q[i,3]:=(q[i,1]-1)div k+1;
    end;
    qsort(1,n);
end;

procedure mo();
var i,j,l,r,cnt:int;
begin
    l:=1;r:=0;cnt:=0;
    for i:=1 to n do begin
        for j:=r+1 to q[i,2] do update(a[j],1);
        for j:=r downto q[i,2]+1 do update(a[j],-1);
        for j:=l to q[i,1]-1 do update(a[j],-1);
        for j:=l-1 downto q[i,1] do update(a[j],1);
        l:=q[i,1];r:=q[i,2];ans[q[i,0]]:=cnt;
    end;
    for i:=1 to n do writeln(ans[i]);
end;

begin end.
</code></pre><h3 id="分块（块状数组）"><a href="#分块（块状数组）" class="headerlink" title="分块（块状数组）"></a>分块（块状数组）</h3><p>只写过一次分块题：<a href="/2016/09/06/NOIP模拟赛-教主的魔法/" title="NOIP模拟赛 教主的魔法">NOIP模拟赛 教主的魔法</a><br>注意点：</p>
<ol>
<li>不要混淆块编号和元素编号</li>
<li>在下面的模型中，tag维护块的懒标记，再暴力首尾两块时不必重新处理，因为尽管块内元素的顺序有变化，但总的增量是不变的</li>
</ol>
<p>带修改，区间中统计不小于k的元素个数<br>```delphi block.pas<br>uses math;<br>const mxn=100010;<br>type int=longint;<br>var<br>    a,b,blk,tag:array[0..mxn] of int;<br>    n,k:int;</p>
<p>function bin(i,x:int):int; //省略<br>procedure qsort(l,r:int); //省略</p>
<p>procedure sort(x:int);<br>var i,l,r:int;<br>begin<br>    l:=(x-1)<em>k+1;r:=min(n,x</em>k); //bug: x是块编号<br>    for i:=l to r do b[i]:=a[i]{+tag[x]};<br>    {tag[x]:=0;}qsort(l,r);<br>end;</p>
<p>procedure modify(l,r,x:int);<br>var i:int;<br>begin<br>    for i:=l to min(r,blk[l]<em>k) do inc(a[i],x); //bug:起始为l<br>    sort(blk[l]);<br>    if blk[l]=blk[r] then exit;<br>    for i:=(blk[r]-1)</em>k+1 to r do inc(a[i],x); //bug:结束为r<br>    sort(blk[r]);<br>    for i:=blk[l]+1 to blk[r]-1 do inc(tag[i],x);<br>end;</p>
<p>function query(l,r,x:int):int;<br>var i:int;<br>begin<br>    query:=0;<br>    for i:=l to min(r,blk[l]<em>k) do<br>        if a[i]+tag[blk[l]]&gt;=x then inc(query); //tag下标是块编号<br>    if blk[l]=blk[r] then exit(query);<br>    for i:=(blk[r]-1)</em>k+1 to r do<br>        if a[i]+tag[blk[r]]&gt;=x then inc(query);<br>    for i:=blk[l]+1 to blk[r]-1 do inc(query,min(i*k,n)-bin(i,x));<br>    //bin(i,x): max_j{b[j]+tag[i]&lt;x,j in i}<br>end;</p>
<p>procedure init();<br>var i:int;<br>begin<br>    k:=trunc(sqrt(n));<br>    for i:=1 to n do blk[i]:=(i-1)div k+1;<br>    for i:=1 to blk[n] do sort(i);<br>end;</p>
<p>begin end.</p>
<pre><code>
### Treap
模板题见此：<a href="/2016/11/05/bzoj-3224/" title="BZOJ-3224 普通平衡树">BZOJ-3224 普通平衡树</a>

### 树剖
想了想还是放在数据结构里吧
&gt;线段树不能虚！注意pushdown
线段树不能虚！注意pushdown
线段树不能虚！注意pushdown

模板题见：<a href="/2016/11/05/luogu-3384/" title="luogu-3384 【模板】树链剖分">luogu-3384 【模板】树链剖分</a>

## 其他
### 高斯消元
解线性方程组，做一道物理题：<a href="/2016/08/29/JSOI2016-提高1班-Day3-resistor/" title="jsoi2016 resistor">jsoi2016 resistor</a>

```delphi gs.pas
const mxn=110;eps=0.000000001;
type
    int=longint;
    mat=array[0..mxn,0..mxn] of double;
procedure gauss(var a:mat;n:int);
var
    i,j,k,p:int;
    tmp:array[0..mxn] of double;
begin
    for i:=1 to n do begin
        p:=i; //换主元
        for j:=i+1 to n do if a[j,i]&gt;a[p,i] then p:=j;
        if abs(a[p,i])&lt;eps then exit; //无解
        tmp:=a[i];a[i]:=a[p];a[p]:=tmp;
        for j:=i+1 to n+1 do a[i,j]:=a[i,j]/a[i,i]; //处理主元所在行
        for j:=1 to n do if i&lt;&gt;j then //处理余下行
            for k:=i+1 to n+1 do a[j,k]:=a[j,k]-a[j,i]*a[i,k];
    end;
    for i:=1 to n do writeln(&#39;x&#39;,i,&#39;=&#39;,a[i,n+1]:0:3);
end;
</code></pre><h3 id="康托展开"><a href="#康托展开" class="headerlink" title="康托展开"></a>康托展开</h3><p>即全排列hash值，如0..8的全排列：<br>$h=\sum_{i=0}^8k(8-i)!,k=\sum_{j=i+1}^8[a[i]&gt;a[j]]$<br><code>delphi kt.pas
function ct(var a:arr):int;
var i,j,cnt:int;
begin
    ct:=0;
    for i:=0 to 8 do begin
        cnt:=0;
        for j:=i+1 to 8 do
            if a[i]&gt;a[j] then inc(cnt);
        inc(ct,cnt*fac[8-i]);
    end;
end;</code></p>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[NOIP2016十连测总结]]></title>
      <url>https://cothrax.github.io/2016/11/10/lydsy-noip-2016-summary/</url>
      <content type="html"><![CDATA[<p>NOIP2016十连测在12天前已经完结，除了几个神坑没有填之外，基本订正完毕。<br>从一个蒟蒻的noiper的角度看，除了god出的前两场，其余均为NOIplus难度。</p>
<blockquote>
<p>I good vegetable.</p>
</blockquote>
<a id="more"></a>
<h2 id="挖坑"><a href="#挖坑" class="headerlink" title="挖坑"></a>挖坑</h2><ol>
<li><a href="/2016/10/03/lydsy-noip-2016-test2/" title="Test2 T3 speed">Test2 T3 speed</a>：好吧题解都看不懂</li>
<li><a href="/2016/10/28/lydsy-noip-2016-test9/" title="Test9 T3 mst">Test9 T3 mst</a>：过于noip的计算几何题</li>
<li><a href="/2016/11/04/lydsy-noip-2016-test7/" title="Test7 T3 tournament">Test7 T3 tournament</a>和<a href="/2016/10/16/lydsy-noip-2016-test6/" title="Test6 T2 goodbye">Test6 T2 goodbye</a>：概率期望的知识要补</li>
<li><a href="/2016/10/28/lydsy-noip-2016-test5/" title="Test5 T3 travel">Test5 T3 travel</a>：题解好长，想法题，先留着吧</li>
<li>一些不明白的地方<ol>
<li><a href="/2016/10/10/lydsy-noip-2016-test4/" title="Test4 T3 ra">Test4 T3 ra</a>的部分分解法和复杂度的分析</li>
<li><a href="/2016/11/04/lydsy-noip-2016-test7/" title="Test7 T2 password">Test7 T2 password</a>的方程个数的期望</li>
</ol>
</li>
</ol>
<h2 id="简单题"><a href="#简单题" class="headerlink" title="简单题"></a>简单题</h2><ol>
<li><a href="/2016/10/02/lydsy-noip-2016-test1/" title="Test1 T1 master">Test1 T1 master</a>：字符串dp</li>
<li><a href="/2016/10/03/lydsy-noip-2016-test2/" title="Test2 T1 div">Test2 T1 div</a>：乱搞</li>
<li><a href="/2016/10/10/lydsy-noip-2016-test4/" title="Test4 T1 orisis">Test4 T1 orisis</a>：水</li>
<li><a href="/2016/10/28/lydsy-noip-2016-test9/" title="Test9 T1 2048">Test9 T1 2048</a>：模拟</li>
<li><a href="/2016/10/16/lydsy-noip-2016-test6/" title="Test6 T1 fantasy">Test6 T1 fantasy</a>：观察+乱搞（被卡常）</li>
</ol>
<h2 id="新知"><a href="#新知" class="headerlink" title="新知"></a>新知</h2><ol>
<li>数论<ol>
<li>裴蜀定理：<a href="/2016/10/28/lydsy-noip-2016-test5/" title="Test5 T1 simple">Test5 T1 simple</a></li>
<li>杜教筛？：<a href="/2016/10/10/lydsy-noip-2016-test4/" title="Test4 T3 ra">Test4 T3 ra</a></li>
</ol>
</li>
<li>dfs序：<a href="/2016/11/04/lydsy-noip-2016-test10/" title="Test10 T3 lca">Test10 T3 lca</a><ul>
<li>“贡献”的思想，还有<a href="/2016/10/09/lydsy-noip-2016-test3/" title="Test3 T3 seq">Test3 T3 seq</a></li>
</ul>
</li>
<li>容斥dp：<a href="/2016/10/10/lydsy-noip-2016-test4/" title="Test4 T2 obelisk">Test4 T2 obelisk</a></li>
</ol>
<h2 id="长见识"><a href="#长见识" class="headerlink" title="长见识"></a>长见识</h2><ol>
<li>dp类<ol>
<li>强行单调后二分：<a href="/2016/10/03/lydsy-noip-2016-test2/" title="Test2 T2 market">Test2 T2 market</a></li>
<li>数据结构优化lis：<a href="/2016/10/30/lydsy-noip-2016-test8/" title="Test8 T2 hamon">Test8 T2 hamon</a></li>
<li>广义矩阵乘法+快速幂：<a href="/2016/11/04/lydsy-noip-2016-test10/" title="Test10 T1 lis">Test10 T1 lis</a></li>
<li>最短路处理dp（woc这是图论题）：<a href="/2016/11/04/lydsy-noip-2016-test10/" title="Test10 T2 bag">Test10 T2 bag</a></li>
</ol>
</li>
<li>位运算求交集：<a href="/2016/10/02/lydsy-noip-2016-test1/" title="Test1 T2 tour">Test1 T2 tour</a></li>
<li>图论<ol>
<li>增点：<a href="/2016/10/02/lydsy-noip-2016-test1/" title="Test1 T3 walk">Test1 T3 walk</a></li>
<li>拆点+路径求交+破环成链+dag上dp：<a href="/2016/10/16/lydsy-noip-2016-test6/" title="Test6 T3 reality">Test6 T3 reality</a></li>
</ol>
</li>
</ol>
<h2 id="脑洞"><a href="#脑洞" class="headerlink" title="脑洞"></a>脑洞</h2><ol>
<li>神奇二分，化最优解为统计问题：<a href="/2016/10/09/lydsy-noip-2016-test3/" title="Test3 T1 ave">Test3 T1 ave</a></li>
<li><a href="/2016/10/28/lydsy-noip-2016-test5/" title="Test5 T2 walk">Test5 T2 walk</a>
<ol>
<li>如何处理常数：链表、栈</li>
<li>如何处理gcd：按倍数枚举</li>
</ol>
</li>
<li>自己看吧：<a href="/2016/10/30/lydsy-noip-2016-test8/" title="Test8 T3 raviel">Test8 T3 raviel</a></li>
<li><a href="/2016/10/28/lydsy-noip-2016-test9/" title="Test9 T2 seq">Test9 T2 seq</a>
<ol>
<li>40分可以dp，noip难度类似2015的子串</li>
<li>结论</li>
</ol>
</li>
<li>可以乱搞：<a href="/2016/11/04/lydsy-noip-2016-test10/" title="Test10 T1 lis">Test10 T1 lis</a></li>
</ol>
<h2 id="知识强化"><a href="#知识强化" class="headerlink" title="知识强化"></a>知识强化</h2><ol>
<li>主席树二维数点：<a href="/2016/10/09/lydsy-noip-2016-test3/" title="Test3 T3 seq">Test3 T3 seq</a></li>
<li>好像没有了</li>
</ol>
<h2 id="数学啊数学"><a href="#数学啊数学" class="headerlink" title="数学啊数学"></a>数学啊数学</h2><ol>
<li>恶心的组合数学dp：<a href="/2016/10/09/lydsy-noip-2016-test3/" title="Test3 T2 color">Test3 T2 color</a></li>
<li>坑爹数论：<a href="/2016/10/30/lydsy-noip-2016-test8/" title="Test8 T1 uria">Test8 T1 uria</a></li>
<li>递推解约瑟夫+<strong>打表</strong>：<a href="/2016/11/04/lydsy-noip-2016-test7/" title="Test7 T1 joseph">Test7 T1 joseph</a></li>
<li>同余方程组+带权并查集：<a href="/2016/11/04/lydsy-noip-2016-test7/" title="Test7 T2 password">Test7 T2 password</a></li>
</ol>
<h2 id="写在后面"><a href="#写在后面" class="headerlink" title="写在后面"></a>写在后面</h2><p>可以说这次十连测暴露出了大量的知识盲区，题目的思维深度超出了一个蒟蒻的能力范围。<br>在算法能力方面，这次测试给了我很大的提升，但完全没有达到训练应试能力/代码能力的效果<del>（因为看完题面连暴力都懒得打了orz）</del></p>
<blockquote>
<p>while true do inc(rp);</p>
</blockquote>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[luogu-3384 【模板】树链剖分]]></title>
      <url>https://cothrax.github.io/2016/11/05/luogu-3384/</url>
      <content type="html"><![CDATA[<h2 id="大意"><a href="#大意" class="headerlink" title="大意"></a>大意</h2><p>一颗根为r、有n个节点的树，点上有权值，要求支持如下操作：</p>
<ol>
<li>操作1：<code>1 x y z</code> x到y的路径上所有点权加z</li>
<li>操作2：格式： <code>2 x y</code> 求x到y路径上的点权和</li>
<li>操作3： 格式： <code>3 x z</code> x子树中所有点权加z</li>
<li>操作4： 格式： <code>4 x</code> 求x子树点权和</li>
</ol>
<a id="more"></a>
<h2 id="链接"><a href="#链接" class="headerlink" title="链接"></a>链接</h2><p><a href="https://www.luogu.org/problem/show?pid=3384#sub" target="_blank" rel="external">luogu-3384</a><br><a href="/2016/11/05/luogu-3384/tree.pas" title="tree.pas">tree.pas</a></p>
<h2 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h2><p>树剖模板题<br>尽管是树剖，遍历方式依然是dfs，所得序列满足dfs序的性质，操作3/4可以轻松解决<br>md线段树调了好久。。。<strong>pushdown要小心不能虚</strong></p>
<h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><p>```delphi tree.pas<br>type int=longint;edge=record v,nxt:int end;<br>var<br>    g:array[0..200010] of edge;<br>    head,siz,dep,par,son,top,w,loc,a:array[0..100010] of int;<br>    seg,tag:array[0..400010] of int;<br>    n,m,k,sz,rt,md,u,v,i,x,y,z,op:int;</p>
<p>procedure add(u,v:int);<br>begin<br>    inc(sz);g[sz].v:=v;<br>    g[sz].nxt:=head[u];head[u]:=sz;<br>end;</p>
<p>procedure dfs1(u,p:int);<br>var i,v:int;<br>begin<br>    par[u]:=p;dep[u]:=dep[p]+1;<br>    siz[u]:=1;son[u]:=0;i:=head[u];<br>    while i&lt;&gt;0 do begin<br>        v:=g[i].v;<br>        if v&lt;&gt;p then begin<br>            dfs1(v,u);<br>            if siz[v]&gt;siz[son[u]] then son[u]:=v;<br>            inc(siz[u],siz[v]);<br>        end;<br>        i:=g[i].nxt;<br>    end;<br>end;</p>
<p>procedure dfs2(u:int);<br>var i,v:int;<br>begin<br>    if u=0 then exit;<br>    if u=son[par[u]] then top[u]:=top[par[u]] else top[u]:=u;<br>    inc(k);loc[u]:=k;a[k]:=u;dfs2(son[u]);<br>    i:=head[u];<br>    while i&lt;&gt;0 do begin<br>        v:=g[i].v;<br>        if (v&lt;&gt;par[u])and(v&lt;&gt;son[u]) then dfs2(v);<br>        i:=g[i].nxt;<br>    end;<br>end;</p>
<p>// seg-tree begin<br>procedure pushdown(i,b,e:int);<br>var l,r,mid:int;<br>begin<br>    l:=i shl 1;r:=l or 1;mid:=(b+e)shr 1;<br>    seg[l]:=(seg[l]+tag[i]<em>(mid-b+1))mod md;<br>    seg[r]:=(seg[r]+tag[i]</em>(e-mid))mod md;<br>    tag[l]:=(tag[l]+tag[i])mod md;<br>    tag[r]:=(tag[r]+tag[i])mod md;<br>    tag[i]:=0;<br>end;<br>procedure build(i,b,e:int);<br>var mid:int;<br>begin<br>    if b=e then begin seg[i]:=w[a[b]];exit end;<br>    mid:=(b+e) shr 1;<br>    build(i shl 1,b,mid);build(i shl 1 or 1,mid+1,e);<br>    seg[i]:=(seg[i shl 1]+seg[i shl 1 or 1])mod md;<br>end;<br>procedure modify(i,b,e,l,r,k:int);<br>var mid:int;<br>begin<br>    if (e<l) or="" (r<b)="" then="" exit;="" if="" (l<="b)" and="" (e<="r)" begin="" seg[i]:="(seg[i]+k*(e-b+1))mod" md;="" tag[i]:="(tag[i]+k)mod" end;="" tag[i]<="">0 then pushdown(i,b,e);<br>    mid:=(b+e) shr 1;<br>    modify(i shl 1,b,mid,l,r,k);<br>    modify(i shl 1 or 1,mid+1,e,l,r,k);<br>    seg[i]:=(seg[i shl 1]+seg[i shl 1 or 1])mod md;<br>end;<br>function query(i,b,e,l,r:int):int;<br>var mid:int;<br>begin<br>    if (e<l) or="" (r<b)="" then="" exit(0);="" if="" (l<="b)" and="" (e<="r)" exit(seg[i]);="" tag[i]<="">0 then pushdown(i,b,e);<br>    mid:=(b+e) shr 1;<br>    query:=(query(i shl 1,b,mid,l,r)+<br>        query(i shl 1 or 1,mid+1,e,l,r))mod md;<br>end;<br>//seg-tree end</l)></l)></p>
<p>procedure swap(var a,b:int);<br>var tmp:int;<br>begin tmp:=a;a:=b;b:=tmp end;</p>
<p>function lca(u,v:int):int;<br>begin<br>    while true do begin<br>        if dep[u]&gt;dep[v] then swap(u,v);<br>        if top[u]=top[v] then break;<br>        if dep[top[u]]&lt;dep[top[v]] then v:=par[top[v]]<br>        else u:=par[top[u]];<br>    end;<br>    lca:=u;<br>end;</p>
<p>procedure mfylnk(u,v,k:int);<br>begin<br>    while true do begin<br>        if dep[u]&gt;dep[v] then swap(u,v);<br>        if top[u]=top[v] then break;<br>        if dep[top[u]]&lt;dep[top[v]] then begin<br>            modify(1,1,n,loc[top[v]],loc[v],k);<br>            v:=par[top[v]];<br>        end else begin<br>            modify(1,1,n,loc[top[u]],loc[u],k);<br>            u:=par[top[u]];<br>        end;<br>    end;<br>    modify(1,1,n,loc[u],loc[v],k);<br>end;</p>
<p>function asklnk(u,v:int):int;<br>begin<br>    asklnk:=0;<br>    while true do begin<br>        if dep[u]&gt;dep[v] then swap(u,v);<br>        if top[u]=top[v] then break;<br>        if dep[top[u]]&lt;dep[top[v]] then begin<br>            asklnk:=(asklnk+query(1,1,n,loc[top[v]],loc[v]))mod md;<br>            v:=par[top[v]];<br>        end else begin<br>            asklnk:=(asklnk+query(1,1,n,loc[top[u]],loc[u]))mod md;<br>            u:=par[top[u]];<br>        end;<br>    end;<br>    asklnk:=(asklnk+query(1,1,n,loc[u],loc[v]))mod md;<br>end;</p>
<p>procedure mfysbt(u,k:int);<br>begin modify(1,1,n,loc[u],loc[u]+siz[u]-1,k) end;</p>
<p>function asksbt(u:int):int;<br>begin asksbt:=query(1,1,n,loc[u],loc[u]+siz[u]-1) end;</p>
<p>procedure walk(i,b,e,d:int);<br>var mid,j:int;<br>begin<br>    mid:=(b+e) shr 1;<br>    if b&lt;e then walk(i<em>2,b,mid,d+1);<br>    for j:=1 to d</em>5 do write(‘ ‘);<br>    writeln(i,’:[‘,b,’,’,e,’]=’,seg[i],’:’,tag[i]);<br>    if b&lt;e then walk(i*2+1,mid+1,e,d+1);<br>end;</p>
<p>begin<br>    read(n,m,rt,md);k:=0;sz:=0;<br>    for i:=1 to n do read(w[i]);<br>    for i:=1 to n-1 do begin<br>        read(u,v);add(u,v);add(v,u);<br>    end;<br>    dfs1(rt,0);dfs2(rt);build(1,1,n);<br>    for i:=1 to m do begin<br>        read(op);<br>        case op of<br>            1:begin read(x,y,z);mfylnk(x,y,z) end;<br>            2:begin read(x,y);writeln(asklnk(x,y)) end;<br>            3:begin read(x,z);mfysbt(x,z) end;<br>            4:begin read(x);writeln(asksbt(x)) end;<br>        end;<br>    end;<br>end.<br>```</p>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[BZOJ-3224 普通平衡树]]></title>
      <url>https://cothrax.github.io/2016/11/05/bzoj-3224/</url>
      <content type="html"><![CDATA[<p>大意：实现一系列操作维护一个数集：插入、删除、查询数x的排名、查询排名为x的数、求前驱和后驱</p>
<a id="more"></a>
<h2 id="链接"><a href="#链接" class="headerlink" title="链接"></a>链接</h2><p><a href="http://www.lydsy.com/JudgeOnline/problem.php?id=3224" target="_blank" rel="external">BZOJ-3224</a><br><a href="https://www.luogu.org/problem/show?pid=3369#sub" target="_blank" rel="external">luogu-3369</a><br><a href="/2016/11/05/bzoj-3224/treap.pas" title="treap.pas">treap.pas</a></p>
<h2 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h2><p>treap模板题，本蒟蒻第一次写平衡树</p>
<h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><p>```delphi treap.pas<br>uses math;<br>type<br>    int=longint;<br>    node=record l,r,w,s,cnt,rnd:int end;<br>const inf=maxlongint;<br>var<br>    tp:array[0..100010] of node;<br>    sz,rt,i,n,op,x:int;</p>
<p>procedure upd(k:int); //更新tp[k].s即子树规模<br>begin tp[k].s:=tp[tp[k].l].s+tp[tp[k].r].s+tp[k].cnt end;</p>
<p>procedure lturn(var k:int); //左旋<br>var t:int;<br>begin<br>    t:=tp[k].r;tp[k].r:=tp[t].l;tp[t].l:=k;<br>    tp[t].s:=tp[k].s;upd(k);k:=t;<br>end;</p>
<p>procedure rturn(var k:int); //右旋<br>var t:int;<br>begin<br>    t:=tp[k].l;tp[k].l:=tp[t].r;tp[t].r:=k;<br>    tp[t].s:=tp[k].s;upd(k);k:=t;<br>end;</p>
<p>procedure ins(var k:int;x:int); //插入<br>begin<br>    if k=0 then begin<br>        inc(sz);k:=sz;tp[sz].w:=x;tp[sz].cnt:=1;<br>        tp[k].s:=1;tp[sz].rnd:=random(inf);exit;<br>    end;<br>    if x=tp[k].w then begin inc(tp[k].cnt);upd(k) end //bug:缺upd(k)<br>    else if x&lt;tp[k].w then begin<br>        ins(tp[k].l,x);upd(k);<br>        if tp[k].rnd&lt;tp[tp[k].l].rnd then rturn(k);<br>    end else begin<br>        ins(tp[k].r,x);upd(k);<br>        if tp[k].rnd&lt;tp[tp[k].r].rnd then lturn(k);<br>    end;<br>end;</p>
<p>procedure del(var k:int;x:int); //堆式删除<br>begin<br>    if k=0 then exit;<br>    if x<tp[k].w then="" del(tp[k].l,x)="" else="" if="" x="">tp[k].w then del(tp[k].r,x)<br>    else begin<br>        if tp[k].cnt&gt;1 then dec(tp[k].cnt)<br>        else if tp[k].l*tp[k].r=0 then k:=max(tp[k].l,tp[k].r)<br>        else if tp[tp[k].l].rnd<tp[tp[k].r].rnd then="" begin="" lturn(k);del(tp[k].l,x)="" end="" else="" rturn(k);del(tp[k].r,x)="" end;="" if="" k<="">0 then upd(k);<br>end;</tp[tp[k].r].rnd></tp[k].w></p>
<p>function low(k,x:int):int; //查询比x小的数的个数<br>begin<br>    if k=0 then exit(0)<br>    else if x=tp[k].w then exit(tp[tp[k].l].s)<br>    else if x&lt;tp[k].w then exit(low(tp[k].l,x))<br>    else exit(tp[tp[k].l].s+tp[k].cnt+low(tp[k].r,x)); //考虑cnt<br>end;</p>
<p>function kth(k,x:int):int; //查询第k个树<br>begin<br>    if k=0 then exit(0)<br>    else if tp[tp[k].l].s+tp[k].cnt<x then="" exit(kth(tp[k].r,x-tp[tp[k].l].s-tp[k].cnt))="" else="" if="" tp[tp[k].l].s="">=x then exit(kth(tp[k].l,x))<br>    else exit(tp[k].w);<br>end;</x></p>
<p>function _min(k:int):int; //查询子树k中的最小值<br>begin<br>    if k=0 then exit(inf)<br>    else if tp[k].l=0 then exit(tp[k].w)<br>    else exit(_min(tp[k].l));<br>end;</p>
<p>function _max(k:int):int; //查询子树k中的最大值<br>begin<br>    if k=0 then exit(-inf)<br>    else if tp[k].r=0 then exit(tp[k].w)<br>    else exit(_max(tp[k].r));<br>end;</p>
<p>function pvs(k,x:int):int; //求树中比x小的最大的数<br>var tmp:int;<br>begin<br>    tmp:=_min(tp[k].r);<br>    if tp[k].w&gt;=x then exit(pvs(tp[k].l,x))<br>    else if tmp&gt;=x then exit(tp[k].w)<br>    else exit(pvs(tp[k].r,x));<br>end;</p>
<p>function nxt(k,x:int):int; //求树中比x大的最小的数<br>var tmp:int;<br>begin<br>    tmp:=_max(tp[k].l);<br>    if tp[k].w&lt;=x then exit(nxt(tp[k].r,x))<br>    else if tmp&lt;=x then exit(tp[k].w)<br>    else exit(nxt(tp[k].l,x));<br>end;</p>
<p>procedure walk(k,d:int); //debug-output<br>var i:int;<br>begin<br>    if k=0 then exit;<br>    walk(tp[k].l,d+1);<br>    for i:=1 to d*7 do write(‘ ‘);<br>    writeln(tp[k].w,’:’,tp[k].cnt,’:’,tp[k].s);<br>    walk(tp[k].r,d+1);<br>end;</p>
<p>begin<br>    randomize;read(n);sz:=0;rt:=0;<br>    for i:=1 to n do begin<br>        read(op,x);<br>        case op of<br>            1:ins(rt,x);<br>            2:del(rt,x);<br>            3:writeln(low(rt,x)+1);<br>            4:writeln(kth(rt,x));<br>            5:writeln(pvs(rt,x));<br>            6:writeln(nxt(rt,x));<br>        end;<br>        //walk(rt,1);<br>    end;<br>end.<br>```</p>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[NOIP2016十连测 Day 10]]></title>
      <url>https://cothrax.github.io/2016/11/04/lydsy-noip-2016-test10/</url>
      <content type="html"><![CDATA[<blockquote>
<p>订正进度(3/3)</p>
</blockquote>
<h1 id="P1-lis"><a href="#P1-lis" class="headerlink" title="P1 lis"></a>P1 lis</h1><p>大意：<br>给定长度n和参数$t_0,A,B,C,D$，定义数列$a_n$：<br>$n=1,a[n]=t_0$<br>$n\geq 2,a[n]=(A\times a_{n-1}^2+B\times a_{n-1}+C)\% D$</p>
<p>求$a_n$的最长不下降子序列<br>$0\leq t_0,A,B,C\leq150,1\leq D\leq150, 1\leq n\leq10^{12}$<br><a id="more"></a></p>
<h2 id="解法一"><a href="#解法一" class="headerlink" title="解法一"></a>解法一</h2><p>复杂度：$O(D^3logN)$<br>根据鸽巢原理，该数列一定有循环节$T\leq D$，该数列为<span>$\{l+m*T+r\}$</span><!-- Has MathJax -->，l为前面不属于循环节的部分，r为末尾剩余的不完整循环<br>考虑纯循环数列的lis<br>记f[n,i,j]为以a[i]开头，a[nT+j]结尾的lis<br>那么$f[n,i,j]=max_{1\leq k\leq T,a[i]\leq a[j]\leq a[k]}(f[n-1,i,k]+f[1,k,j]-1)$</p>
<p>这里定义矩阵$C=A\times B$：$$C[i,j]=max_{k=1}^n(A[i,k]+B[k,j]-1)$$</p>
<p>可以证明该乘法满足结合律，那么可以用矩阵快速幂求解f[n]：<br>$f[n]=f[n-1]\times f[1]=f[1]^n$<br>要求$a[i]\leq a[j]$，则不合法的g[i,j]标记为$-\infty$<br>单位矩阵的对角线上为0，其余为$-\infty$<br>初始矩阵f[1]直接dp求即可</p>
<p>记l[i]为<span>$\{l\}$</span><!-- Has MathJax -->中满足上界为T[i]的lis<br>记r[i]为<span>$\{r\}$</span><!-- Has MathJax -->中满足下界为T[i]的lis<br>这两个用直接dp求得</p>
<p>然后枚举中间部分的左右端点<br>$ans=max_{1\leq i,j\leq T}(l[i]+r[i]+g[m-1,i,j])$</p>
<p>细节：</p>
<ol>
<li>两个特判<ol>
<li>$n\leq l+T$，此时暴力求</li>
<li>循环节长为1时特判</li>
</ol>
</li>
<li>初始化矩阵时，枚举i,j求i..T+j的lis值，注意必须要以i开头、T+j结尾</li>
<li>快速幂的指数为m-1</li>
<li>不要让$-\infty$参与运算，防止出现诡异的错误</li>
</ol>
<p><div style="display:none;" class="copy"><br>    <a href="/2016/11/04/lydsy-noip-2016-test10/lis_.pas" title="{plain text}">{plain text}</a><br></div><br>```delphi _lis.pas<br>uses math;<br>const inf=1000000000;<br>type<br>    int=longint;<br>    mat=array[0..155,0..155] of int64;<br>var<br>    a,b,c,d,k,i,j,x,til,len,rst:int;<br>    l,r,f,s,loc:array[0..2240] of int;<br>    g:mat;n,m,ans:int64;</p>
<p>function bin(x,n:int):int;<br>var l,r,mid:int;<br>begin<br>    //max_j{f[j]&lt;=x}<br>    l:=1;r:=n;bin:=0;<br>    while l&lt;=r do begin<br>        mid:=(l+r) shr 1;<br>        if f[mid]&lt;=x then begin bin:=mid;l:=mid+1 end<br>        else r:=mid-1;<br>    end;<br>end;</p>
<p>function lis(dn,up,n,b:int):int;<br>var i,j:int;<br>begin<br>    for i:=1 to n do f[i]:=inf;<br>    lis:=0;f[0]:=0;<br>    for i:=1 to n do begin<br>        if (s[b+i]<dn)or(s[b+i]>up) then continue;<br>        j:=bin(s[b+i],lis);<br>        f[j+1]:=min(f[j+1],s[b+i]);<br>        if j=lis then inc(lis);<br>    end;<br>end;</dn)or(s[b+i]></p>
<p>function _lis(n,b:int):int;<br>var i,j,len:int;<br>begin<br>    for i:=1 to n do f[i]:=inf;<br>    f[1]:=s[b+1];len:=1;<br>    for i:=2 to n do begin<br>        j:=bin(s[b+i],len);<br>        if j&gt;0 then f[j+1]:=min(f[j+1],s[b+i]);<br>        if j=len then inc(len);<br>    end;<br>    _lis:=j+1;<br>end;</p>
<p>function mul(var a,b:mat):mat;<br>var i,j,k:int;<br>begin<br>    fillchar(mul,sizeof(mul),224);<br>    for i:=1 to len do<br>        for j:=1 to len do<br>            for k:=1 to len do if min(a[i,k],b[k,j])&gt;=0 then<br>                mul[i,j]:=max(mul[i,j],a[i,k]+b[k,j]-1);<br>end;</p>
<p>function mpow(var a:mat;p:int64):mat;<br>var i:int;<br>begin<br>    fillchar(mpow,sizeof(mpow),224);<br>    for i:=1 to len do mpow[i,i]:=1;<br>    while p&gt;0 do begin<br>        if p and 1=1 then mpow:=mul(mpow,a);<br>        a:=mul(a,a);<br>        p:=p shr 1;<br>    end;<br>end;</p>
<p>begin<br>    assign(input,’lis.in’);reset(input);<br>    assign(output,’lis.out’);rewrite(output);<br>    read(n,s[1],a,b,c,d);k:=1;<br>    //找循环节<br>    while true do begin<br>        x:=(a<em>sqr(s[k])+b</em>s[k]+c)mod d;<br>        if loc[x]&gt;0 then break;<br>        inc(k);s[k]:=x;loc[x]:=k;<br>    end;<br>    til:=loc[x]-1;len:=k-loc[x]+1;<br>    rst:=(n-til)mod len;m:=(n-til)div len;<br>    if n&lt;=k then //不足一个周期特判<br>        begin write(lis(-1,d,n,0));halt end;<br>    if len=1 then //周期为1特判<br>        begin write(m+lis(-1,s[til+1],til,0));halt end;<br>    for i:=k+1 to k+len do s[i]:=s[i-len];<br>    //预处理<br>    for i:=1 to len do begin<br>        l[i]:=lis(-1,s[til+i],til,0);<br>        r[i]:=lis(s[til+i],d,rst,til);<br>    end;<br>    //矩阵快速幂<br>    //g[n,i,j]=max(g[n-1,i,j]+g[1,j,k]) a[i]&lt;=a[j]&lt;=a[k]<br>    for i:=1 to len do<br>        for j:=1 to len do<br>            if s[til+i]&gt;s[til+j] then g[i,j]:=-inf<br>            else g[i,j]:=_lis(len-i+j+1,til-1+i);<br>    g:=mpow(g,m-1);ans:=0;<br>    //统计答案<br>    for i:=1 to len do<br>        for j:=1 to len do<br>            ans:=max(ans,l[i]+r[j]+g[i,j]);<br>    write(ans);<br>    close(input);close(output);<br>end.</p>
<pre><code>
## 解法二
复杂度：$O(D^2logN)$
其实这题可以乱搞：
在n比较小时，可以直接暴力生成$O(NlogN)$求LIS
而当n足够大时，有如下解法：
为叙述方便，记$LIS(dn,up,seq)$为求在数列seq中$seq[i]\in[dn,up]$的LIS值
枚举一个循环节中的数T[i]，记$dt=l^2$
用<span>$LIS(-\infty,T[i],\{l+dt*T\})+(m-2*l)+LIS(T[i],+\infty,\{dt*T+r\})$</span><!-- Has MathJax -->
简单来说，就是求l并上$l^2$个T的lis、$l^2$个T并上r的lis，中间部分的lis=循环节数
正确性显然
细节：注意端点

&lt;div style=&quot;display:none;&quot; class=&quot;copy&quot;&gt;
    <a href="/2016/11/04/lydsy-noip-2016-test10/lis.pas" title="{plain text}">{plain text}</a>
&lt;/div&gt;
```delphi lis.pas
uses math;
type int=longint;ll=int64;
const inf=1000000;mx=100000;
var 
    loc:array[0..155] of int;
    seq,f:array[0..mx+10] of int;
    a,b,c,d,k,x,i:int;n:int64;

function bin(x,n:int):int;
var l,r,mid:int;
begin
    l:=0;r:=n;bin:=0;
    while l&lt;=r do begin
        mid:=(l+r) shr 1;
        if f[mid]&lt;=x then begin bin:=mid;l:=mid+1 end
        else r:=mid-1;
    end;
end;

function lis(dn,up,n,b:int):int;
var i,j:int;
begin
    for i:=1 to n do f[i]:=inf;
    f[0]:=0;lis:=0;
    for i:=1 to n do begin
        if (seq[b+i]&lt;dn)or(seq[b+i]&gt;up) then continue;
        j:=bin(seq[b+i],lis);
        f[j+1]:=min(f[j+1],seq[b+i]);
        if j=lis then inc(lis);
    end;
end;

procedure solv();
var b,r,l,i,dt:int;ans,m:int64;
begin
    b:=loc[x];l:=k-loc[x]+1;
    m:=(n-b+1)div l;r:=(n-b+1)mod l;
    dt:=l*l;
    for i:=k+1 to k+dt do seq[i]:=seq[i-l];
    ans:=0;
    for i:=b to k do
        ans:=max(ans,ll(lis(-1,seq[i],b-1+dt,0))+
            ll(lis(seq[i],d,r+dt,b-1))+m-2*l);
    write(ans);
end;

begin
    assign(input,&#39;lis.in&#39;);reset(input);
    assign(output,&#39;lis.out&#39;);rewrite(output);
    read(n,seq[1],a,b,c,d);
    if n&lt;=mx then begin
        for i:=2 to n do
            seq[i]:=(a*sqr(seq[i-1])+b*seq[i-1]+c) mod d;
        write(lis(-1,d,n,0));halt;
    end;
    loc[seq[1]]:=1;k:=1;
    while true do begin
        x:=(a*sqr(seq[k])+b*seq[k]+c) mod d;
        if loc[x]&lt;&gt;0 then break;
        inc(k);seq[k]:=x;loc[x]:=k;
    end;
    solv();
    close(input);close(output);
end.
</code></pre><h1 id="P2-bag"><a href="#P2-bag" class="headerlink" title="P2 bag"></a>P2 bag</h1><p>大意：给定n种物品，第i种体积为$v_i$，其中体积不小于l的物品总数不能超过c件，其他个数无限。有m次询问，第i次给定容量$w_i$的背包，问是否存在恰好装满的方案<br>$n\leq 50;m\leq 10^5;v_i,l\leq 10^4;$<br>$c\leq 30,w_i\leq 10^{18}$</p>
<h2 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h2><p>最短路处理dp<br>记最小的物品体积为v0，分类讨论</p>
<ul>
<li>$v0&gt;l$</li>
</ul>
<p>这种情况下体积有上限cV<br>于是直接dp：<br>f[i,j,k] 1..i种物品，大物品有j件，总体积为k的方案是否存在<br>转移：$f[i,j,k]=f[i-1,j,k]\ or\ f[i,j-1,k-v[i]]$<br>对于一个w，答案是f[n,0..c,w]<br>可以用bitset优化，但pascal没有所以不讨论</p>
<ul>
<li>$v0\leq l$</li>
</ul>
<p>如果存在体积为w的方案，那么一定存在体积为w+v0的方案<br>答案具有一定的单调性，也就是说可以表示为w=p*v0+k的方案可以归为一类<br>记s=f[i,j,k] 1..i种物品，大物品限制j件，当$s\% v0=k$时s的最小值<br>转移：<br>$v[i]&gt;v0$,$f[i,j,k]=min(f[i-1,j,k],f[i,j-1,(k-v[i])\% v0]+v[i])$<br>$v[i]\leq v0$,$f[i,j,k]=min(f[i-1,j,k],f[i,j,(k-v[i])\% v0]+v[i])$</p>
<p>第一种直接for循环即可<br>第二种的转移是存在环的，用节点建图，就规约为最短路的求解<br>记原点s，从s向f[i,j,k]连权为f[i-1,j,k]的边<br>从f[i,j,k]向f[i,j,(k+v[i])%v0]连权为v[i]的边<br>然后spfa</p>
<p>其实图是不用存的，转移时处理即可</p>
<p>bug</p>
<ol>
<li>记得检查输出格式，换行</li>
<li>状态f[i,j,k]的含义是 大物品件数=j时的解，最后要用前缀最小值f[n,0..j,k]</li>
<li>up和lim不可混用</li>
<li>数据范围！$w\leq 10^{18}$</li>
</ol>
<p><div style="display:none;" class="copy"><br>    <a href="/2016/11/04/lydsy-noip-2016-test10/bag.pas" title="{plain text}">{plain text}</a><br></div><br>```delphi bag.pas<br>uses math;<br>type int=longint;<br>var<br>    n,m,mn,mx,up,lim,i:int;<br>    v:array[0..55] of int;<br>    f:array[0..35,0..300010] of int64;</p>
<p>procedure solv1();<br>var<br>    f:array[0..35,0..300010] of boolean;<br>    i,j,k:int;w:int64;<br>begin<br>    fillchar(f,sizeof(f),false);<br>    f[0,0]:=true;mx:=mx*n;<br>    for i:=1 to n do<br>        for j:=1 to lim do<br>            for k:=v[i] to mx do<br>                f[j,k]:=f[j,k] or f[j-1,k-v[i]];<br>    for i:=1 to m do begin<br>        read(w);<br>        if (w&lt;=mx) and f[lim,w] then writeln(‘Yes’)<br>        else writeln(‘No’);<br>    end;<br>end;</p>
<p>procedure solv2();<br>var<br>    q:array[0..10010] of int;<br>    inq:array[0..10010] of boolean;<br>    i,j,k:int;w:int64;</p>
<pre><code>procedure spfa(x:int64);
var i,v,u,h,t:int;
begin
    h:=0;t:=mn;
    for i:=0 to mn-1 do q[i]:=i;
    fillchar(inq,sizeof(inq),true);
    while h&lt;&gt;t do begin
        u:=q[h];v:=(u+x)mod mn;
        if f[j,v]&gt;f[j,u]+x then begin
            f[j,v]:=f[j,u]+x;
            if not inq[v] then begin
                q[t]:=v;inq[v]:=true;
                inc(t);if t&gt;10010 then t:=0;
            end;
        end;
        inq[u]:=false;inc(h);if h&gt;10010 then h:=0;
    end;
end;
</code></pre><p>begin<br>    fillchar(f,sizeof(f),31);<br>    f[0,0]:=0;<br>    for i:=1 to n do begin<br>        if v[i]&gt;=up then for j:=1 to lim do for k:=0 to mn-1 do<br>            f[j,k]:=min(f[j,k],f[j-1,((k-v[i])mod mn+mn)mod mn]+v[i])<br>        else for j:=0 to lim do spfa(v[i]);<br>    end;<br>    for k:=0 to mn-1 do<br>        for j:=0 to lim-1 do f[lim,k]:=min(f[lim,k],f[j,k]);<br>    for i:=1 to m do begin<br>        read(w);<br>        if f[lim,w mod mn]&lt;=w then writeln(‘Yes’)<br>        else writeln(‘No’);<br>    end;<br>end;</p>
<p>begin<br>    assign(input,’bag_sample3.in’);reset(input);<br>    assign(output,’bag.out’);rewrite(output);<br>    read(n,m);mn:=maxlongint;<br>    for i:=1 to n do begin<br>        read(v[i]);mn:=min(mn,v[i]);mx:=max(mx,v[i])<br>    end;<br>    read(up,lim);<br>    if mn&gt;=up then solv1() else solv2();<br>    close(input);close(output);<br>end.</p>
<pre><code>
# P2 lca
大意：给定n个节点的树，点上有权值，开始所有点是白色的
共有m次操作，分为两种：
1. `Modify v` 把v改成黑色
2. `Query v` 求lca(v,一个黑色节点)的权值的最大值

$n\leq 10^5,m\leq 2*10^5$

## 题解
dfs序+线段树
考虑一个点u的权值对查询v的贡献，显然只有当v在u的子树中时才会产生贡献
于是对于每次修改u，遍历u到根的路径，对于路径上的每个点v，更新v的子树的答案，排除u所在的那颗子树
这样只要先求出dfs序，然后用线段树维护最大值即可
此外，如果一个点w之前被遍历过，那么其父节点p一定被以相同的方式处理过，因此更新完w后break即可

线段树注意点：
1. pushdown下移标记时不是简单赋值
2. 处理区间时，分清当前区间[b,e]和操作区间[l,r]，mid=(b+e) shr 1
3. 其实本题只有单点查值，没有pushdown的必要

&lt;div style=&quot;display:none;&quot; class=&quot;copy&quot;&gt;
    <a href="/2016/11/04/lydsy-noip-2016-test10/lca.pas" title="{plain text}">{plain text}</a>
&lt;/div&gt;
```delphi lca.pas
uses math;
type int=longint;edge=record v,nxt:int end;
var 
    g:array[0..200010] of edge;
    seg:array[0..400010] of int;
    w,l,r,head,par:array[0..100010] of int;
    flg:array[0..100010] of boolean;
    n,m,sz,i,k,u,v:int;s:string;

procedure add(u,v:int);
begin
    inc(sz);g[sz].v:=v;
    g[sz].nxt:=head[u];head[u]:=sz;
end;

procedure dfs(u:int);
var i,v:int;
begin
    inc(k);l[u]:=k;i:=head[u];
    while i&lt;&gt;0 do begin
        v:=g[i].v;
        if l[v]=0 then begin par[v]:=u;dfs(v) end;
        i:=g[i].nxt;
    end;
    r[u]:=k;
end;

procedure _modify(i,b,e,l,r,k:int);
var mid:int;
begin
    if (l&gt;r) or (e&lt;l) or (b&gt;r) then exit;
    if (l&lt;=b) and (e&lt;=r) then begin
        seg[i]:=max(seg[i],k);
        exit;
    end;
    mid:=(b+e) shr 1;
    _modify(i shl 1,b,mid,l,r,k);
    _modify(i shl 1 or 1,mid+1,e,l,r,k);
end;

function _query(i,b,e,x:int):int;
var mid:int;
begin
    if b=e then exit(seg[i]);
    mid:=(b+e) shr 1;
    if x&lt;=mid then _query:=max(seg[i],_query(i shl 1,b,mid,x))
    else _query:=max(seg[i],_query(i shl 1 or 1,mid+1,e,x));
end;

procedure modify(u:int);
var v:int;
begin
    _modify(1,1,n,l[u],r[u],w[u]);
    if flg[u] then exit;
    flg[u]:=true;v:=u;u:=par[u];
    while u&lt;&gt;0 do begin 
        _modify(1,1,n,l[u],l[v]-1,w[u]);
        _modify(1,1,n,r[v]+1,r[u],w[u]);
        if flg[u] then exit;
        flg[u]:=true;v:=u;u:=par[u];
    end;
end;

procedure query(u:int);
begin writeln(_query(1,1,n,l[u])) end;

begin
    assign(input,&#39;lca_sample2.in&#39;);reset(input);
    assign(output,&#39;lca.out&#39;);rewrite(output);
    readln(n,m);
    for i:=1 to n do read(w[i]);readln;
    for i:=1 to n-1 do begin
        readln(u,v);add(u,v);add(v,u);
    end;
    k:=0;dfs(1);
    fillchar(seg,sizeof(seg),255);
    for i:=1 to m do begin
        readln(s);
        case s[1] of
            &#39;Q&#39;:begin val(copy(s,7,length(s)-6),u,v);query(u)end;
            &#39;M&#39;:begin val(copy(s,8,length(s)-7),u,v);modify(u)end;
        end;
    end;
    close(input);close(output);
end.
</code></pre>]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[NOIP十连测 Day 7]]></title>
      <url>https://cothrax.github.io/2016/11/04/lydsy-noip-2016-test7/</url>
      <content type="html"><![CDATA[<blockquote>
<p>订正进度(2/3)</p>
</blockquote>
<h1 id="T1-约瑟夫游戏"><a href="#T1-约瑟夫游戏" class="headerlink" title="T1 约瑟夫游戏"></a>T1 约瑟夫游戏</h1><p>大意：定义约瑟夫游戏：个人围成一圈,从 1 号开始依次报数,当报到 m 时,报1、2、…、m-1 的人出局,下一个人接着从 1 开始报,保证(n-1)是(m-1)的倍数。最后剩的一个人获胜。<br>求获胜者的编号<br>$2\leq m \leq n\leq 2^{63}-2$</p>
<a id="more"></a>
<h2 id="水解"><a href="#水解" class="headerlink" title="水解"></a>水解</h2><p>记f[i]为i个人时的答案，递推：<br>$f[i]=f[i-(m-1)]\%(i-m+1)+m$<br>记$g[i]=f[1+i(m-1)]$<br>则$g[i+1]=f[1+(i+1)(m-1)]=f[1+i(m-1)]\%(1+i(m-1))+m$<br>$\therefore g[i+1]=g[i]\%(1+i(m-1))+m$</p>
<p>复杂度$O(n/m)$</p>
<p><div style="display:none;" class="copy"><br>    <a href="/2016/11/04/lydsy-noip-2016-test7/joseph.pas" title="{plain text}">{plain text}</a><br></div><br>```delphi joseph.pas<br>uses math;<br>type int=longint;<br>var<br>    n,m,k,i,j:int;<br>    f:array[0..1000000] of int;</p>
<p>begin<br>    assign(input,’joseph.in’);reset(input);<br>    assign(output,’joseph.out’);rewrite(output);<br>    read(n,m);<br>    k:=(n-1) div (m-1);<br>    f[0]:=1;<br>    for i:=0 to k-1 do<br>        f[i+1]:=f[i]mod(i*(m-1)+1)+m;<br>    write(f[k]);<br>end.</p>
<pre><code>
## 正解
基于递推的方法，打表观察：
发现：除了$i=m^a+m-1$外，所有的f[i]=km
找出这个规律后直接模拟即可

&lt;div style=&quot;display:none;&quot; class=&quot;copy&quot;&gt;
    <a href="/2016/11/04/lydsy-noip-2016-test7/joseph_tmp.pas" title="{plain text}">{plain text}</a>
&lt;/div&gt;
```delphi joseph_tmp.pas
uses math;
type int=longint;
var 
    n,m,k,i,j:int;
    f:array[0..1000000] of int;

begin
    read(n,m);
    assign(input,&#39;joseph.in&#39;);reset(input);
    assign(output,&#39;joseph.out&#39;);rewrite(output);
    i:=1;
    while i&lt;=n do k:=k*m;
    write((n-i div m) div (m-1)*m);
    close(input);close(output);
end.
</code></pre><h1 id="T2-密码游戏"><a href="#T2-密码游戏" class="headerlink" title="T2 密码游戏"></a>T2 密码游戏</h1><p>有两个0..m-1的全排列a和b，有n次操作x，每次的结果y=b[a[x]]，之后a排列向前循环一次，即a’[(i+1)%m]=a[i]，每操作m次之后b向前循环一次。<br>现在给定n次操作的x和y，求a和b的初值。如果有多解输出任意一组<br>$2\leq m\leq 26,m^2\leq n\leq 10^5$</p>
<h2 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h2><p>如果$y[i]=y[j]$<br>则$b[(a[(x[i]+i)\%m]+i/m)\%m]=b[(a[(x[j]+j)\%m]+j/m)\%m]$(*)</p>
<p>$(a[(x[i]+i)\%m]+i/m)\%m=a[(x[j]+j)\%m]+j/m)\%m$</p>
<p>$a[(x[i]+i)\%m]-a[(x[j]+j)\%m]\equiv j/m-i/m (\%m)$</p>
<p>这样就得到的若干形如$a[i]-a[j]\equiv k(\%m)$的形式<br>我们可以用带全并查集处理同余方程，然后设根节点为0，递推出所有的a[i]<br>然后在推出(*)推出b即可<br>注意点：由于题意是操作后移动，上述式子中的i代表的是第i+1次操作</p>
<p>题解告诉我们，有效方程个数的期望为$(n-m)(m-1)/m$<br>而$m^2\leq n$，则个数$\geq (m-1)^2\geq m-1$<br>所以可以得到m个节点间的关系（也就是最终合并到一颗树上）</p>
<blockquote>
<p>挖个坑：个数的期望不知道是怎么算的</p>
</blockquote>
<p>注：由于没有大样例，oj又不支持spj，下面的代码仅供参考<br>以及我的草稿</p>
<blockquote>
<p>y[i]=y[j]<br>b[(a[(x[i]+i)%m]+i/m)%m]=b[(a[(x[j]+j)%m]+j/m)%m]<br>a[(x[i]+i)%m]-a[(x[j]+j)%m]=j/m-i/m (%m)<br>=&gt;a[i]-a[j]=k (%m)<br>uf-set<br>a[i]-a[j]=k (i-&gt;j)=k<br>w[x-&gt;p[x]]=(x-p[x])%m<br>union(i,j,k)<br>a[0]=0<br>a[0]-p[a[0]]=w[0] =&gt; p[a[0]]=a[0]-w[0]<br>find<br>    w[par[x]]=par[x]-&gt;rt  w[x]=x-&gt;par[x]<br>    x-&gt;rt=w[x]+w[par[x]]=new w[x]<br>union<br>    x-&gt;y=k  w[x]=x-&gt;par[x]  w[y]=y-&gt;par[y]<br>    par[x]-&gt;par[y] = par[x]-&gt;x + x-&gt;y + y-&gt;par[y] =-w[x]+k+w[y]</p>
</blockquote>
<p><div style="display:none;" class="copy"><br>    <a href="/2016/11/04/lydsy-noip-2016-test7/password.pas" title="{plain text}">{plain text}</a><br></div><br>```delphi password.pas<br>type int=longint;node=record w,nxt:int end;<br>var<br>    n,m,sz,i,j,u,v:int;<br>    lnk:array[0..100010] of node;<br>    x,y:array[0..100010] of int;<br>    a,b,ptr,par,w:array[0..30] of int;</p>
<p>procedure insert(i,x:int);<br>begin<br>    inc(sz);lnk[sz].w:=x;<br>    lnk[sz].nxt:=ptr[i];ptr[i]:=sz;<br>end;</p>
<p>function find(x:int):int;<br>begin<br>    if par[x]=x then find:=x<br>    else begin<br>        find:=find(par[x]);<br>        inc(w[x],w[par[x]]);<br>        par[x]:=find;<br>    end;<br>end;</p>
<p>procedure union(x,y,k:int);<br>var px,py:int;<br>begin<br>    px:=find(x);py:=find(y);<br>    if px=py then exit;<br>    w[px]:=-w[x]+k+w[y];par[px]:=py;<br>end;</p>
<p>procedure dfs(x:int);<br>begin<br>    if par[x]=x then a[x]:=0<br>    else begin<br>        if a[par[x]]=-1 then dfs(par[x]);<br>        a[x]:=(a[par[x]]+w[x])mod m;<br>    end;<br>end;</p>
<p>begin<br>    assign(input,’password.in’);reset(input);<br>    assign(output,’password.out’);rewrite(output);<br>    read(n,m);<br>    for i:=0 to n-1 do read(x[i]);<br>    for i:=0 to n-1 do begin read(y[i]);insert(y[i],i) end;<br>    for i:=0 to m-1 do begin par[i]:=i;w[i]:=0 end;<br>    for j:=0 to m-1 do begin<br>        i:=ptr[j];u:=lnk[i].w;i:=lnk[i].nxt;<br>        while i&lt;&gt;0 do begin<br>            v:=lnk[i].w;<br>            union((x[u]+u)mod m,(x[v]+v)mod m,<br>                ((v div m-u div m)mod m+m)mod m);<br>            u:=v;i:=lnk[i].nxt;<br>        end;<br>    end;<br>    fillchar(a,sizeof(a),255);<br>    for i:=0 to m-1 do if a[i]=-1 then dfs(i);<br>    for i:=0 to n-1 do b[(a[(x[i]+i)mod m]+i div m)mod m]:=y[i];<br>    for i:=0 to m-1 do write(a[i],’ ‘);writeln;<br>    for i:=0 to m-1 do write(b[i],’ ‘);<br>    close(input);close(output);<br>end.<br>```</p>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[NOIP十连测 Day 8]]></title>
      <url>https://cothrax.github.io/2016/10/30/lydsy-noip-2016-test8/</url>
      <content type="html"><![CDATA[<blockquote>
<p>订正进度(3/3)</p>
</blockquote>
<h1 id="P1-神炎皇"><a href="#P1-神炎皇" class="headerlink" title="P1 神炎皇"></a>P1 神炎皇</h1><p>大意：给定n，求满足$a+b\leq n$且$(a+b)|ab$的有序对(a,b)的个数<br>$n\leq 10^{14}$</p>
<a id="more"></a>
<h2 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h2><p>坑爹数论<br>记$g=gcd(a,b),c=a/g,d=b/g$<br>则$(c+d)g|cdg^2$</p>
<blockquote>
<p>定理：若$gcd(c,d)=1$，则$(c+d)|cd$一定不成立</p>
</blockquote>
<p>先yy一下，c和d的约数都不是c+d的约数，那么c+d的质因子拆分中一定包含不是cd的约数的成分。<br>也可以反证：不妨设$k(c+d)=cd,k\in N*$<br>则$kc+kd=(c-k)d+kd$<br>那么$kc=(c-k)d$<br>因为$gcd(c,d)=1$<br>所以$c=c-k,k=d$无解，与假设矛盾</p>
<p>于是式子变成了$(c+d)|g$<br>令$k=c+d$，则$g=kp,p\in N*$，又$gk=k^2p\leq n$，那么$k\leq\sqrt{n}$<br>枚举k，则p有$n/k^2$个，下面要求(c,d)的对数</p>
<blockquote>
<p>根据辗转相减，$gcd(p,q)=gcd(p-q,q),p&gt;q$</p>
</blockquote>
<p>于是$gcd(c,d)=1$与$gcd(c+d,d)=(k,d)=1$一一对应，而(k,d)的对数就是$\varphi(k)$</p>
<p>于是，答案为$\sum_{k=2}^{\lfloor\sqrt{n}\rfloor} \varphi(k)*\lfloor n/k^2\rfloor$</p>
<p><div style="display:none;" class="copy"><br>    <a href="/2016/10/30/lydsy-noip-2016-test8/uria.pas" title="{plain text}">{plain text}</a><br></div><br>```delphi uria.pas<br>type int=longint;<br>var<br>    n,ans,i,sq:int64;<br>    phi,p:array[0..10000010] of int;<br>    f:array[0..10000100] of boolean;</p>
<p>procedure euler();<br>var i,j,t,k:int;<br>begin<br>    phi[1]:=1;k:=0;<br>    for i:=2 to sq do begin<br>        if not f[i] then begin<br>            inc(k);p[k]:=i;phi[i]:=i-1;<br>        end;<br>        j:=1;t:=p[j]<em>i;<br>        while t&lt;=sq do begin<br>            f[t]:=true;<br>            if i mod p[j]=0 then begin<br>                phi[t]:=p[j]</em>phi[i];break<br>            end else<br>                phi[t]:=(p[j]-1)<em>phi[i];<br>            inc(j);t:=p[j]</em>i;<br>        end;<br>    end;<br>end;</p>
<p>begin<br>    //assign(input,’uria.in’);reset(input);<br>    //assign(output,’uria.out’);rewrite(output);<br>    read(n);sq:=trunc(sqrt(n));<br>    foo();halt;<br>    euler();ans:=0;i:=2;<br>    while i&lt;=sq do begin<br>        inc(ans,phi[i]<em>trunc(n/(i</em>i)));<br>        inc(i);<br>    end;<br>    write(ans);<br>    close(input);close(output);<br>end.</p>
<pre><code>
# P2 降雷皇
大意：给定长度n的序列a，求最长单调不降子序列，以及其方案数
$n,a_i\leq 10^5$

## 题解
数据结构优化的dp
第一问显然lis，考虑$O(N^2)$的求法

记f[i]为以a[i]结尾的最长lis长度

<span>$f[i]=max_{i&lt;j,a[j]\leq a[i]}\{f[j]+1\}$</span><!-- Has MathJax -->
有另一种思路优化到$O(NlogN)$，但由于第二问的存在，我们考虑数据结构优化
可以用树状数组以a[i]为下标，维护f[i]的前缀最大值
那么转移时查询[1..a[i]]中的最大的f[j]即可

第二问：
记g[i]为f[i]的方案数

<span>$g[i]=\sum_{i&lt;j,a[i]&lt;=a[j],f[i]=f[j]+1}g[j]$</span><!-- Has MathJax -->

这个可以对每以个f[i]维护一颗线段树，以a[i]为下标，维护区间[l,r]内的$\sum g[i]$
类似主席树的写法

这样，复杂度为$O(NlogN)$
一个sb错误：Line53的查询参数为x-1

&lt;div style=&quot;display:none;&quot; class=&quot;copy&quot;&gt;
    <a href="/2016/10/30/lydsy-noip-2016-test8/hamon.pas" title="{plain text}">{plain text}</a>
&lt;/div&gt;
```delphi hamon.pas
uses math;
type int=longint;ll=int64;node=record lc,rc,w:int end;
const mx=100000;md=123456789;
var
    seg:array[0..mx*20] of node;
    bit,rt,f,g:array[0..mx+10] of int;
    n,sz,i,tp,x,ans,cnt:int;

procedure _add(x,k:int);
begin
    while x&lt;=mx do begin
        bit[x]:=max(bit[x],k);
        inc(x,x and (-x));
    end;
end;
function _query(x:int):int;
begin
    _query:=0;
    while x&gt;0 do begin
        _query:=max(_query,bit[x]);
        x:=x and (x-1);
    end;
end;

procedure add(var i:int;l,r,x,k:int);
var mid:int;
begin
    inc(sz);seg[sz]:=seg[i];i:=sz;
    seg[i].w:=(ll(seg[i].w)+ll(k))mod md;
    if l=r then exit;
    mid:=(l+r) shr 1;
    if x&lt;=mid then add(seg[i].lc,l,mid,x,k)
    else add(seg[i].rc,mid+1,r,x,k);
end;
function query(i,l,r,k:int):int;
var mid,lc,rc:int;
begin
    if l=r then exit(seg[i].w);
    mid:=(l+r) shr 1;
    lc:=seg[i].lc;rc:=seg[i].rc;
    if k&lt;=mid then query:=query(lc,l,mid,k)
    else query:=(ll(seg[lc].w)+ll(query(rc,mid+1,r,k)))mod md;
end;

begin
    assign(input,&#39;hamon.in&#39;);reset(input);
    assign(output,&#39;hamon.out&#39;);rewrite(output);
    read(n,tp);sz:=0;
    for i:=1 to n do begin
        read(x);
        f[i]:=_query(x-1);
        if f[i]=0 then g[i]:=1
        else g[i]:=query(rt[f[i]],1,n,x-1);
        inc(f[i]);add(rt[f[i]],1,n,x,g[i]);_add(x,f[i]);
    end;
    ans:=0;cnt:=0;
    for i:=1 to n do ans:=max(ans,f[i]);
    for i:=1 to n do
        if f[i]=ans then cnt:=(cnt+g[i])mod md;
    writeln(ans);if tp=1 then write(cnt);
    close(input);close(output);
end.
</code></pre><h1 id="P3-幻魔皇"><a href="#P3-幻魔皇" class="headerlink" title="P3 幻魔皇"></a>P3 幻魔皇</h1><p>定义斐波那契树：</p>
<ol>
<li>根为白色节点</li>
<li>白色节点有一个黑色子节点</li>
<li>黑色节点有一个黑色子节点和一个白色子节点</li>
</ol>
<p>给定树高n，对于$i\in [1,2n]$求距离为i的白色节点对数，答案对123456789取模<br>$n\leq 5000$</p>
<h2 id="80分题解"><a href="#80分题解" class="headerlink" title="80分题解"></a>80分题解</h2><p>我的思路：$O(N^3)$ DP<br>f[i,j] 高为i的子树到根距离为j的节点数<br>g[i,j] 高为i的子树中距离为j的节点对数</p>
<p>f[i,j]=f[i-1,j-1]+f[i-2,j-2]<br>特判新增的白色节点：f[i,1]+=1</p>
<p>统计到新增的白色节点的部分：g[i,j]=f[i-1,j-2]+f[i-2,j-1]<br>加上原来的：g[i,j]+=g[i-1,j]+g[i-2,j]<br>枚举左右子树i,j：g[i,j+k+3]+=f[i-1,j]*f[i-2,k]</p>
<p>递推n-2次，然后特判白色根节点：g[n-2,j]+=f[n-2,j-1]<br>答案是g[n-2,1..n*2]</p>
<p>复杂度的瓶颈在于枚举左右子树的部分，容易发现这一部分的计算实际上是多项式系数向量的卷积，于是可以用fft优化到$O(N^2logN)$，似乎会被卡常，而且这玩意不在noip范围</p>
<p><div style="display:none;" class="copy"><br>    <a href="/2016/10/30/lydsy-noip-2016-test8/raviel_80.pas" title="{plain text}">{plain text}</a><br></div><br>```delphi raviel_80.pas<br>type int=longint;ll=int64;<br>const<br>    md=123456789;mx=5000;<br>    nxt:array[0..2] of int=(1,2,0);<br>var<br>    f,g:array[0..2,-2..mx*2+10] of int;<br>    n,i,j,k,i0,i1,i2:int;</p>
<p>begin<br>    assign(input,’raviel.in’);reset(input);<br>    assign(output,’raviel.ans’);rewrite(output);<br>    read(n);<br>    i0:=2;i1:=1;i2:=0;<br>    for i:=1 to n-2 do begin<br>        i0:=nxt[i0];i1:=nxt[i1];i2:=nxt[i2];<br>        for j:=1 to i do f[i0,j]:=0;<br>        //calc f[i0]<br>        for j:=1 to i do<br>            f[i0,j]:=(f[i1,j-1]+f[i2,j-2])mod md;<br>        f[i0,1]:=(f[i0,1]+1)mod md;<br>        //calc g[i0]<br>        for j:=1 to i<em>2 do<br>            g[i0,j]:=(f[i1,j-2]+f[i2,j-1]+g[i1,j]+g[i2,j])mod md;<br>        for j:=1 to i</em>2 do<br>            for k:=1 to i<em>2-j do<br>                g[i0,j+k+3]:=(ll(g[i0,j+k+3])+<br>                    ll(f[i1,j])</em>ll(f[i2,k]))mod md;<br>    end;<br>    for j:=1 to 2<em>n do g[i0,j]:=(g[i0,j]+f[i0,j-1])mod md;<br>    for i:=1 to 2</em>n do write(g[i0,i],’ ‘);<br>    close(input);close(output);<br>end.</p>
<pre><code>
## 100分题解
标算：$O(N^2)$
考虑到其实每一棵黑色根节点的树都是同构的，不单独考虑树高直接枚举距离
可以发现：到黑色节点距离i的白色节点数是斐波那契数f[i]，记$s[i]=\sum_{i=1}^n f[i]$
而深度i的子树中的白色节点数为f[i-2]+1（特判根节点），黑色节点数为f[i-1]
分两种情况：记u,v为白色节点对
1. lca(u,v)=u或v，那么可以算出lca的范围中的白色节点数s[n-2-i]，对于每个lca，距离为d的节点数为f[j-1]
2. lca(u,v)=一黑色节点，$O(N^2)$枚举u和v到lca的距离，类似1处理即可

&lt;div style=&quot;display:none;&quot; class=&quot;copy&quot;&gt;
    <a href="/2016/10/30/lydsy-noip-2016-test8/raviel.pas" title="{plain text}">{plain text}</a>
&lt;/div&gt;
```delphi raviel.pas
uses math;
type int=longint;ll=int64;
const md=123456789;mx=5000;
var
    f,s,g:array[-1..mx*2+10] of int;
    n,i,j:int;

begin
    assign(input,&#39;raviel.in&#39;);reset(input);
    assign(output,&#39;raviel.out&#39;);rewrite(output);
    read(n);f[1]:=1;s[0]:=0;
    for i:=2 to n do f[i]:=(f[i-1]+f[i-2]) mod md;
    for i:=1 to n do s[i]:=(s[i-1]+f[i]) mod md;
    for i:=1 to n-1 do g[i]:=ll(s[n-2-i]+1)*ll(f[i-1]) mod md;
    f[-1]:=1; //便于特判根节点
    for i:=1 to n-1 do
        for j:=1 to n-1 do
            g[i+j]:=(ll(g[i+j])+(ll(f[i-2])*ll(f[j-1])mod md)*
                ll(s[n-1-max(i,j)]))mod md;
    for i:=1 to n*2 do write(g[i],&#39; &#39;);
    close(input);close(output);
end.
</code></pre>]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[笔记 欧拉函数]]></title>
      <url>https://cothrax.github.io/2016/10/30/note-euler-function/</url>
      <content type="html"><![CDATA[<p>noip前复习数论，怎么感觉是在预习Q(AQ)*</p>
<h1 id="欧拉函数的性质"><a href="#欧拉函数的性质" class="headerlink" title="欧拉函数的性质"></a>欧拉函数的性质</h1><ol>
<li>$p$为素数，$\varphi(p)=p-1$</li>
<li>欧拉定理：若$gcd(a,n)=1$，则$a^{\varphi(n)}\equiv 1(mod\ n)$<br>注：这玩意可以用来证明费马小定理</li>
<li>$p$为素数，$\varphi(p^k)=p^k-p^{k-1}$</li>
<li>若$gcd(p,q)=1$，则$\varphi(pq)=\varphi(p)\varphi(q)$</li>
<li>任意$n\in N*$，$\varphi(n)=\varphi(\prod_i p_i^k)=\prod_i p^{k-1}(p_i-1)=n\prod_i(1-1/p_i)$</li>
<li>对于$n&gt;2$，$2|\varphi(n)$</li>
<li>若$n\ mod\ p=0$，则$\varphi(np)=p\cdot \varphi(n)$</li>
</ol>
<a id="more"></a>
<p>证明可以看：<a href="/2016/10/30/note-euler-function/eluer-funtion.doc" title="欧拉函数及其证明">欧拉函数及其证明</a></p>
<h1 id="求单个-varphi-n"><a href="#求单个-varphi-n" class="headerlink" title="求单个$\varphi(n)$"></a>求单个$\varphi(n)$</h1><p>根据性质5，质因数分解然后暴力即可，复杂度$O(\sqrt{N})$</p>
<pre><code class="pascal">function phi(n:int):int;
var i:int;
begin
    phi:=n;
    for i:=2 to ceil(sqrt(n)) do
        if n mod i=0 then begin
            phi:=phi div i*(i-1);
            while n mod i=0 do n:=n div i;
        end;
    if n&gt;1 then phi:=phi div n*(n-1);
end;
</code></pre>
<h1 id="线性筛-varphi-n"><a href="#线性筛-varphi-n" class="headerlink" title="线性筛$\varphi(n)$"></a>线性筛$\varphi(n)$</h1><p>由性质4和7得到，若p为素数，则<br><img src="/2016/10/30/note-euler-function/7350.gif" alt="7350.gif" title=""><br>就是在筛素数时顺便求欧拉函数，线性筛与普通筛的区别：<br>例如，对于合数6会在i=2和i=3被筛两次，而线性筛只会筛i=2一次<br>关键就在line16的那个break<br>当$p[j]|i$时，下一个要被筛的合数$p[j+1]\cdot i$能被表示为$(p[j+1]\cdot i’)\cdot p[j]$，因此它可以被更小的素数$p[j]$筛出，即当循环到合数$p[j+1]\cdot i’$时，再去筛它也不迟<br>这样每个数只会被筛一次，因此复杂度$O(N)$</p>
<pre><code class="pascal">procedure euler(n:int);
var 
    i,j,k:int;
    f:array[0..1010] of boolean; //素数标记
    p:array[0..1010] of int; //素数表，规模为k
begin
    fillchar(f,sizeof(f),false);
    phi[1]:=1;k:=0;
    for i:=2 to n do begin
        if not f[i] then 
            begin inc(k);p[k]:=i;phi[i]:=i-1 end;
        j:=1;
        while i*p[j]&lt;=n do begin
            f[i*p[j]]:=true;
            if i mod p[j]=0 then begin
                phi[i*p[j]]:=phi[i]*p[j];break
            end else
                phi[i*p[j]]:=phi[i]*(p[j]-1);
            inc(j);
        end;
    end;
end;
</code></pre>
<p>一坨pascal代码：<a href="/2016/10/30/note-euler-function/1030.pas" title="1030.pas">1030.pas</a></p>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[NOIP2016十连测 Day 9]]></title>
      <url>https://cothrax.github.io/2016/10/28/lydsy-noip-2016-test9/</url>
      <content type="html"><![CDATA[<p>2016-10-28<br>已经挖了好多坑了。。<delete>大flag：noip前填完</delete><br><strong>P3由于过于noip拒绝订正</strong></p>
<blockquote>
<p>订正进度(2/3)</p>
</blockquote>
<h1 id="P1-小P的2048"><a href="#P1-小P的2048" class="headerlink" title="P1 小P的2048"></a>P1 小P的2048</h1><p>大意：2048都玩过吧。。。给定棋盘和操作序列，求得分和有效操作数<br>因为是蛋疼模拟，各种细节就不写了。<br><a id="more"></a></p>
<h2 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h2><p>都说了是模拟<br>不知怎么丢了10分，算了不想改了。。</p>
<p><div style="display:none;" class="copy"><br>    <a href="/2016/10/28/lydsy-noip-2016-test9/game.pas" title="{plain text}">{plain text}</a><br></div><br>```delphi game.pas<br>{90pts}<br>uses math;<br>type int=longint;<br>var<br>    n,m,d,i,j,k,v,r,amt:int;ans:int64;b:boolean;<br>    a:array[0..10,0..10] of int;</p>
<p>function mv(x,y,dx,dy:int):boolean;<br>var lx,ly:int;flg:boolean;<br>begin<br>    lx:=x-dx;ly:=y-dy;mv:=false;flg:=true;<br>    while (min(x,y)&gt;0)and(max(x,y)&lt;=n) do begin<br>        if a[x,y]&gt;0 then begin<br>            if flg and (a[x,y]=a[lx,ly]) then begin<br>                a[lx,ly]:=a[lx,ly]*2;inc(ans,a[lx,ly]);<br>                a[x,y]:=0;<br>                inc(r);mv:=true;flg:=false;<br>            end else begin<br>                inc(lx,dx);inc(ly,dy);<br>                a[lx,ly]:=a[x,y];flg:=true;<br>                if (lx&lt;&gt;x)or(ly&lt;&gt;y) then begin<br>                    a[x,y]:=0;mv:=true;<br>                end;<br>            end;<br>        end;<br>        inc(x,dx);inc(y,dy);<br>    end;<br>    b:=b or mv;<br>end;</p>
<p>procedure add(k,v:int);<br>var i,j,cnt:int;<br>begin<br>    cnt:=0;dec(r);<br>    for i:=1 to n do<br>        for j:=1 to n do<br>            if a[i,j]=0 then begin<br>                inc(cnt);<br>                if cnt=k then begin a[i,j]:=v;exit end;<br>            end;<br>end;</p>
<p>begin<br>    assign(input,’game.in’);reset(input);<br>    assign(output,’game.out’);rewrite(output);<br>    read(n,m);r:=n*n-2;ans:=0;amt:=m;<br>    read(i,j,k);a[i,j]:=k;<br>    read(i,j,k);a[i,j]:=k;<br>    for i:=1 to m do begin<br>        read(d,k,v);b:=false;<br>        case d of<br>            0:for j:=1 to n do mv(1,j,1,0);<br>            1:for j:=1 to n do mv(n,j,-1,0);<br>            2:for j:=1 to n do mv(j,1,0,1);<br>            3:for j:=1 to n do mv(j,n,0,-1);<br>        end;<br>        if (r=0) or not b then begin amt:=i-1;break end;<br>        k:=1+k mod r;add(k,v);<br>    end;<br>    writeln(amt);write(ans);<br>    close(input);close(output);<br>end.</p>
<pre><code>
# P2 小P的单调数列
定义一个单调数列的价值：所有数的总和
定义一个数列的价值：划分为若干极长单调区间后，这些区间价值的平均值，第一个区间必须单调增
注：极长单调区间即保证相邻两个区间单调性不同
给定长为n的数列$a_i$，求其价值最大的子序列


## 40分解法
即对于$a_i$的若干单调子序列和的平均值，求最大值
显然想到dp
记f[i,j] 为a[1..i]中划分j个单调区间的答案
1. $j\%2=1$
   1. $a[k]&lt;a[j],f[i,j]=max(f[k,j],f[k,j-1])+a[i]$
   2. $a[k]&gt;a[j],f[i,j]=max(f[k,j-1])+a[i]$
2. $j\%2=0$ 类似

答案为$max(f[i,j]/j)$
初始：$f[0,0]=0,f[i,j]=+\infty$
复杂度：$O(N^3)$

&lt;div style=&quot;display:none;&quot; class=&quot;copy&quot;&gt;
    <a href="/2016/10/28/lydsy-noip-2016-test9/seq.pas" title="{plain text}">{plain text}</a>
&lt;/div&gt;
```delphi seq.pas
uses math;
type int=longint;
var
    f:array[0..210,0..210] of int64;
    a:array[0..210] of int64;
    n,i,j,k:int;ans:double;

begin
    assign(input,&#39;seq.in&#39;);reset(input);
    assign(output,&#39;seq.ans&#39;);rewrite(output);
    read(n);
    for i:=1 to n do read(a[i]);
    fillchar(f,sizeof(f),192);
    f[0,0]:=0;ans:=0;a[0]:=maxlongint;
    for i:=1 to n do
    for j:=1 to n do
    for k:=i-1 downto 0 do
        if ((a[k]&gt;a[i])xor(j and 1=1)) and (a[k]&lt;&gt;a[i]) then
            f[i,j]:=max(f[i,j],max(f[k,j],f[k,j-1])+a[i])
        else f[i,j]:=max(f[i,j],f[k,j-1]+a[i]);
    for i:=1 to n do
        for j:=1 to n do
            ans:=max(ans,f[i,j]/j);
    write(ans:0:3);
    close(input);close(output);
end.
</code></pre><h2 id="100分解法"><a href="#100分解法" class="headerlink" title="100分解法"></a>100分解法</h2><p>结论是：最优解的单调区间数一定$\leq 2$<br>因为是平均值，如果区间数$\geq 3$，根据比例的性质，去掉其中和最小的那个区间，能得到更优解<br>这么说只有一个区间是更优的，但由于题目要求第一个区间是单调增的，所以会存在两个区间的情况<br>这样对于每个数，求左边的lis和右边的lds，然后枚举分界点找最大值即可<br>然后还要考虑一个单调增区间的情况，即拿整个数列的lis更新答案<br>至于dp可以用树状数组优化，详见<a href="/2016/10/30/lydsy-noip-2016-test8/" title="Test8的P2">Test8的P2</a><br>复杂度$O(NlogN)$</p>
<p><div style="display:none;" class="copy"><br>    <a href="/2016/10/28/lydsy-noip-2016-test9/seq_.pas" title="{plain text}">{plain text}</a><br></div><br>```delphi seq_.pas<br>uses math;<br>type int=longint;<br>var<br>    n,m,i:int;ans:double;<br>    a:array[0..100010,0..1] of int;<br>    b,l:array[0..100010] of int;<br>    bit,lis,lds:array[0..100010] of int64;</p>
<p>procedure qsort(l,r:int);<br>var i,j,x:int;tmp:array[0..1] of int;<br>begin<br>    i:=l;j:=r;x:=a[random(r-l)+l,0];<br>    repeat<br>        while a[i,0]<x do="" inc(i);="" while="" a[j,0]="">x do dec(j);<br>        if i&lt;=j then begin<br>            tmp:=a[i];a[i]:=a[j];a[j]:=tmp;<br>            inc(i);dec(j);<br>        end;<br>    until i&gt;j;<br>    if l&lt;j then qsort(l,j);<br>    if i&lt;r then qsort(i,r);<br>end;</x></p>
<p>function query(x:int):int64;<br>begin<br>    query:=0;<br>    while x&gt;0 do begin<br>        query:=max(query,bit[x]);<br>        x:=x and (x-1);<br>    end;<br>end;</p>
<p>procedure add(x:int;k:int64);<br>begin<br>    while x&lt;=n do begin<br>        bit[x]:=max(bit[x],k);<br>        inc(x,x and (-x));<br>    end;<br>end;</p>
<p>begin<br>    assign(input,’seq.in’);reset(input);<br>    assign(output,’seq.out’);rewrite(output);<br>    read(n);<br>    for i:=1 to n do read(a[i,0]);<br>    for i:=1 to n do a[i,1]:=i;<br>    qsort(1,n);m:=0;l[m]:=0;<br>    for i:=1 to n do begin<br>        if a[i,0]&gt;l[m] then begin inc(m);l[m]:=a[i,0] end;<br>        b[a[i,1]]:=m;<br>    end;<br>    //f[i]=max(f[j])+a[i] i&lt;j&amp;&amp;a[i]&lt;=a[j] max(1..a[j]) of f[]<br>    for i:=1 to n do begin<br>        lis[i]:=query(b[i]-1)+l[b[i]];<br>        add(b[i],lis[i]);<br>    end;<br>    fillchar(bit,sizeof(bit),0);<br>    for i:=n downto 1 do begin<br>        lds[i]:=query(b[i]-1)+l[b[i]];<br>        add(b[i],lds[i]);<br>    end;<br>    for i:=2 to n do lis[i]:=max(lis[i],lis[i-1]);<br>    for i:=n-1 downto 1 do lds[i]:=max(lds[i],lds[i+1]);<br>    ans:=lis[n];<br>    for i:=1 to n-1 do ans:=max(ans,(lis[i]+lds[i+1])/2);<br>    write(ans:0:3);<br>    close(input);close(output);<br>end.<br>```</p>
<h1 id="P3-小P的生成树"><a href="#P3-小P的生成树" class="headerlink" title="P3 小P的生成树"></a>P3 小P的生成树</h1><p>给定n个节点，m条边的连通的带权无向简单图，边权为向量，求一个生成树，使得树上的边权向量和的模最大。<br>$n\leq 50, m\leq 200$</p>
<h2 id="注"><a href="#注" class="headerlink" title="注"></a>注</h2><blockquote>
<p>涉及计算几何内容，暂不订正</p>
</blockquote>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[NOIP2016十连测 Day 5]]></title>
      <url>https://cothrax.github.io/2016/10/28/lydsy-noip-2016-test5/</url>
      <content type="html"><![CDATA[<p>跪</p>
<blockquote>
<p>订正进度(2/3)</p>
</blockquote>
<h1 id="P1-Simple"><a href="#P1-Simple" class="headerlink" title="P1 Simple"></a>P1 Simple</h1><p>给定$n,m,q\in N*$，求$[1,q]内，$$\not\exists x,y\in N,c=nx+my$的c的个数<br>共T组询问<br>$n≤10^5,m≤10^9,q≤10^{18},T≤10$</p>
<a id="more"></a>
<h2 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h2><p>从反面入手，求可以表示成$nx+my,n,m\in N$的c的个数<br>根据裴蜀定理，$c=nx+my$有解当且仅当$gcd(n,m)|c$<br>记$g=gcd(n,m)$<br>这样解的范围被缩小到$[1,n/g]$，$n=n/g,m=m/g$，此时n和m互质<br>然后根据数论知识，不能被表示成$nx+my,n,m\in N*$的最大整数为$nm-n-m$</p>
<p>那么考虑$[1,nm]$的数，其中能表示为$ym-xn,y\in[0,n-1]$的数一定满足题意：<br>由扩展欧几里得可知，已知$ym+(-x)n=c$的一组解$(-x,y)$，那么它的所有解为$(-x+t\cdot m,y-t\cdot n)$，其中必定有一个是负数<br>这样枚举[0,n-1]统计即可。</p>
<p><div style="display:none;" class="copy"><br>    <a href="/2016/10/28/lydsy-noip-2016-test5/simple.pas" title="{plain text}">{plain text}</a><br></div><br>```delphi simple.pas<br>uses math;<br>type int=longint;<br>var n,m,q,g,l,r,ans:int64;i,j,t:int;<br>function gcd(a,b:int64):int64;<br>begin if b=0 then gcd:=a else gcd:=gcd(b,a mod b) end;<br>function cldv(n,m:int64):int64;<br>begin<br>    cldv:=n div m;<br>    if n mod m&lt;&gt;0 then inc(cldv);<br>end;</p>
<p>begin<br>    //assign(input,’simple.in’);reset(input);<br>    //assign(output,’simple.out’);rewrite(output);<br>    read(t);<br>    repeat<br>        read(n,m,q);g:=gcd(n,m);<br>        ans:=q;q:=q div g;dec(ans,q);<br>        n:=n div g;m:=m div g;<br>        for i:=0 to n-1 do begin<br>            l:=max(1,cldv(i<em>m-q,n));<br>            r:=trunc((i</em>m-1)/n);<br>            inc(ans,max(r-l+1,0));<br>        end;<br>        writeln(ans);<br>        dec(t);<br>    until t=0;<br>    close(input);close(output);<br>end.</p>
<pre><code>
# P2 Walk
大意：给定n个节点的树，边长为1，边权为w，定义一条路径的权值为路径上所有边权的最大公约数，对于任意$i\in[1,n]$,求树上所有长度为i的简单路径中权值最大的是多少。

## 题解
大暴力，枚举答案，每次都重新构图，跑树（森林）上最长链
一点总结：
1. 关于gcd的处理：枚举gcd，那么权为gcd倍数的边都是合法的
2. 关于复杂度的分析：每条边e(u,v)=w只有在枚举值为w的约数时才会被遍历，理论复杂度为$O(N\sqrt{N})$
3. 关于常数
  - 用链表维护边集，将边权相等的边串起来
  - 用栈维护点集，在加边时将端点入栈
  - 清空临时的边集数组时，由于只有在栈内的点的head值被修改，遍历栈中的点即可
  - 标记数组：当前为第idx次遍历，用flag[u]=idx表示u以被访问，避免每次清空数组
4. 关于树上最长链：之前在学树形dp时用过一种比较复杂的方法，记录一个点的最长链、次长链、链经过的子节点，两次dp得到；更简单的方法见代码
5. 关于一些sb错误
  - 栈要开2*n
  - 混淆栈中元素和栈下标

&lt;div style=&quot;display:none;&quot; class=&quot;copy&quot;&gt;
    <a href="/2016/10/28/lydsy-noip-2016-test5/walk.pas" title="{plain text}">{plain text}</a>
&lt;/div&gt;
```delphi walk.pas
uses math;
type 
    int=longint;
    edge=record v,next:int end;
    e1=record u,v,next:int end;
var 
    g:array[0..800010] of edge;
    e:array[0..400010] of e1;
    head,flag,ans:array[0..400010] of int;
    stk:array[0..800010] of int;
    ptr:array[0..1000010] of int;
    sz,k,mx,n,i,j,l,u,v,w,idx,len,t:int;

procedure add(u,v:int);
begin
    inc(sz);g[sz].v:=v;
    g[sz].next:=head[u];head[u]:=sz;
end;
procedure _add(u,v,w:int);
begin
    inc(k);e[k].u:=u;e[k].v:=v;
    e[k].next:=ptr[w];ptr[w]:=k;
end;

function dfs(u:int):int;
var v,i,tmp:int;
begin
    flag[u]:=idx;i:=head[u];dfs:=0;
    while i&lt;&gt;0 do begin
        v:=g[i].v;
        if flag[v]&lt;idx then begin
            tmp:=dfs(v);
            len:=max(len,dfs+tmp+1);
            dfs:=max(dfs,tmp+1);
        end;
        i:=g[i].next;
    end;
end;

begin
    assign(input,&#39;ex_walk3.in&#39;);reset(input);
    assign(output,&#39;walk.out&#39;);rewrite(output);
    read(n);k:=0;mx:=0;
    for i:=1 to n-1 do begin
        read(u,v,w);_add(u,v,w);mx:=max(mx,w);
    end;
    idx:=0;len:=0;
    for i:=1 to mx do begin
        sz:=0;inc(idx);l:=i;t:=0;
        while l&lt;=mx do begin
            j:=ptr[l];inc(l,i);
            while j&lt;&gt;0 do begin
                add(e[j].u,e[j].v);add(e[j].v,e[j].u);
                inc(t,2);stk[t-1]:=e[j].u;stk[t]:=e[j].v;
                j:=e[j].next;
            end;
        end;
        len:=0;
        for j:=1 to t do if flag[stk[j]]&lt;idx then dfs(stk[j]);
        for j:=1 to t do head[stk[j]]:=0;
        ans[len]:=i;
    end;
    for i:=n-1 downto 1 do
        ans[i]:=max(ans[i],ans[i+1]);
    for i:=1 to n do writeln(ans[i]);
    close(input);close(output);
end.
</code></pre><h1 id="P3-Travel"><a href="#P3-Travel" class="headerlink" title="P3 Travel"></a>P3 Travel</h1><blockquote>
<p>挖个坑</p>
</blockquote>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[NOIP模拟赛 游戏]]></title>
      <url>https://cothrax.github.io/2016/10/16/noip-2009-11-1-2-game/</url>
      <content type="html"><![CDATA[<h2 id="描述"><a href="#描述" class="headerlink" title="描述"></a>描述</h2><p>windy学会了一种游戏。<br>对于1到N这N个数字，都有唯一且不同的1到N的数字与之对应。<br>最开始windy把数字按顺序1，2，3，……，N写一排在纸上。<br>然后再在这一排下面写上它们对应的数字。<br>然后又在新的一排下面写上它们对应的数字。<br>如此反复，直到序列再次变为1，2，3，……，N。<br><a id="more"></a><br>如：<br>1 2 3 4 5 6<br>对应的关系为<br>1-&gt;2 2-&gt;3 3-&gt;1 4-&gt;5 5-&gt;4 6-&gt;6<br>windy的操作如下<br>1 2 3 4 5 6<br>2 3 1 5 4 6<br>3 1 2 4 5 6<br>1 2 3 5 4 6<br>2 3 1 4 5 6<br>3 1 2 5 4 6<br>1 2 3 4 5 6<br>这时，我们就有若干排1到N的排列，上例中有7排。<br>现在windy想知道，对于所有可能的对应关系，有多少种可能的排数。 </p>
<h2 id="格式"><a href="#格式" class="headerlink" title="格式"></a>格式</h2><h3 id="输入格式"><a href="#输入格式" class="headerlink" title="输入格式"></a>输入格式</h3><p>输入文件game.in包含一个整数，N。</p>
<h3 id="输出格式"><a href="#输出格式" class="headerlink" title="输出格式"></a>输出格式</h3><p>输出文件game.out包含一个整数，可能的排数。</p>
<h2 id="样例"><a href="#样例" class="headerlink" title="样例"></a>样例</h2><h3 id="样例输入"><a href="#样例输入" class="headerlink" title="样例输入"></a>样例输入</h3><blockquote>
<p>3</p>
</blockquote>
<h3 id="样例输出"><a href="#样例输出" class="headerlink" title="样例输出"></a>样例输出</h3><blockquote>
<p>3</p>
</blockquote>
<h2 id="提示​"><a href="#提示​" class="headerlink" title="提示​"></a>提示​</h2><p>30%的数据，满足 1 &lt;= N &lt;= 10 。<br>100%的数据，满足 1 &lt;= N &lt;= 1000 。 </p>
<h2 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h2><p>规约为：<span>$n\geq\sum_ia_i$</span><!-- Has MathJax -->，求不同的<span>$lcm\{a_i\}$</span><!-- Has MathJax -->的个数<br>先筛素数，然后dp<br>f[i,j]为1..i个素数，和为j的方案数</p>
<p><div style="display:none;" class="copy"><br>    <a href="/2016/10/16/noip-2009-11-1-2-game/game.pas" title="{plain text}">{plain text}</a><br></div><br>```delphi game.pas<br>type int=longint;<br>var<br>    p:array[0..1010] of boolean;<br>    a:array[0..1010] of int;<br>    f:array[0..1010] of int64;<br>    n,m,i,j,k:int;ans:int64;</p>
<p>begin<br>    assign(input,’game.in’);reset(input);<br>    assign(output,’game.out’);rewrite(output);<br>    read(n);m:=0;<br>    for i:=2 to n do<br>        if not p[i] then begin<br>            inc(m);a[m]:=i;<br>            j:=i<em>2;<br>            while j&lt;=n do begin<br>                p[j]:=true;inc(j,i);<br>            end;<br>        end;<br>    f[0]:=1;<br>    //j-k</em>a[i]&gt;=0 -&gt; k&lt;=j/a[i]<br>    for i:=1 to m do<br>        for j:=n downto 1 do begin<br>            k:=a[i];<br>            while k&lt;=j do begin<br>                inc(f[j],f[j-k]);k:=k*a[i];<br>            end;<br>        end;<br>    ans:=0;<br>    for i:=0 to n do inc(ans,f[i]);<br>    write(ans);<br>    close(input);close(output);<br>end.<br>```</p>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[NOIP2016十连测 Day 6]]></title>
      <url>https://cothrax.github.io/2016/10/16/lydsy-noip-2016-test6/</url>
      <content type="html"><![CDATA[<p>又一场NOIplus模拟赛。<br>第一题同样是暴力，pascal被卡常<br>第三题yy了scc+dfs，忘记判无解的情况，又是捆绑测试，然后爆0</p>
<blockquote>
<p>订正进度(2/3)</p>
</blockquote>
<h1 id="P1-幻想"><a href="#P1-幻想" class="headerlink" title="P1 幻想"></a>P1 幻想</h1><p>大意：（其实是描述的片段）<br>给定一个不小于 2 的整数 k ,按照如下方式生成一个无限长的序列S (下标从 0 开始)。<br>1.初始时序列只有一个元素 S(0) = 0 。<br>2.对于j=1,2,…,k-1分别把当前序列的每个元素都加上j,得到新的k-1个序列。<br>3.把新的k-1个序列依次接在当前序列后面,得到一个长度为当前序列长度 k 倍的序列。<br>4.把这个序列每一项都变成其除以 k 之后的余数,并把这个序列作为新的当前序列。<br>5.执行无穷次操作 2-4。<br>给定l,r，求$\sum_{i=L}^{R}h(i)\times S_i$<br>其中$h(i)=\lfloor\dfrac{(i\% 20000116)^2+i+804}{233}\rfloor$<br>答案对$2^{32}$取模<br>$T≤100 ; 2≤k≤1000 ; 0≤L≤R≤10^16;\sum(R-L)≤10^8$<br>时限2s</p>
<a id="more"></a>
<h2 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h2><p>观察发现S(i)就是i在k进制下，数位和mod k的值，r-l又不是很大，暴力求<br>pascal被卡常<br>附我的草稿</p>
<blockquote>
<p>123 456 789 012 345 678 901 234 567<br>012 120 201 120 201 012 201 012 120</p>
<p>f(i) i mod 3=1=d -&gt; init=d-1<br>bl=ceil(i/k) -&gt; 9 –&gt;<br>ceil(i/k^2)) -&gt; 3 –&gt;<br>ceil(i/k^3)) -&gt; 1 –&gt; 0</p>
<p>19=2*3^2+1*3^0 -&gt; (2+1 -1)%3<br>16=1*3^2+2*3^1+1*3^0 (1+2+1 -1)%3=1<br>O((r-l)*log_k(n)*(k-1))</p>
<p>l-&gt;r ??<br>∑i*3^k -&gt; ∑i*3^k+1 ??</p>
</blockquote>
<p><div style="display:none;" class="copy"><br>    <a href="/2016/10/16/lydsy-noip-2016-test6/fantasy.pas" title="{plain text}">{plain text}</a><br></div><br>```delphi fantasy.pas<br>{$R-}<br>uses math;<br>type int=longint;qw=qword;dw=dword;<br>const z0:qw=20000116;<br>var<br>    T,i:int;l,r,x:qw;ans,k,cnt:dw;<br>    nxt:array[0..1100] of dw;<br>    f:array[0..60] of dw;</p>
<p>begin<br>    //assign(input,’fantasy.in’);reset(input);<br>    //assign(output,’fantasy.out’);rewrite(output);<br>    read(T);<br>    repeat<br>        read(k,l,r);<br>        fillchar(f,sizeof(f),0);<br>        x:=l;i:=0;cnt:=0;<br>        while x&gt;0 do begin<br>            f[i]:=x mod k;x:=x div k;cnt:=cnt+f[i];i:=i+1;<br>        end;<br>        for i:=0 to k-2 do nxt[i]:=i+1;nxt[k-1]:=0;<br>        cnt:=cnt mod k;<br>        ans:=qw(cnt)<em>trunc((sqr(l mod z0)+l+804)/233);<br>        if l=r then exit;x:=l+1;<br>        repeat<br>            f[0]:=f[0]+1;cnt:=nxt[cnt];i:=0;<br>            while f[i]=k do begin<br>                f[i+1]:=f[i+1]+1;f[i]:=0;i:=i+1;<br>                cnt:=nxt[cnt];<br>            end;<br>            ans:=qw(ans)+qw(cnt)</em>trunc((sqr(x mod z0)+x+804)/233);<br>            x:=x+1;<br>        until x=r+1;<br>        writeln(ans);<br>        dec(T);<br>    until T=0;<br>    //close(input);close(output);<br>end.</p>
<pre><code>
# T3 现实
大意：给定n个节点、m条边的有向图，求所有图中满足如下条件的点v：删去点v后，图变成dag
$n\leq5\times 10^5;m\leq10^6$

## 水解
转换一下思路，就是求图中所有简单环的交集。
这个可以tarjan找出强连通分量，然后暴力dfs遍历所有环
当然是会TLE的

&lt;div style=&quot;display:none;&quot; class=&quot;copy&quot;&gt;
    <a href="/2016/10/16/lydsy-noip-2016-test6/reality_che.pas" title="{plain text}">{plain text}</a>
&lt;/div&gt;
```delphi reality.pas
uses math;
type 
    int=longint;
    edge=record v,nxt:int end;
var
    g:array[0..1000010] of edge;
    head,s,dfn,low,scc,siz,f:array[0..500010] of int;
    ins{,vis}:array[0..500010] of boolean;
    sz,n,m,k,i,t,u,v,cc,tim,cnt,ans:int;

procedure add(u,v:int);
begin
    inc(sz);g[sz].v:=v;
    g[sz].nxt:=head[u];head[u]:=sz;
end;

procedure tarjan(u:int);
var i,v:int;
begin
    inc(tim);dfn[u]:=tim;low[u]:=tim;
    inc(t);s[t]:=u;ins[u]:=true;
    i:=head[u];
    while i&lt;&gt;0 do begin
        v:=g[i].v;
        if dfn[v]=0 then begin
            tarjan(v);low[u]:=min(low[v],low[u]);
        end else if ins[v] then
            low[u]:=min(low[u],dfn[v]);        
        i:=g[i].nxt;
    end;
    if dfn[u]=low[u] then begin
        inc(cc);siz[cc]:=0;
        while s[t+1]&lt;&gt;u do begin
            scc[s[t]]:=cc;ins[s[t]]:=false;
            inc(siz[cc]);dec(t);
        end;
    end;
end;

procedure dfs(u:int);
var v,i,j:int;
begin
    inc(t);s[t]:=u;ins[u]:=true;
    i:=head[u];
    while i&lt;&gt;0 do begin
        v:=g[i].v;
        if scc[v]=k then begin
            if ins[v] then begin
                inc(cnt);j:=t;
                while s[j+1]&lt;&gt;v do 
                    begin inc(f[s[j]]);dec(j) end;
            end else dfs(v);
        end;
        i:=g[i].nxt;
    end;
    ins[u]:=false;dec(t);
end;

begin
    //assign(input,&#39;reality.in&#39;);reset(input);
    //assign(output,&#39;reality.out&#39;);rewrite(output);
    read(n,m);
    for i:=1 to m do begin
        read(u,v);add(u,v);
    end;
    t:=0;tim:=0;cc:=0;
    for i:=1 to n do
        if dfn[i]=0 then tarjan(i);
    k:=-1;
    for i:=1 to cc do
        if siz[i]&gt;1 then begin 
            if k&lt;&gt;-1 then begin write(0);halt end;
            k:=i; 
        end;
    if k=-1 then begin 
        writeln(n);for i:=1 to n do write(i,&#39; &#39;);halt;
    end;
    for i:=1 to n do
        if scc[i]=k then begin u:=i;break end;
    fillchar(s,sizeof(s),0);
    ans:=0;cnt:=0;dfs(u);
    for i:=1 to n do
        if f[i]=cnt then begin inc(ans);inc(t);s[t]:=i end;
    writeln(ans);
    for i:=1 to t do write(s[i],&#39; &#39;);
    close(input);close(output);
end.
</code></pre><h2 id="正解"><a href="#正解" class="headerlink" title="正解"></a>正解</h2><p>dfs找一个环+拓扑排序+dag上dp<br>同水解一样，考虑求环交的点集<br>直接求点集有如下缺陷</p>
<ol>
<li>删掉一个环后，剩下的不一定是dag</li>
<li>无法处理自环</li>
</ol>
<p>于是拆点，把点拆成入点和出点，入点向出点连边，这样点集变成了边集。<br>然后dfs找到一个环，如果找不到说明原来就是dag，特判输出<br>然后把这个环删掉，拓扑排序；如果还有环，说明无解，特判输出<br>破环成链，然后顺次给环上的点编号loc[u]<br>然后dp，考虑两种路径<br><img src="/2016/10/16/lydsy-noip-2016-test6/g.png" alt="g.png" title=""></p>
<ol>
<li>第一种<ol>
<li>求点u，顺着非环边能走到的环上点的最小编号f1[u]</li>
<li>求点u，逆着非环边能走到的环上点的最大编号f2[u]</li>
<li>考虑环上的点u，如果f1[u]&lt;loc[u]则loc[u]&lt;loc[v]的点v都不在环交中；如果loc[u]&lt;f2[u]，则loc[v]&lt;loc[u]的点v都不在环交中</li>
</ol>
</li>
<li>第二种<ol>
<li>求点u，顺着非环边能走到的环上的点的最大编号f3[u]</li>
<li>考虑环上的点u，如果loc[u]&lt;f3[u]，那么编号在(loc[u],f3[u])的点都不在环交中</li>
</ol>
</li>
</ol>
<p>区间修改可以用差分序列<br>一些细节：</p>
<ol>
<li>找环时记录路径上点的入边edg[u]和dfs树上的父节点pre[u]，找到环后回头标记</li>
<li>第一写非递归的拓扑排序（以前都是用dfs的）</li>
<li>在环上，出点u+n与原来的点u是一一对应的（因为记录的是入边）</li>
<li>第一种的两种子情况看似是等价的，但如果只求一种情况是有漏洞的，比如：<img src="/2016/10/16/lydsy-noip-2016-test6/sp.png" alt="sp.png" title="">
图中有两条非环边e1和e2，如果指对a4求f1的话，得到的答案是a2,a3,a4；但实际上a2不在环交中</li>
</ol>
<p><div style="display:none;" class="copy"><br>    <a href="/2016/10/16/lydsy-noip-2016-test6/reality.pas" title="{plain text}">{plain text}</a><br></div><br>```delphi reality.pas<br>uses math;<br>const inf=1000000000;<br>type<br>    int=longint;<br>    edge=record u,v,nxt:int;f:boolean end;<br>    arr=array[0..1000010] of int;<br>var<br>    g:array[0..1500010] of edge;<br>    head,top,pre,edg,flg,loc,cyc,f1,f2,f3,a,ans:arr;<br>    sz,n,m,i,j,k,u,v,cnt:int;</p>
<p>procedure add(u,v:int);<br>begin<br>    inc(sz);g[sz].u:=u;g[sz].v:=v;g[sz].f:=true;<br>    g[sz].nxt:=head[u];head[u]:=sz;<br>end;</p>
<p>function dfs(u:int):boolean;<br>var i,v,w:int;<br>begin<br>    flg[u]:=1;i:=head[u];<br>    while i&lt;&gt;0 do begin<br>        v:=g[i].v;<br>        if flg[v]=1 then begin<br>            w:=u;k:=0;<br>            while w&lt;&gt;v do begin<br>                inc(k);cyc[k]:=w;loc[w]:=k;<br>                g[edg[w]].f:=false;<br>                w:=pre[w];<br>            end;<br>            inc(k);cyc[k]:=v;loc[v]:=k;<br>            edg[v]:=i;g[i].f:=false;<br>            exit(true);<br>        end;<br>        if flg[v]=0 then begin<br>            pre[v]:=u;edg[v]:=i;<br>            if dfs(v) then exit(true);<br>        end;<br>        i:=g[i].nxt;<br>    end;<br>    flg[u]:=2;dfs:=false;<br>end;</p>
<p>function sort():boolean;<br>var i,u,v,h,t:int;deg:arr;<br>begin<br>    fillchar(deg,sizeof(deg),0);t:=0;<br>    for i:=1 to sz do<br>        if g[i].f then inc(deg[g[i].v]);<br>    for i:=1 to n<em>2 do<br>        if deg[i]=0 then<br>            begin inc(t);top[t]:=i end;<br>    h:=1;<br>    while h&lt;=t do begin<br>        u:=top[h];inc(h);i:=head[u];<br>        while i&lt;&gt;0 do begin<br>            if g[i].f then begin<br>                v:=g[i].v;dec(deg[v]);<br>                if deg[v]=0 then begin inc(t);top[t]:=v end;<br>            end;<br>            i:=g[i].nxt;<br>        end;<br>    end;<br>    sort:=t=n</em>2;<br>end;</p>
<p>begin<br>    assign(input,’ex_reality5.in’);reset(input);<br>    assign(output,’reality.out’);rewrite(output);<br>    read(n,m);<br>    for i:=1 to n do add(i,i+n);<br>    for i:=1 to m do begin<br>        read(u,v);add(u+n,v);<br>    end;<br>    for i:=1 to n<em>2 do<br>        if (flg[i]=0) and dfs(i) then break;<br>    if k=0 then begin<br>        writeln(n);<br>        for i:=1 to n do write(i,’ ‘);halt;<br>    end;<br>    if not sort() then begin write(0);halt end;<br>    filldword(f1,sizeof(f1) div 4,inf);<br>    filldword(f3,sizeof(f3) div 4,inf);<br>    for i:=1 to n</em>2 do<br>        if loc[i]&gt;0 then<br>             begin f1[i]:=loc[i];f2[i]:=loc[i];f3[i]:=loc[i] end;<br>    for j:=n<em>2 downto 1 do begin<br>        u:=top[j];i:=head[u];<br>        while i&lt;&gt;0 do begin<br>            v:=g[i].v;<br>            if g[i].f then begin<br>                f1[u]:=min(f1[u],f1[v]);<br>                f2[u]:=max(f2[u],f2[v]);<br>            end;<br>            i:=g[i].nxt;<br>        end;<br>    end;<br>    for j:=1 to n</em>2 do begin<br>        u:=top[j];i:=head[u];<br>        while i&lt;&gt;0 do begin<br>            v:=g[i].v;<br>            if g[i].f then f3[v]:=min(f3[u],f3[v]);<br>            i:=g[i].nxt;<br>        end;<br>    end;<br>    for i:=1 to k do begin<br>        u:=cyc[i];<br>        if f1[u]<i then="" begin="" inc(a[f1[u]]);dec(a[i])="" end;="" if="" f2[u]="">i then begin inc(a[1]);dec(a[i]) end;<br>        if f3[u]<i then="" inc(a[i]);="" end;="" for="" i:="2" to="" k="" do="" inc(a[i],a[i-1]);="" if="" (a[i]="0)and(cyc[i]">n) then flg[cyc[i]-n]:=-1;<br>    cnt:=0;<br>    for i:=1 to n do<br>        if flg[i]=-1 then begin inc(cnt);ans[cnt]:=i end;<br>    writeln(cnt);<br>    for i:=1 to cnt do write(ans[i],’ ‘);<br>end.<br>```</i></i></p>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[NOIP模拟赛 2014-11-2]]></title>
      <url>https://cothrax.github.io/2016/10/16/noip-2014-11-2/</url>
      <content type="html"><![CDATA[<table>
<thead>
<tr>
<th style="text-align:center">题目</th>
<th style="text-align:center">思路</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">disk</td>
<td style="text-align:center">?</td>
</tr>
<tr>
<td style="text-align:center">car</td>
<td style="text-align:center">Hash</td>
</tr>
<tr>
<td style="text-align:center">rollcall</td>
<td style="text-align:center">离线+离散化+线段树</td>
</tr>
</tbody>
</table>
<h1 id="P1-盘子序列"><a href="#P1-盘子序列" class="headerlink" title="P1 盘子序列"></a>P1 盘子序列</h1><p>有 n 个盘子。盘子被生产出来后,被按照某种顺序摞在一起。初始盘堆中如果一<br>个盘子比所有它上面的盘子都大,那么它是安全的,否则它是危险的。称初始盘堆为<br>A,另外有一个开始为空的盘堆 B。为了掩盖失误,生产商会对盘子序列做一些“处<br>理”,每次进行以下操作中的一个:(1)将 A 最上面的盘子放到 B 最上面;(2)将 B 最上<br>面的盘子给你。<br>在得到所有 n 个盘子之后,你需要判断初始盘堆里是否有危险的盘子。<br><a id="more"></a></p>
<h2 id="格式"><a href="#格式" class="headerlink" title="格式"></a>格式</h2><h3 id="输入格式"><a href="#输入格式" class="headerlink" title="输入格式"></a>输入格式</h3><p>输入文件包含多组数据(不超过 10 组)<br>每组数据的第一行为一个整数 n<br>接下来 n 个整数,第 i 个整数表示你收到的第 i 个盘子的大小</p>
<h3 id="输出格式"><a href="#输出格式" class="headerlink" title="输出格式"></a>输出格式</h3><p>对于每组数据,如果存在危险的盘子,输出”J”,否则输出”Y”</p>
<h2 id="样例"><a href="#样例" class="headerlink" title="样例"></a>样例</h2><h3 id="样例输入"><a href="#样例输入" class="headerlink" title="样例输入"></a>样例输入</h3><blockquote>
<p>3<br>2 1 3<br>3<br>3 1 2</p>
</blockquote>
<h3 id="样例输出"><a href="#样例输出" class="headerlink" title="样例输出"></a>样例输出</h3><blockquote>
<p>Y<br>J</p>
</blockquote>
<h2 id="提示​"><a href="#提示​" class="headerlink" title="提示​"></a>提示​</h2><p>20%的数据保证 n&lt;=8<br>80%的数据保证 n&lt;=1,000<br>100%的数据保证 1&lt;=n&lt;=100,000,0&lt;盘子大小&lt;1,000,000,000 且互不相等</p>
<h2 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h2><blockquote>
<p>此坑未填</p>
</blockquote>
<h1 id="P2-四轮车"><a href="#P2-四轮车" class="headerlink" title="P2 四轮车"></a>P2 四轮车</h1><p>在地图上散落着 n 个车轮,小 J 想用它们造一辆车。要求如下:</p>
<ol>
<li>一辆车需要四个车轮,且四个车轮构成一个正方形</li>
<li>车轮不能移动<br>你需要计算有多少种造车的方案(两个方案不同当且仅当所用车轮不全相同,坐<br>标相同的两个车轮视为不同车轮)<!--more-->
</li>
</ol>
<h2 id="格式-1"><a href="#格式-1" class="headerlink" title="格式"></a>格式</h2><h3 id="输入格式-1"><a href="#输入格式-1" class="headerlink" title="输入格式"></a>输入格式</h3><p>第一行一个整数 n<br>接下来 n 行,每行两个整数 x y,表示在(x,y)处有一个车轮</p>
<h3 id="输出格式-1"><a href="#输出格式-1" class="headerlink" title="输出格式"></a>输出格式</h3><p>一行一个整数,表示方案数</p>
<h2 id="样例-1"><a href="#样例-1" class="headerlink" title="样例"></a>样例</h2><h3 id="样例输入-1"><a href="#样例输入-1" class="headerlink" title="样例输入"></a>样例输入</h3><blockquote>
<p>9<br>0 0<br>1 0<br>2 0<br>0 2<br>1 2<br>2 2<br>0 1<br>1 1<br>2 1</p>
</blockquote>
<h3 id="样例输出-1"><a href="#样例输出-1" class="headerlink" title="样例输出"></a>样例输出</h3><blockquote>
<p>6</p>
</blockquote>
<h2 id="提示​-1"><a href="#提示​-1" class="headerlink" title="提示​"></a>提示​</h2><p>30%的数据保证 n ≤ 30<br>100%的数据保证 1 ≤ n ≤ 1000; |x|, |y| &lt;= 20000</p>
<h2 id="题解-1"><a href="#题解-1" class="headerlink" title="题解"></a>题解</h2><p>坐标插入hash，然后$O(N^2)$枚举，根据向量关系算出另外两点，查询hash统计答案。<br>注意点：</p>
<ol>
<li>坐标有重复</li>
<li>坐标可能为负数，慎用qword</li>
</ol>
<p><div style="display:none;" class="copy"><br>    <a href="/2016/10/16/noip-2014-11-2/car.pas" title="{plain text}">{plain text}</a><br></div><br>```delphi car.pas<br>uses math;<br>type int=longint;<br>const z=1000003;mx=20000;<br>var<br>    hash,x,y:array[0..1010] of qword;<br>    nxt,cnt:array[0..1010] of int;<br>    head:array[0..z] of int;<br>    n,i,j,k,l,sz,x0,y0:int;dx,dy,ans:qword;</p>
<p>procedure insert(k:qword);<br>var i:int;<br>begin<br>    i:=k mod z;<br>    if head[i]=0 then begin<br>        inc(sz);head[i]:=sz;hash[sz]:=k;cnt[sz]:=1;exit;<br>    end;<br>    i:=head[i];<br>    while nxt[i]&lt;&gt;0 do begin<br>        if hash[i]=k then begin inc(cnt[i]);exit end;<br>        i:=nxt[i];<br>    end;<br>    if hash[i]=k then begin inc(cnt[i]);exit end;<br>    inc(sz);nxt[i]:=sz;hash[sz]:=k;cnt[sz]:=1;<br>end;</p>
<p>function query(k:qword):int;<br>var i:int;<br>begin<br>    i:=head[k mod z];<br>    while i&lt;&gt;0 do begin<br>        if hash[i]=k then exit(i);<br>        i:=nxt[i];<br>    end;<br>    query:=-1;<br>end;</p>
<p>begin<br>    assign(input,’car.in’);reset(input);<br>    assign(output,’car.out’);rewrite(output);<br>    read(n);sz:=0;<br>    for i:=1 to n do begin<br>        read(x0,y0);<br>        x[i]:=x0+mx;y[i]:=y0+mx;<br>        insert(x[i]<em>mx+y[i]);<br>    end;<br>    ans:=0;<br>    for i:=1 to n do<br>        for j:=i+1 to n do begin<br>            dx:=x[i]-x[j];dy:=y[i]-y[j];<br>            k:=query((x[i]-dy)</em>mx+y[i]+dx);<br>            l:=query((x[j]-dy)<em>mx+y[j]+dx);<br>            if min(k,l)&gt;0 then inc(ans,min(cnt[k],cnt[l]));<br>            k:=query((x[i]+dy)</em>mx+y[i]-dx);<br>            l:=query((x[j]+dy)*mx+y[j]-dx);<br>            if min(k,l)&gt;0 then inc(ans,min(cnt[k],cnt[l]));<br>        end;<br>    write(ans div 4);<br>    close(input);close(output);<br>end.</p>
<pre><code>

# P3 点名
在 J 班的体育课上,同学们常常会迟到几分钟,
但体育老师的点名却一直很准时。
老师只关心同学的身高,他会依次询问当前最高的身高,次高的身高,第三高的身高,
等等。在询问的过程中,会不时地有人插进队伍里。你需要回答老师每次的询问。
&lt;!--more--&gt;

## 格式
### 输入格式
第一行两个整数 n m,表示先后有 n 个人进队,老师询问了 m 次
第二行 n 个整数,第 i 个数 Ai 表示第 i 个进入队伍的同学的身高为 Ai
第三行 m 个整数,第 j 个数 Bj 表示老师在第 Bj 个同学进入队伍后有一次询问

### 输出格式
m 行,每行一个整数,依次表示老师每次询问的答案。数据保证合法

## 样例
### 样例输入
&gt;7 4
9 7 2 8 14 1 8
1 2 6 6

### 样例输出
&gt;9
9
7
8

## 提示​
(9){No.1 = 9}; (9 7){No.2 = 9}; (9 7 2 8 14 1){No.3 = 7; No.4 = 8}
40%的数据保证 n ≤ 1000
100%的数据保证 1 ≤ m ≤ n ≤ 30000; 0 ≤ Ai ≤ 2^32-1

## 题解
查询序列第k大
离线+离散化+线段树
注意数据会爆int

&lt;div style=&quot;display:none;&quot; class=&quot;copy&quot;&gt;
    <a href="/2016/10/16/noip-2014-11-2/rollcall.pas" title="{plain text}">{plain text}</a>
&lt;/div&gt;
```delphi rollcall.pas
type 
    int=longint;
    sort=array[0..30010,0..1] of qword;
var 
    a,q:sort;
    b,l,ans:array[0..30010] of qword;
    sgt:array[0..120010] of int;
    n,m,k,lst,i:int;

procedure swap(var a,b:qword);
var tmp:qword;
begin tmp:=a;a:=b;b:=tmp end;

procedure qsort(var a:sort;l,r:int);
var i,j:int;x:qword;
begin
    i:=l;j:=r;x:=a[random(r-l)+l,0];
    repeat
        while a[i,0]&lt;x do inc(i);
        while a[j,0]&gt;x do dec(j);
        if i&lt;=j then begin
            swap(a[i,0],a[j,0]);swap(a[i,1],a[j,1]);
            inc(i);dec(j);
        end;
    until i&gt;j;
    if i&lt;r then qsort(a,i,r);
    if l&lt;j then qsort(a,l,j);
end;

procedure insert(i,b,e,x:int);
var l,r,mid:int;
begin
    if b=e then begin inc(sgt[i]);exit end;
    l:=i shl 1;r:=l or 1;mid:=(b+e) shr 1;
    if x&lt;=mid then insert(l,b,mid,x)
    else insert(r,mid+1,e,x);
    sgt[i]:=sgt[l]+sgt[r];
end;

function query(i,b,e,x:int):int;
var mid,l,r:int;
begin
    if b=e then exit(b);
    l:=i shl 1;r:=l or 1;mid:=(b+e) shr 1;
    if sgt[l]&gt;=x then query:=query(l,b,mid,x)
    else query:=query(r,mid+1,e,x-sgt[l]);
end;

begin
    assign(input,&#39;rollcall.in&#39;);reset(input);
    assign(output,&#39;rollcall.out&#39;);rewrite(output);
    read(n,m);
    for i:=1 to n do begin read(a[i,0]);a[i,1]:=i end;
    for i:=1 to m do begin read(q[i,0]);q[i,1]:=i end;
    qsort(a,1,n);qsort(q,1,m);
    k:=0;lst:=0;
    for i:=1 to n do begin
        if a[i,0]&gt;a[lst,0] then begin 
            inc(k);l[k]:=a[i,0];lst:=i;
        end;
        b[a[i,1]]:=k;
    end;
    k:=1;
    for i:=1 to n do begin
        insert(1,1,n,b[i]);
        while q[k,0]=i do begin
            ans[q[k,1]]:=l[query(1,1,n,q[k,1])];inc(k)
        end;
    end;
    for i:=1 to m do writeln(ans[i]);
    close(input);close(output);
end.
</code></pre>]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[NOIP2016十连测 Day 4]]></title>
      <url>https://cothrax.github.io/2016/10/10/lydsy-noip-2016-test4/</url>
      <content type="html"><![CDATA[<p>10-8-2016<br>NOIprofessional</p>
<blockquote>
<p>订正进度(3/3)</p>
</blockquote>
<h1 id="P1-天空龙"><a href="#P1-天空龙" class="headerlink" title="P1 天空龙"></a>P1 天空龙</h1><p>大意：给定a个红色,b个黄色,c个蓝色；现在需要至少x个红色,y个黄色和z个蓝色，可以将两种相同颜色变成另一种颜色，问是否有可行方案</p>
<a id="more"></a>
<h2 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h2><p>水题，$O(1)$统计</p>
<p><div style="display:none;" class="copy"><br>    <br></div><br>```delphi orisis.pas<br>type int=longint;<br>var<br>    t,i,pos,neg:int;<br>    a,b:array[0..2] of int;</p>
<p>procedure solv(i,j:int);<br>begin<br>    if i&gt;j then inc(pos,(i-j) div 2) else inc(neg,j-i);<br>end;</p>
<p>begin<br>    assign(input,’osiris.in’);reset(input);<br>    assign(output,’osiris.out’);rewrite(output);<br>    read(t);<br>    repeat<br>        read(a[0],a[1],a[2],b[0],b[1],b[2]);<br>        pos:=0;neg:=0;<br>        for i:=0 to 2 do solv(a[i],b[i]);<br>        if pos&gt;=neg then writeln(‘YES’) else writeln(‘NO’);<br>        dec(t);<br>    until t=0;<br>    close(input);close(output);<br>end.</p>
<pre><code>
# P3 巨神兵
大意：给定n个节点、m条边的有向图，统计其无环子图的个数，子图指任意边集，答案对1000000007取模。
（n≤17）

## 题解
状压DP+容斥
第一次切容斥题。
考察DAG的性质，必定有出度为0的点
记f[S]为选取点集S，其中的无环子图数
在S的补集中选取点集k，作为出度为0的点，由f[S]转移到f[S∪k]
含义为点集S∪k中，点集k的出度为0的dag数
根据点集k容斥即可
转移：记S指向k的边数为p，则$f[S∪k]+=(-1)^{|k|+1}\cdot p\cdot f[S]$

&lt;div style=&quot;display:none;&quot; class=&quot;copy&quot;&gt;
    <a href="/2016/10/10/lydsy-noip-2016-test4/obelisk.pas" title="{plain text}">{plain text}</a>
&lt;/div&gt;
```delphi obelisk.pas
type int=longint;
const mx=1 shl 17-1;inf:int64=1000000007;
var
    g:array[0..20,0..20] of int;
    num,b,a:array[0..mx] of int;
    f:array[0..mx] of int64;
    bin:array[0..400] of int64;
    n,m,t,i,j,k,l,u,v,r:int;
begin
    assign(input,&#39;obelisk.in&#39;);reset(input);
    assign(output,&#39;obelisk.out&#39;);rewrite(output);
    read(n,m);t:=1 shl n-1;
    for i:=1 to m do begin
        read(u,v);g[u,v]:=1;
    end;
    bin[0]:=1;num[0]:=-1;f[0]:=1;
    for i:=1 to sqr(n) do bin[i]:=bin[i-1]*2 mod inf;
    for i:=1 to t doa num[i]:=num[i and(i-1)]*(-1);
    for i:=0 to t-1 do begin
        j:=i;
        while j&gt;0 do begin
            k:=round(ln(j and (-j))/ln(2))+1;
            for l:=1 to n do inc(a[bin[l-1]],g[k,l]);
            j:=j and(j-1);
        end;
        r:=t xor i;j:=r;b[0]:=0;
        repeat
            j:=(j-1)and r;k:=j xor r;
            b[k]:=b[k and(k-1)]+a[k and(-k)];
            f[i or k]:=(f[i or k]+num[k]*bin[b[k]]*f[i])mod inf;
        until j=0;
        for l:=1 to n do a[bin[l-1]]:=0;
    end;
    write(f[t]);
    close(input);close(output);
end.
</code></pre><h1 id="P3-太阳神"><a href="#P3-太阳神" class="headerlink" title="P3 太阳神"></a>P3 太阳神</h1><p>给定n，求$a,b\in N*$，$a,b\leq n$且$lcm(a,b)&gt;n$的有序对(a,b)的个数，答案对1000000007取模<br>$n\leq 10^10$</p>
<h2 id="题解-1"><a href="#题解-1" class="headerlink" title="题解"></a>题解</h2><p>答案是$\sum_{1\leq a,b\leq n}[lcm(a,b)&gt;n]=n^2-\sum_{1\leq a,b\leq n}[lcm(a,b)\leq n]$</p>
<p>记$d=gcd(a,b),k=n/d$，那么答案为$\sum_{1\leq k\leq n}\sum_{1\leq a,b\leq k}[ab\leq k][gcd(a,b)=1]$</p>
<p>则变形为$f(k)=\sum_{1\leq a,b\leq k}[ab\leq k][gcd(a,b)=1]$</p>
<p>记$f‘(k)=\sum_{1\leq a,b\leq k}[ab=k][gcd(a,b)=1]$</p>
<p>记k的不同质因数个数为$a(k)$，可以用<a href="/2016/10/30/note-euler-function/" title="线性筛">线性筛</a>筛出，则$f’(k)=2^{a(k)}$，然后求$f’(k)$的前缀和得到$f(k)$<br>因为$10^7$内的$a(k)$很小，算f(k)时不用担心炸int的情况。</p>
<p>但$O(N)$是无法通过全部数据的，考虑只筛出$10^7$以内的$f(k)$</p>
<p>其余通过迭代求值：</p>
<p>记$s(k)=\sum_{1\leq a,b\leq n}[ab\leq k]$</p>
<p>显然$f(k)=s(k)-\sum_{1&lt;t}f(k/t^2)$</p>
<p>这样，通过枚举$d$，求出相应的$f(n/d)$来算出答案</p>
<p>并不知道$O(N^{2/3})$的复杂度是怎么算的</p>
<p>小细节：</p>
<ol>
<li>由于对于$[d,\lfloor\dfrac{n}{\lfloor n/d\rfloor} \rfloor]$的$d$，$\lfloor n/d\rfloor $是定值，于是枚举的d只会有$\sqrt(n)$个</li>
<li>大于$10^7$的部分的$f(k)$要存到$g(n/k)$中，因为细节1保证$n/(n/d)$只会被算一次，$f(k)$与$g(n/k)$存在对应关系</li>
</ol>
<blockquote>
<p>听说这玩意叫杜教筛，身为noiper并看不懂tangjz的教程<br>另外留个坑，目前看不懂部分分的题解</p>
</blockquote>
<p><div style="display:none;" class="copy"><br>    <a href="/2016/10/10/lydsy-noip-2016-test4/ra.pas" title="{plain text}">{plain text}</a><br></div><br>```delphi ra.pas<br>uses math;<br>type int=longint;ll=int64;<br>const mx=10000000;md=1000000007;<br>var<br>    f,g,a,p:array[0..mx+5] of int;<br>    flg:array[0..mx+5] of boolean;<br>    n,i,j,ans:int64;</p>
<p>procedure siev(n:int);<br>var i,j,k,x:int;<br>begin<br>    k:=0;<br>    for i:=2 to n do begin<br>        if not flg[i] then begin<br>            inc(k);p[k]:=i;a[i]:=1;<br>        end;<br>        j:=1;x:=p[j]<em>i;<br>        while x&lt;=n do begin<br>            flg[x]:=true;<br>            if i mod p[j]=0 then<br>                begin a[x]:=a[i];break end;<br>            a[x]:=a[i]+1;<br>            inc(j);x:=p[j]</em>i;<br>        end;<br>    end;<br>    f[0]:=0;<br>    for i:=1 to n do<br>        f[i]:=(f[i-1]+(1 shl a[i]))mod md;<br>end;</p>
<p>function calc(x:int64):int64;<br>var i,y,j:int64;<br>begin<br>    if x&lt;=mx then exit(f[x]);<br>    y:=trunc(n/x);<br>    if g[y]&lt;&gt;-1 then exit(g[y]);<br>    g[y]:=0;i:=1;<br>    while i&lt;=x do begin<br>        j:=trunc(x/trunc(x/i));<br>        g[y]:=(g[y]+trunc(x/i)<em>(j-i+1))mod md;<br>        i:=j+1;<br>    end;<br>    i:=2;<br>    while i</em>i&lt;=x do begin<br>        g[y]:=(g[y]-calc(trunc(x/(i*i)))+md)mod md;<br>        inc(i);<br>    end;<br>    calc:=g[y];<br>end;</p>
<p>begin<br>    assign(input,’ra.in’);reset(input);<br>    assign(output,’ra.out’);rewrite(output);<br>    fillchar(g,sizeof(g),255);<br>    read(n);siev(min(n,mx));i:=1;ans:=0;<br>    while i&lt;=n do begin<br>        j:=trunc(n/trunc(n/i));<br>        ans:=(ans+calc(trunc(n/i))<em>(j-i+1))mod md;<br>        i:=j+1;<br>    end;<br>    n:=n mod md;ans:=(n</em>n-ans+md)mod md;<br>    write(ans);<br>    close(input);close(output);<br>end.<br>```</p>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[NOIP2016十连测 Day 3]]></title>
      <url>https://cothrax.github.io/2016/10/09/lydsy-noip-2016-test3/</url>
      <content type="html"><![CDATA[<p>10-7-2016<br>白天月考，晚上noip（NOIplus）模拟赛</p>
<h1 id="P1-平均数"><a href="#P1-平均数" class="headerlink" title="P1 平均数"></a>P1 平均数</h1><p>大意：给定一个长度为n的序列，求所有连续子序列的平均值中，第k小的那个值<br>n≤100000,k≤n*(n+1)/2<br><a id="more"></a></p>
<h2 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h2><p>二分答案x，判断序列中平均值小于x的区间个数为k-1<br>将原序列a的值都减去x后，就便成了区间和小于0的区间个数<br>对这个序列做前缀和，答案就变成的前缀数组中的逆序对数<br>然后归并排序求逆序对</p>
<p><div style="display:none;" class="copy"><br>    <a href="/2016/10/09/lydsy-noip-2016-test3/ave.pas" title="{plain text}">{plain text}</a><br></div><br>```delphi ave.pas<br>uses math;<br>type int=longint;<br>var<br>    a,b,c:array[0..100010] of double;<br>    n,i:int;l,r,mid:double;m,cnt:int64;</p>
<p>procedure merge(l,r:int);<br>var mid,p,q:int;<br>begin<br>    if l=r then exit;<br>    mid:=(l+r) shr 1;<br>    merge(l,mid);merge(mid+1,r);<br>    p:=l;q:=mid+1;<br>    for i:=l to r do<br>        if (p&gt;mid) or ((q&lt;=r) and (b[q]&lt;b[p])) then begin<br>            c[i]:=b[q];inc(cnt,mid-p+1);inc(q)<br>        end else begin<br>            c[i]:=b[p];inc(p)<br>        end;<br>    for i:=l to r do b[i]:=c[i];<br>end;</p>
<p>function jud(x:double):boolean;<br>var i:int;<br>begin<br>    b[0]:=0;<br>    for i:=1 to n do b[i]:=a[i]-x+b[i-1];<br>    cnt:=0;merge(0,n);jud:=cnt&gt;=m;<br>end;</p>
<p>begin<br>    read(n,m);l:=maxlongint;r:=0;<br>    for i:=1 to n do begin<br>        read(a[i]);<br>        l:=min(a[i],l);r:=max(a[i],r);<br>    end;<br>    while r-l&gt;0.000001 do begin<br>        mid:=(l+r)/2;<br>        if jud(mid) then r:=mid else l:=mid;<br>    end;<br>    write(l:0:4);<br>end.</p>
<pre><code>
# P2 涂色游戏
大意：用p中颜色涂n行m列的格子，定义合法方案为：任意相邻两列都出现了至少q种颜色。求合法方案数mod 998244353。
n≤100,m≤10^9 ,q≤p≤100

## 题解
统计方案当然是dp，看到m的范围果断矩阵快速幂。
然后是一堆恶心的组合数学
一些细节：
1. 递推矩阵的幂指数是m-1
2. 快速幂要特判矩阵是否为**零矩阵**
2. 涉及除法要算逆元，由于模数m是素数，费马小定理得i模m的逆元为$i^{m-2}\% m$，逆元还有一个通用求法$\dfrac{a}{b}\% m=a\% (bm)/b$，但要求$a|b$所以这里不行
3. 涉及三个数乘法时小心溢出
4. int64常数很大，换成qword会快一些

&lt;div style=&quot;display:none;&quot; class=&quot;copy&quot;&gt;
    <a href="/2016/10/09/lydsy-noip-2016-test3/color.pas" title="{plain text}">{plain text}</a>
&lt;/div&gt;
```delphi color.pas
uses math;
const md:qword=998244353;
type 
    int=longint;
    mat=array[-1..110,-1..110] of qword;
var 
    f,c,a:mat;
    g:array[-1..110] of qword;
    n,p,q,i,j,k:int;ans,m:qword;

function mul(a,b:mat):mat;
var i,j,k:int;
begin
    fillchar(mul,sizeof(mul),0);
    for i:=1 to p do
        for j:=1 to p do
            for k:=1 to p do
                mul[i,j]:=(mul[i,j]+a[i,k]*b[k,j])mod md;
end;

function mpow(a:mat;k:qword):mat;
var i:int;is0:boolean;
begin
    fillchar(mpow,sizeof(mpow),0);
    is0:=true;
    for i:=1 to p do for j:=1 to p do is0:=is0 and (a[i,j]=0);
    if is0 then exit;
    for i:=1 to p do mpow[i,i]:=1;
    while k&gt;0 do begin
        if k and 1=1 then mpow:=mul(mpow,a);
        a:=mul(a,a);k:=k shr 1;
    end;
end;

function ipow(a,k:qword):qword;
begin
    if a=0 then exit(0);
    ipow:=1;
    while k&gt;0 do begin
        if k and 1=1 then ipow:=ipow*a mod md;
        a:=a*a mod md;k:=k shr 1;
    end;
end;

begin
    //assign(input,&#39;color.in&#39;);reset(input);
    //assign(output,&#39;color.ans&#39;);rewrite(output);
    read(n,m,p,q);
    f[0,0]:=1;
    for i:=1 to n do
        for j:=1 to p do
            f[i,j]:=(f[i-1,j-1]*(p-j+1)+f[i-1,j]*j)mod md;
    c[0,0]:=1;
    for i:=1 to p do
        for j:=0 to i do
            c[i,j]:=(c[i-1,j]+c[i-1,j-1])mod md;
    for i:=1 to p do g[i]:=f[n,i]*ipow(c[p,i],md-2)mod md;
    for i:=1 to p do
        for j:=1 to p do
            for k:=max(max(i,j),q) to min(n,p) do
                a[i,j]:=(a[i,j]+c[i,i+j-k]*
                    (c[p-i,k-i]*g[j]mod md))mod md;
    a:=mpow(a,m-1);
    ans:=0;
    for i:=1 to p do
        for j:=1 to p do
            ans:=(ans+a[i,j]*f[n,i])mod md;
    write(ans);
    //close(input);close(output);
end.
</code></pre><h1 id="P3-序列"><a href="#P3-序列" class="headerlink" title="P3 序列"></a>P3 序列</h1><p>大意：<br>给定长度n的序列，有m个询问，每个询问答案为区间[l,r]内不小于k的数的个数。<br>有q次修改，将位置p上的数改成v，对于每次修改后，输出所有询问的答案之和。强制在线<br>n,m,q≤100000,序列中的数(包括修改后的)均为正数且不超过n</p>
<h2 id="题解-1"><a href="#题解-1" class="headerlink" title="题解"></a>题解</h2><p>考虑每个数x对答案的贡献=$x\in [l,r]$且$k≤x$的询问数<br>对于每次单点修改，重新统计该点的答案即可<br>这个用主席树就好<br>将每个询问区间拆成左右两个端点，分别建树<br>对于前缀1..i的线段树，维护落在1..i的端点信息<br>一个线段[l,r]保存 查询值k落在该区间内的端点个数</p>
<p>然后对于序列中的一个数a[i]，它的贡献为：<br>左端点落在1..i的查询数-右端点落在1..i-1的查询数</p>
<p>端点的数据要预处理一下，用链表就可以了</p>
<p><div style="display:none;" class="copy"><br>    <a href="/2016/10/09/lydsy-noip-2016-test3/seq.pas" title="{plain text}">{plain text}</a><br></div><br>```delphi seq.pas<br>type<br>    int=longint;<br>    arr=array[0..100010] of int;<br>var<br>    tr:array[0..4001000] of record lc,rc,w:int end;<br>    lk:array[0..400010] of record w,nxt:int end;<br>    cnt:array[0..100010] of int64;<br>    a,rt1,rt2,hd1,hd2:arr;<br>    st,sl,n,m,q,i,j,l0,r0,x:int;ans:int64;</p>
<p>procedure update(var i:int;l,r,x:int);<br>var mid:int;<br>begin<br>    inc(st);tr[st]:=tr[i];i:=st;inc(tr[i].w);<br>    if l=r then exit;<br>    mid:=(l+r) shr 1;<br>    if x&lt;=mid then update(tr[i].lc,l,mid,x)<br>    else update(tr[i].rc,mid+1,r,x);<br>end;</p>
<p>function query(i,l,r,x:int):int;<br>var mid:int;<br>begin<br>    if r&lt;=x then exit(tr[i].w);<br>    mid:=(l+r) shr 1;<br>    if x&lt;=mid then query:=query(tr[i].lc,l,mid,x)<br>    else query:=query(tr[i].rc,mid+1,r,x)+tr[tr[i].lc].w;<br>end;</p>
<p>function calc(i,x:int):int;<br>begin<br>    calc:=query(rt1[i],1,n,x)-query(rt2[i],1,n,x);<br>end;</p>
<p>procedure insert(var hd:arr;i,x:int);<br>begin<br>    inc(sl);lk[sl].w:=x;<br>    lk[sl].nxt:=hd[i];hd[i]:=sl;<br>end;</p>
<p>procedure init(var hd,rt:arr;j:int);<br>var i:int;<br>begin<br>    rt[j]:=rt[j-1];i:=hd[j];<br>    while i&lt;&gt;0 do begin<br>        update(rt[j],1,n,lk[i].w);i:=lk[i].nxt;<br>    end;<br>end;</p>
<p>begin<br>    assign(input,’seq.in’);reset(input);<br>    assign(output,’seq.out’);rewrite(output);<br>    read(n,m,q);sl:=0;st:=0;ans:=0;<br>    for i:=1 to n do read(a[i]);<br>    for i:=1 to m do begin<br>        read(l0,r0,x);insert(hd1,l0,x);<br>        if r0&lt;n then insert(hd2,r0+1,x);<br>    end;<br>    for i:=1 to n do begin<br>        init(hd1,rt1,i);init(hd2,rt2,i)<br>    end;<br>    for i:=1 to n do begin<br>        cnt[i]:=calc(i,a[i]);inc(ans,cnt[i]);<br>    end;<br>    for i:=1 to q do begin<br>        writeln(ans);read(j,x);<br>        j:=j xor ans;x:=x xor ans;<br>        dec(ans,cnt[j]);cnt[j]:=calc(j,x);inc(ans,cnt[j]);<br>    end;<br>    write(ans);<br>    close(input);close(output);<br>end.<br>```</p>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[NOIP模拟赛 2014-10-29]]></title>
      <url>https://cothrax.github.io/2016/10/04/noip-2014-10-29/</url>
      <content type="html"><![CDATA[<p>P2裸的折半枚举没有写</p>
<table>
<thead>
<tr>
<th style="text-align:center">题目</th>
<th style="text-align:center">思路</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">cowids</td>
<td style="text-align:center">DP+回溯</td>
</tr>
<tr>
<td style="text-align:center">senso</td>
<td style="text-align:center">树形DP</td>
</tr>
</tbody>
</table>
<h1 id="P1-奶牛编号"><a href="#P1-奶牛编号" class="headerlink" title="P1 奶牛编号"></a>P1 奶牛编号</h1><p>作为一个神秘的电脑高手，Farmer John 用二进制数字标识他的奶牛。<br>然而，他有点迷信，标识奶牛用的二进制数字，必须只含有K位“1”<br>(1 &lt;= K &lt;= 10)。 当然，每个标识数字的首位必须为“1”。<br>FJ按递增的顺序，安排标识数字，开始是最小可行的标识数字<br>（由“1”组成的一个K位数）。<br>不幸的是，他没有记录下标识数字。请帮他计算，第N个标识数字<br>(1 &lt;= N &lt;= 10^7)。<br><a id="more"></a></p>
<h2 id="格式"><a href="#格式" class="headerlink" title="格式"></a>格式</h2><h3 id="输入格式"><a href="#输入格式" class="headerlink" title="输入格式"></a>输入格式</h3><p>空格隔开的两个整数，N和K。</p>
<h3 id="输出格式"><a href="#输出格式" class="headerlink" title="输出格式"></a>输出格式</h3><p>如题，第N个标识数字</p>
<h2 id="样例"><a href="#样例" class="headerlink" title="样例"></a>样例</h2><h3 id="样例输入"><a href="#样例输入" class="headerlink" title="样例输入"></a>样例输入</h3><blockquote>
<p>7 3</p>
</blockquote>
<h3 id="样例输出"><a href="#样例输出" class="headerlink" title="样例输出"></a>样例输出</h3><blockquote>
<p>10110</p>
</blockquote>
<h2 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h2><p>dp统计方案数，然后回溯找答案<br>懒了不想码了<br><a href="http://haizs.com/simu2014-10-29b/" target="_blank" rel="external">http://haizs.com/simu2014-10-29b/</a></p>
<p><div style="display:none;" class="copy"><br>    <a href="/2016/10/04/noip-2014-10-29/cowids.cpp" title="{plain text}">{plain text}</a><br></div><br>```cpp cowids.cpp</p>
<p>#include <algorithm></algorithm></p>
<p>#include <iostream></iostream></p>
<p>#include <cstring></cstring></p>
<p>#include <cstdio><br>using namespace std;</cstdio></p>
<p>const int N = 5e3, INF = 1e7;</p>
<p>int n, m, f[N + 1][11];<br>bool flag;</p>
<p>void Dfs(int x, int y, int step) {<br>    if (step == 0) return ;<br>    if (f[step - 1][y] &gt;= x) {<br>        if (flag) putchar(‘0’);<br>        Dfs(x, y, step - 1);<br>    }<br>    else {<br>        putchar(‘1’); flag = 1;<br>        Dfs(x - f[step - 1][y], y - 1, step - 1);<br>    }<br>    return ;<br>}</p>
<p>int main() {<br>    freopen(“cowids.in”, “r”, stdin);<br>    freopen(“cowids.out”, “w”, stdout);<br>    scanf(“%d%d”, &amp;n, &amp;m);<br>    if (m == 1) {<br>        putchar(‘1’);<br>        for (int i = 1; i &lt; n; ++i)<br>            putchar(‘0’);<br>    }<br>    else {<br>        for (int i = 0; i &lt;= N; ++i)<br>            f[i][0] = 1;<br>        for (int i = 1; i &lt;= N; ++i)<br>            for (int j = 1; j &lt;= m; ++j)<br>                f[i][j] = min(INF, f[i - 1][j] + f[i - 1][j - 1]);<br>        Dfs(n, m, N);<br>    }<br>    puts(“”);<br>    fclose(stdin);fclose(stdout);<br>    return 0;<br>}</p>
<pre><code>
# P3 宠物大战
众所周知，moreD的宠物已经被moreD奴役得体无完肤。这只宠物实在忍无可忍，把自己每天走魔法树的经历告诉了自己的宠物。同时他还说明了自己爬树是多么地慢，以至于moreD每天都残酷地训练他爬树。
幸运的是moreD的宠物的宠物不是moreD的宠物，moreD的宠物深知”宠物是用来宠的而不是用来奴役的”这一点，所以moreD的宠物 对待自己的宠物很有爱。所以moreD的宠物与其宠物商量着要推翻moreD的暴政，方法是把moreD告上法庭，就以自己每天被迫爬树来做证据。
由于魔法树是树，训练树当然也是树啦。
moreD的训练有着GX的文化，每天moreD会把自己的宠物通灵到树的一个端点上，这个通灵点可能与之前的通灵点相同。然后moreD命令他的宠物从这个点开始走，让这只宠物随便访问自己该天之前没有访问过的节点，一直走到该天无路可走，训练才会结束，宠物才可以休息。
moreD的宠物每天都会在这棵树上训练，幸运的是他每天走过的训练路径都不同，直到若干天后，所有可能的训练路径都被走遍了。
你，作为moreD宠物的宠物，一只被moreD的宠物宠着的宠物，当然想帮moreD的宠物算出他总共走过的路径长度啦。
&lt;!--more--&gt;

## 格式
### 输入格式
第一行包含两个正整数N,M，表示树的点数与边数。
接下来M行，每行三个正整数表示Li,bi,ci分别表示树上有一条长度为Li的连接bi,ci两个结点的边。
### 输出格式
仅一行表示答案

## 样例
### 样例输入
&gt;5 4
1 2 1
1 3 1
2 4 2
2 5 2

### 样例输出
&gt;37

## 提示​
【数据范围】
对于30%的数据N≤300
对于70%的数据N≤3,000
对于100%的数据对于所有输入的整数均不大于100,000，输入的树保证连通，无重边，无自环。

可能的训练路径有(1-2-4),(1-2-5),(1-3),(2-4),(2-5),(2-1-3),(3-1-2-4),(3-1-2-5)
(4-2-5),(4-2-1-3),(5-2-4),(5-2-1-3)
长度依次为3，3，1，2，2，2，4，4，4，4，4，4。和为37.

## 题解
大意：在一棵树上，统计满足从任意一点到达一个叶节点的路径条数
树形DP啦，直接做的话各种分类码了半天没码对，如果想看可以去这里：http://hzwer.com/4888.html
标程的思路很神：
考虑一条边e(u,v)对答案的贡献
一条边被计算的次数是这条边分开的两棵子树中左边的节点数乘右边的叶子数加上右边的节点数乘左边的叶子数。
遍历两次统计即可。

&lt;div style=&quot;display:none;&quot; class=&quot;copy&quot;&gt;
    <a href="/2016/10/04/noip-2014-10-29/senso.pas" title="{plain text}">{plain text}</a>
&lt;/div&gt;
```delphi senso.pas
type 
    int=longint;
    edge=record v,next:int;w:int64 end;
var
    g:array[0..6010] of edge;
    head:array[0..3010] of int;
    lea,cnt:array[0..3010] of int64;
    n,m,sz,i,u,v,w:int;ans:int64;

procedure add(u,v:int;w:int64);
begin
    inc(sz);
    g[sz].v:=v;g[sz].w:=w;
    g[sz].next:=head[u];head[u]:=sz;
end;

procedure dfs(u,p:int);
var i,v:int;
begin
    lea[u]:=0;cnt[u]:=1;
    i:=head[u];
    while i&lt;&gt;0 do begin
        v:=g[i].v;
        if v&lt;&gt;p then begin
            dfs(v,u);
            inc(cnt[u],cnt[v]);
            inc(lea[u],lea[v]);
        end;
        i:=g[i].next;
    end;
    if lea[u]=0 then lea[u]:=1;
end;

procedure dp(u,p:int);
var i,v:int;
begin
    i:=head[u];
    while i&lt;&gt;0 do begin
        v:=g[i].v;
        if v&lt;&gt;p then begin
            inc(ans,g[i].w*(cnt[v]*(lea[1]-lea[v])+
                lea[v]*(cnt[1]-cnt[v])));
            dp(v,u);
        end;
        i:=g[i].next;
    end;
end;

begin
    assign(input,&#39;senso.in&#39;);reset(input);
    assign(output,&#39;senso.out&#39;);rewrite(output);
    read(n,m);
    for i:=1 to m do begin
        read(w,u,v);
        add(u,v,w);add(v,u,w);
    end;
    dfs(1,0);
    //for i:=1 to n do writeln(i,&#39;&gt;&#39;,cnt[i],&#39; &#39;,lea[i]);
    ans:=0;dp(1,0);write(ans);
    close(input);close(output);
end.
</code></pre>]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[NOIP模拟赛 2014-10-30-2]]></title>
      <url>https://cothrax.github.io/2016/10/04/noip-2014-10-30-2/</url>
      <content type="html"><![CDATA[<p>两道几何果断跳过</p>
<table>
<thead>
<tr>
<th style="text-align:center">题目</th>
<th style="text-align:center">思路</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">nmtg</td>
<td style="text-align:center">计数+gcd</td>
</tr>
<tr>
<td style="text-align:center">sdtg</td>
<td style="text-align:center">结论(斐波)+LCA</td>
</tr>
</tbody>
</table>
<h1 id="P2-三角形"><a href="#P2-三角形" class="headerlink" title="P2 三角形"></a>P2 三角形</h1><p>给定一张 N*M 的网格,计算三个点都在网格上的三角形有多少个。三角形三点不能共线。<br><a id="more"></a></p>
<h2 id="格式"><a href="#格式" class="headerlink" title="格式"></a>格式</h2><h3 id="输入格式"><a href="#输入格式" class="headerlink" title="输入格式"></a>输入格式</h3><p>一行两个正整数 N,M。</p>
<h3 id="输出格式"><a href="#输出格式" class="headerlink" title="输出格式"></a>输出格式</h3><p>一行一个整数代表数量。</p>
<h2 id="样例"><a href="#样例" class="headerlink" title="样例"></a>样例</h2><h3 id="样例输入"><a href="#样例输入" class="headerlink" title="样例输入"></a>样例输入</h3><blockquote>
<p>1 1</p>
</blockquote>
<h3 id="样例输出"><a href="#样例输出" class="headerlink" title="样例输出"></a>样例输出</h3><blockquote>
<p>4</p>
</blockquote>
<h2 id="提示​"><a href="#提示​" class="headerlink" title="提示​"></a>提示​</h2><p>对于 10%的数据有 N,M &lt;= 10<br>对于 30%的数据有 N,M &lt;= 100<br>对于 100%的数据有 N,M &lt;= 1000</p>
<h2 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h2><p>下面的n,m指端点数<br>先算出取三个点的方案数即C(nm,3)<br>然后减去行、列、斜着的的共线数<br>关于斜着的：枚举边长i*j，g=gcd(i*j)-1就是(i,j)的线段上的整点数（除端点），g&gt;0的情况下，该线段的贡献为2g(n-i)(m-j)</p>
<p><div style="display:none;" class="copy"><br>    <a href="/2016/10/04/noip-2014-10-30-2/nmtg.pas" title="{plain text}">{plain text}</a><br></div><br>```delphi nmtg.pas<br>uses math;<br>type int=longint;ll=int64;<br>var    n,m,i,j,k:int;ans:ll;</p>
<p>function c(x:int64):int64;<br>begin<br>    if x&lt;3 then exit(0);<br>    c:=x<em>(x-ll(1))</em>(x-ll(2));<br>end;</p>
<p>function gcd(a,b:int):int;<br>begin<br>    if b=0 then gcd:=a else gcd:=gcd(b,a mod b);<br>end;</p>
<p>begin<br>    assign(input,’nmtg.in’);reset(input);<br>    assign(output,’nmtg.out’);rewrite(output);<br>    read(n,m);<br>    inc(n);inc(m);<br>    ans:=(c(n<em>m)-m</em>c(n)-n<em>c(m)) div 6;<br>    for i:=1 to n do<br>        for j:=1 to m do begin<br>            k:=gcd(i,j)+1;<br>            if k&lt;=2 then continue;<br>            dec(ans,(n-i)</em>(m-j)<em>(k-2)</em>2);<br>        end;<br>    write(ans);<br>    close(input);close(output);<br>end.</p>
<pre><code>
# P3 忧桑三角形
有一棵树,树上每个点都有点权,现在有以下两个操作:
1. 修改某个点的点权
2. 查询点 u 和点 v 构成的简单路径上是否能选出三个点组成三角形
&lt;!--more--&gt;

## 格式
### 输入格式
第一行两个整数 N,Q,代表点数和询问数。第二行 N 个整数表示点权。下面 N-1
行每行两个整数 a,b 代表 a,b 之间有一条边。下面 Q 行每行 3 个整数 t,a,b:若 t=0,询问(a,b);否则将点 a 的权值修改为 b
### 输出格式
对于每个询问输出 Y 表示能构成三角形,输出 N 表示不能构成三角形
## 样例
### 样例输入
&gt;5 5
1 2 3 4 5
1 2
2 3
3 4
1 5
0 1 3
0 4 5
1 1 4
0 2 5
0 2 3

### 样例输出
&gt;N
Y
Y
N

## 提示​
对于 30%的数据有 N,Q&lt;= 1000
对于 100%的数据有 N,Q&lt;= 10^5,点权范围在 32 位整数范围内

## 题解
&gt;点权范围在 32 位整数范围内

也就是说，当a和b距离很远时一定能构成三角形
考虑构造不能构成三角形的一条链f[i-2]+f[i-1]=f[i]，1,1,2,3,5...，就是斐波那契，当i&gt;50时爆int，所以当dist(a,b)&gt;50时，输出y即可，否则暴力算

&lt;div style=&quot;display:none;&quot; class=&quot;copy&quot;&gt;
    <a href="/2016/10/04/noip-2014-10-30-2/sdtg.pas" title="{plain text}">{plain text}</a>
&lt;/div&gt;
```delphi sdtg.pas
uses math;
type 
    int=longint;ll=int64;
    edge=record v,next:int end;
var
    g:array[0..200010] of edge;
    par:array[0..100010,0..20] of int;
    a:array[0..52] of int;
    head,dep,w:array[0..100010] of int;
    sz,n,m,lg,i,j,d,p,u,v:int;

procedure add(u,v:int);
begin
    inc(sz);g[sz].v:=v;
    g[sz].next:=head[u];head[u]:=sz;
end;

procedure dfs(u,p:int);
var v,i:int;
begin
    par[u,0]:=p;dep[u]:=dep[p]+1;
    i:=head[u];
    while i&lt;&gt;0 do begin
        v:=g[i].v;
        if v&lt;&gt;p then dfs(v,u);
        i:=g[i].next;
    end;
end;

procedure swap(var a,b:int);
var tmp:int;
begin tmp:=a;a:=b;b:=tmp end;

function lca(u,v:int):int;
var i:int;
begin
    if dep[u]&lt;dep[v] then swap(u,v);
    for i:=lg downto 0 do
        if dep[par[u,i]]&gt;=dep[v] then
            u:=par[u,i];
    if u=v then exit(u);
    for i:=lg downto 0 do
        if par[u,i]&lt;&gt;par[v,i] then begin
            u:=par[u,i];v:=par[v,i];
        end;
    lca:=par[u,0];
end;

procedure qsort(l,r:int);
var i,j,x:int;
begin
    i:=l;j:=r;x:=a[random(r-l)+l];
    repeat
        while a[i]&lt;x do inc(i);
        while a[j]&gt;x do dec(j);
        if i&lt;=j then begin
            swap(a[i],a[j]);
            inc(i);dec(j);
        end;
    until i&gt;j;
    if i&lt;r then qsort(i,r);
    if l&lt;j then qsort(l,j);
end;

function calc(u,v,p:int):char;
var i,k:int;
begin
    k:=0;
    while u&lt;&gt;p do begin
        inc(k);a[k]:=w[u];u:=par[u,0];
    end;
    while v&lt;&gt;p do begin
        inc(k);a[k]:=w[v];v:=par[v,0];
    end;
    inc(k);a[k]:=w[p];
    qsort(1,k);
    for i:=1 to k-2 do
        if ll(a[i])+ll(a[i+1])&gt;ll(a[i+2]) then exit(&#39;Y&#39;);
    calc:=&#39;N&#39;;
end;

begin
    assign(input,&#39;sdtg.in&#39;);reset(input);
    assign(output,&#39;sdtg.out&#39;);rewrite(output);
    read(n,m);lg:=floor(ln(n)/ln(2));
    for i:=1 to n do read(w[i]);
    for i:=1 to n-1 do begin
        read(u,v);add(u,v);add(v,u);    
    end;
    dfs(1,0);
    for j:=1 to lg do
        for i:=1 to n do
            par[i,j]:=par[par[i,j-1],j-1];
    for i:=1 to m do begin
        read(j,u,v);
        if j=0 then begin
            p:=lca(u,v);
            d:=dep[u]+dep[v]-2*dep[p];
            if d&gt;52 then writeln(&#39;Y&#39;)
            else writeln(calc(u,v,p));
        end else w[u]:=v;
    end;
    close(input);close(output);
end.
</code></pre>]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[NOIP模拟赛 2014-10-31-1]]></title>
      <url>https://cothrax.github.io/2016/10/04/noip-2014-10-31-1/</url>
      <content type="html"><![CDATA[<table>
<thead>
<tr>
<th style="text-align:center">题目</th>
<th style="text-align:center">思路</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">and</td>
<td style="text-align:center">位运算+贪心</td>
</tr>
<tr>
<td style="text-align:center">elephant</td>
<td style="text-align:center">概率期望+DP</td>
</tr>
<tr>
<td style="text-align:center">move</td>
<td style="text-align:center">分层图最短路</td>
</tr>
<tr>
<td style="text-align:center">meteorite</td>
<td style="text-align:center">带权并查集</td>
</tr>
</tbody>
</table>
<h1 id="P1-“与”"><a href="#P1-“与”" class="headerlink" title="P1 “与”"></a>P1 “与”</h1><p>给你一个长度为n的序列A，请你求出一对Ai，Aj（<span>$1&le;i&lt;j&le;n$</span><!-- Has MathJax -->）使Ai“与”Aj最大。<br>Ps：“与”表示位运算and，在c++中表示为&amp;。</p>
<a id="more"></a>
<h2 id="格式"><a href="#格式" class="headerlink" title="格式"></a>格式</h2><h3 id="输入格式"><a href="#输入格式" class="headerlink" title="输入格式"></a>输入格式</h3><p>第一行为n。接下来n行，一行一个数字表示Ai。</p>
<h3 id="输出格式"><a href="#输出格式" class="headerlink" title="输出格式"></a>输出格式</h3><p>输出最大的Ai“与”Aj的结果。</p>
<h2 id="样例"><a href="#样例" class="headerlink" title="样例"></a>样例</h2><h3 id="样例输入"><a href="#样例输入" class="headerlink" title="样例输入"></a>样例输入</h3><blockquote>
<p>3<br>8<br>10<br>2</p>
</blockquote>
<h3 id="样例输出"><a href="#样例输出" class="headerlink" title="样例输出"></a>样例输出</h3><blockquote>
<p>8</p>
</blockquote>
<h2 id="提示​"><a href="#提示​" class="headerlink" title="提示​"></a>提示​</h2><p>样例解释：<br>8 and 10 = 8<br>8 and 2 = 0<br>10 and 2 = 2<br>数据范围：<br>20%的数据保证n&lt;=5000<br>100%的数据保证 n&lt;=3*10^5，0&lt;=Ai&lt;=10^9</p>
<h2 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h2><p>从高位到低位逐个考虑即可，如果第i位有≥2个数是1，就要取这一位</p>
<p><div style="display:none;" class="copy"><br>    <br></div><br>```delphi add.pas<br>type int=longint;<br>var<br>    n,i,p,j,ans:int;<br>    cnt:array[0..40] of int;<br>    a:array[0..300010] of int;</p>
<p>procedure calc(x:int);<br>var i:int;<br>begin<br>    for i:=0 to 30 do<br>        if ((x shr i) and 1)=1 then inc(cnt[i]);<br>end;</p>
<p>begin<br>    assign(input,’and.in’);reset(input);<br>    assign(output,’and.out’);rewrite(output);<br>    read(n);<br>    for i:=1 to n do read(a[i]);<br>    ans:=0;p:=31;<br>    while true do begin<br>        fillchar(cnt,sizeof(cnt),0);<br>        for i:=1 to n do<br>            if (ans and a[i])=ans then calc(a[i]);<br>        //for i:=0 to 31 do write(cnt[i]:3);writeln;<br>        j:=-1;<br>        for i:=p downto 0 do<br>            if cnt[i]&gt;=2 then begin<br>                ans:=ans or (1 shl i);<br>                j:=i-1;break;<br>            end;<br>        if j=-1 then break;<br>        p:=j;<br>    end;<br>    write(ans);<br>    close(input);close(output);<br>end.</p>
<pre><code>
# P2 小象涂色
小象喜欢为箱子涂色。小象现在有c种颜色，编号为0~c-1；还有n个箱子，编号为1~n，最开始每个箱子的颜色为1。小象涂色时喜欢遵循灵感：它将箱子按编号排成一排，每次涂色时，它随机选择[L，R]这个区间里的一些箱子（不选看做选0个），为之涂上随机一种颜色。若一个颜色为a的箱子被涂上b色，那么这个箱子的颜色会变成（a\*b）mod c。请问在k次涂色后，所有箱子颜色的编号和期望为多少？

&lt;!--more--&gt;

## 格式
### 输入格式
第一行为T，表示有T组测试数据。
对于每组数据，第一行为三个整数n,c,k。
接下来k行，每行两个整数Li，Ri，表示第i个操作的L和R。

### 输出格式
对于每组测试数据，输出所有箱子颜色编号和的期望值，结果保留9位小数。

## 样例
### 样例输入
&gt;3
3 2 2
2 2
1 3
1 3 1
1 1
5 2 2
3 4
2 4

### 样例输出
&gt;2.062500000
1.000000000
3.875000000

## 提示​
数据范围：
40%的数据1 &lt;= T &lt;= 5，1 &lt;= n, k &lt;= 15，2 &lt;= c &lt;= 20
100%的数据满足1 &lt;= T &lt;= 10，1 &lt;= n, k &lt;= 50，2 &lt;= c &lt;= 100，1 &lt;= Li &lt;= Ri &lt;= n

## 题解
看到概率期望就头疼。。。
求期望的话，可以先求概率
一次染色中，一个箱子被染色的概率为1/2，染成颜色i的概率为1/c
记f[i,j]为一个箱子染i次，染成颜色j的概率
DP：
$f[i+1,j]+=f[i,j]/2$
$f[i+1,(j\*p)\%c]+=f[i,j]/2/c$
初始：$f[0,1]=1$
答案：$\sum\_{i=1}^{n}\sum\_{j=0}^{c-1}f[a[i],j]\*j$
其中a[i]是箱子i被染色的次数，可以差分求，也可以暴力

&lt;div style=&quot;display:none;&quot; class=&quot;copy&quot;&gt;
    <a href="/2016/10/04/noip-2014-10-31-1/elephant.pas" title="{plain text}">{plain text}</a>
&lt;/div&gt;
```delphi elephant.pas
type int=longint;
const eps=0.00000000001;
var 
    f:array[0..55,0..110] of double;
    a:array[0..55] of int;
    t,n,m,k,i,j,p,l,r:int;ans,cur:double;

procedure incd(var a:double;b:double);
begin a:=a+b end;

begin
    assign(input,&#39;elephant.in&#39;);reset(input);
        assign(output,&#39;elephant.out&#39;);rewrite(output);
    read(t);
    repeat
        read(n,m,k);
        fillchar(a,sizeof(a),0);
        for i:=1 to k do begin
            read(l,r);
            inc(a[l]);dec(a[r+1]);
        end;
        for i:=1 to n do inc(a[i],a[i-1]);
        //dp
        fillchar(f,sizeof(f),0);
        f[0,1]:=1;
        for i:=0 to k do
            for j:=0 to m-1 do
                if f[i,j]&gt;eps then begin
                    incd(f[i+1,j],f[i,j]/2);
                    for p:=0 to m-1 do 
                        incd(f[i+1,(j*p) mod m],f[i,j]/2/m);
                end;
        //calc
        ans:=0;
        for i:=1 to n do begin
            cur:=0;
            for j:=0 to m-1 do
                incd(cur,f[a[i],j]*j);
            incd(ans,cur);
        end;
        writeln(ans:0:9);
        dec(t);
    until t=0;
    close(input);close(output);
end.
</code></pre><h1 id="P3-行动！行动！"><a href="#P3-行动！行动！" class="headerlink" title="P3 行动！行动！"></a>P3 行动！行动！</h1><p>大CX国的大兵Jack接到一项任务：敌方占领了n座城市（编号0~n-1），有些城市之间有双向道路相连。Jack需要空降在一个城市S，并徒步沿那些道路移动到T城市。虽然Jack每从一个城市到另一个城市都会受伤流血，但大CX国毕竟有着“过硬”的军事实力，它不仅已经算出Jack在每条道路上会损失的血量，还给Jack提供了k个“简易急救包”，一个包可以让Jack在一条路上的流血量为0。Jack想知道自己最少会流多少血，不过他毕竟是无脑的大兵，需要你的帮助。<br><!--more--></p>
<h2 id="格式-1"><a href="#格式-1" class="headerlink" title="格式"></a>格式</h2><h3 id="输入格式-1"><a href="#输入格式-1" class="headerlink" title="输入格式"></a>输入格式</h3><p>第一行有三个整数n,m,k，分别表示城市数，道路数和急救包个数。<br>第二行有两个整数，S,T。分别表示Jack空降到的城市编号和最终要到的城市。<br>接下来有m行，每行三个整数a,b,c，表示城市a与城市b之间有一条双向道路。</p>
<h3 id="输出格式-1"><a href="#输出格式-1" class="headerlink" title="输出格式"></a>输出格式</h3><p>Jack最少要流的血量。</p>
<h2 id="样例-1"><a href="#样例-1" class="headerlink" title="样例"></a>样例</h2><h3 id="样例输入-1"><a href="#样例输入-1" class="headerlink" title="样例输入"></a>样例输入</h3><blockquote>
<p>5 6 1<br>0 3<br>3 4 5<br>0 1 5<br>0 2 100<br>1 2 5<br>2 4 5<br>2 4 3</p>
</blockquote>
<h3 id="样例输出-1"><a href="#样例输出-1" class="headerlink" title="样例输出"></a>样例输出</h3><blockquote>
<p>8</p>
</blockquote>
<h2 id="提示​-1"><a href="#提示​-1" class="headerlink" title="提示​"></a>提示​</h2><p>对于30%的数据,2&lt;=n&lt;=50,1&lt;=m&lt;=300,k=0;<br>对于50%的数据,2&lt;=n&lt;=600,1&lt;=m&lt;=6000,0&lt;=k&lt;=1;<br>对于100%的数据,2&lt;=n&lt;=10000,1&lt;=m&lt;=50000,0&lt;=k&lt;=10.</p>
<h2 id="题解-1"><a href="#题解-1" class="headerlink" title="题解"></a>题解</h2><p>分层图最短路，建图后heap+dijkstra</p>
<p><div style="display:none;" class="copy"><br>    <a href="/2016/10/04/noip-2014-10-31-1/move.pas" title="{plain text}">{plain text}</a><br></div><br>```delphi move.pas<br>type<br>    int=longint;<br>    edge=record v,w,next:int end;<br>const inf=1000000000;<br>var<br>    g:array[0..2200010] of edge;<br>    head,l,d:array[0..110010] of int;<br>    h:array[0..110010,0..1] of int;<br>    n,m,k,sz,hs,u,v,w,s,t,i,j:int;</p>
<p>procedure add(u,v,w:int);<br>begin<br>    inc(sz);g[sz].v:=v;g[sz].w:=w;<br>    g[sz].next:=head[u];head[u]:=sz;<br>end;</p>
<p>procedure swap(i,j:int);<br>var tmp:int;<br>begin<br>    l[h[i,1]]:=j;l[h[j,1]]:=i;<br>    tmp:=h[i,0];h[i,0]:=h[j,0];h[j,0]:=tmp;<br>    tmp:=h[i,1];h[i,1]:=h[j,1];h[j,1]:=tmp;<br>end;</p>
<p>procedure hfy(i:int);<br>var l,r,s:int;<br>begin<br>    l:=i shl 1;r:=l or 1;<br>    if (l&lt;=hs) and (h[l,0]<h[i,0]) then="" s:="l" else="" if="" (r<="hs)" and="" (h[r,0]<h[s,0])="" i<="">s then begin<br>        swap(i,s);hfy(s);<br>    end;<br>end;</h[i,0])></p>
<p>procedure ext();<br>begin<br>    swap(1,hs);dec(hs);hfy(1);<br>end;</p>
<p>procedure red(i,k:int);<br>begin<br>    h[i,0]:=k;<br>    while (i&gt;1) and (h[i,0]&lt;h[i shr 1,0]) do begin<br>        swap(i,i shr 1);i:=i shr 1;<br>    end;<br>end;</p>
<p>procedure ins(x,k:int);<br>begin<br>    inc(hs);l[x]:=hs;<br>    h[hs,1]:=x;h[hs,0]:=inf;red(hs,k);<br>end;</p>
<p>procedure dij();<br>var i,u,v:int;<br>begin<br>    hs:=0;<br>    for i:=1 to n*(k+1) do<br>        if i=s then ins(i,0) else ins(i,inf);<br>    while hs&gt;0 do begin<br>        u:=h[1,1];d[u]:=h[1,0];ext;<br>        //writeln(‘&gt;’,u,’ ‘,d[u]);<br>        i:=head[u];<br>        while i&lt;&gt;0 do begin<br>            v:=g[i].v;<br>            if h[l[v],0]&gt;d[u]+g[i].w then<br>                red(l[v],d[u]+g[i].w);<br>            i:=g[i].next;<br>        end;<br>    end;<br>end;</p>
<p>begin<br>    assign(input,’move.in’);reset(input);<br>    assign(output,’move.out’);rewrite(output);<br>    read(n,m,k,s,t);inc(s);inc(t);<br>    for i:=1 to m do begin<br>        read(u,v,w);inc(u);inc(v);<br>        add(u,v,w);add(v,u,w);<br>        for j:=1 to k do begin<br>            add(u+j<em>n,v+j</em>n,w);add(u+(j-1)<em>n,v+j</em>n,0);<br>            add(v+j<em>n,u+j</em>n,w);add(v+(j-1)<em>n,u+j</em>n,0);<br>        end;<br>    end;<br>    dij();<br>    write(d[t+k*n]);<br>    close(input);close(output);<br>end.</p>
<pre><code>

# P4 Hzwer的陨石
经过不懈的努力，Hzwer召唤了很多陨石。已知Hzwer的地图上共有n个区域，且一开始的时候第i个陨石掉在了第i个区域。有电力喷射背包的ndsf很自豪，他认为搬陨石很容易，所以他将一些区域的陨石全搬到了另外一些区域。
在ndsf愉快的搬运过程中，Hzwer想知道一些陨石的信息。对于Hzwer询问的每个陨石i，你必须告诉他，在当前这个时候，i号陨石在所在区域x、x区域共有的陨石数y、以及i号陨石被搬运的次数z。
&lt;!--more--&gt;

## 格式
### 输入格式
输入的第一行是一个正整数T。表示有多少组输入数据。
接下来共有T组数据，对于每组数据，第一行包含两个整数：N和Q。
接下来Q行，每行表示一次搬运或一次询问，格式如下：
T A B：表示搬运，即将所有在A号球所在地区的陨石都搬到B号球所在地区去。
Q A：悟空想知道Ａ号陨石的x，y，z。
### 输出格式
对于第ｉ组数据，第一行输出“Case i：”接下来输出每一个询问操作的x，y，z，每一个询问操作的答案占一行。每组数据之间没有空行。
## 样例
### 样例输入
&gt;2
3 3
T 1 2
T 3 2
Q 2
3 4
T 1 2
Q 1
T 1 3
Q 1

### 样例输出
&gt;Case 1：
2 3 0
Case 2：
2 2 1
3 3 2

## 提示​
数据范围：
20%的数据保证：0≤T≤20，2＜N＜＝100，2＜Q＜＝100。
100%的数据保证：0≤T≤100，2＜N＜＝10000，2＜Q＜＝10000。
对于所有数据保证搬运操作中AB在Ｎ的范围内且所在区域不相同。

## 题解
带权并查集，用向量关系表示节点与父节点的移动次数差，区域编号就是根的编号，至于个数随便加加就好了

&lt;div style=&quot;display:none;&quot; class=&quot;copy&quot;&gt;
    <a href="/2016/10/04/noip-2014-10-31-1/meteorite.pas" title="{plain text}">{plain text}</a>
&lt;/div&gt;
```delphi meteorite.pas
type int=longint;
var 
    par,w,s:array[0..10010] of int;
    t,n,m,i,j,x,y:int;c:char;

function find(x:int):int;
begin
    if par[x]=x then find:=x
    else begin
        find:=find(par[x]);
        inc(w[x],w[par[x]]);
        par[x]:=find;
    end;
end;

procedure union(x,y:int); //x-&gt;y
begin
    x:=find(x);y:=find(y);
    par[x]:=y;inc(s[y],s[x]);
    inc(w[x]);w[x]:=w[y]-w[x];
end;

procedure query(x:int);
begin
    y:=find(x);writeln(y,&#39; &#39;,s[y],&#39; &#39;,w[y]-w[x]);
end;

begin
    assign(input,&#39;meteorite.in&#39;);reset(input);
    assign(output,&#39;meteorite.out&#39;);rewrite(output);
    readln(t);
    for j:=1 to t do begin
        readln(n,m);
        for i:=1 to n do begin 
            par[i]:=i;w[i]:=0;s[i]:=1
        end;
        writeln(&#39;Case &#39;,j,&#39;: &#39;);
        for i:=1 to m do begin
            read(c);
            case c of 
                &#39;T&#39;:begin readln(x,y);union(x,y) end;
                &#39;Q&#39;:begin readln(x);query(x) end;
            end;
        end;
    end;
    close(input);close(output);
end.
</code></pre>]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[NOIP模拟赛 graph]]></title>
      <url>https://cothrax.github.io/2016/10/04/noip-2014-10-30-1-graph/</url>
      <content type="html"><![CDATA[<p>这份模拟赛的后2题都在前面的比赛中出现过了。</p>
<h2 id="描述"><a href="#描述" class="headerlink" title="描述"></a>描述</h2><p>给出 N 个点，M 条边的有向图，对于每个点 v，求 A(v) 表示从点 v 出发，能到达的编号最大的点。<br><a id="more"></a></p>
<h2 id="格式"><a href="#格式" class="headerlink" title="格式"></a>格式</h2><h3 id="输入格式"><a href="#输入格式" class="headerlink" title="输入格式"></a>输入格式</h3><p>第 1 行，2 个整数 N,M。 接下来 M 行，每行 2 个整数 Ui,Vi，表示边 ⟨Ui,Vi⟩。点用 1,2,…,N 编号。</p>
<h3 id="输出格式"><a href="#输出格式" class="headerlink" title="输出格式"></a>输出格式</h3><p>N 个整数 A(1),A(2),…,A(N)。</p>
<h2 id="样例"><a href="#样例" class="headerlink" title="样例"></a>样例</h2><h3 id="样例输入"><a href="#样例输入" class="headerlink" title="样例输入"></a>样例输入</h3><blockquote>
<p>4 3<br>1 2<br>2 4<br>4 3</p>
</blockquote>
<h3 id="样例输出"><a href="#样例输出" class="headerlink" title="样例输出"></a>样例输出</h3><blockquote>
<p>4 4 3 4</p>
</blockquote>
<h2 id="提示​"><a href="#提示​" class="headerlink" title="提示​"></a>提示​</h2><p>对于 60% 的数据，1 ≤ N,K ≤ 10^3<br>对于 100% 的数据，1 ≤ N,M ≤ 10^5。</p>
<h2 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h2><p>标程是强连通分量+DAG+DP<br>其实乱搞就可以了，参见noip提高的最优贸易那题<br>在转置图上，类似spfa进行松弛即可：<br>对于转置边e(v,u)，如果A(v)&gt;A(u)，那么更新A(u)，且u入队</p>
<p><div style="display:none;" class="copy"><br>    <a href="/2016/10/04/noip-2014-10-30-1-graph/graph.pas" title="{plain text}">{plain text}</a><br></div><br>```delphi graph.pas<br>type<br>    int=longint;<br>    edge=record u,next:int end;<br>var<br>    g:array[0..100010] of edge;<br>    head,w,q:array[0..100010] of int;<br>    inq:array[0..100010] of boolean;<br>    n,m,i,v,u,sz,h,t:int;</p>
<p>procedure add(v,u:int);<br>begin<br>    inc(sz);g[sz].u:=u;<br>    g[sz].next:=head[v];head[v]:=sz;<br>end;</p>
<p>begin<br>    assign(input,’graph.in’);reset(input);<br>    assign(output,’graph.out’);rewrite(output);<br>    read(n,m);sz:=0;<br>    for i:=1 to m do begin<br>        read(v,u);add(u,v);<br>    end;<br>    h:=1;t:=n+1;<br>    for i:=1 to n do begin<br>        w[i]:=i;q[i]:=n-i+1;<br>    end;<br>    fillchar(inq,sizeof(inq),true);<br>    while h&lt;&gt;t do begin<br>        v:=q[h];inq[v]:=false;//writeln(v);<br>        inc(h);if h&gt;100010 then h:=0;<br>        i:=head[v];<br>        while i&lt;&gt;0 do begin<br>            u:=g[i].u;<br>            if w[u]<w[v] then="" begin="" w[u]:="w[v];//writeln(v,'-">',u);
                if not inq[u] then begin
                    q[t]:=u;inq[u]:=true;
                    inc(t);if t>100010 then t:=0;<br>                end;<br>            end;<br>            i:=g[i].next;<br>        end;<br>    end;<br>    for i:=1 to n do write(w[i],’ ‘);<br>    close(input);close(output);<br>end.<br>```</w[v]></p>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[NOIP2016十连测 Day 2]]></title>
      <url>https://cothrax.github.io/2016/10/03/lydsy-noip-2016-test2/</url>
      <content type="html"><![CDATA[<p>160滚粗，T1很db地写了hash，T2没想到二分而暴力询问，inf开的不够大又丢了20分，T3完全不会，暴力20分</p>
<h1 id="T1-Divisors"><a href="#T1-Divisors" class="headerlink" title="T1 Divisors"></a>T1 Divisors</h1><p>大意：给定m个不同的正整数 <span>$a_1,a_2,...,a_m$</span><!-- Has MathJax -->，对$[0,m]$内每一个k计算：在区间$[1,n]$里有多少正整数是a中恰好k个数的约数。<br>$m≤200;n,a_i≤10^9$ 。<br><a id="more"></a></p>
<h2 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h2><p>计算每个$a_i$在$[1,n]$内的约数，然后去重计数即可。我sb的用了hash，其实qsort+for就好。</p>
<p><div style="display:none;" class="copy"><br>    <a href="/2016/10/03/lydsy-noip-2016-test2/div.pas" title="{plain text}">{plain text}</a><br></div><br>```delphi div.pas<br>uses math;<br>type int=longint;<br>const md=1001003;<br>var<br>    a,ans:array[0..210] of int;<br>    h,next,cnt:array[0..10000000] of int;<br>    head:array[0..md] of int;<br>    sz,n,m,i,tot:int;</p>
<p>procedure insert(x:int);<br>var i,j:int;<br>begin<br>    j:=x mod md;<br>    if head[j]=0 then begin<br>        inc(sz);head[j]:=sz;<br>        h[sz]:=x;cnt[sz]:=1;<br>        exit;<br>    end;<br>    i:=head[j];<br>    while next[i]&lt;&gt;0 do begin<br>        if h[i]=x then begin inc(cnt[i]);exit end;<br>        i:=next[i];<br>    end;<br>    if h[i]=x then begin inc(cnt[i]);exit end;<br>    inc(sz);next[i]:=sz;<br>    h[sz]:=x;cnt[sz]:=1;<br>end;</p>
<p>procedure calc(x:int);<br>var i:int;<br>begin<br>    for i:=1 to trunc(sqrt(x)) do<br>        if x mod i=0 then begin<br>            insert(i);<br>            if i&lt;&gt;x div i then insert(x div i);<br>        end;<br>end;</p>
<p>begin<br>    //assign(input,’div.in’);reset(input);<br>    //assign(output,’div.out’);rewrite(output);<br>    read(n,m);<br>    sz:=0;<br>    for i:=1 to m do read(a[i]);<br>    for i:=1 to m do calc(a[i]);<br>    tot:=0;<br>    for i:=1 to sz do<br>        if h[i]&lt;=n then begin<br>            inc(tot);<br>            if cnt[i]&lt;=m then inc(ans[cnt[i]]);<br>        end;<br>    writeln(n-tot);<br>    for i:=1 to m do writeln(ans[i]);<br>    //close(input);close(output);<br>end.</p>
<pre><code>
# T2 Market
给定n个物品，每个物品可以不选或选一个，第i个物品的价格为ci,价值为vi,出现时间为ti。有m个询问，每次询问在出现时间不超过Ti的所有物品中选若干件,总花费不超过Mi的情况下,被选择物品的价值和的最大值是多少。
$n≤300,m≤100000;c\_i,M\_i≤10^9,v\_i≤300$

&lt;!--more--&gt;

## 题解
先将物品qsort升序
首先想到01背包，但c和M太大无法承受。
考虑到vi很小：记f[i,j]为1..i件物品选出j的价值和的最小花费
$O(N^3)$，空间刚好足够
对于一个询问的答案就是：
算出在Ti时间内所能购买的物品范围[1,x]
答案就是满足$f[x,j]≤Mi$的最大j
暴力处理询问的话依然会TLE
于是二分：
记g[x,j]为f[x,j...]的最小值，这样g[x]就是单调增的
答案就是满足$g[x,j]≤Mi$的最大j

&lt;div style=&quot;display:none;&quot; class=&quot;copy&quot;&gt;
    <a href="/2016/10/03/lydsy-noip-2016-test2/market.pas" title="{plain text}">{plain text}</a>
&lt;/div&gt;
```delphi market.pas
uses math;
type int=longint;
const inf=1000000010;
var
    v,t,c,sum:array[0..310] of int;
    f:array[0..310,0..90010] of int;
    n,m,i:int;

procedure swap(var a,b:int);
var tmp:int;
begin tmp:=a;a:=b;b:=tmp end;

procedure qsort(l,r:int);
var i,j,x:int;
begin
    i:=l;j:=r;x:=t[random(r-l)+l];
    repeat
        while t[i]&lt;x do inc(i);
        while t[j]&gt;x do dec(j);
        if i&lt;=j then begin
            swap(t[i],t[j]);swap(v[i],v[j]);swap(c[i],c[j]);
            inc(i);dec(j);
        end;
    until i&gt;j;
    if i&lt;r then qsort(i,r);
    if l&lt;j then qsort(l,j);
end;

procedure dp();
var i,j:int;
begin
    sum[0]:=0;
    for i:=1 to n do sum[i]:=sum[i-1]+v[i];
    filldword(f,sizeof(f) div 4,inf);
    f[0,0]:=0;
    for i:=1 to n do
        for j:=0 to sum[i] do begin
            f[i,j]:=f[i-1,j];
            if j&gt;=v[i] then 
                f[i,j]:=min(f[i,j],f[i-1,j-v[i]]+c[i]);
        end;
    for i:=1 to n do
        for j:=sum[i]-1 downto 0 do
            f[i,j]:=min(f[i,j],f[i,j+1]);
end;

function calc():int;
var l,r,mid,x,t0,m0:int;
begin
    read(t0,m0);
    l:=1;r:=n;x:=-1;
    while l&lt;=r do begin
        mid:=(l+r) shr 1;
        if t[mid]&lt;=t0 then begin x:=mid;l:=mid+1 end
        else r:=mid-1;
    end;
    if x=-1 then exit(0);
    l:=0;r:=sum[x];calc:=0;
    //max_v{f[x,v]&lt;=m0}
    while l&lt;=r do begin
        mid:=(l+r) shr 1;
        if f[x,mid]&lt;=m0 then begin calc:=mid;l:=mid+1 end
        else r:=mid-1;
    end;
end;

begin
    //assign(input,&#39;market.in&#39;);reset(input);
    //assign(output,&#39;market.ans&#39;);rewrite(output);
    read(n,m);
    for i:=1 to n do read(c[i],v[i],t[i]);
    qsort(1,n);dp();
    for i:=1 to m do writeln(calc());
    //close(input);close(output);
end.
</code></pre><h1 id="T3-Dash-Speed"><a href="#T3-Dash-Speed" class="headerlink" title="T3 Dash Speed"></a>T3 Dash Speed</h1><p>给定一棵有n个点的树,每条边有承受区间[li,ri]。m次询问,每次给定一个值speed,求一条最长的链,使得上面所有边的承受区间都包括speed。</p>
<h2 id="题解-1"><a href="#题解-1" class="headerlink" title="题解"></a>题解</h2><p>树剖+线段树+并查集+分治，std都破100行了，如果我写不是要300+吗<br>来欣赏一下std吧</p>
<p><div style="display:none;" class="copy"><br>    <a href="/2016/10/03/lydsy-noip-2016-test2/speed.cpp" title="{plain text}">{plain text}</a><br></div><br>```cpp speed.cpp</p>
<p>#include<cstdio></cstdio></p>
<p>#include<algorithm><br>using namespace std;<br>const int N=70010,M=N<em>20;<br>int n,m,i,g[N],v[N&lt;<1],nxt[n<<1],ed,cur,ans[n]; int="" size[n],f[n],d[n],son[n],top[n];="" fa[n],dep[n],a[n],b[n];="" g[262150],v[m],w[m],nxt[m],ed;="" struct="" e{int="" t,x,y;e(){}e(int="" _t,int="" _x,int="" _y){t="_t,x=_x,y=_y;}}q[N<<2];" void="" add(int="" x,int="" y){v[++ed]="y;nxt[ed]=g[x];g[x]=ed;}" dfs(int="" x){="" size[x]="1;" for(int="" i="g[x];i;i=nxt[i])if(v[i]!=f[x]){" f[v[i]]="x,d[v[i]]=d[x]+1;" dfs(v[i]),size[x]+="size[v[i]];" if(size[v[i]]="">size[son[x]])son[x]=v[i];<br>    }<br>}<br>void dfs2(int x,int y){<br>    top[x]=y;<br>    if(son[x])dfs2(son[x],y);<br>    for(int i=g[x];i;i=nxt[i])if(v[i]!=son[x]&amp;&amp;v[i]!=f[x])dfs2(v[i],v[i]);<br>}<br>int lca(int x,int y){<br>    for(;top[x]!=top[y];x=f[top[x]])if(d[top[x]]&lt;d[top[y]])swap(x,y);<br>    return d[x]&lt;d[y]?x:y;<br>}<br>int dis(int x,int y){return d[x]+d[y]-2</1],nxt[n<<1],ed,cur,ans[n];></em>d[lca(x,y)];}<br>int F(int x){return fa[x]==x?x:F(fa[x]);}<br>void merge(int x,int y,int&amp;ret){<br>    x=F(x),y=F(y);<br>    int u,v,t=-1,tmp;<br>    tmp=dis(A[x],B[x]);<br>    if(tmp&gt;t)t=tmp,u=A[x],v=B[x];<br>    tmp=dis(A[x],A[y]);<br>    if(tmp&gt;t)t=tmp,u=A[x],v=A[y];<br>    tmp=dis(A[x],B[y]);<br>    if(tmp&gt;t)t=tmp,u=A[x],v=B[y];<br>    tmp=dis(B[x],A[y]);<br>    if(tmp&gt;t)t=tmp,u=B[x],v=A[y];<br>    tmp=dis(B[x],B[y]);<br>    if(tmp&gt;t)t=tmp,u=B[x],v=B[y];<br>    tmp=dis(A[y],B[y]);<br>    if(tmp&gt;t)t=tmp,u=A[y],v=B[y];<br>    if(ret<t)ret=t; if(dep[x]="=dep[y]){" dep[x]++;="" q[++cur]="E(0,x,0);" }="" if(dep[x]<dep[y])swap(x,y);="" fa[y]="x,A[x]=u,B[x]=v;" void="" retrace(int="" t){="" while(cur="">t){<br>        if(!q[cur].t)dep[q[cur].x]–;<br>        if(q[cur].t==1)fa[q[cur].x]=q[cur].x;<br>        if(q[cur].t==2)A[q[cur].x]=q[cur].y;<br>        if(q[cur].t==3)B[q[cur].x]=q[cur].y;<br>        cur–;<br>    }<br>}<br>void ins(int x,int a,int b,int c,int d,int p,int q){<br>    if(c&lt;=a&amp;&amp;b&lt;=d){<br>        V[++ED]=p;<br>        W[ED]=q;<br>        NXT[ED]=G[x];<br>        G[x]=ED;<br>        return;<br>    }<br>    int mid=(a+b)&gt;&gt;1;<br>    if(c&lt;=mid)ins(x&lt;<1,a,mid,c,d,p,q); if(d="">mid)ins(x&lt;<1|1,mid+1,b,c,d,p,q); }="" void="" solve(int="" x,int="" a,int="" b,int="" ret){="" int="" pos="cur;" for(int="" i="G[x];i;i=NXT[i])merge(V[i],W[i],ret);" if(a="=b){" ans[a]="ret;" retrace(pos);="" return;="" mid="(a+b)">&gt;1;<br>    solve(x&lt;&lt;1,a,mid,ret);<br>    solve(x&lt;&lt;1|1,mid+1,b,ret);<br>    retrace(pos);<br>}<br>int main(){<br>    freopen(“speed.in”,”r”,stdin);freopen(“speed.out”,”w”,stdout);<br>    scanf(“%d%d”,&amp;n,&amp;m);<br>    for(i=1;i&lt;n;i++){<br>        int x,y,l,r;<br>        scanf(“%d%d%d%d”,&amp;x,&amp;y,&amp;l,&amp;r);<br>        add(x,y),add(y,x);<br>        ins(1,1,n,l,r,x,y);<br>    }<br>    dfs(1);dfs2(1,1);<br>    for(i=1;i&lt;=n;i++)fa[i]=A[i]=B[i]=i;<br>    solve(1,1,n,0);<br>    while(m–)scanf(“%d”,&amp;i),printf(“%d\n”,ans[i]);<br>    fclose(stdin);fclose(stdout);<br>    return 0;<br>}<br>```</1|1,mid+1,b,c,d,p,q);></1,a,mid,c,d,p,q);></t)ret=t;></algorithm></p>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[NOIP2016十连测 Day 1]]></title>
      <url>https://cothrax.github.io/2016/10/02/lydsy-noip-2016-test1/</url>
      <content type="html"><![CDATA[<p>没有人通知我提交的ftp地址，然后测试时在没有上数据的oj上交了n次囧</p>
<h1 id="P1-String-Master"><a href="#P1-String-Master" class="headerlink" title="P1 String Master"></a>P1 String Master</h1><p>大意：给定两个长度n的字符串，允许修改k次，求它们的最长公共子串（<strong>连续子串</strong>）。<br>n≤300,0≤k≤n。</p>
<a id="more"></a>
<h2 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h2><p>修改一定是贪心改掉失配的字符<br>记f[i,j,k]为a[1..i]和b[1..j]修改k次后的以a[i]和b[j]结尾的最长子串的长度。<br>不修改的部分：</p>
<ol>
<li>a[i]=a[j]时，f[i,j,0]=f[i-1,j-1,0]+1</li>
<li>a[i]≠a[j]时，f[i,j,0]=0</li>
</ol>
<p>考虑修改：</p>
<ol>
<li>a[i]=a[j]时，f[i,j,k]=f[i-1,j-1,k]+1</li>
<li>a[i]≠a[j]时，f[i,j,k]=f[i-1,j-1,k-1]+1</li>
</ol>
<p>答案在转移过程中统计</p>
<p><div style="display:none;" class="copy"><br>    <a href="/2016/10/02/lydsy-noip-2016-test1/master.pas" title="{plain text}">{plain text}</a><br></div><br>```delphi master.pas<br>uses math;<br>type int=longint;<br>var<br>    a,b:ansistring;<br>    n,m,i,j,k,p,c,ans:int;<br>    f:array[0..1,0..310,0..310] of int;</p>
<p>begin<br>    //assign(input,’master.in’);reset(input);<br>    //assign(output,’master.out’);rewrite(output);<br>    readln(n,m);readln(a);readln(b);<br>    ans:=0;<br>    for i:=1 to n do<br>        for j:=1 to n do begin<br>            if a[i]=b[j] then f[0,i,j]:=f[0,i-1,j-1]+1<br>            else f[0,i,j]:=0;<br>            ans:=max(ans,f[0,i,j]);<br>        end;<br>    for k:=1 to m do begin<br>        c:=k and 1;p:=c xor 1;<br>        fillchar(f[c],sizeof(f[c]),0);<br>        for i:=1 to n do<br>            for j:=1 to n do begin<br>                f[c,i,j]:=f[p,i-1,j-1]+1;<br>                if a[i]=b[j] then<br>                    f[c,i,j]:=max(f[c,i,j],f[c,i-1,j-1]+1);<br>                ans:=max(ans,f[c,i,j]);<br>            end;<br>    end;<br>    write(ans);<br>    //close(input);close(output);<br>end.</p>
<pre><code>
# P2 Tourist Attractions
大意：给定n个节点的无向图的邻接矩阵，统计经过4个点的简单路径的数量。
n≤1500
&lt;!--more--&gt;

## 题解
先统计经过三条边的路径，再减掉三元环的数量
至于前面那个，我的递推方法比较sb：
f[v,i]表示v为起点经过i个点的路径数
1. f[v,1]=2
2. f[v,2]=度数
3. f[v,k]+=f[u,k-1]-f[v,k-2]+1

标程是枚举边，统计顶点入度乘积
至于三元环：记与v有直接连边的点构成的集合为s[v]
那么，对于边e(v,u)，所构成的三元环数量即$card(s[v]∩s[u])$
这个可以用bitset，悲剧的pascal只好手写，没有涉及位移操作，所以还算好写。

&lt;div style=&quot;display:none;&quot; class=&quot;copy&quot;&gt;
    <a href="/2016/10/02/lydsy-noip-2016-test1/tour.pas" title="{plain text}">{plain text}</a>
&lt;/div&gt;
```delphi tour.pas
uses math;
type 
    int=longint;
    edge=record t,next:int end;
var 
    g:array[0..2250010] of edge;
    mat:array[0..1510,0..1510] of char;
    head:array[0..1510] of int;
    f:array[0..1510,0..4] of int64;
    cnt:array[0..1 shl 20] of int;
    b:array[0..1510,0..80] of int;
    n,sz,i,j,v,u:int;ans:int64;

procedure add(f,t:int);
begin
    inc(sz);g[sz].t:=t;
    g[sz].next:=head[f];head[f]:=sz;
end;

function tri():int64;
var i,j,k,p,t,x:int;
begin
    t:=20;p:=floor((n-1)/t)+1;
    for i:=1 to 1 shl t do
        cnt[i]:=cnt[i and (i-1)]+1;
    for i:=1 to n do
        for j:=0 to p-1 do
            for k:=0 to t-1 do
                if mat[i,j*t+k+1]=&#39;1&#39; then
                    b[i,j]:=b[i,j] or (1 shl k);
    tri:=0;
    for i:=1 to n do
        for j:=1 to n do
            if mat[i,j]=&#39;1&#39; then
                for k:=0 to p-1 do begin
                    x:=b[i,k] and b[j,k];
                    inc(tri,int64(cnt[x]));    
                end;
end;

begin
    assign(input,&#39;tour.in&#39;);reset(input);
    assign(output,&#39;tour.out&#39;);rewrite(output);
    readln(n);sz:=0;
    for i:=1 to n do f[i,1]:=2;
    for i:=1 to n do begin
        for j:=1 to n do begin
            read(mat[i,j]);
            if mat[i,j]=&#39;1&#39; then begin
                add(i,j);inc(f[i,2]);
            end;
        end;
        readln;
    end;
    for j:=3 to 4 do
        for v:=1 to n do begin
            i:=head[v];
            while i&lt;&gt;0 do begin
                u:=g[i].t;
                inc(f[v,j],f[u,j-1]-f[v,j-2]+1);
                i:=g[i].next;
            end;
        end;
    ans:=0;
    for i:=1 to n do inc(ans,f[i,4]);
    write(ans-tri());
    close(input);close(output);
end.
</code></pre><h2 id="UPD-2016-11-5"><a href="#UPD-2016-11-5" class="headerlink" title="UPD: 2016-11-5"></a>UPD: 2016-11-5</h2><p>今天回头看了标算，发现有常数更小的写法<br>一些小技巧，比如说：统计1的位数可以拆开处理，节省预处理cnt的时间</p>
<p><div style="display:none;" class="copy"><br>    <a href="/2016/10/02/lydsy-noip-2016-test1/tour_tmp.pas" title="{plain text}">{plain text}</a><br></div><br>```delphi _tour_tmp.pas<br>type<br>    int=longint;qw=qword;<br>    bit=array[0..25] of qw;<br>const mx:qw=1 shl 16-1;<br>var<br>    cnt:array[0..65536] of int;<br>    deg:array[0..1510] of int;<br>    g:array[0..1510,0..1510] of char;<br>    f:array[0..1510] of bit;<br>    i,j,n,m:int;ans:int64;</p>
<p>function _cnt(x:qword):int;<br>begin<br>    _cnt:=cnt[x and mx]+cnt[(x shr 16)and mx]+<br>        cnt[(x shr 32)and mx]+cnt[(x shr 48)and mx];<br>end;</p>
<p>procedure _set(var x:bit;i:int);<br>begin x[i shr 6]:=x[i shr 6]or (qw(1) shl (i and 63)) end;</p>
<p>function inter(var x,y:bit):int;<br>var i:int;<br>begin<br>    inter:=0;<br>    for i:=0 to m do inc(inter,_cnt(x[i] and y[i]));<br>end;</p>
<p>begin<br>    assign(input,’tour.in’);reset(input);<br>    assign(output,’tour.out’);rewrite(output);<br>    readln(n);m:=(n-1) shr 6;<br>    for i:=1 to n do begin<br>        for j:=1 to n do read(g[i,j]);<br>        readln;<br>    end;<br>    for i:=1 to mx do cnt[i]:=cnt[i and(i-1)]+1;<br>    for i:=1 to n do<br>        for j:=1 to n do<br>            if g[i,j]=’1’ then<br>                begin inc(deg[i]);_set(f[i],j) end;<br>    ans:=0;<br>    for i:=1 to n do<br>        for j:=1 to n do<br>            if g[i,j]=’1’ then<br>                inc(ans,(deg[i]-1)*(deg[j]-1)-inter(f[i],f[j]));<br>    write(ans);<br>    close(input);close(output);<br>end.</p>
<pre><code>
还有dword的版本，常数比qword大一些

&lt;div style=&quot;display:none;&quot; class=&quot;copy&quot;&gt;
    <a href="/2016/10/02/lydsy-noip-2016-test1/tour_.pas" title="{plain text}">{plain text}</a>
&lt;/div&gt;
```delphi _tour.pas
type 
    int=longint;dw=dword;
    bit=array[0..50] of dw;
const mx=1 shl 16;
var
    cnt:array[0..mx+10] of int64;
    deg:array[0..1510] of int64;
    g:array[0..1510,0..1510] of char;
    f:array[0..1510] of bit;
    i,j,n,m:int;ans:int64;

function _cnt(x:dword):int64;
begin _cnt:=cnt[x shr 16]+cnt[x and (mx-1)] end;

procedure _set(var x:bit;i:int);
begin x[i shr 5]:=x[i shr 5]or dw(1 shl (i and 31)) end;

function inter(var x,y:bit):int64;
var i:int;
begin
    inter:=0;
    for i:=0 to m do inc(inter,_cnt(x[i] and y[i]));
end;

begin
    assign(input,&#39;tour.in&#39;);reset(input);
    assign(output,&#39;tour.out&#39;);rewrite(output);
    readln(n);m:=(n-1) shr 5;
    for i:=1 to n do begin
        for j:=1 to n do read(g[i,j]);
        readln;
    end;
    for i:=1 to mx do cnt[i]:=cnt[i and(i-1)]+1;
    for i:=1 to n do
        for j:=1 to n do
            if g[i,j]=&#39;1&#39; then 
                begin inc(deg[i]);_set(f[i],j) end;
    ans:=0;
    for i:=1 to n do
        for j:=1 to n do
            if g[i,j]=&#39;1&#39; then
                inc(ans,(deg[i]-1)*(deg[j]-1)-inter(f[i],f[j]));
    write(ans);
    close(input);close(output);
end.
</code></pre><h1 id="P3-Walk"><a href="#P3-Walk" class="headerlink" title="P3 Walk"></a>P3 Walk</h1><p>大意：给定一张有n个点的有向图，原来就有m条边，每个点i有一个权值v[i]，如果$v[i]\ and\ v[j]=v[j]$，那么i到j有额外的一条边。所有边的边权都是1，求从点1出发到所有点的最短路，如果不可达输出-1<br>n≤200000,m≤300000。1≤v[i]≤2e20</p>
<h2 id="题解-1"><a href="#题解-1" class="headerlink" title="题解"></a>题解</h2><p>这一题非常的神（对于我这种蒟蒻来缩）<br>首先对于所有权值新增2e20个点</p>
<ol>
<li>点i的权值为v[i]，那么i到v[i]连权1的边，v[i]到i连权0的边</li>
<li>对于权值之间连权0的边，具体来说，i只需要向i去掉某一位的1的点连边。</li>
</ol>
<p>这样边数只有20*2e20+2n+m。<br>实现细节</p>
<ol>
<li>20*2e20的边不用存，否则mle，只需要在转移时处理即可</li>
<li>权0和权1的边分开存，方便每次bfs时把用0权值的边连接的所有点都加入队尾,以保证距离不降。</li>
<li>上述过程可用bfs套dfs来实现</li>
</ol>
<p><div style="display:none;" class="copy"><br>    <a href="/2016/10/02/lydsy-noip-2016-test1/walk.pas" title="{plain text}">{plain text}</a><br></div><br>```delphi walk.pas<br>type<br>    int=longint;<br>    edge=record t,next:int end;<br>    graph=array[0..500010] of edge;<br>    arr=array[0..1300010] of int;<br>const mx=1 shl 20;inf=maxlongint shr 2;<br>var<br>    g0,g1:graph;h0,h1,d,q:arr;<br>    n,m,i,j,f,t,h:int;</p>
<p>procedure add(var g:graph;var head:arr;f,t:int);<br>var sz:int;<br>begin<br>    inc(head[0]);sz:=head[0];<br>    g[sz].t:=t;<br>    g[sz].next:=head[f];head[f]:=sz;<br>end;</p>
<p>procedure dfs(v,w:int);<br>var i,j,x,u:int;<br>begin<br>    d[v]:=w;q[t]:=v;inc(t);<br>    i:=h0[v];<br>    while i&lt;&gt;0 do begin<br>        u:=g0[i].t;<br>        if d[u]=inf then dfs(u,w);<br>        i:=g0[i].next;<br>    end;<br>    if v&gt;mx then exit;<br>    j:=v;<br>    while j&gt;0 do begin<br>        x:=j and (-j);<br>        if (v&lt;&gt;x) and (d[v-x]=inf) then dfs(v-x,w);<br>        dec(j,x);<br>    end;<br>end;</p>
<p>procedure bfs();<br>var i,v,u:int;<br>begin<br>    filldword(d,sizeof(d) div 4,inf);<br>    h:=1;t:=2;q[h]:=mx+1;<br>    d[mx+1]:=0;<br>    while h&lt;&gt;t do begin<br>        v:=q[h];inc(h);i:=h1[v];<br>        while i&lt;&gt;0 do begin<br>            u:=g1[i].t;<br>            if d[u]=inf then dfs(u,d[v]+1);<br>            i:=g1[i].next;<br>        end;<br>    end;<br>end;</p>
<p>begin<br>    read(n,m);<br>    for i:=1 to n do begin<br>        read(j);<br>        add(g1,h1,i+mx,j);<br>        add(g0,h0,j,i+mx);<br>    end;<br>    for i:=1 to m do begin<br>        read(f,t);<br>        add(g1,h1,f+mx,t+mx);<br>    end;<br>    bfs();<br>    for i:=mx+1 to mx+n do<br>        if d[i]=inf then writeln(-1) else writeln(d[i]);<br>end.<br>```</p>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[NOIP模拟赛 2014-10-28]]></title>
      <url>https://cothrax.github.io/2016/09/30/noip-2014-10-28/</url>
      <content type="html"><![CDATA[<table>
<thead>
<tr>
<th style="text-align:center">题目</th>
<th style="text-align:center">思路</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">tstrip</td>
<td style="text-align:center">二分+最短路+负环</td>
</tr>
<tr>
<td style="text-align:center">puzzle</td>
<td style="text-align:center">dfs</td>
</tr>
<tr>
<td style="text-align:center">greendam</td>
<td style="text-align:center">最短路+最小割</td>
</tr>
</tbody>
</table>
<h1 id="P1-时间与空间之旅"><a href="#P1-时间与空间之旅" class="headerlink" title="P1 时间与空间之旅"></a>P1 时间与空间之旅</h1><p>公元22××年，宇宙中最普遍的交通工具是spaceship。spaceship的出现使得星系之间的联系变得更为紧密，所以spaceship船长也成了最热门的职业之一。当然，要成为一名出色的船长，必须通过严格的考核，例如下面是最简单的问题中的一个。<br>用1~n的整数给n个星系标号，目前你在标号为1的星系，你需要送快递到标号为n的星系，星系之间由于存在陨石带，并不是都可以直连的。同时，由于超时空隧道的存在，在某些星系间飞行会出现时间静止甚至倒流，飞行时间为0或为负数。另外,由星系i到星系j的时间和由星系j到星系i的时间不一定是相同的。<br>在寄出日期之前收到快递被认为是不允许的，所以每部spaceship上都有一个速度调节装置，可以调节飞行的时间。简单来说其功能就是让所有两个星系间的飞行时间(如果可以直达)都增加或减少相同的整数值，你的任务就是调整速度调节器，找出一条用最短时间完成任务的路径，并且保证这个最短时间的值大于或等于0。<br><a id="more"></a></p>
<h2 id="格式"><a href="#格式" class="headerlink" title="格式"></a>格式</h2><h3 id="输入格式"><a href="#输入格式" class="headerlink" title="输入格式"></a>输入格式</h3><p>输入文件包含多组数据，第1个数为T，表示数据的数量。<br>对于每一组数据，输入第1行为两个正整数N(2≤N≤100)，E(1≤E≤N*(N-1)/2)，为星系的个数和星系间飞行的路线数。然后E行，每行三个整数i，j和t（1≤i,j≤N，i≠j，-100000≤t≤100000)，表示由星系i到星系j飞行的时间为t。由i到j最多只会有一条飞行线路。</p>
<h3 id="输出格式"><a href="#输出格式" class="headerlink" title="输出格式"></a>输出格式</h3><p>输出文件共T行，每组数据输出一行；<br>如果可以通过调节速度调节器完成任务，则输出一个非负整数，表示由星系1到星系N的最短时间。<br>如果不能由星系1到达星系N，则输出-1。</p>
<h2 id="样例"><a href="#样例" class="headerlink" title="样例"></a>样例</h2><h3 id="样例输入"><a href="#样例输入" class="headerlink" title="样例输入"></a>样例输入</h3><blockquote>
<p>1<br>4 5<br>1 2 1<br>1 3 1<br>2 3 -3<br>3 1 1<br>3 4 1</p>
</blockquote>
<h3 id="样例输出"><a href="#样例输出" class="headerlink" title="样例输出"></a>样例输出</h3><blockquote>
<p>2</p>
</blockquote>
<h2 id="提示​"><a href="#提示​" class="headerlink" title="提示​"></a>提示​</h2><p>如果设置速度控制器的值为0，则有如下路径:1→2→3→1→2→……→3→4，使得投递的时间为负无穷大，显然是不符合要求的，所以应该把速度控制器的值设为1,相当于每个时间值加1,得到的最短路径为1→2→3→4,所需时间为2+(-2)+2=2。</p>
<h2 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h2><p>题意：给图上的所有边权加上一个整数，在保证1到n存在最短路的情况下，最小化该值。<br>先bfs两次，重构图，只保留同时在1到n路径上的点<br>然后二分+spfa，顺便判负环</p>
<p><div style="display:none;" class="copy"><br>    <a href="/2016/09/30/noip-2014-10-28/tstrip.pas" title="{plain text}">{plain text}</a><br></div><br>```delphi tstrip.pas<br>type<br>    int=longint;<br>    edge=record f,t,w,next:int end;<br>    arr=array[0..110] of int;<br>    graph=array[0..10010] of edge;<br>const inf=100000000;<br>var<br>    g,gt:graph;head,ht,q,cnt,d:arr;<br>    flag:array[0..110] of boolean;<br>    t,n,m,i,x,y,w,l,r,ans,mid:int;</p>
<p>procedure add(var g:graph;var head:arr;f,t,w:int);<br>var sz:int;<br>begin<br>    inc(head[0]);sz:=head[0];<br>    g[sz].f:=f;g[sz].t:=t;g[sz].w:=w;<br>    g[sz].next:=head[f];head[f]:=sz;<br>end;</p>
<p>procedure bfs(g:graph;head:arr;s:int);<br>var<br>    i,v,u,h,t:int;<br>    used:array[0..110] of boolean;<br>begin<br>    fillchar(used,sizeof(used),false);<br>    h:=1;t:=2;q[h]:=s;used[s]:=true;<br>    while h&lt;&gt;t do begin<br>        v:=q[h];inc(h);if h&gt;110 then h:=0;<br>        i:=head[v];<br>        while i&lt;&gt;0 do begin<br>            u:=g[i].t;<br>            if not used[u] then begin<br>                used[u]:=true;<br>                q[t]:=u;<br>                inc(t);if t&gt;110 then t:=0;<br>            end;<br>            i:=g[i].next;<br>        end;<br>    end;<br>    for i:=1 to n do flag[i]:=flag[i] and used[i];<br>end;</p>
<p>function jud(x:int):boolean;<br>var h,t,i,v,u:int;<br>begin<br>    fillchar(flag,sizeof(flag),false);<br>    filldword(d,sizeof(d) div 4,inf);<br>    fillchar(cnt,sizeof(cnt),0);<br>    h:=1;t:=2;q[h]:=1;d[1]:=0;<br>    flag[1]:=true;cnt[1]:=1;<br>    while h&lt;&gt;t do begin<br>        v:=q[h];flag[v]:=false;<br>        inc(h);if h&gt;110 then h:=0;<br>        i:=head[v];<br>        while i&lt;&gt;0 do begin<br>            u:=g[i].t;<br>            if d[u]&gt;d[v]+g[i].w+x then begin<br>                d[u]:=d[v]+g[i].w+x;<br>                if not flag[u] then begin<br>                    flag[u]:=true;inc(cnt[u]);<br>                    if cnt[u]&gt;n then exit(false);<br>                    q[t]:=u;inc(t);if t&gt;110 then t:=0;<br>                end;<br>            end;<br>            i:=g[i].next;<br>        end;<br>    end;<br>    jud:=(d[n]&gt;=0);<br>end;</p>
<p>begin<br>    assign(input,’tstrip.in’);reset(input);<br>    assign(output,’tstrip.out’);rewrite(output);<br>    read(t);<br>    repeat<br>        fillchar(head,sizeof(head),0);<br>        fillchar(ht,sizeof(ht),0);<br>        read(n,m);<br>        for i:=1 to m do begin<br>            read(x,y,w);<br>            add(g,head,x,y,w);add(gt,ht,y,x,w);<br>        end;<br>        fillchar(flag,sizeof(flag),true);<br>        bfs(g,head,1);bfs(gt,ht,n);<br>        fillchar(head,sizeof(head),0);<br>        for i:=1 to m do<br>            if flag[g[i].f] and flag[g[i].t] then<br>                add(g,head,g[i].f,g[i].t,g[i].w);<br>        l:=-inf;r:=inf;ans:=inf;<br>        while l&lt;=r do begin<br>            mid:=(l+r) div 2;<br>            if jud(mid) then begin ans:=d[n];r:=mid-1 end<br>            else l:=mid+1;<br>        end;<br>        if ans=inf then writeln(-1) else writeln(ans);<br>        dec(t);<br>    until t=0;<br>    close(input);close(output);<br>end.</p>
<pre><code>
# P2 狐狸的谜语
话说某一个月黑风高的晚上,一只褐色的狐狸快速地跳过了一只懒狗,并留下一个字符串“032089”和一个数字5。
这其中一定隐含了某些秘密!酷爱思考的你马上发现，这个字符串可以写成：“03+2+0*89”，结果为5。这是一个非常有趣的问题!
现在给出一个长度为N的数字字符串和一个数字T，要求插入最少的加号或者乘号，使得数字字符串的运算结果为T。运算符*号优先级高于+号，运算数可以有任意个前导0。

&lt;!--more--&gt;

## 格式
### 输入格式
输入不超过5组数据,每组数据两行。
每组数据的第1行为长度为N，只包含0~9的数字字符串，第2行为一个数字T。
输入T&lt;0表示输入结束。

### 输出格式
输出一个数字单独占一行，表示最少需要添加的运算符(+号或*号)数，无解输出-1。

## 样例
### 样例输入
&gt;032089
5
333
9
00
-1

### 样例输出
&gt;3
2

## 提示​
对于30%的数据,有1≤N≤10，0≤T≤50。
对于50%的数据,有1≤N≤15，0≤T≤200。
对于全部的数据,有1≤N≤20，0≤T≤200。

## 题解
可以迭代（或二分）dfs，不过事实证明暴力dfs更快
预处理从a[i..j]表示的数f[i,j]，大于t的设为t+1
dfs时把式子分成三段：
1. 开始到最后一个加号：值为s
2. 最后一个加号到最后一个乘号：值为c
3. 最后一个数f[p,x]

可行性剪枝：
1. s&gt;m
2. s+c&gt;0且f[p,x]≠0且x+1..n中没有0

最优性剪枝：所用符号数&gt;已知最优解

&lt;div style=&quot;display:none;&quot; class=&quot;copy&quot;&gt;
    <a href="/2016/09/30/noip-2014-10-28/puzzle.pas" title="{plain text}">{plain text}</a>
&lt;/div&gt;
```delphi puzzle.pas
uses math;
type int=longint;
const inf=100;
var
    a:array[0..21] of int;
    f:array[0..21,0..21] of int;
    b:array[0..21] of boolean;
    n,m,i,j,ans:int;s:string;

procedure dfs(x,p,s,c,d:int);
begin
    if (d&gt;ans) or (s&gt;m) then exit;
    if x=n+1 then begin
        inc(s,c*f[p,n]);
        if s=m then ans:=min(ans,d);
        exit;
    end;
    if b[x] and (f[p,x]&lt;&gt;0) and (s+c&gt;m) then exit;
    dfs(x+1,p,s,c,d);
    if x=n then exit;
    dfs(x+1,x+1,s+c*f[p,x],1,d+1);
    dfs(x+1,x+1,s,c*f[p,x],d+1);
end;

begin
    assign(input,&#39;puzzle.in&#39;);reset(input);
    assign(output,&#39;puzzle.out&#39;);rewrite(output);
    while true do begin
        readln(s);readln(m);
        if m&lt;0 then break;
        n:=length(s);
        for i:=1 to n do a[i]:=ord(s[i])-ord(&#39;0&#39;);
        fillchar(f,sizeof(f),0);
        for i:=1 to n do
            for j:=i to n do
                f[i,j]:=min(m+1,f[i,j-1]*10+a[j]);
        fillchar(b,sizeof(b),true);
        for i:=1 to n do
            if a[i]=0 then
                for j:=i downto 1 do
                    b[j]:=false;
        ans:=inf;
        dfs(1,1,0,1,0);
        if ans=inf then writeln(-1) else writeln(ans);
    end;
    close(input);close(output);
end.
</code></pre><h1 id="P3-花园的守护之神"><a href="#P3-花园的守护之神" class="headerlink" title="P3 花园的守护之神"></a>P3 花园的守护之神</h1><p>看着正在被上古神兽们摧残的花园，花园的守护之神――小Bug同学泪流满面。然而，FZOI不相信眼泪，小bug与神兽们的战争将进行到底！<br>通过google，小Bug得知，神兽们来自遥远的戈壁。为了扭转战局，小Bug决定拖延神兽增援的速度。从戈壁到达花园的路径错综复杂，由若干段双向的小路组成。神兽们通过每段小路都需要一段时间。小Bug可以通过向其中的一些小路投掷小xie来拖延神兽。她可以向任意小路投掷小Xie，而且可以在同一段小路上投掷多只小xie。每只小Xie可以拖延神兽一个单位的时间。即神兽通过整段路程的总时间，等于没有小xie时他们通过同样路径的时间加上路上经过的所有小路上的小xie数目总和。<br>神兽们是很聪明的。他们会在出发前侦查到每一段小路上的小Xie数目，然后选择总时间最短的路径。小Bug现在很想知道最少需要多少只小Xie，才能使得神兽从戈壁来到花园的时间变长。作为花园中可爱的花朵，你能帮助她吗?<br><!--more--></p>
<h2 id="格式-1"><a href="#格式-1" class="headerlink" title="格式"></a>格式</h2><h3 id="输入格式-1"><a href="#输入格式-1" class="headerlink" title="输入格式"></a>输入格式</h3><p>第1行包括一个整数N，表示地图中路点的个数；一个整数M，表示小路个数；以及整数S和T，分别表示戈壁和花园的路点编号。N个路点分别被编号为自然数1~N。<br>以下M行,每行三个整数A、B和C，表示路点A和B之间有一条小路相连，且通过它需要的时间为C。<br>输入数据保证两路点间最多只有一条小路相连，且戈壁和花园的路点是连通的。</p>
<h3 id="输出格式-1"><a href="#输出格式-1" class="headerlink" title="输出格式"></a>输出格式</h3><p>一个整数，表示使S到T之间最短路增长所需要的最少的小xie的数目。</p>
<h2 id="样例-1"><a href="#样例-1" class="headerlink" title="样例"></a>样例</h2><h3 id="样例输入-1"><a href="#样例输入-1" class="headerlink" title="样例输入"></a>样例输入</h3><blockquote>
<p>5 5 1 5<br>1 2 1<br>2 3 3<br>1 4 2<br>4 3 2<br>5 1</p>
</blockquote>
<h3 id="样例输出-1"><a href="#样例输出-1" class="headerlink" title="样例输出"></a>样例输出</h3><blockquote>
<p>1</p>
</blockquote>
<h2 id="提示​-1"><a href="#提示​-1" class="headerlink" title="提示​"></a>提示​</h2><p>对于30%的数据，满足N≤10，M≤50。<br>对于50%的数据，满足N≤200，M≤10000。<br>对于全部的数据，满足N≤1000，M≤499500，0&lt;C≤1000000。</p>
<h2 id="题解-1"><a href="#题解-1" class="headerlink" title="题解"></a>题解</h2><p>答案是最短路图上的最小割<br>spfa有一个点被卡，改用dijkstra+heap<br>记到起点距离df[v]，到终点距离dt[v]，如果$df[v]+e(v,u)+dt[u]=df[u]$那么边e(v,u)在最短路上<br>重构的图是有向图<br>最小割用最大流即可</p>
<p><div style="display:none;" class="copy"><br>    <a href="/2016/09/30/noip-2014-10-28/greendam.pas" title="{plain text}">{plain text}</a><br></div><br>```delphi greendam.pas<br>uses math;<br>type<br>    int=longint;<br>    edge=record f,t,w,next:int end;<br>    graph=array[0..1000010] of edge;<br>    arr=array[0..1010] of int;<br>const inf=100000000;<br>var<br>    g0,g:graph;q,d,df,dt,h0,l,iter,head:arr;<br>    h:array[0..1010,0..1] of int;<br>    n,m,sz,i,f0,t0,f,t,w:int;</p>
<p>//heap begin<br>procedure swap(x,y:int);<br>var tmp:int;<br>begin<br>    l[h[x,1]]:=y;l[h[y,1]]:=x;<br>    tmp:=h[x,0];h[x,0]:=h[y,0];h[y,0]:=tmp;<br>    tmp:=h[x,1];h[x,1]:=h[y,1];h[y,1]:=tmp;<br>end;</p>
<p>procedure heapify(i:int);<br>var l,r,s:int;<br>begin<br>    l:=i shl 1;r:=l or 1;<br>    if (l&lt;=sz) and (h[l,0]<h[i,0]) then="" s:="l" else="" if="" (r<="sz)" and="" (h[r,0]<h[s,0])="" i<="">s then begin<br>        swap(i,s);heapify(s);<br>    end;<br>end;</h[i,0])></p>
<p>procedure extract();<br>begin<br>    swap(1,sz);dec(sz);heapify(1);<br>end;</p>
<p>procedure reduceto(x,k:int);<br>var i:int;<br>begin<br>    h[x,0]:=k;i:=x;<br>    while (i&gt;1) and (h[i,0]&lt;h[i shr 1,0]) do begin<br>        swap(i,i shr 1);i:=i shr 1;<br>    end;<br>end;</p>
<p>procedure insert(i,k:int);<br>begin<br>    inc(sz);l[i]:=sz;<br>    h[sz,0]:=inf;h[sz,1]:=i;<br>    reduceto(sz,k);<br>end;<br>//heap end</p>
<p>procedure dijkstra(s:int;var d:arr);<br>var i,v,u:int;<br>begin<br>    sz:=0;<br>    for i:=1 to n do<br>        if i=s then insert(i,0) else insert(i,inf);<br>    while sz&gt;0 do begin<br>        v:=h[1,1];d[v]:=h[1,0];extract;<br>        i:=h0[v];<br>        while i&lt;&gt;0 do begin<br>            u:=g0[i].t;<br>            if (l[u]&lt;=sz) and (h[l[u],0]&gt;d[v]+g0[i].w) then<br>                reduceto(l[u],d[v]+g0[i].w);<br>            i:=g0[i].next;<br>        end;<br>    end;<br>end;</p>
<p>procedure add(var g:graph;var head:arr;f,t,w:int);<br>var sz:int;<br>begin<br>    inc(head[0]);sz:=head[0];<br>    g[sz].f:=f;g[sz].t:=t;g[sz].w:=w;<br>    g[sz].next:=head[f];head[f]:=sz;<br>end;</p>
<p>//maxflow begin<br>function bfs(s,t0:int):boolean;<br>var h,t,i,v,u:int;<br>begin<br>    fillchar(d,sizeof(d),255);<br>    h:=1;t:=2;q[h]:=s;d[s]:=0;<br>    while h&lt;&gt;t do begin<br>        v:=q[h];inc(h);if h&gt;1010 then h:=0;<br>        i:=head[v];<br>        while i&lt;&gt;0 do begin<br>            u:=g[i].t;<br>            if (d[u]=-1) and (g[i].w&gt;0) then begin<br>                d[u]:=d[v]+1;<br>                q[t]:=u;inc(t);if t&gt;1010 then t:=0;<br>            end;<br>            i:=g[i].next;<br>        end;<br>    end;<br>    bfs:=d[t0]&lt;&gt;-1;<br>end;</p>
<p>function dfs(v,t,f:int):int;<br>var i,u,tmp:int;<br>begin<br>    if v=t then exit(f);<br>    i:=iter[v];dfs:=0;<br>    while i&lt;&gt;0 do begin<br>        u:=g[i].t;<br>        if (g[i].w&gt;0) and (d[u]=d[v]+1) then begin<br>            tmp:=dfs(u,t,min(f-dfs,g[i].w));<br>            dec(g[i].w,tmp);<br>            inc(g[i xor 1].w,tmp);<br>            inc(dfs,tmp);<br>            if g[i].w&gt;0 then iter[v]:=i;<br>            if f=dfs then exit(f);<br>        end;<br>        i:=g[i].next;<br>    end;<br>    if dfs=0 then d[v]:=-1;<br>end;</p>
<p>function maxflow(s,t:int):int;<br>var i:int;<br>begin<br>    maxflow:=0;<br>    while bfs(s,t) do begin<br>        for i:=1 to n do iter[i]:=head[i];<br>        inc(maxflow,dfs(s,t,inf));<br>    end;<br>end;<br>//maxflow end</p>
<p>begin {main}<br>    assign(input,’greendam.in’);reset(input);<br>    assign(output,’greendam.out’);rewrite(output);<br>    read(n,m,f0,t0);<br>    fillchar(h0,sizeof(h0),0);<br>    for i:=1 to m do begin<br>        read(f,t,w);<br>        add(g0,h0,f,t,w);add(g0,h0,t,f,w);<br>    end;<br>    dijkstra(f0,df);dijkstra(t0,dt);<br>    fillchar(head,sizeof(head),0);<br>    head[0]:=1;<br>    for i:=1 to 2*m do<br>        if df[g0[i].f]+g0[i].w+dt[g0[i].t]=df[t0] then begin<br>            add(g,head,g0[i].f,g0[i].t,1);<br>            add(g,head,g0[i].t,g0[i].f,0);<br>        end;<br>    writeln(maxflow(f0,t0));<br>    close(input);close(output);<br>end.<br>```</p>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[欢乐赛 2014-10-24]]></title>
      <url>https://cothrax.github.io/2016/09/30/noip-2014-10-24/</url>
      <content type="html"><![CDATA[<table>
<thead>
<tr>
<th style="text-align:center">题目</th>
<th style="text-align:center">思路</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">hdogs</td>
<td style="text-align:center">gcd</td>
</tr>
<tr>
<td style="text-align:center">meeting</td>
<td style="text-align:center">组合数学+容斥</td>
</tr>
<tr>
<td style="text-align:center">shirt</td>
<td style="text-align:center">状压dp</td>
</tr>
</tbody>
</table>
<h1 id="P1-分火腿"><a href="#P1-分火腿" class="headerlink" title="P1 分火腿"></a>P1 分火腿</h1><p>小月言要过四岁生日了，她的妈妈为她准备了n根火腿，她想将这些火腿均分给m位小朋友，所以她可能需要切火腿。为了省事，小月言想切最少的刀数，使这n根火腿分成均等的m份。请问最少要切几刀？</p>
<a id="more"></a>
<h2 id="格式"><a href="#格式" class="headerlink" title="格式"></a>格式</h2><h3 id="输入格式"><a href="#输入格式" class="headerlink" title="输入格式"></a>输入格式</h3><p>第一行一个整数T，表示有T组数据。<br>接下来T组数据，每组共一行，有两个数字n，m。</p>
<h3 id="输出格式"><a href="#输出格式" class="headerlink" title="输出格式"></a>输出格式</h3><p>每组数据一行，输出最少要切的刀数。</p>
<h2 id="样例"><a href="#样例" class="headerlink" title="样例"></a>样例</h2><h3 id="样例输入"><a href="#样例输入" class="headerlink" title="样例输入"></a>样例输入</h3><blockquote>
<p>2<br>2 6<br>6 2</p>
</blockquote>
<h3 id="样例输出"><a href="#样例输出" class="headerlink" title="样例输出"></a>样例输出</h3><blockquote>
<p>4<br>0</p>
</blockquote>
<h2 id="提示​"><a href="#提示​" class="headerlink" title="提示​"></a>提示​</h2><p>100%的数据保证T&lt;=1000；n,m&lt;=2147483647。</p>
<h2 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h2><p>答案即满足$\dfrac{kn}{m}\in \textbf{Z},k\in[1,m]$的k的个数<br>答案是m-gcd(n,m)</p>
<p><div style="display:none;" class="copy"><br>    <a href="/2016/09/30/noip-2014-10-24/hdogs.pas" title="{plain text}">{plain text}</a><br></div><br>```delphi hdogs.pas<br>type int=longint;<br>var t,i:int;n,m:qword;</p>
<p>function gcd(a,b:qword):qword;<br>begin<br>    if b=0 then gcd:=a else gcd:=gcd(b,a mod b);<br>end;</p>
<p>begin<br>    assign(input,’hdogs.in’);reset(input);<br>    assign(output,’hdogs.out’);rewrite(output);<br>    read(t);<br>    for i:=1 to t do begin<br>        read(n,m);<br>        writeln(m-gcd(n,m));<br>    end;<br>    close(input);close(output);<br>end.</p>
<pre><code>
# P2 无聊的会议
土豪学长作为一名光荣的学生会干部，每天要参加很多无聊的会议。他发现：他开会的会议桌一定是正n边形，n个干部坐在这个多边形顶点上。因为太无聊了，所以他想要数出所有的“完全”等腰三角形——这种等腰三角形的三个顶点一定全是给出n多边形的顶点，且三个顶点上坐的干部性别相同。
土豪学长是土豪，他用1000000000%10的佣金雇用你，让你帮他数。PS：如果两个“完全”等腰三角形三个顶点相同，计算时只算一个。
&lt;!--more--&gt;

## 格式
### 输入格式
第一行一个数字T，表示有T组数据。
接下来有T组数据，每组数据共一行。这一行给出一个长度为n的字符串，表示正n边形n个顶点上干部的性别。1为男，0为女。

### 输出格式
对于第i组数据：输出”Case i: ans”(不带引号)，ans为“完全”等腰三角形的数量。

## 样例
### 样例输入
&gt;5
0001
01
10001
1101010
111010

### 样例输出
&gt;Case 1: 1
Case 2: 0
Case 3: 1
Case 4: 3
Case 5: 2

## 提示​
40%的数据保证n&lt;=20
100%的数据保证 n&lt;=10^6
所有数据保证T&lt;=10

## 题解
坑爹的数学题：计数+容斥
记边数为n
1. n为奇数
   1. 等腰三角形的个数cnt，只要考虑底边的数量，显然奇数边形中，任意两顶点的连边都对应一个以该边为底的三角形，于是$cnt=n*(n-1)/2$
   2. 考虑不合法的等腰三角形数量，只要考虑不合法的边数del（即一个顶点为0，一个顶点为1的边），记值为0的顶点数为s0，值1的顶点数为s1，$del=s0*s1$
   3. 一条边参与了三个等腰三角形的构成，于是$del*=3$
   4. 考虑一个不合法的三角形，它包含两条不合法的边，于是会被统计两次，于是不合法的三角形数为$del/=2$
   5. 当n%3=0时，等边三角形会被重复统计，枚举1..n/3，判断并更新del即可
   6. 答案是$cnt-del$
2. n为偶数
   1. 考虑到只有距离为偶数的两个顶点的连线（下称作偶数边）可以作为等腰三角形的底边，而一条这样的边参与了两个等腰三角形的构成，于是等腰三角形的数量为$n(n/2-1)$
   2. 对于偶数边，它会参与四个等腰三角形的构成；对于奇数边，由于只能做腰，只参与两个三角形的构成，这可以通过将顶点编号分奇偶讨论统计得
   3. 不合法三角形数同理
   4. 过中心的边不能作为等腰三角形的腰，1..n/2特判
   5. 等边三角形同理特判

&lt;div style=&quot;display:none;&quot; class=&quot;copy&quot;&gt;
    <a href="/2016/09/30/noip-2014-10-24/meeting.pas" title="{plain text}">{plain text}</a>
&lt;/div&gt;
```delphi meeting.pas
type int=longint;
var
    t,n,i:int;
    a:ansistring;

function od():int64;
var cnt,del,s0,s1,d:int64;i:int;
begin
    cnt:=n*(n-1) div 2;
    s0:=0;s1:=0;
    for i:=1 to n do
        if a[i]=&#39;0&#39; then inc(s0)
        else inc(s1);
    del:=s0*s1*3;
    if n mod 3=0 then begin
        d:=n div 3;
        dec(cnt,d*2);
        for i:=1 to d do
            if (a[i]&lt;&gt;a[i+d]) or 
                (a[i+d]&lt;&gt;a[i+2*d]) then dec(del,4);
    end;
    od:=cnt-del div 2;
end;

function ev():int64;
var 
    cnt,del,d:int64;i:int;
    s0,s1:array[0..1] of int64;
begin
    cnt:=n*(n div 2-1);
    s0[0]:=0;s0[1]:=0;s1[0]:=0;s1[1]:=0;
    for i:=1 to n do
        if a[i]=&#39;0&#39; then inc(s0[i and 1])
        else inc(s1[i and 1]);
    del:=(s0[0]*s1[0]+s0[1]*s1[1])*4+
        (s0[1]*s1[0]+s1[1]*s0[0])*2;
    d:=n div 2;
    for i:=1 to d do
        if a[i]&lt;&gt;a[i+d] then
            dec(del,2);
    if n mod 3=0 then begin
        d:=n div 3;
        dec(cnt,d*2);
        for i:=1 to d do
            if (a[i]&lt;&gt;a[i+d]) or 
                (a[i+d]&lt;&gt;a[i+2*d]) then dec(del,4);
    end;
    ev:=cnt-del div 2;
end;

begin
    assign(input,&#39;meeting.in&#39;);reset(input);
    assign(output,&#39;meeting.out&#39;);rewrite(output);
    readln(t);
    for i:=1 to t do begin
        readln(a);
        n:=length(a);
        write(&#39;Case &#39;,i,&#39;: &#39;);
        if odd(n) then writeln(od()) else writeln(ev);
    end;
    close(input);close(output);
end.
</code></pre><h1 id="P3-班服"><a href="#P3-班服" class="headerlink" title="P3 班服"></a>P3 班服</h1><p>要开运动会了，神犇学校的n个班级要选班服，班服共有100种样式，编号1~100。现在每个班都挑出了一些样式待选，每个班最多有100个待选的样式。要求每个班最终选定一种样式作为班服，且该班的样式不能与其他班级的相同，求所有可能方案的总数，由于方案总数可能很大，所以要求输出mod 1000000007后的答案。</p>
<!--more-->
<h2 id="格式-1"><a href="#格式-1" class="headerlink" title="格式"></a>格式</h2><h3 id="输入格式-1"><a href="#输入格式-1" class="headerlink" title="输入格式"></a>输入格式</h3><p>共有T组数据。<br>对于每组数据，第一行为一个整数n，表示有n个班级。<br>2~n+1行，每行有最多100个数字，表示第i-1班待选班服的编号。</p>
<h3 id="输出格式-1"><a href="#输出格式-1" class="headerlink" title="输出格式"></a>输出格式</h3><p>对于每组数据，输出方案总数 mod 1000000007后的答案。</p>
<h2 id="样例-1"><a href="#样例-1" class="headerlink" title="样例"></a>样例</h2><h3 id="样例输入-1"><a href="#样例输入-1" class="headerlink" title="样例输入"></a>样例输入</h3><blockquote>
<p>2<br>3<br>5 100 1<br>2<br>5 100<br>2<br>3 5<br>8 100</p>
</blockquote>
<h3 id="样例输出-1"><a href="#样例输出-1" class="headerlink" title="样例输出"></a>样例输出</h3><blockquote>
<p>4<br>4</p>
</blockquote>
<h2 id="提示​-1"><a href="#提示​-1" class="headerlink" title="提示​"></a>提示​</h2><p>对于30%的数据，1&lt;=T&lt;=3, 1&lt;=n&lt;=3，每班待选样式不超过10种。<br>对于50%的数据，1&lt;=T&lt;=5, 1&lt;=n&lt;=5，每班待选样式不超过50种。<br>对于100%的数据，1&lt;=T&lt;=10, 1&lt;=n&lt;=10，每班待选样式不超过100种。</p>
<h2 id="题解-1"><a href="#题解-1" class="headerlink" title="题解"></a>题解</h2><p>考虑到班级很少，状压DP<br>f[i,s]为当前考虑第i种样式，班级的情况（1..i-1的样式）为s的方案数<br>预处理a[i]表示与第i个样式匹配的班级<br>然后转移<br>$f[i+1,s\ or\ x]+=f[i,s]\ |\ x \not\in s\ and\ x \in a[i]$</p>
<p><div style="display:none;" class="copy"><br>    <a href="/2016/09/30/noip-2014-10-24/shirt.pas" title="{plain text}">{plain text}</a><br></div><br>```delphi shirt.pas<br>type int=longint;<br>const inf=1000000007;<br>var<br>    t,n,m,i,j:int;<br>    a:array[0..110] of int;<br>    f:array[0..110,0..1 shl 10] of qword;</p>
<p>procedure inc(var a:qword;b:qword);<br>begin<br>    a:=a+b;<br>    if a&gt;=inf then a:=a mod inf;<br>end;</p>
<p>procedure update(i,s:int);<br>var lb,x:int;<br>begin<br>    x:=a[i];<br>    inc(f[i+1,s],f[i,s]);<br>    while x&gt;0 do begin<br>        lb:=x and (-x);<br>        if (s or lb)&gt;s then<br>            inc(f[i+1,s or lb],f[i,s]);<br>        x:=x and not lb;<br>    end;<br>end;</p>
<p>begin<br>    assign(input,’shirt.in’);reset(input);<br>    assign(output,’shirt.out’);rewrite(output);<br>    read(t);<br>    repeat<br>        readln(n);m:=1 shl n-1;<br>        fillchar(a,sizeof(a),0);<br>        for i:=1 to n do begin<br>            while not eoln do begin<br>                read(j);<br>                a[j]:=a[j] or (1 shl (i-1));<br>            end;<br>            readln;<br>        end;<br>        //f[i,s] style i, 1..i-1 -&gt; s<br>        //f[i+1,s+?]+=f[i,s]<br>        fillchar(f,sizeof(f),0);<br>        f[1,0]:=1;<br>        for i:=1 to 100 do<br>            for j:=0 to m do<br>                if f[i,j]&gt;0 then update(i,j);<br>        writeln(f[101,m]);<br>        dec(t);<br>    until t=0;<br>    close(input);close(output);<br>end.<br>```</p>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[NOIP2016十连测热身赛 星球联盟]]></title>
      <url>https://cothrax.github.io/2016/09/25/lydsy-noip-2016-pretest/</url>
      <content type="html"><![CDATA[<h2 id="描述"><a href="#描述" class="headerlink" title="描述"></a>描述</h2><p>在遥远的S星系中一共有N个星球，编号为1…N。其中的一些星球决定组成联盟，以方便相互间的交流。但是，组成联盟的首要条件就是交通条件。初始时，在这N个星球间有M条太空隧道。每条太空隧道连接两个星球，使得它们能够相互到达。若两个星球属于同一个联盟，则必须存在一条环形线路经过这两个星球，即两个星球间存在两条没有公共隧道的路径。为了壮大联盟的队伍，这些星球将建设P条新的太空隧道。这P条新隧道将按顺序依次建成。一条新轨道建成后，可能会使一些星球属于同一个联盟。你的任务是计算出，在一条新隧道建设完毕后，判断这条新轨道连接的两个星球是否属于同一个联盟，如果属于同一个联盟就计算出这个联盟中有多少个星球。<br><a id="more"></a></p>
<h2 id="格式"><a href="#格式" class="headerlink" title="格式"></a>格式</h2><h3 id="输入格式"><a href="#输入格式" class="headerlink" title="输入格式"></a>输入格式</h3><p>第1行三个整数N，M和P，分别表示总星球数，初始时太空隧道的数目和即将建设的轨道数目。<br>第2至第M+1行，每行两个整数，表示初始时的每条太空隧道连接的两个星球编号。<br>第M+2行至第M+P+1行，每行两个整数，表示新建的太空隧道连接的两个星球编号。<br>这些太空隧道按照输入的顺序依次建成。<br>对于10%的数据有1≤N,M,P≤100；<br>对于40%的数据有1≤N,M,P≤2000；<br>对于100%的数据有1≤N,M,P≤200000。</p>
<h3 id="输出格式"><a href="#输出格式" class="headerlink" title="输出格式"></a>输出格式</h3><p>输出共P行。如果这条新的太空隧道连接的两个星球属于同一个联盟，就输出一个整数，表示这两个星球所在联盟<br>的星球数。如果这条新的太空隧道连接的两个星球不属于同一个联盟，就输出”No”（不含引号）。</p>
<h2 id="样例"><a href="#样例" class="headerlink" title="样例"></a>样例</h2><h3 id="样例输入"><a href="#样例输入" class="headerlink" title="样例输入"></a>样例输入</h3><blockquote>
<p>3 2 1<br>1 2<br>1 3<br>2 3    </p>
</blockquote>
<h3 id="样例输出"><a href="#样例输出" class="headerlink" title="样例输出"></a>样例输出</h3><blockquote>
<p>3</p>
</blockquote>
<h2 id="提示​"><a href="#提示​" class="headerlink" title="提示​"></a>提示​</h2><p>【样例1说明】<br>新建成的隧道连接2、3两个星球。<br>这条隧道1和2，2和3，1和3之间都存在环形线路。1,2,3同属一个联盟，答案为3</p>
<h2 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h2><p>先吐槽一下第一题，pascal不论用堆排还是快排都是TLE，然后看了下status用pascal的没人a，果断换c++只要sort就水过了。<br>第二次原题来自：<a href="/2016/09/20/noip-2014-10-4/" title="P3">P3</a><br>关于本题：<br>这是一道综合性很强的图论题<br>题意：在一张无向图上动态维护<strong>边双连通分量</strong></p>
<ol>
<li>用<strong>tarjan缩点</strong>，求出原图的边双连通分量（下称分量）</li>
<li>缩点后就图便成了一个<strong>森林</strong>，其中的连通块（下称为树）用<strong>并查集tr</strong>维护</li>
<li>如果在同一棵树的两个分量之间连一条边，那么这两个分量就合并成了一个大的分量，这个用另一个<strong>并查集bl</strong>维护</li>
<li>考虑向图中加边<strong>e(u,v)</strong>：<ol>
<li>如果u和v在同一分量中，输出该分量大小即可</li>
<li>如果u和v不在同一分量但在同一棵树中，那么添加边e会使得u-&gt;lca-&gt;v的所有分量合并成一个分量，用朴素的方法求<strong>lca</strong>，边求边合并并查集bl</li>
<li>如果u和v不在同一棵树中，此时不会产生新的分量，而将两棵树合并，我们通过tr维护树的节点个数，然后<strong>启发式合并</strong></li>
</ol>
</li>
</ol>
<p>复杂度：记缩点后森林的规模为K，tarjan为$O(N+M)$，lca部分最坏$O(KP\alpha(K))$，启发式合并最坏$O(KlogK\alpha(K))$，但实际表现还不错。<br>注意点：<strong>有重边</strong>，tarjan时对反向边做标记</p>
<p><div style="display:none;" class="copy"><br>    <a href="/2016/09/25/lydsy-noip-2016-pretest/c.pas" title="{plain text}">{plain text}</a><br></div><br>```delphi c.pas<br>uses math;<br>type<br>    int=longint;<br>    edge=record f,t,next:int;v:boolean end;<br>    arr=array[0..200010] of int;<br>    st=array[0..200010,0..1] of int;<br>    pst=^st;<br>var<br>    g:array[0..800010] of edge;<br>    head,dep,par,dfn,low,dcc,s:arr;<br>    tr,bl:st;<br>    ins:array[0..200010] of boolean;<br>    n,m,q,sz,i,f,t,cc,tim:int;</p>
<p>procedure add(f,t:int);<br>begin<br>    inc(sz);<br>    g[sz].f:=f;g[sz].t:=t;g[sz].v:=true;<br>    g[sz].next:=head[f];head[f]:=sz;<br>end;</p>
<p>procedure tarjan(v,p:int);<br>var i,u:int;<br>begin<br>    inc(tim);dfn[v]:=tim;low[v]:=tim;<br>    inc(t);s[t]:=v;ins[v]:=true;<br>    i:=head[v];<br>    while i&lt;&gt;0 do begin<br>        u:=g[i].t;<br>        if g[i].v then begin<br>            g[i xor 1].v:=false;<br>            if dfn[u]=0 then begin<br>                tarjan(u,v);<br>                low[v]:=min(low[v],low[u]);<br>            end else if ins[u] then<br>                low[v]:=min(low[v],dfn[u]);<br>        end;<br>        i:=g[i].next;<br>    end;<br>    if low[v]=dfn[v] then begin<br>        inc(cc);bl[cc,1]:=0;<br>        while s[t+1]&lt;&gt;v do begin<br>            ins[s[t]]:=false;<br>            inc(bl[cc,1]);dcc[s[t]]:=cc;<br>            dec(t);<br>        end;<br>    end;<br>end;</p>
<p>function find(p:pst;x:int):int;<br>begin<br>    if x=p^[x,0] then find:=x<br>    else begin<br>        p^[x,0]:=find(p,p^[x,0]);<br>        find:=p^[x,0];<br>    end;<br>end;</p>
<p>procedure union(p:pst;x,y:int);<br>begin<br>    x:=find(p,x);y:=find(p,y);<br>    if x=y then exit;<br>    inc(p^[y,1],p^[x,1]);p^[x,1]:=0;<br>    p^[x,0]:=y;<br>end;</p>
<p>function same(p:pst;x,y:int):boolean;<br>begin same:=find(p,x)=find(p,y) end;</p>
<p>procedure dfs(v,p:int);<br>var i,u:int;<br>begin<br>    if p&lt;&gt;0 then union(@tr,v,p);<br>    par[v]:=p;dep[v]:=dep[p]+1;<br>    i:=head[v];<br>    while i&lt;&gt;0 do begin<br>        u:=g[i].t;<br>        if u&lt;&gt;p then dfs(u,v);<br>        i:=g[i].next;<br>    end;<br>end;</p>
<p>procedure swap(var a,b:int);<br>var tmp:int;<br>begin tmp:=a;a:=b;b:=tmp end;</p>
<p>procedure lca(u,v:int);<br>begin<br>    if dep[u]<dep[v] then="" swap(u,v);="" while="" dep[u]="">dep[v] do begin<br>        union(@bl,u,par[u]);<br>        u:=par[u];<br>    end;<br>    while u&lt;&gt;v do begin<br>        union(@bl,u,par[u]);u:=par[u];<br>        union(@bl,v,par[v]);v:=par[v];<br>    end;<br>end;</dep[v]></p>
<p>procedure merge(u,v:int);<br>begin<br>    if tr[find(@tr,u),1]&gt;tr[find(@tr,v),1] then swap(u,v);<br>    add(v,u);add(u,v);dfs(u,v);<br>end;</p>
<p>begin<br>    assign(input,’c.in’);reset(input);<br>    assign(output,’c.out’);rewrite(output);<br>    //input<br>    read(n,m,q);sz:=1;<br>    for i:=1 to m do begin<br>        read(f,t);add(f,t);add(t,f);<br>    end;<br>    //tarjan<br>    tim:=0;t:=0;cc:=0;<br>    for i:=1 to n do if dfn[i]=0 then tarjan(i,0);<br>    //init set<br>    for i:=1 to cc do begin<br>        tr[i,0]:=i;tr[i,1]:=1;bl[i,0]:=i;<br>    end;<br>    //build tree<br>    f:=sz;sz:=0;<br>    fillchar(head,sizeof(head),0);<br>    for i:=0 to f do<br>        if dcc[g[i].f]&lt;&gt;dcc[g[i].t] then<br>            add(dcc[g[i].f],dcc[g[i].t]);<br>    for i:=1 to cc do<br>        if dep[i]=0 then dfs(i,0);<br>    //query<br>    for i:=1 to q do begin<br>        read(f,t);<br>        f:=dcc[f];t:=dcc[t];<br>        if not same(@tr,f,t) then begin<br>            merge(f,t);<br>            writeln(‘No’);<br>        end else begin<br>            if not same(@bl,f,t) then lca(f,t);<br>            writeln(bl[find(@bl,f),1]);<br>        end;<br>    end;<br>    close(input);close(output);<br>end.<br>```</p>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[NOIP模拟赛 2014-10-23]]></title>
      <url>https://cothrax.github.io/2016/09/24/noip-2014-10-23/</url>
      <content type="html"><![CDATA[<table>
<thead>
<tr>
<th style="text-align:center">题目</th>
<th style="text-align:center">思路</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">pour</td>
<td style="text-align:center">扩展欧几里得</td>
</tr>
<tr>
<td style="text-align:center">stol</td>
<td style="text-align:center">网格dp</td>
</tr>
<tr>
<td style="text-align:center">?</td>
<td style="text-align:center">?</td>
</tr>
</tbody>
</table>
<h1 id="P1-Jams倒酒"><a href="#P1-Jams倒酒" class="headerlink" title="P1 Jams倒酒"></a>P1 Jams倒酒</h1><p>Jams是一家酒吧的老板，他的酒吧提供2种体积的啤酒，a ml 和 b ml，分别使用容积为a ml 和 b ml的酒杯来装载。<br>酒吧的生意并不好。Jams发现酒鬼们都很穷，不像他那么土豪。有时，他们会因为负担不起a ml 或者 b ml酒的消费，而不得不离去。因此，Jams决定出手第三种体积的啤酒(较小体积的啤酒)。<br>Jams只有两种杯子，容积分别为 a ml 和 b ml，而且啤酒杯是没有刻度的。他只能通过两种杯子和酒桶间的互相倾倒来得到新的体积的酒。<br>倒酒步骤为:<br>(1) 规定a&gt;=b<br>(2) 酒桶容积无限，酒桶中酒体积无限大。<br>(3) 只能包含三种可能的倒酒操作：<br>1、 将酒桶中的酒倒入容积为b ml的酒杯中；<br>2、 将容积为a ml的酒杯中的酒倒入酒桶；<br>3、 将容积为b ml的酒杯中的酒倒入容积为 a ml的酒杯中。<br>(4) 每次倒酒必须把杯子倒满或者把被倾倒的杯子倒空。<br>Jams希望通过若干次倾倒得到容积为 a ml酒杯中剩下的就体积尽可能小，他请求你帮助他设计倾倒方案。<br><a id="more"></a></p>
<h2 id="格式"><a href="#格式" class="headerlink" title="格式"></a>格式</h2><h3 id="输入格式"><a href="#输入格式" class="headerlink" title="输入格式"></a>输入格式</h3><p>两个整数a,b(0&lt;b&lt;=a&lt;=10^9)</p>
<h3 id="输出格式"><a href="#输出格式" class="headerlink" title="输出格式"></a>输出格式</h3><p>第一行一个整数，表示可以得到的最小体积的酒。<br>第二行两个整数Pa和Pb（中间用一个空格分开），分别表示从体积为a ml的酒杯中到处酒的次数和将酒倒入体积为b ml的酒杯的次数。<br>若有多种可能的Pa，Pb满足要求，那么请输出Pa最小的。若Pa最小的时候有多个Pb，那么输出Pb最小的。</p>
<h2 id="样例"><a href="#样例" class="headerlink" title="样例"></a>样例</h2><h3 id="样例输入"><a href="#样例输入" class="headerlink" title="样例输入"></a>样例输入</h3><blockquote>
<p>5 3</p>
</blockquote>
<h3 id="样例输出"><a href="#样例输出" class="headerlink" title="样例输出"></a>样例输出</h3><blockquote>
<p>1<br>1 2</p>
</blockquote>
<h2 id="提示​"><a href="#提示​" class="headerlink" title="提示​"></a>提示​</h2><p>倾倒方案为：<br>1、 桶-&gt;B；<br>2、 B-&gt;A；<br>3、 桶-&gt;B;<br>4、 B-&gt;A;<br>5、 A-&gt;桶；<br>6、 B-&gt;A;</p>
<p>对于20%的数据，pa,pb总和不超过5<br>对于60%的数据，pa&lt;=10^8<br>对于100%的数据，0&lt;b&lt;=a&lt;=10^9</p>
<h2 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h2><p>记向b倒入y次，从a倒出x次，那么最后a剩余的酒体积为$w=by-ax$<br>要最小化w，由数论显然w最小是$gcd(a,b)$，于是题目变成了解方程$by-ax=gcd(a,b)$<br>令x=-x，上扩展欧几里得即可，最后答案是-x,y<br>至于最优解的调整，已知一组解(x,y)<br>那么任意一组解为$x_t=x+b\cdot t,y_t=y-a\cdot t$<br>答案调整到最大非负整数x</p>
<p><div style="display:none;" class="copy"><br>    <a href="/2016/09/24/noip-2014-10-23/pour.pas" title="{plain text}">{plain text}</a><br></div><br>```delphi pour.pas<br>type int=longint;<br>var a,b,x,y,g:int;</p>
<p>function gcd(a,b:int):int;<br>begin<br>    if b=0 then gcd:=a else gcd:=gcd(b,a mod b);<br>end;</p>
<p>procedure extgcd(a,b:int;var x,y:int);<br>begin<br>    if b=0 then begin<br>        x:=1;y:=0;<br>    end else begin<br>        extgcd(b,a mod b,y,x);<br>        dec(y,(a div b)*x);<br>    end;<br>end;</p>
<p>begin<br>    assign(input,’pour.in’);reset(input);<br>    assign(output,’pour.out’);rewrite(output);<br>    read(a,b);<br>    g:=gcd(a,b);<br>    writeln(g,’ ‘);<br>    a:=a div g;b:=b div g;<br>    extgcd(a,b,x,y);<br>    while x&gt;0 do begin<br>        dec(x,b);inc(y,a);<br>    end;<br>    while x+b&lt;0 do begin<br>        inc(x,b);dec(y,a);<br>    end;<br>    write(-x,’ ‘,y);<br>    close(input);close(output);<br>end.</p>
<pre><code>
# P2 土豪聪要请客
众所周知，聪哥(ndsf)是个土豪，不过你们不知道的是他的MZ和他的RMB一样滴多……
某天土豪聪又赚了10^10000e的RMB，他比较开心，于是准备请客。他在自己在XX星上的别墅里面大摆酒席，想要邀请尽可能多的MZ来参加他的宴会。他将会同MZ一起坐在一个巨大的长方形桌子上。这个桌子能坐下的人数等于他的周长。聪哥要求他的桌子能够放进他的别墅，并且桌子的边必须与别墅的边界平行。给定别墅的平面图，请你求出聪哥最多可以请多少个MZ。
&lt;!--more--&gt;

## 格式
### 输入格式
第一行n,m。表示别墅的长宽
下面n行，每行M个字符，表示一个方块是空的(‘ ’)或是被占用了(‘X’)。
聪哥只要他的桌子放在别墅里，并且桌子不能占用任何一个已经占用了的方块。

### 输出格式
一个数，表示聪哥最多可以请几个Maze。

## 样例
### 样例输入
&gt;4 4
X.XX
X..X
..X.
..XX

### 样例输出
&gt;9

## 题解
怎么搞都可以的网格dp
预处理l[i,j]为点(i,j)向左的连续空位的数量，u[i,j]为(i,j)向上的连续空位的数量
记f[i,j,k]为以点(i,j)为右下角，纵向长度为k时的最大横向长度
然后转移
细节
1. 循环变量打错m写成n
2. 滚动数组每次循环时初始化

&lt;div style=&quot;display:none;&quot; class=&quot;copy&quot;&gt;
    <a href="/2016/09/24/noip-2014-10-23/stol.pas" title="{plain text}">{plain text}</a>
&lt;/div&gt;
```delphi stol.pas
uses math;
type int=longint;
var 
    f:array[0..1,0..410,0..410] of int;
    l,u:array[0..410,0..410] of int;
    a:array[0..410,0..410] of char;
    n,m,i,p,c,j,k,t1,t2,ans:int;

begin
    assign(input,&#39;stol.in&#39;);reset(input);
    assign(output,&#39;stol.out&#39;);rewrite(output);
    readln(n,m);
    for i:=1 to n do begin
        for j:=1 to m do read(a[i,j]);
        readln;
    end;
    for i:=1 to n do
        for j:=1 to m do
            if a[i,j]=&#39;X&#39; then begin
                l[i,j]:=0;u[i,j]:=0;
            end else begin
                l[i,j]:=l[i,j-1]+1;
                u[i,j]:=u[i-1,j]+1;
            end;
    ans:=0;
    for i:=1 to n do begin
        c:=i and 1;p:=c xor 1;
        fillchar(f[c],sizeof(f[c]),0);
        for j:=1 to m do
            for k:=1 to u[i,j] do begin
                t1:=f[c,j-1,k]+1;
                t2:=min(f[p,j,k-1],l[i,j]);
                f[c,j,k]:=max(t1,t2);
                ans:=max(ans,f[c,j,k]*2+k*2);
            end;
    end;
    write(ans-1);
    close(input);close(output);
end.
</code></pre><h1 id="P3-最强大脑"><a href="#P3-最强大脑" class="headerlink" title="P3 最强大脑"></a>P3 最强大脑</h1><blockquote>
<p>还没有做</p>
</blockquote>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[NOIP模拟赛 2014-10-22]]></title>
      <url>https://cothrax.github.io/2016/09/23/noip-2014-10-22/</url>
      <content type="html"><![CDATA[<table>
<thead>
<tr>
<th style="text-align:center">题目</th>
<th style="text-align:center">思路</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">bishop</td>
<td style="text-align:center">dfs+打表</td>
</tr>
<tr>
<td style="text-align:center">czybm</td>
<td style="text-align:center">左右取数dp</td>
</tr>
<tr>
<td style="text-align:center">hop</td>
<td style="text-align:center">图论建模+lca</td>
</tr>
</tbody>
</table>
<h1 id="P1-传教士"><a href="#P1-传教士" class="headerlink" title="P1 传教士"></a>P1 传教士</h1><p>panzhili王国的疆土恰好是一个矩形，为了管理方便，国王jjs将整个疆土划分成N＊M块大小相同的区域。由于jjs希望他的子民也能信教爱教（”打拳”神教），所以他想安排一些传教士到全国各地去传教。但这些传教士的传教形式非常怪异，他们只在自己据点周围特定的区域内传教且领地意识极其强烈（即任意一个传教士的据点都不能在其他传教士的传教区域内，否则就会发生冲突）。现在我们知道传教士的传教区域为以其据点为中心的两条斜对角线上（如图）。现在jjs请你帮忙找出一个合理的安置方案，使得可以在全国范围内安置尽可能多的传教士而又不至于任意两个传教士会发生冲突。</p>
<table>
<thead>
<tr>
<th style="text-align:center"></th>
<th style="text-align:center"></th>
<th style="text-align:center"></th>
<th style="text-align:center">x</th>
<th style="text-align:center"></th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">x</td>
<td style="text-align:center"></td>
<td style="text-align:center">x</td>
<td style="text-align:center"></td>
<td style="text-align:center"></td>
</tr>
<tr>
<td style="text-align:center"></td>
<td style="text-align:center">A</td>
<td style="text-align:center"></td>
<td style="text-align:center"></td>
<td style="text-align:center"></td>
</tr>
<tr>
<td style="text-align:center">x</td>
<td style="text-align:center"></td>
<td style="text-align:center">x</td>
<td style="text-align:center"></td>
</tr>
</tbody>
</table>
<p>（若A为某传教士的据点，则其传教范围为所有标有X的格子。为不产生冲突，则第二个传教士的据点只能放在上图的空格中。）<br><a id="more"></a></p>
<h2 id="格式"><a href="#格式" class="headerlink" title="格式"></a>格式</h2><h3 id="输入格式"><a href="#输入格式" class="headerlink" title="输入格式"></a>输入格式</h3><p>输入文件共一行，包含两个整数N和M，代表国土的大小，n为水平区域数，m为垂直区域数。</p>
<h3 id="输出格式"><a href="#输出格式" class="headerlink" title="输出格式"></a>输出格式</h3><p>输出文件仅一行，包含一个整数，即最多可以安置的传教士的数目。</p>
<h2 id="样例"><a href="#样例" class="headerlink" title="样例"></a>样例</h2><h3 id="样例输入"><a href="#样例输入" class="headerlink" title="样例输入"></a>样例输入</h3><blockquote>
<p>3 4</p>
</blockquote>
<h3 id="样例输出"><a href="#样例输出" class="headerlink" title="样例输出"></a>样例输出</h3><blockquote>
<p>6</p>
</blockquote>
<h2 id="提示​"><a href="#提示​" class="headerlink" title="提示​"></a>提示​</h2><p>说明：样例安置方案如下图所示，X表示为某传教士的据点。<br>XXX<br>OOO<br>OOO<br>XXX<br>对于100%的数据，1&lt;=n,m&lt;=9，且数据规模呈梯度上升。</p>
<h2 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h2><p>先暴力dfs打个表<br>由于是对角线，可以用x+y=b和x-y=b（斜率为±1的直线）进行状态转移</p>
<p><div style="display:none;" class="copy"><br>    <a href="/2016/09/23/noip-2014-10-22/bishop.pas" title="{plain text}">{plain text}</a><br></div><br>```delphi bishop.pas<br>uses math;<br>type int=longint;<br>var<br>    l,r:array[-10..30] of boolean;<br>    ans,n,m:int;</p>
<p>procedure dfs(x,y,k:int);<br>begin<br>    if y=m+1 then begin y:=1;inc(x) end;<br>    if x=n+1 then begin<br>        ans:=max(ans,k);exit<br>    end;<br>    dfs(x,y+1,k);<br>    if r[x+y] and l[y-x] then begin<br>        r[x+y]:=false;l[y-x]:=false;<br>        dfs(x,y+1,k+1);<br>        r[x+y]:=true;l[y-x]:=true;<br>    end;<br>end;</p>
<p>begin<br>    //read(n,m);<br>    for n:=1 to 9 do begin<br>        for m:=1 to 9 do begin<br>            fillchar(l,sizeof(l),true);<br>            fillchar(r,sizeof(r),true);<br>            ans:=0;<br>            dfs(1,1,0);<br>            write(ans:3);<br>        end;<br>        writeln;<br>    end;<br>end.</p>
<pre><code>&lt;div&gt;

然后找找规律
打表后发现：分行列讨论，对角线特判

&lt;div style=&quot;display:none;&quot; class=&quot;copy&quot;&gt;
    <a href="/2016/09/23/noip-2014-10-22/bishop1.pas" title="{plain text}">{plain text}</a>
&lt;/div&gt;
```delphi bishop1.pas
type int=longint;
var n,m:int;
begin
    assign(input,&#39;bishop.in&#39;);reset(input);
    assign(output,&#39;bishop.out&#39;);rewrite(output);
    read(n,m);
    if n=m then begin
        if n=1 then write(1:3) 
        else write(2*(n-1):3);
    end else begin
        if odd(m) then write(n+m-1:3)
        else write(m+2*((n-1) div 2):3);
    end;
    close(input);close(output);
end.
</code></pre><h1 id="P2-czy把妹"><a href="#P2-czy把妹" class="headerlink" title="P2 czy把妹"></a>P2 czy把妹</h1><p>Czy是个大丧失，非常喜欢bm。他经常挑战bm的极限，同时b很多的mz。(虽然也许质量不容乐观)<br>这一天，czy又开始了他的极限挑战。在一个数轴上有n个maze,她们都在等待着czy的到来。Czy一开始站在k号妹子的旁边，他需要搞定所有的妹子(由于他向fewdan学会了绝技，所以搞定妹子的时间是无限接近于0的，也就是一瞬间就搞定而不用花额外的时间)。Maze们都很没有耐心，每让她们多等1s,她们就会增加w[i]的不开心值。现在，czy从k号妹子这里出发，以1m/s的速度开始行动，他希望在搞定所有maze的情况下使得她们的不开心值总和最小，于是他找到了即将在NOIP2014 AK的你来帮他解决这个问题。<br><!--more--></p>
<h2 id="格式-1"><a href="#格式-1" class="headerlink" title="格式"></a>格式</h2><h3 id="输入格式-1"><a href="#输入格式-1" class="headerlink" title="输入格式"></a>输入格式</h3><p>输入文件的第一行包含一个整数N，2&lt;=N&lt;=1000，表示maze的数量。<br>第二行包含一个整数V，1&lt;=V&lt;=N，表示开始时czy站在几号maze的旁边.接下来的N行中，每行包含两个用空格隔开的整数D和W，用来描述每个maze，其中0&lt;=D&lt;=1000，0&lt;=W&lt;=1000。D表示MM在数轴上的位置(单位: m)，W表示每秒钟会增加的不开心值。</p>
<h3 id="输出格式-1"><a href="#输出格式-1" class="headerlink" title="输出格式"></a>输出格式</h3><p>一个整数，最小的不开心值。(答案不超过10^9)</p>
<h2 id="样例-1"><a href="#样例-1" class="headerlink" title="样例"></a>样例</h2><h3 id="样例输入-1"><a href="#样例输入-1" class="headerlink" title="样例输入"></a>样例输入</h3><blockquote>
<p>4<br>3<br>2 2<br>5 8<br>6 1<br>8 7</p>
</blockquote>
<h3 id="样例输出-1"><a href="#样例输出-1" class="headerlink" title="样例输出"></a>样例输出</h3><blockquote>
<p>56</p>
</blockquote>
<h2 id="提示​-1"><a href="#提示​-1" class="headerlink" title="提示​"></a>提示​</h2><p>对于40%的数据，1&lt;=n&lt;=7<br>对于100%的数据，1&lt;=n&lt;=1000 0&lt;=D&lt;=1000 0&lt;=w&lt;=1000</p>
<h2 id="题解-1"><a href="#题解-1" class="headerlink" title="题解"></a>题解</h2><p>因为只要路过一个mz必定要干掉，于是已经干掉的妹子构成的是一个连续区间。<br>以k为起点，左右取数的dp<br>状态f[i,j,s]：k以左取i个，右取j个，s=0在现在在左边，s=1现在在右边<br>部分数据预处理，然后转移</p>
<p>其实和洛谷的关路灯那题一模一样<br>dp时注意数组越界，要加判断i&gt;0和j&gt;0</p>
<p><div style="display:none;" class="copy"><br>    <a href="/2016/09/23/noip-2014-10-22/czybm.pas" title="{plain text}">{plain text}</a><br></div><br>```delphi czybm.pas<br>uses math;<br>type int=longint;<br>const inf=1000000000;<br>var<br>    i,j,n,k:int;<br>    f:array[0..1010,0..1010,0..1] of int;<br>    d,w,l,r:array[0..1010] of int;</p>
<p>procedure swap(var a,b:int);<br>var tmp:int;<br>begin tmp:=a;a:=b;b:=tmp end;</p>
<p>procedure qsort(l,r:int);<br>var i,j:int;x:int;<br>begin<br>    i:=l;j:=r;x:=d[random(r-l)+l];<br>    repeat<br>        while d[i]<x do="" inc(i);="" while="" d[j]="">x do dec(j);<br>        if i&lt;=j then begin<br>            if i=k then k:=j;if j=k then k:=i;<br>            swap(d[i],d[j]);swap(w[i],w[j]);<br>            inc(i);dec(j);<br>        end;<br>    until i&gt;j;<br>    if i&lt;r then qsort(i,r);<br>    if l&lt;j then qsort(l,j);<br>end;    </x></p>
<p>begin<br>    assign(input,’czybm.in’);reset(input);<br>    assign(output,’czybm.out’);rewrite(output);<br>    read(n,k);<br>    for i:=1 to n do read(d[i],w[i]);<br>    qsort(1,n);l[k-1]:=0;r[n-k]:=0;<br>    for i:=k-2 downto 0 do l[i]:=l[i+1]+w[k-1-i];<br>    for i:=n-k-1 downto 0 do r[i]:=r[i+1]+w[k+1+i];<br>    filldword(f,sizeof(f) div 4,inf);<br>    f[0,0,0]:=0;f[0,0,1]:=0;<br>    for i:=0 to k-1 do<br>        for j:=0 to n-k do begin<br>            if i&gt;0 then f[i,j,0]:=min(<br>                f[i-1,j,0]+(l[i-1]+r[j])<em>(d[k-i+1]-d[k-i]),<br>                f[i-1,j,1]+(l[i-1]+r[j])</em>(d[k+j]-d[k-i]));<br>            if j&gt;0 then f[i,j,1]:=min(<br>                f[i,j-1,1]+(l[i]+r[j-1])<em>(d[k+j]-d[k+j-1]),<br>                f[i,j-1,0]+(l[i]+r[j-1])</em>(d[k+j]-d[k-i]));<br>        end;<br>    write(min(f[k-1,n-k,0],f[k-1,n-k,1]));<br>    close(input);close(output);<br>end.</p>
<pre><code>
# P3 跳跳棋
Hzwer的跳跳棋是在一条数轴上进行的。棋子只能摆在整点上。每个点不能摆超过一个棋子。
某一天，黄金大神和cjy用跳跳棋来做一个简单的游戏：棋盘上有3颗棋子，分别在a，b，c这三个位置。他们要通过最少的跳动把它们的位置移动成x，y，z。（棋子是没有区别的）
跳动的规则很简单，任意选一颗棋子，对一颗中轴棋子跳动。跳动后两颗棋子距离不变。一次只允许跳过1颗棋子。
写一个程序，首先判断是否可以完成任务。如果可以，输出最少需要的跳动次数。
&lt;!--more--&gt;

## 格式
### 输入格式
第一行包含三个整数，表示当前棋子的位置a b c。（互不相同）
第二行包含三个整数，表示目标位置x y z。（互不相同）

### 输出格式
如果无解，输出一行NO。
如果可以到达，第一行输出YES，第二行输出最少步数。

## 样例
### 样例输入
&gt;1 2 3
0 3 5

### 样例输出
&gt;YES
2

## 提示​
20% 输入整数的绝对值均不超过10
40% 输入整数的绝对值均不超过10000
100% 绝对值不超过10^9


## 题解
考察状态(a,b,c)，其中$a&lt;b&lt;c$
写暴力bfs时可以发现，当将b向外跳得到下一个状态时(a&#39;,b&#39;,c)时a&#39;只可以通过向里跳得到上一个状态，这个状态转移是树形的：
1. b向外跳得到两个状态作为儿子
2. a/c向里跳得到的是父亲

而且很容易发现存在根节点为(a,b,c)其中a-b=b-c
于是对于起始和目标状态，想要最短步转移，实际上就是找LCA，可以用辗转相除模拟向上走的过程，然后二分处理LCA

注意点
1. 要调整到同一深度
2. 注意inf大小

&lt;div style=&quot;display:none;&quot; class=&quot;copy&quot;&gt;
    <a href="/2016/09/23/noip-2014-10-22/hop.pas" title="{plain text}">{plain text}</a>
&lt;/div&gt;
```delphi hop.pas
uses math;
type 
    int=longint;
    arr=array[0..3] of int;
    pint=^int;
var
    f,t,r1,r2:arr;
    l,r,mid,ans,c1,c2,i:int;

procedure swap(var a,b:int);
var tmp:int;
begin tmp:=a;a:=b;b:=tmp end;

procedure sort(var f:arr);
var i,j:int;
begin
    for i:=1 to 2 do
        for j:=i+1 to 3 do
            if f[i]&gt;f[j] then swap(f[i],f[j]);
end;

function cal(f:arr;k:int;p:pint):arr;
var d1,d2,x:int;
begin
    d1:=f[2]-f[1];d2:=f[3]-f[2];
    if d1=d2 then exit(f);
    if d1&gt;d2 then begin
        x:=min(d1 div d2,k);
        if d2*x=d1 then dec(x);
        dec(k,x);inc(p^,x);
        dec(f[2],x*d2);dec(f[3],x*d2);
    end else begin
        x:=min(d2 div d1,k);
        if d1*x=d2 then dec(x);
        dec(k,x);inc(p^,x);
        inc(f[1],x*d1);inc(f[2],x*d1);
    end;
    if k=0 then cal:=f else cal:=cal(f,k,p);
end;

function equ(a,b:arr):boolean;
var i:int;
begin
    for i:=1 to 3 do
        if a[i]&lt;&gt;b[i] then exit(false);
    equ:=true;
end;

begin
    assign(input,&#39;hop.in&#39;);reset(input);
    assign(output,&#39;hop.out&#39;);rewrite(output);
    for i:=1 to 3 do read(f[i]);
    for i:=1 to 3 do read(t[i]);
    sort(f);c1:=0;r1:=cal(f,maxlongint,@c1);
    sort(t);c2:=0;r2:=cal(t,maxlongint,@c2);
    if not equ(r1,r2) then begin write(&#39;NO&#39;);halt end;
    if c1&gt;c2 then f:=cal(f,c1-c2,@i);
    if c2&gt;c1 then t:=cal(t,c2-c1,@i);
    l:=0;r:=c1+c2;ans:=0;
    while l&lt;=r do begin
        mid:=(l+r) shr 1;
        if equ(cal(f,mid,@i),cal(t,mid,@i)) then begin
            ans:=mid*2;r:=mid-1
        end else l:=mid+1;
    end;
    writeln(&#39;YES&#39;);write(ans+abs(c1-c2));
    close(input);close(output);
end.
</code></pre>]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[NOIP模拟赛 2014-10-18]]></title>
      <url>https://cothrax.github.io/2016/09/22/noip-2014-10-18/</url>
      <content type="html"><![CDATA[<table>
<thead>
<tr>
<th style="text-align:center">题目</th>
<th style="text-align:center">思路</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">jkl</td>
<td style="text-align:center">贪心乱搞</td>
</tr>
<tr>
<td style="text-align:center">walk</td>
<td style="text-align:center">倍增</td>
</tr>
<tr>
<td style="text-align:center">mokou</td>
<td style="text-align:center">mst+遍历</td>
</tr>
<tr>
<td style="text-align:center">submatrix</td>
<td style="text-align:center">单调栈</td>
</tr>
</tbody>
</table>
<h1 id="P1-肥得更高"><a href="#P1-肥得更高" class="headerlink" title="P1 肥得更高"></a>P1 肥得更高</h1><p>现在，你有n亩的小麦地需要增产，你拥有一些金坷垃，但是金坷垃极其稀少，掺肥料也只够你撒K次。<br>众所周知，金坷垃能激活土壤深处的氮磷钾，同一块地可以撒多次肥料，但是效果是有略微衰减的。<br>实地考察后你发现，第i亩土地第x次撒肥料增产a[i]-x+1公斤。<br>hzwer将代替你去撒肥料，但是他是个蒟蒻，完全不动大脑，所以你想知道如果他随机撒肥料，最坏情况下小麦将增产多少，最好情况下将增产多少？(他最多只会对第i亩地撒肥料a[i]次)<br><a id="more"></a></p>
<h2 id="格式"><a href="#格式" class="headerlink" title="格式"></a>格式</h2><h3 id="输入格式"><a href="#输入格式" class="headerlink" title="输入格式"></a>输入格式</h3><p>第一行两个整数n，K<br>第二行n个整数，第i个整数为a[i]</p>
<h3 id="输出格式"><a href="#输出格式" class="headerlink" title="输出格式"></a>输出格式</h3><p>输出最大值，最小值，空格隔开</p>
<h2 id="样例"><a href="#样例" class="headerlink" title="样例"></a>样例</h2><h3 id="样例输入"><a href="#样例输入" class="headerlink" title="样例输入"></a>样例输入</h3><blockquote>
<p>5 10<br>10 3 3 1 2</p>
</blockquote>
<h3 id="样例输出"><a href="#样例输出" class="headerlink" title="样例输出"></a>样例输出</h3><blockquote>
<p>58 26</p>
</blockquote>
<h2 id="提示​"><a href="#提示​" class="headerlink" title="提示​"></a>提示​</h2><p>对于30%的数据n，k&lt;=1000<br>对于70%的数据n，k&lt;=200000<br>对于100%的数据n，k，a[i]&lt;=1000000</p>
<h2 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h2><p>贪心乱搞<br>显然每次取最小值，每次取出a[i]后，a[i]-=1，可以用cnt[i]记录当前a[j]=i的j的个数<br>至于最大值，拿一个指针指想cnt[i]&gt;0的最大i，每次<code>dec(cnt[i]);inc(cnt[i-1])</code>，模拟k次即可<br>最小值的话，因为根据样例a[i]不能减负数，那么用一个指针指向cnt[i]&gt;0的最小i，然后一次性处理cnt[i]（相当于对a[j]=i的所有地j各撒i此，让a[j]减到0，用等差数列求和），然后向上找可用的i，记录次数直到k次<br>最后一个点会爆int</p>
<p><div style="display:none;" class="copy"><br>    <a href="/2016/09/22/noip-2014-10-18/jkl.pas" title="{plain text}">{plain text}</a><br></div><br>```delphi jkl.pas<br>uses math;<br>type int=longint;<br>var<br>    tmp,cnt:array[-1000010..1000010] of int;<br>    n,k,i,j,mn,mx,p:int;ans:int64;</p>
<p>begin<br>    assign(input,’jkl.in’);reset(input);<br>    assign(output,’jkl.out’);rewrite(output);<br>    read(n,k);<br>    mn:=maxlongint;mx:=0;<br>    for i:=1 to n do begin<br>        read(j);inc(cnt[j]);<br>        mn:=min(j,mn);mx:=max(j,mx);<br>    end;<br>    tmp:=cnt;ans:=0;<br>    for i:=1 to k do begin<br>        while cnt[mx]=0 do dec(mx);<br>        inc(ans,mx);dec(cnt[mx]);inc(cnt[mx-1]);<br>    end;<br>    write(ans,’ ‘);<br>    p:=mn;i:=k;ans:=0;<br>    while i&gt;0 do begin<br>        while (tmp[p]=0) do inc(p);<br>        //p+p-1+p-2+…1<br>        dec(tmp[p]);j:=min(i,p);dec(i,j);<br>        inc(ans,(p+(p-j+1))*j div 2);<br>    end;<br>    write(ans);<br>    close(input);close(output);<br>end.</p>
<pre><code>
# P2 滑板鞋
你在魅力之都购买了一双时尚的滑板鞋，你非常兴奋地到处摩擦！
hzwer很想问一个问题：按照你的行动方式，你从某个结点摩擦（移动）K步后能到的目的地
这显然是一个很简单的问题，但是蒟蒻hzwer总是问个不停，所以你决定写一个程序回答他的询问

&lt;!--more--&gt;

## 格式
### 输入格式
第一行两个数n，m表示结点个数和询问次数
接下来n行，第i个数一个数a[i]表示你在第i个结点的话，下一步会移动到第a[i]个结点
接下来m行，每行两个数t,k，蒟蒻hzwer询问如果你当前在第t个结点，k步之后你会到第几个节点


### 输出格式
m行为每次询问的结果

## 样例
### 样例输入
&gt;3 2
2
3
2
1 2
2 4

### 样例输出
&gt;3
2

## 提示​
共十个测试点，每个测试点数据规模如下所示
1. n=10^2,m=n,k&lt;=10^2
2. n=10^3,m=n,k&lt;=10^3
3. n=10^4,m=1,k&lt;=10^9
4. n=10^5,m=1,k&lt;=10^9
5. n=10^5,m=1,k&lt;=10^12
6. n=10^5,m=1,k&lt;=10^15
7. n=10^5,m=1,k&lt;=10^18
8. n=10^5,m=n,k&lt;=10^12
9. n=10^5,m=n,k&lt;=10^15
10.n=10^5,m=n,k&lt;=10^18

## 题解
倍增即可

&lt;div style=&quot;display:none;&quot; class=&quot;copy&quot;&gt;
    <a href="/2016/09/22/noip-2014-10-18/walk.pas" title="{plain text}">{plain text}</a>
&lt;/div&gt;
```delphi walk.pas
type int=longint;
const mx=60;
var
    f:array[0..100010,0..mx] of int;
    bin:array[0..mx] of int64;
    n,m,t,i,j:int;k:int64;

begin
    assign(input,&#39;walk.in&#39;);reset(input);
    assign(output,&#39;walk.out&#39;);rewrite(output);
    read(n,m);
    for i:=1 to n do read(f[i,0]);
    bin[0]:=1;
    for i:=1 to mx do bin[i]:=bin[i-1]*int64(2);
    for j:=1 to mx do
        for i:=1 to n do
            f[i,j]:=f[f[i,j-1],j-1];
    for i:=1 to m do begin
        read(t,k);
        for j:=mx downto 0 do
            if bin[j]&lt;=k then begin
                dec(k,bin[j]);t:=f[t,j];
            end;
        writeln(t);
    end;
    close(input);close(output);
end.
</code></pre><h1 id="P3-警察叔叔"><a href="#P3-警察叔叔" class="headerlink" title="P3 警察叔叔"></a>P3 警察叔叔</h1><p>魅力之都是一个有N个路口，M条双向道路连接的城市。警察叔叔绘制了一张特殊的地图，在地图上只保留了N-1条道路，我们称这些道路为【特殊道路】，要保证任意两个路口间有且仅有一条路径，且满足所有保留的道路长度之和最小。<br>现在要在其中一个连接有多条【特殊道路】的路口设立【根据地】，去掉【根据地】所在路口后，就会出现某些路口间无法通过【特殊道路】相互连通的情况，我们认为这时仍然能够通过【特殊道路】连通的路口属于同一个【区域】。警察叔叔希望最后每个【区域】的【特殊道路】总长尽可能平均。警察叔叔找到了hzwer，但是hzwer是个无向图和有向图都无法区分的蒟蒻，请你帮他计算出应该选择哪一个路口作为【根据地】。<br>(尽可能平均即权值最小，设每一块【区域】的路线总长为Length[i]（包括连接【根据地】与该【区域】的边），平均路线长度为Avg=SUM{Length[i]}/区域数，权值d=∑ (Length[i]-Avg)^2</p>
<!--more-->
<h2 id="格式-1"><a href="#格式-1" class="headerlink" title="格式"></a>格式</h2><h3 id="输入格式-1"><a href="#输入格式-1" class="headerlink" title="输入格式"></a>输入格式</h3><p>第1行：2个正整数N,M<br>第2..M+1行：每行2个整数u,v和1个实数len，表示u,v之间存在长度为len的边</p>
<h3 id="输出格式-1"><a href="#输出格式-1" class="headerlink" title="输出格式"></a>输出格式</h3><p>第1行：1个整数，最后选择的路口编号（存在多个可选路口时选择编号小的）</p>
<h2 id="样例-1"><a href="#样例-1" class="headerlink" title="样例"></a>样例</h2><h3 id="样例输入-1"><a href="#样例输入-1" class="headerlink" title="样例输入"></a>样例输入</h3><blockquote>
<p>3 3<br>3 1 5<br>3 2 4<br>1 2 3</p>
</blockquote>
<h3 id="样例输出-1"><a href="#样例输出-1" class="headerlink" title="样例输出"></a>样例输出</h3><blockquote>
<p>2</p>
</blockquote>
<h2 id="提示​-1"><a href="#提示​-1" class="headerlink" title="提示​"></a>提示​</h2><p>对于60%的数据：3 ≤ N ≤ 2,000，N-1 ≤ M ≤ 50,000<br>对于100%的数据：3 ≤ N ≤ 40,000，N-1 ≤ M ≤ 200,000<br>对于100%的数据：0 &lt; len ≤ 100,000,000<br>保证不存在相同距离的线路，两个路口间可能出现多条路径，且任意点对间至少存在一条路径</p>
<h2 id="题解-1"><a href="#题解-1" class="headerlink" title="题解"></a>题解</h2><p>首先最小生成树显然<br>然后以1为根，在树上遍历统计以点i为根的子树上的边权和len[i]，在for一遍每个点找出最小值。<br>注意权值不是方差，而是方差×n。</p>
<p><div style="display:none;" class="copy"><br>    <a href="/2016/09/22/noip-2014-10-18/mokou.pas" title="{plain text}">{plain text}</a><br></div><br>```delphi mokou.pas<br>type<br>    int=longint;<br>    edge=record t,next:int;w:double end;<br>    e1=record f,t:int;w:double end;<br>const eps=0.0000000001;<br>var<br>    e:array[0..200010] of e1;<br>    g:array[0..80010] of edge;<br>    head,par,rnk,cnt:array[0..40010] of int;<br>    len:array[0..40010] of double;<br>    n,m,sz,i,ans:int;tmp,sum,mn:double;</p>
<p>procedure add(f,t:int;w:double);<br>begin<br>    inc(sz);g[sz].t:=t;g[sz].w:=w;<br>    g[sz].next:=head[f];head[f]:=sz;<br>end;</p>
<p>procedure swap(var a,b:e1);<br>var tmp:e1;<br>begin tmp:=a;a:=b;b:=tmp end;<br>procedure qsort(l,r:int);<br>var i,j:int;x:double;<br>begin<br>    i:=l;j:=r;x:=e[random(r-l)+l].w;<br>    repeat<br>        while e[i].w<x do="" inc(i);="" while="" e[j].w="">x do dec(j);<br>        if i&lt;=j then begin<br>            swap(e[i],e[j]);inc(i);dec(j);<br>        end;<br>    until i&gt;j;<br>    if i&lt;r then qsort(i,r);<br>    if l&lt;j then qsort(l,j);<br>end;</x></p>
<p>function find(x:int):int;<br>begin<br>    if par[x]=x then find:=x<br>    else begin<br>        par[x]:=find(par[x]);find:=par[x];<br>    end;<br>end;<br>procedure union(x,y:int);<br>begin<br>    x:=find(x);y:=find(y);<br>    if x=y then exit;<br>    if rnk[x]&lt;rnk[y] then par[x]:=y<br>    else begin<br>        par[y]:=x;<br>        if rnk[x]=rnk[y] then inc(rnk[x]);<br>    end;<br>end;<br>function same(x,y:int):boolean;<br>begin same:=find(x)=find(y) end;</p>
<p>function dfs(v,p:int):double;<br>var i,u:int;<br>begin<br>    len[v]:=0;cnt[v]:=0;<br>    i:=head[v];<br>    while i&lt;&gt;0 do begin<br>        u:=g[i].t;inc(cnt[v]);<br>        if u&lt;&gt;p then len[v]:=len[v]+dfs(u,v)+g[i].w;<br>        i:=g[i].next;<br>    end;<br>    dfs:=len[v];<br>end;</p>
<p>function cal(v:int):double;<br>var i,u:int;avg:double;<br>begin<br>    if cnt[v]=1 then exit(-1);<br>    avg:=sum/cnt[v];cal:=0;<br>    i:=head[v];<br>    while i&lt;&gt;0 do begin<br>        u:=g[i].t;<br>        if len[u]<len[v] then="" cal:="cal+sqr(len[u]+g[i].w-avg);" i:="g[i].next;" end;="" if="" v<="">1 then begin<br>        cal:=cal+sqr(sum-len[v]-avg);<br>    end;<br>end;</len[v]></p>
<p>begin<br>    assign(input,’mokou.in’);reset(input);<br>    assign(output,’mokou.out’);rewrite(output);<br>    read(n,m);<br>    for i:=1 to m do read(e[i].f,e[i].t,e[i].w);<br>    qsort(1,m);<br>    for i:=1 to n do begin<br>        par[i]:=i;rnk[i]:=0;<br>    end;<br>    sz:=0;sum:=0;<br>    for i:=1 to m do<br>        if not same(e[i].f,e[i].t) then begin<br>            union(e[i].f,e[i].t);<br>            sum:=sum+e[i].w;<br>            add(e[i].f,e[i].t,e[i].w);<br>            add(e[i].t,e[i].f,e[i].w);<br>        end;<br>    mn:=-1;dfs(1,0);<br>    for i:=1 to n do begin<br>        tmp:=cal(i);if tmp+1&lt;eps then continue;<br>        if (mn=-1) or (tmp&lt;mn) then begin<br>            mn:=tmp;ans:=i;<br>        end;<br>    end;<br>    write(ans);<br>    close(input);close(output);<br>end.</p>
<pre><code>
# P4 请客
chenzeyu97的家可以看成是一个n\*m的矩阵，每块区域都有独一无二的海拔高度h（h&gt;0）！其最大值为n\*m。现在他要选择一个子矩阵摆放一张桌子，在他眼里，这样摆放桌子的美观度为这个子矩阵的最小值，他想知道，如果他要求摆放桌子的美观度为i，那么可以选择多少种子矩阵呢？对于所有可能的i值（1&lt;=i&lt;=n\*m），你都应该得出其方案数，这样你就能顶替蒟蒻hzwer获得被请客的资格！

&lt;!--more--&gt;

## 格式
### 输入格式
第一行两个整数n，m
接下来n行，每行m个整数，描述chenzeyu97的家

### 输出格式
n*m行，每行一个整数，第i行表示美观度i的方案数

## 样例
### 样例输入
&gt;2 3
2 5 1
6 3 4

### 样例输出
&gt;6
4
5
1
1
1

## 提示​
30%的数据1&lt;=n,m&lt;=50
100%的数据1&lt;=n,m&lt;=300

## 题解
单调栈
依然考虑每个点对答案的贡献
对于一个点向二维扩展不方便，于是枚举左右边界l和r
预处理每一行l..r的最小值mn
对行i，记向上的第一个mn[j]小于mn[i]的行为j，向下第一个mn[k]小于mn[i]的行为k，那么i对答案（美观度为mn[i]的数量）的贡献为(i-j)*(i-k)
对于j和k可以用单调栈求得

&lt;div style=&quot;display:none;&quot; class=&quot;copy&quot;&gt;
    <a href="/2016/09/22/noip-2014-10-18/submatrix.pas" title="{plain text}">{plain text}</a>
&lt;/div&gt;
```delphi submatrix.pas
uses math;
type int=longint;
const inf=1000000000;
var 
    a:array[0..310,0..310] of int;
    mn:array[0..310] of int;
    s:array[0..310,0..1] of int;
    ans:array[0..100010] of int;
    n,m,i,j,k:longint;

procedure cal();
var t,i:int;
begin
    t:=0;s[0,1]:=0;
    for i:=1 to n do begin
        while (t&gt;0) and (s[t,0]&gt;mn[i]) do begin
            inc(ans[s[t,0]],(s[t,1]-s[t-1,1])*(i-s[t,1]));
            dec(t);
        end;
        inc(t);s[t,0]:=mn[i];s[t,1]:=i;
    end;
    while t&gt;0 do begin
        inc(ans[s[t,0]],(s[t,1]-s[t-1,1])*(n+1-s[t,1]));
        dec(t);
    end;
end;

begin
    assign(input,&#39;submatrix.in&#39;);reset(input);
    assign(output,&#39;submatrix.out&#39;);rewrite(output);
    read(n,m);
    for i:=1 to n do
        for j:=1 to m do read(a[i,j]);
    for i:=1 to m do begin
        filldword(mn,sizeof(mn) div 4,inf);
        for j:=i to m do begin
            for k:=1 to n do
                mn[k]:=min(mn[k],a[k,j]);
            cal();
        end;
    end;
    for i:=1 to m*n do writeln(ans[i]);
    close(input);close(output);
end.
</code></pre>]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[NOIP模拟赛 2014-10-5]]></title>
      <url>https://cothrax.github.io/2016/09/22/noip-2014-10-5/</url>
      <content type="html"><![CDATA[<table>
<thead>
<tr>
<th style="text-align:center">题目</th>
<th style="text-align:center">思路</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">tree</td>
<td style="text-align:center">LCA</td>
</tr>
<tr>
<td style="text-align:center">mat</td>
<td style="text-align:center">概率期望+指针+前缀</td>
</tr>
<tr>
<td style="text-align:center">num</td>
<td style="text-align:center">背包+组合数学+容斥</td>
</tr>
</tbody>
</table>
<h1 id="P1-祖孙询问"><a href="#P1-祖孙询问" class="headerlink" title="P1 祖孙询问"></a>P1 祖孙询问</h1><p>已知一棵n个节点的有根树。有m个询问。每个询问给出了一对节点的编号x和y，询问x与y的祖孙关系。<br><a id="more"></a></p>
<h2 id="格式"><a href="#格式" class="headerlink" title="格式"></a>格式</h2><h3 id="输入格式"><a href="#输入格式" class="headerlink" title="输入格式"></a>输入格式</h3><p> 输入第一行包括一个整数n表示节点个数。<br>接下来n行每行一对整数对a和b表示a和b之间有连边。如果b是-1，那么a就是树的根。<br>第n+2行是一个整数m表示询问个数。<br>接下来m行，每行两个正整数x和y。</p>
<h3 id="输出格式"><a href="#输出格式" class="headerlink" title="输出格式"></a>输出格式</h3><p>对于每一个询问，输出1:如果x是y的祖先，输出2:如果y是x的祖先，否则输出0。</p>
<h2 id="样例"><a href="#样例" class="headerlink" title="样例"></a>样例</h2><h3 id="样例输入"><a href="#样例输入" class="headerlink" title="样例输入"></a>样例输入</h3><blockquote>
<p>10<br>234 -1<br>12 234<br>13 234<br>14 234<br>15 234<br>16 234<br>17 234<br>18 234<br>19 234<br>233 19<br>5<br>234 233<br>233 12<br>233 13<br>233 15<br>233 19</p>
</blockquote>
<h3 id="样例输出"><a href="#样例输出" class="headerlink" title="样例输出"></a>样例输出</h3><blockquote>
<p>1<br>0<br>0<br>0<br>2</p>
</blockquote>
<h2 id="提示​"><a href="#提示​" class="headerlink" title="提示​"></a>提示​</h2><p>对于30%的数据，n,m≤1000。<br>对于100%的.据,n,m≤40000，每个节点的编号都不超过40000。</p>
<h2 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h2><p>裸的LCA，倍增即可</p>
<p><div style="display:none;" class="copy"><br>    <a href="/2016/09/22/noip-2014-10-5/tree.pas" title="{plain text}">{plain text}</a><br></div><br>```delphi tree.pas<br>uses math;<br>type<br>    int=longint;<br>    edge=record t,next:int end;<br>var<br>    g:array[0..80010] of edge;<br>    head,dep:array[0..40010] of int;<br>    par:array[0..40010,0..20] of int;<br>    n,m,logn,k,sz,i,j,r,f,t:int;</p>
<p>procedure add(f,t:int);<br>begin<br>    inc(sz);g[sz].t:=t;<br>    g[sz].next:=head[f];head[f]:=sz;<br>end;</p>
<p>procedure dfs(v,p:int);<br>var i,u:int;<br>begin<br>    dep[v]:=dep[p]+1;par[v,0]:=p;<br>    i:=head[v];<br>    while i&lt;&gt;0 do begin<br>        u:=g[i].t;<br>        if u&lt;&gt;p then dfs(u,v);<br>        i:=g[i].next;<br>    end;<br>end;</p>
<p>procedure swap(var a,b:int);<br>var tmp:int;<br>begin tmp:=a;a:=b;b:=tmp end;</p>
<p>function lca(u,v:int):int;<br>var i:int;<br>begin<br>    if dep[u]<dep[v] 0="" then="" swap(u,v);="" for="" i:="logn" downto="" do="" if="" dep[par[u,i]]="">=dep[v] then<br>            u:=par[u,i];<br>    if v=u then exit(u);<br>    for i:=logn downto 0 do<br>        if par[u,i]&lt;&gt;par[v,i] then begin<br>            u:=par[u,i];v:=par[v,i];<br>        end;<br>    lca:=par[u,0];<br>end;</dep[v]></p>
<p>begin<br>    assign(input,’tree.in’);reset(input);<br>    assign(output,’tree.out’);rewrite(output);<br>    read(n);k:=0;<br>    for i:=1 to n do begin<br>        read(f,t);<br>        k:=max(k,max(f,t));<br>        if t=-1 then r:=f<br>        else begin add(f,t);add(t,f) end;<br>    end;<br>    dep[0]:=0;dfs(r,0);<br>    logn:=floor(ln(n)/ln(2));<br>    for i:=1 to logn do<br>        for j:=1 to k do<br>            par[j,i]:=par[par[j,i-1],i-1];<br>    read(m);<br>    for i:=1 to m do begin<br>        read(f,t);<br>        //if f=t then begin writeln(0);continue end;<br>        j:=lca(f,t);<br>        if j=f then writeln(1)<br>        else if j=t then writeln(2)<br>        else writeln(0);<br>    end;<br>    close(input);close(output);<br>end.</p>
<pre><code>
# P2 比赛
有两个队伍A和B，每个队伍都有n个人。这两支队伍之间进行n场1对1比赛，每一场都是由A中的一个选手与B中的一个选手对抗。同一个人不会参加多场比赛，每个人的对手都是随机而等概率的。例如A队有A1和A2两个人，B队有B1和B2两个人，那么(A1 vs B1,A2 vs B2)和(A1 vs B2,A2 vs B1)的概率都是均等的50%。
每个选手都有一个非负的实力值。如果实力值为X和Y的选手对抗，那么实力值较强的选手所在的队伍将会获得(X-Y)^2的得分。
求A的得分减B的得分的期望值。
&lt;!--more--&gt;

## 格式
### 输入格式
第一行一个数n表示两队的人数为n。
第二行n个数，第i个数A[i]表示队伍A的第i个人的实力值。
第三行n个数，第i个数B[i]表示队伍B的第i个人的实力值。

### 输出格式
输出仅包含一个实数表示A期望赢B多少分。答案保留到小数点后一位（注意精度）。
## 样例
### 样例输入
&gt;2
3 7
1 5

### 样例输出
&gt;20.0

## 提示​
对于30%的数据，n≤50。
对于100%的.据,n≤50000;A[i],B[i]≤50000。

## 题解
考虑a中的每个点对答案的贡献
对于点i，它对答案的贡献$$=\frac{\sum_j(a[i]-a[j])^2-\sum_k(a[i]-a[k])^2}{n}$$
其中j为b中所有实力值小于a[i]的人，k为b中所有实力值大于a[i]的人，这个值可以qsort后，用一个指针维护。
式子变形后，维护一个前缀和、前缀平方和，即可在O(N)内解决。
注意点：a数组设为int64，int与int64混合计算可能溢出

&lt;div style=&quot;display:none;&quot; class=&quot;copy&quot;&gt;
    <a href="/2016/09/22/noip-2014-10-5/mat.pas" title="{plain text}">{plain text}</a>
&lt;/div&gt;
```delphi mat.pas
type 
    int=longint;
    arr=array[0..50010] of int64;
var 
    sum,squ,a,b:arr;
    n,i,p:int;sa,sb:int64;

procedure swap(var a,b:int64);
var tmp:int64;
begin tmp:=a;a:=b;b:=tmp end;

procedure qsort(var b:arr;l,r:int);
var i,j:int;x:int64;
begin
    i:=l;j:=r;x:=b[random(r-l)+l];
    repeat
        while b[i]&lt;x do inc(i);
        while b[j]&gt;x do dec(j);
        if i&lt;=j then begin
            swap(b[i],b[j]);
            inc(i);dec(j);
        end;
    until i&gt;j;
    if i&lt;r then qsort(b,i,r);
    if l&lt;j then qsort(b,l,j);
end;

begin
    assign(input,&#39;mat.in&#39;);reset(input);
    assign(output,&#39;mat.out&#39;);rewrite(output);
    read(n);
    for i:=1 to n do read(a[i]);
    for i:=1 to n do read(b[i]);
    qsort(a,1,n);qsort(b,1,n);
    sum[0]:=0;squ[0]:=0;
    for i:=1 to n do begin
        sum[i]:=sum[i-1]+b[i];
        squ[i]:=squ[i-1]+sqr(b[i]);
    end;
    p:=1;sa:=0;sb:=0;
    for i:=1 to n do begin
        while (p&lt;=n) and (b[p]&lt;=a[i]) do inc(p);
        sa:=sa+(p-1)*sqr(a[i])-2*a[i]*sum[p-1]+squ[p-1];
        sb:=sb+(n-p+1)*sqr(a[i])-2*a[i]*(sum[n]-sum[p-1])
            +squ[n]-squ[p-1];
    end;
    write((sa-sb)/n:0:1);
    close(input);close(output);
end.
</code></pre><h1 id="P3-数字"><a href="#P3-数字" class="headerlink" title="P3 数字"></a>P3 数字</h1><p>一个数字被称为好数字当他满足下列条件：</p>
<ol>
<li>它有2*n个数位，n是正整数(允许有前导0)。</li>
<li>构成它的每个数字都在给定的数字集合S中。</li>
<li>它前n位之和与后n位之和相等或者它奇数位之和与偶数位之和相等<br>例如对于n=2,S={1,2}，合法的好数字有1111,1122,1212,1221,2112,2121,2211,2222这样8种。<br>已知n，求合法的好数字的个数mod 999983。</li>
</ol>
<!--more-->
<h2 id="格式-1"><a href="#格式-1" class="headerlink" title="格式"></a>格式</h2><h3 id="输入格式-1"><a href="#输入格式-1" class="headerlink" title="输入格式"></a>输入格式</h3><p>第一行一个数n。<br>接下来一个长度不超过10的字符串，表示给定的数字集合。</p>
<h3 id="输出格式-1"><a href="#输出格式-1" class="headerlink" title="输出格式"></a>输出格式</h3><p>一行一个数字表示合法的好数字的个数mod 999983。</p>
<h2 id="样例-1"><a href="#样例-1" class="headerlink" title="样例"></a>样例</h2><h3 id="样例输入-1"><a href="#样例输入-1" class="headerlink" title="样例输入"></a>样例输入</h3><blockquote>
<p>2<br>0987654321</p>
</blockquote>
<h3 id="样例输出-1"><a href="#样例输出-1" class="headerlink" title="样例输出"></a>样例输出</h3><blockquote>
<p>1240</p>
</blockquote>
<h2 id="提示​-1"><a href="#提示​-1" class="headerlink" title="提示​"></a>提示​</h2><p>对于20%的数据，n≤7。<br>对于100%的.据,n≤1000,|S|≤10。</p>
<h2 id="题解-1"><a href="#题解-1" class="headerlink" title="题解"></a>题解</h2><p>背包+组合数学+容斥<br>见此：<a href="http://www.voidcn.com/blog/pzler/article/p-2260743.html" target="_blank" rel="external">http://www.voidcn.com/blog/pzler/article/p-2260743.html</a><br>$O(|S|N^2)$比较大，注意背包时向前转移，这样可以舍去无效点，加快速度。</p>
<p><div style="display:none;" class="copy"><br>    <a href="/2016/09/22/noip-2014-10-5/num.pas" title="{plain text}">{plain text}</a><br></div><br>```delphi num.pas<br>type int=longint;<br>const z=999983;<br>var<br>    f:array[0..1010,0..10010] of int64;<br>    a:array[0..10] of int;<br>    n,m,i,j,k:int;s:string;<br>    ans,od,ev:int64;p:^int64;</p>
<p>function cal(n:int):int64;<br>var i:int;<br>begin<br>    cal:=0;<br>    for i:=0 to n*9 do cal:=(cal+sqr(f[n,i])) mod z;<br>end;</p>
<p>begin<br>    assign(input,’num.in’);reset(input);<br>    assign(output,’num.out’);rewrite(output);<br>    readln(n);readln(s);<br>    m:=length(s);<br>    for i:=1 to m do a[i]:=ord(s[i])-ord(‘0’);<br>    fillchar(f,sizeof(f),0);<br>    f[0,0]:=1;<br>    for i:=0 to n do<br>        for j:=0 to i<em>9 do<br>            if f[i,j]&gt;0 then<br>                for k:=1 to m do begin<br>                    p:=@f[i+1,j+a[k]];<br>                    p^:=(p^+f[i,j]) mod z;<br>                end;<br>    ans:=cal(n);ev:=cal(n shr 1);od:=cal((n+1) shr 1);<br>    write((ans</em>2+z-ev*od mod z) mod z);<br>    close(input);close(output);<br>end.<br>```</p>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[NOIP模拟赛 2014-10-6]]></title>
      <url>https://cothrax.github.io/2016/09/21/noip-2014-10-6/</url>
      <content type="html"><![CDATA[<p>一道模拟和一道平衡树区间k大没有做</p>
<table>
<thead>
<tr>
<th style="text-align:center">题目</th>
<th style="text-align:center">思路</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">catclimb</td>
<td style="text-align:center">dfs</td>
</tr>
<tr>
<td style="text-align:center">disblo</td>
<td style="text-align:center">分组背包+输出方案</td>
</tr>
</tbody>
</table>
<h1 id="P1-小猫爬山"><a href="#P1-小猫爬山" class="headerlink" title="P1 小猫爬山"></a>P1 小猫爬山</h1><p>Freda和rainbow饲养了N只小猫，这天，小猫们要去爬山。经历了千辛万苦，小猫们终于爬上了山顶，但是疲倦的它们再也不想徒步走下山了（呜咕&gt;_&lt;）。<br>Freda和rainbow只好花钱让它们坐索道下山。索道上的缆车最大承重量为W，而N只小猫的重量分别是C1、C2……CN。当然，每辆缆车上的小猫的重量之和不能超过W。每租用一辆缆车，Freda和rainbow就要付1美元，所以他们想知道，最少需要付多少美元才能把这N只小猫都运送下山？<br><a id="more"></a></p>
<h2 id="格式"><a href="#格式" class="headerlink" title="格式"></a>格式</h2><h3 id="输入格式"><a href="#输入格式" class="headerlink" title="输入格式"></a>输入格式</h3><p>第一行包含两个用空格隔开的整数，N和W。<br>接下来N行每行一个整数，其中第i+1行的整数表示第i只小猫的重量C i。</p>
<h3 id="输出格式"><a href="#输出格式" class="headerlink" title="输出格式"></a>输出格式</h3><p>输出一个整数，最少需要多少美元，也就是最少需要多少辆缆车。</p>
<h2 id="样例"><a href="#样例" class="headerlink" title="样例"></a>样例</h2><h3 id="样例输入"><a href="#样例输入" class="headerlink" title="样例输入"></a>样例输入</h3><blockquote>
<p>5 1996<br>1<br>2<br>1994<br>12<br>29</p>
</blockquote>
<h3 id="样例输出"><a href="#样例输出" class="headerlink" title="样例输出"></a>样例输出</h3><blockquote>
<p>2</p>
</blockquote>
<h2 id="提示​"><a href="#提示​" class="headerlink" title="提示​"></a>提示​</h2><p>对于100%的数据，1&lt;=N&lt;=18，1&lt;=C i &lt;=W&lt;=10^8。</p>
<h2 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h2><p>dfs即可，加上最优性剪枝可过</p>
<p><div style="display:none;" class="copy"><br>    <a href="/2016/09/21/noip-2014-10-6/catclimb.pas" title="{plain text}">{plain text}</a><br></div><br>```delphi catclimb.pas<br>uses math;<br>type int=longint;<br>var<br>    a,f:array[0..20] of int;<br>    n,i,cnt,ans:int;w:int;</p>
<p>procedure dfs(x:int);<br>var i:int;<br>begin<br>    if cnt&gt;=ans then exit;<br>    if x=n+1 then begin ans:=min(ans,cnt);exit end;<br>    for i:=1 to cnt do<br>        if a[x]+f[i]&lt;=w then begin<br>            inc(f[i],a[x]);<br>            dfs(x+1);<br>            dec(f[i],a[x]);<br>        end;<br>    inc(cnt);inc(f[cnt],a[x]);<br>    dfs(x+1);<br>    dec(f[cnt],a[x]);dec(cnt);<br>end;</p>
<p>begin<br>    assign(input,’catclimb.in’);reset(input);<br>    assign(output,’catclimb.out’);rewrite(output);<br>    read(n,w);<br>    for i:=1 to n do read(a[i]);<br>    ans:=maxlongint;<br>    dfs(1);<br>    write(ans);<br>    close(input);close(output);<br>end.</p>
<pre><code>
# P2 暗黑破坏神
无聊中的小x玩起了Diablo I...
游戏的主人公有n个魔法
每个魔法分为若干个等级，第i个魔法有p[i]个等级(不包括0)
每个魔法的每个等级都有一个效果值，一个j级的i种魔法的效果值为w[i][j]
魔法升一级需要一本相应的魔法书
购买魔法书需要金币，第i个魔法的魔法书价格为c[i]
而小x只有m个金币(好孩子不用修改器)
你的任务就是帮助小x决定如何购买魔法书才能使所有魔法的效果值之和最大
开始时所有魔法为0级 效果值为0
&lt;!--more--&gt;

## 格式
### 输入格式
第一行 用空格隔开的两个整数n m
以下n行 描述n个魔法
第i+1行描述 第i个魔法 格式如下
c[i] p[i] w[i][1] w[i][2] ... w[i][p[i]]

### 输出格式
第一行输出一个整数，即最大效果值。
以后n行输出你的方案：
第i+1行有一个整数v[i] 表示你决定把第i个魔法学到v[i]级
如果有多解 输出花费金币最少的一组
如果还多解 输出任意一组

## 样例
### 样例输入
&gt;3 10
1 3 1 2 2
2 3 2 4 6
3 3 2 1 10

### 样例输出
&gt;11
1
0
3

## 提示​
1&lt;=n&lt;=100
1&lt;=m&lt;=500
1&lt;=p[i]&lt;=50
1&lt;=c[i]&lt;=10
保证输入数据和最终结果在longint范围内

## 题解
分组背包
f[i,j]表示前i个花费j的最大值，$k\in[1,p_i]$
方程：$$f[i,j]:=max\{f[i,j],f[i-1,j-k*c[i]]+w[i,k]\}$$
至于输出方案，向前迭代即可。

&lt;div style=&quot;display:none;&quot; class=&quot;copy&quot;&gt;
    <a href="/2016/09/21/noip-2014-10-6/diablo.pas" title="{plain text}">{plain text}</a>
&lt;/div&gt;
```delphi diablo.pas
uses math;
type int=longint;
var 
    p,c:array[0..110] of int;
    w:array[0..110,0..51] of int;
    f:array[0..110,0..1010] of int;
    g:array[0..110] of int;
    n,m,i,j,k,ans:int;

begin
    assign(input,&#39;diablo.in&#39;);reset(input);
    assign(output,&#39;diablo.out&#39;);rewrite(output);
    read(n,m);
    for i:=1 to n do begin
        read(c[i],p[i]);
        for j:=1 to p[i] do read(w[i,j]);
    end;
    f[0,0]:=0;
    for i:=1 to n do
        for j:=0 to m do
            for k:=0 to min(j div c[i],p[i]) do
                f[i,j]:=max(f[i,j],f[i-1,j-k*c[i]]+w[i,k]);
    ans:=0;
    for i:=1 to m do
        if f[n,i]&gt;ans then begin
            ans:=f[n,i];j:=i;
        end;
    for i:=n downto 1 do
        for k:=0 to min(j div c[i],p[i]) do
            if f[i,j]=f[i-1,j-k*c[i]]+w[i,k] then begin
                g[i]:=k;j:=j-k*c[i];break;
            end;
    writeln(ans);
    for i:=1 to n do writeln(g[i]);
    close(input);close(output);
end.
</code></pre>]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[NOIP模拟赛 2014-10-4]]></title>
      <url>https://cothrax.github.io/2016/09/20/noip-2014-10-4/</url>
      <content type="html"><![CDATA[<table>
<thead>
<tr>
<th style="text-align:center">题目</th>
<th style="text-align:center">思路</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">password</td>
<td style="text-align:center">折半枚举</td>
</tr>
<tr>
<td style="text-align:center">formation</td>
<td style="text-align:center">LIS</td>
</tr>
<tr>
<td style="text-align:center">escape</td>
<td style="text-align:center">二分+bfs</td>
</tr>
</tbody>
</table>
<h1 id="P1-某种密码"><a href="#P1-某种密码" class="headerlink" title="P1 某种密码"></a>P1 某种密码</h1><p>关于某种密码有如下描述：某种密码的原文A是由N个数字组成，而密文B是一个长度为N的01数串，原文和密文的关联在于一个钥匙码KEY。若KEY=∑▒〖Ai*Bi〗，则密文就是原文的一组合法密码。<br>现在有原文和钥匙码，请编一个程序来帮助他统计到底有多少个符合条件的密文。<br><a id="more"></a></p>
<h2 id="格式"><a href="#格式" class="headerlink" title="格式"></a>格式</h2><h3 id="输入格式"><a href="#输入格式" class="headerlink" title="输入格式"></a>输入格式</h3><p>第一行两个数N，KEY，意义同题目描述；<br>第二行N个数表示原文A，意义同题目描述。</p>
<h3 id="输出格式"><a href="#输出格式" class="headerlink" title="输出格式"></a>输出格式</h3><p>一个数ANS，表示对于原文A和KEY，有多少组可行的密文B。</p>
<h2 id="样例"><a href="#样例" class="headerlink" title="样例"></a>样例</h2><h3 id="样例输入"><a href="#样例输入" class="headerlink" title="样例输入"></a>样例输入</h3><blockquote>
<p>3 2<br>1 1 2</p>
</blockquote>
<h3 id="样例输出"><a href="#样例输出" class="headerlink" title="样例输出"></a>样例输出</h3><blockquote>
<p>2</p>
</blockquote>
<h2 id="提示​"><a href="#提示​" class="headerlink" title="提示​"></a>提示​</h2><p>密文110，1<em>1+1</em>1+0<em>2=2<br>密文001，0</em>1+0<em>1+1</em>2=2<br>一共两组可行的密文。<br>60%数据满足N&lt;=25<br>100%数据满足N&lt;=40，-maxlongint&lt;=∑Ai&lt;=maxlongint</p>
<h2 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h2><p>裸的折半枚举<br>注意点：</p>
<ol>
<li>ai可能为负数</li>
<li>hash中重复元素的计数：每次insert时遍历一遍该链的元素。</li>
</ol>
<p><div style="display:none;" class="copy"><br>    <a href="/2016/09/20/noip-2014-10-4/password.pas" title="{plain text}">{plain text}</a><br></div><br>```delphi password.pas<br>type int=longint;<br>const z=500009;<br>var<br>    a:array[0..41] of int;<br>    hash:array[0..1500000] of int;<br>    amt:array[0..1500000] of int;<br>    next:array[0..1500000] of int;<br>    head:array[0..z] of int;<br>    sz,n,f,k,w,i:int;cnt:int64;</p>
<p>procedure insert(x:int64);<br>var i:int;<br>begin<br>    i:=(x mod z+z) mod z;<br>    if head[i]=0 then begin<br>        inc(sz);head[i]:=sz;<br>        hash[sz]:=x;inc(amt[sz]);<br>        exit;<br>    end;<br>    i:=head[i];<br>    while next[i]&lt;&gt;0 do begin<br>        if hash[i]=x then begin inc(amt[i]);exit end;<br>        i:=next[i];<br>    end;<br>    if hash[i]=x then begin inc(amt[i]);exit end;<br>    inc(sz);hash[sz]:=x;inc(amt[sz]);next[i]:=sz;<br>end;</p>
<p>function query(x:int):int;<br>var i:int;<br>begin<br>    i:=head[(x mod z+z) mod z];<br>    while i&lt;&gt;0 do begin<br>        if hash[i]=x then exit(i);<br>        i:=next[i];<br>    end;<br>    query:=-1;<br>end;</p>
<p>procedure dfs(c,x:int);<br>var t:int;<br>begin<br>    if (x=0) and (c=k+1) then begin insert(f);exit end;<br>    if (x=1) and (c=n+1) then begin<br>        t:=query(w-f);<br>        if t&lt;&gt;-1 then inc(cnt,amt[t]);<br>        exit;<br>    end;<br>    inc(f,a[c]);dfs(c+1,x);<br>    dec(f,a[c]);dfs(c+1,x);<br>end;</p>
<p>begin<br>    assign(input,’password.in’);reset(input);<br>    assign(output,’password.out’);rewrite(output);<br>    read(n,w);k:=n shr 1;<br>    for i:=1 to n do read(a[i]);<br>    sz:=0;f:=0;dfs(1,0);<br>    cnt:=0;f:=0;dfs(k+1,1);<br>    write(cnt);<br>    close(input);close(output);<br>end.</p>
<pre><code>
# P2 球的序列
N个编号为1-n的球，每个球都有唯一的编号。这些球被排成两种序列，分别为A、B序列，现在需要重新寻找一个球的序列l，对于这个子序列l中任意的两个球，要求j,k(j&lt;k)，都要求满足lj在A中位置比lk在A中位置靠前，却lj在B中位置比lk在B中位置靠前，请你计算这个子序列l的最大长度。
&lt;!--more--&gt;

## 格式
### 输入格式
第一行一个整数，表示N。
第二行N个整数，表示A序列。
第三行N个整数，表示B序列。
### 输出格式
一个整数。

## 样例
### 样例输入
&gt;5
1 2 4 3 5
5 2 3 4 1

### 样例输出
&gt;2

## 提示​
样例说明
L可以是{2,3}，也可以是{2,4}
数据范围:
40% N&lt;=5000
100% N&lt;=50000

## 题解
以在a中下标重新给球编号，以在b中下标作为球的权值，然后就变成了LIS。
LIS有$O(NlogN)$的求法


&lt;div style=&quot;display:none;&quot; class=&quot;copy&quot;&gt;
    <a href="/2016/09/20/noip-2014-10-4/formation.pas" title="{plain text}">{plain text}</a>
&lt;/div&gt;
```delphi formation.pas
uses math;
type int=longint;
const inf=100000000;
var 
    a,b,w,f:array[0..50010] of int;
    n,i,j,len:int;

function bin(x:int):int;
var l,r,mid:int;
begin
    bin:=0;;l:=1;r:=len;
    while l&lt;=r do begin
        mid:=(l+r) shr 1;
        if f[mid]&lt;x then begin bin:=mid;l:=mid+1 end
        else r:=mid-1;
    end;
end;

begin
    assign(input,&#39;formation.in&#39;);reset(input);
    assign(output,&#39;formation.out&#39;);rewrite(output);
    read(n);
    for i:=1 to n do read(a[i]);
    for i:=1 to n do begin read(j);b[j]:=i end;
    for i:=1 to n do w[i]:=b[a[i]];
    filldword(f,sizeof(f) div 4,inf);
    f[0]:=0;len:=0;
    for i:=1 to n do begin
        j:=bin(w[i])+1;
        f[j]:=min(f[j],w[i]);
        len:=max(len,j);
    end;
    write(len);
    close(input);close(output);
end.
</code></pre><h1 id="P3-大逃亡"><a href="#P3-大逃亡" class="headerlink" title="P3 大逃亡"></a>P3 大逃亡</h1><p>N（1&lt;=N&lt;=10000），X（1&lt;=x&lt;=1000），Y（1&lt;=Y&lt;=1000）,代表有N个敌人分布一个X行Y列的矩阵上，矩形的行号从0到X-1,列号从0到Y-1再给出四个数字x1,y1,x2,y2,代表你要从点(x1,y1)移到(x2,y2)。在移动的过程中你当然希望离敌人的距离的最小值最大化，现在请求出这个值最大可以为多少,以及在这个前提下，你最少要走多少步才可以回到目标点。注意这里距离的定义为两点的曼哈顿距离，即某两个点的坐标分为(a,b),(c,d),那么它们的距离为|a-c|+|b-d|。<br><!--more--></p>
<h2 id="格式-1"><a href="#格式-1" class="headerlink" title="格式"></a>格式</h2><h3 id="输入格式-1"><a href="#输入格式-1" class="headerlink" title="输入格式"></a>输入格式</h3><p>第一行给出数字N，X，Y<br>第二行给出x1,y1,x2,y2<br>下面将有N行，给出N个敌人所在的坐标</p>
<h3 id="输出格式-1"><a href="#输出格式-1" class="headerlink" title="输出格式"></a>输出格式</h3><p>在一行内输出你离敌人的距离及在这个距离的限制下，你回到目标点最少要移动多少步。</p>
<h2 id="样例-1"><a href="#样例-1" class="headerlink" title="样例"></a>样例</h2><h3 id="样例输入-1"><a href="#样例输入-1" class="headerlink" title="样例输入"></a>样例输入</h3><blockquote>
<p>2 5 6<br>0 0 4 0<br>2 1<br>2 3</p>
</blockquote>
<h3 id="样例输出-1"><a href="#样例输出-1" class="headerlink" title="样例输出"></a>样例输出</h3><blockquote>
<p>2 14</p>
</blockquote>
<h2 id="题解-1"><a href="#题解-1" class="headerlink" title="题解"></a>题解</h2><p>先从敌人所在点bfs一次，计算出每个点离最近敌人的距离<br>然后二分答案+bfs判解</p>
<p><div style="display:none;" class="copy"><br>    <a href="/2016/09/20/noip-2014-10-4/escape.pas" title="{plain text}">{plain text}</a><br></div><br>```delphi escape.pas<br>uses math;<br>type int=longint;<br>const d:array[0..3,0..1] of int=((1,0),(0,1),(-1,0),(0,-1));<br>var<br>    mp,dist:array[0..1010,0..1010] of int;<br>    q:array[0..1000010,0..1] of int;<br>    k,n,m,i,h,t,<br>    x,y,sx,sy,tx,ty,nx,ny,<br>    l,r,mid,ans,mn:int;</p>
<p>function check(x0:int):boolean;<br>begin<br>    if mp[sx,sy]<x0 then="" exit(false);="" fillchar(dist,sizeof(dist),255);="" h:="0;t:=1;q[h,0]:=sx;q[h,1]:=sy;dist[sx,sy]:=0;" while="" h<="">t do begin<br>        x:=q[h,0];y:=q[h,1];inc(h);<br>        for i:=0 to 3 do begin<br>            nx:=x+d[i,0];ny:=y+d[i,1];<br>            if (min(nx,ny)<0) or="" (nx="">=n) or (ny&gt;=m) then continue;<br>            if dist[nx,ny]&lt;&gt;-1 then continue;<br>            if mp[nx,ny]<x0 then="" continue;="" dist[nx,ny]:="dist[x,y]+1;" q[t,0]:="nx;q[t,1]:=ny;inc(t);" end;="" check:="dist[tx,ty]<">-1;<br>end;</x0></0)></x0></p>
<p>begin<br>    assign(input,’escape.in’);reset(input);<br>    assign(output,’escape.out’);rewrite(output);<br>    fillchar(mp,sizeof(mp),255);<br>    read(k,n,m,sx,sy,tx,ty);<br>    h:=0;t:=0;<br>    for i:=1 to k do begin<br>        read(x,y);<br>        q[t,0]:=x;q[t,1]:=y;inc(t);<br>        mp[x,y]:=0;<br>    end;</p>
<pre><code>while h&lt;&gt;t do begin
    x:=q[h,0];y:=q[h,1];inc(h);
    for i:=0 to 3 do begin
        nx:=x+d[i,0];ny:=y+d[i,1];
        if (min(nx,ny)&lt;0) or (nx&gt;=n) or (ny&gt;=m) then continue;
        if mp[nx,ny]&lt;&gt;-1 then continue;
        mp[nx,ny]:=mp[x,y]+1;
        q[t,0]:=nx;q[t,1]:=ny;inc(t);
    end;
end;
l:=0;r:=n+m+2;
while l&lt;=r do begin
    mid:=(l+r) shr 1;
    if check(mid) then begin 
        ans:=mid;mn:=dist[tx,ty];l:=mid+1; 
    end else r:=mid-1;
end;
write(ans,&#39; &#39;,mn);
close(input);close(output);
</code></pre><p>end.<br>```</p>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[NOIP模拟赛 打地鼠游戏]]></title>
      <url>https://cothrax.github.io/2016/09/15/noip-2014-8-2-mouse/</url>
      <content type="html"><![CDATA[<h2 id="描述"><a href="#描述" class="headerlink" title="描述"></a>描述</h2><p>伟大的2320学长特别喜欢打地鼠游戏，这个游戏开始后，会在地板上冒出一些地鼠来，你可以用榔头去敲击这些地鼠，每个地鼠被敲击后，将会增加相应的游戏分值。可是，所有地鼠只会在地上出现一段时间（而且消失后再也不会出现），每个地鼠都在0时刻冒出，但停留的时间可能是不同的，而且每个地鼠被敲击后增加的游戏分值也可能是不同。<br>最近2320学长经常玩这个游戏，以至于敲击每个地鼠只要1秒。他在想如何敲击能使总分最大。<br><a id="more"></a></p>
<h2 id="格式"><a href="#格式" class="headerlink" title="格式"></a>格式</h2><h3 id="输入格式"><a href="#输入格式" class="headerlink" title="输入格式"></a>输入格式</h3><p>输入包含3行，第一行包含一个整数n（1&lt;=n&lt;=100000）表示有n个地鼠从地上冒出来，第二行n个用空格分隔的整数表示每个地鼠冒出后停留的时间（Maxt&lt;=50000），第三行n个用空格分隔的整数表示每个地鼠被敲击后会增加的分值v（v&lt;=1000）。每行中第i个数都表示第i个地鼠的信息。</p>
<h3 id="输出格式"><a href="#输出格式" class="headerlink" title="输出格式"></a>输出格式</h3><p>一个整数，最大分值。</p>
<h2 id="样例"><a href="#样例" class="headerlink" title="样例"></a>样例</h2><h3 id="样例输入"><a href="#样例输入" class="headerlink" title="样例输入"></a>样例输入</h3><blockquote>
<p>5<br>5 3 6 1 4<br>7 9 2 1 5</p>
</blockquote>
<h3 id="样例输出"><a href="#样例输出" class="headerlink" title="样例输出"></a>样例输出</h3><blockquote>
<p>24</p>
</blockquote>
<h2 id="提示​"><a href="#提示​" class="headerlink" title="提示​"></a>提示​</h2><p>30%的数据保证n&lt;=100, t&lt;=500,v&lt;=50<br>60%的数据保证 n&lt;=10000,t&lt;=3000,v&lt;=500<br>100%的数据保证 n&lt;=100000,t&lt;=5000,v&lt;=1000</p>
<h2 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h2><p>以前在codevs上做过这道题，因为数据小写了背包</p>
<p><div style="display:none;" class="copy"><br>    <a href="/2016/09/15/noip-2014-8-2-mouse/7166.pas" title="{plain text}">{plain text}</a><br></div><br>```delphi 7166.pas<br>uses math;<br>var<br>    n,m,i,j,ans:longint;<br>    t,w:array[0..101] of longint;<br>    f:array[0..1010] of longint;</p>
<p>procedure qsort(b,e:longint);<br>var i,j,x,tmp:longint;<br>begin<br>    i:=b;j:=e;x:=t[random(e-b)+b];<br>    repeat<br>        while t[i]<x do="" inc(i);="" while="" t[j]="">x do dec(j);<br>        if i&lt;=j then begin<br>            tmp:=t[i];t[i]:=t[j];t[j]:=tmp;<br>            tmp:=w[i];w[i]:=w[j];w[j]:=tmp;<br>            inc(i);dec(j);<br>        end;<br>    until i&gt;j;<br>    if i&lt;e then qsort(i,e);<br>    if b&lt;j then qsort(b,j);<br>end;</x></p>
<p>begin<br>    read(n);<br>    for i:=1 to n do read(t[i]);<br>    for i:=1 to n do read(w[i]);<br>    qsort(1,n);m:=t[n];<br>    fillchar(f,sizeof(f),0);<br>    for i:=1 to n do<br>        for j:=t[i] downto 1 do<br>            f[j]:=max(f[j],f[j-1]+w[i]);<br>    ans:=0;<br>    for i:=1 to m do ans:=max(ans,f[i]);<br>    write(ans);<br>end.</p>
<pre><code>
但这次数据比较大，于是有两种贪心的思路

- 按价值降序排列，1..n遍历，对于一个地鼠i，从t[i]..1遍历一遍，如果找到没有用过的1秒，用这1秒打这只地鼠。
但最坏复杂度为$O(maxT\cdot n)$，与dp相同

&lt;div style=&quot;display:none;&quot; class=&quot;copy&quot;&gt;
    <a href="/2016/09/15/noip-2014-8-2-mouse/mouse_che.pas" title="{plain text}">{plain text}</a>
&lt;/div&gt;
```delphi mouse_che.pas
type int=longint;
var 
    a,t:array[0..100010] of int;
    used:array[0..50010] of boolean;
    n,i,j:int;ans:int64;

procedure swap(var a,b:int);
var tmp:int;
begin tmp:=a;a:=b;b:=tmp end;

procedure qsort(l,r:int);
var i,j,x:int;
begin
    i:=l;j:=r;x:=a[random(r-l)+r];
    repeat
        while a[i]&gt;x do inc(i);
        while a[j]&lt;x do dec(j);
        if i&lt;=j then begin
            swap(t[i],t[j]);swap(a[i],a[j]);
            inc(i);dec(j);
        end;
    until i&gt;j;
    if i&lt;r then qsort(i,r);
    if l&lt;j then qsort(l,j);
end;

begin
    assign(input,&#39;mouse.in&#39;);reset(input);
    assign(output,&#39;mouse.out&#39;);rewrite(output);
    read(n);
    for i:=1 to n do read(t[i]);
    for i:=1 to n do read(a[i]);
    qsort(1,n);ans:=0;
    for i:=1 to n do begin
        j:=t[i];
        while (j&gt;0) and used[j] do dec(j);
        if j&lt;&gt;0 then begin 
            inc(ans,a[i]);used[j]:=true;
        end;
    end;
    write(ans);
end.
</code></pre><ul>
<li>按时间升序排列地鼠，1..n遍历，打地鼠并统计个数，如果个数超过当前时间，删除已打的地鼠中价值最小的，可以用堆维护。<br>复杂度为$O(NlogN)$</li>
</ul>
<p><div style="display:none;" class="copy"><br>    <a href="/2016/09/15/noip-2014-8-2-mouse/mouse.pas" title="{plain text}">{plain text}</a><br></div><br>```delphi mouse.pas<br>type int=longint;<br>var<br>    n,sz,i,cnt:int;ans:int64;<br>    a,t:array[0..100010] of int;<br>    h:array[0..200010] of int;</p>
<p>procedure swap(var a,b:int);<br>var tmp:int;<br>begin tmp:=a;a:=b;b:=tmp end;</p>
<p>procedure heapify(i:int);<br>var l,r,s:int;<br>begin<br>    l:=i<em>2;r:=i</em>2+1;<br>    if (l&lt;=sz) and (h[l]<h[i]) then="" s:="l" else="" if="" (r<="sz)" and="" (h[r]<h[s])="" i<="">s then begin<br>        swap(h[i],h[s]);heapify(s);<br>    end;<br>end;</h[i])></p>
<p>function extract():int;<br>begin extract:=h[1];h[1]:=h[sz];dec(sz);heapify(1) end;</p>
<p>procedure insert(x:int);<br>var i:int;<br>begin<br>    inc(sz);h[sz]:=x;i:=sz;<br>    while (i&gt;1) and (h[i]&lt;h[i shr 1]) do begin<br>        swap(h[i],h[i shr 1]);i:=i shr 1;<br>    end;<br>end;</p>
<p>procedure qsort(l,r:int);<br>var i,j,x:int;<br>begin<br>    i:=l;j:=r;x:=t[random(r-l)+l];<br>    repeat<br>        while t[i]<x do="" inc(i);="" while="" t[j]="">x do dec(j);<br>        if i&lt;=j then begin<br>            swap(t[i],t[j]);swap(a[i],a[j]);<br>            inc(i);dec(j);<br>        end;<br>    until i&gt;j;<br>    if i&lt;r then qsort(i,r);<br>    if l&lt;j then qsort(l,j);<br>end;</x></p>
<p>begin<br>    assign(input,’mouse.in’);reset(input);<br>    assign(output,’mouse.out’);rewrite(output);<br>    read(n);<br>    for i:=1 to n do read(t[i]);<br>    for i:=1 to n do read(a[i]);<br>    qsort(1,n);<br>    sz:=0;cnt:=0;ans:=0;<br>    for i:=1 to n do begin<br>        inc(cnt);inc(ans,a[i]);insert(a[i]);<br>        while cnt&gt;t[i] do begin<br>            dec(cnt);dec(ans,extract);<br>        end;<br>    end;<br>    write(ans);<br>    close(input);close(output);<br>end.<br>```</p>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[NOIP模拟赛 交通]]></title>
      <url>https://cothrax.github.io/2016/09/15/noip-2014-9-27-traffic/</url>
      <content type="html"><![CDATA[<h2 id="描述"><a href="#描述" class="headerlink" title="描述"></a>描述</h2><p>黄金大神国的首都位于hzwer河中的一座岛屿。一道上班的时候，成千上万辆汽车通过岛屿从西岸的住宅区（由桥连接岛的西部）到东岸的工业区（由桥连接岛的东部）。<br>该岛类似于矩形，它的边平行于主方向。故可将它看作是笛卡尔坐标系中的一个A*B的矩形，它的对角分别为（0, 0）和（A, B）。<br>岛上有n个交通节点（后宫建筑），编号为1…n，第i个节点坐标为(xi, yi)。如果一个节点的坐标为(0, y)，它就位于岛的西岸。类似的，坐标为(A, y)的节点位于岛的东岸。各个节点由街道连接，每条街道用线段连接两个节点。街道有单向行驶或双向行驶之分。除端点外任意两条街道都没有公共点。也没有桥梁或者隧道。<br>你不能对道路网络形状做任何其他假设。沿河岸的街道或节点可能没有入口或者出口街道。由于交通堵塞日趋严重，黄金大神想快速治理好他的国家，于是聘请你测试岛上当前的道路网是否足够。要求你写一个程序确定从岛的西岸的每个节点能够到达东岸的多少个节点。<br><a id="more"></a></p>
<h2 id="格式"><a href="#格式" class="headerlink" title="格式"></a>格式</h2><h3 id="输入格式"><a href="#输入格式" class="headerlink" title="输入格式"></a>输入格式</h3><p>第1行包含4个整数n, m, A, B，分别表示hzwer市中心的节点数，街道数和岛屿的尺寸。<br>接下来的n行，每行包含两个整数xi，yi (0≤xi≤A,0≤yi≤B)，表示第i个节点的坐标。任意两个节点的坐标都不相同。<br>再往下的m行表示街道，每条街道用3个整数ci, di, ki（1≤ci, di≤n, ci≠di, ki∈{1,2}），表示节点ci、di有街道连接，如果ki=1,表示从ci到di的街道是单向的，否则，这条街道可以双向行驶。每个无序对{ci, di}最多出现1次。<br>你可以假设西岸节点中至少有1个能够到达东岸的一些节点。</p>
<h3 id="输出格式"><a href="#输出格式" class="headerlink" title="输出格式"></a>输出格式</h3><p>为每个西岸节点输出1行，表示这个节点出发能够到达东岸的节点数目</p>
<h2 id="样例"><a href="#样例" class="headerlink" title="样例"></a>样例</h2><h3 id="样例输入"><a href="#样例输入" class="headerlink" title="样例输入"></a>样例输入</h3><blockquote>
<p>12 13 7 9<br>0 1<br>0 3<br>2 2<br>5 2<br>7 1<br>7 4<br>7 6<br>7 7<br>3 5<br>0 5<br>0 9<br>3 9<br>1 3 2<br>3 2 1<br>3 4 1<br>4 5 1<br>5 6 1<br>9 3 1<br>9 4 1<br>9 7 1<br>9 12 2<br>10 9 1<br>11 12 1<br>12 8 1<br>12 10 1</p>
</blockquote>
<h3 id="样例输出"><a href="#样例输出" class="headerlink" title="样例输出"></a>样例输出</h3><blockquote>
<p>4<br>4<br>0<br>2</p>
</blockquote>
<h2 id="提示​"><a href="#提示​" class="headerlink" title="提示​"></a>提示​</h2><p>对于30%的数据，n, m≤6000<br>对于100%的数据，1≤n≤300000, 0≤m≤900000,1≤A,B≤10^9<br><img src="/2016/09/15/noip-2014-9-27-traffic/illu.png" alt="illu.png" title=""></p>
<h2 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h2><p>第一遍看题目，发现除了两边的点以外的坐标毫无用处，然后yy缩点+各种数据结构的启发式合并，然后果断看了标程。<br>其实这个图的形式正是本题的关键所在：</p>
<blockquote>
<p>除端点外任意两条街道都没有公共点。也没有桥梁或者隧道。</p>
</blockquote>
<p>这是一个<strong>平面图</strong>：</p>
<blockquote>
<p>在图论中，平面图是可以画在平面上并且使得不同的边可以互不交叠的图。–Wikipedia</p>
</blockquote>
<p>先从西岸正向bfs，标记所有从西岸可达的点；对于可达点i，d[i]=1<br>考虑西岸的一个点i，记它能到达的东岸上最北边的点为u[i]，最南边的点为d[i]，那么，那么点i能够到达<strong>东岸上$y_j\in[y_{d[i]},y_{u[i]}]\ and\ d[j]=1$的所有点j</strong>：</p>
<blockquote>
<p>由于图上的边不能相交，<em>边i-&gt;u[i]</em>,<em>边i-&gt;d[i]</em>和<em>东岸</em>构成了一个封闭的三角形，位于其中的点j想与外界联通，必然要经过<span>$\{i,(a,d[i]),(a,u[i])\}$</span><!-- Has MathJax -->中的点，即与i连通<br>所以将东岸的点排序后，反向bfs，做两次标记算出d[i]和u[i]即可。</p>
</blockquote>
<p>平面图还有一些奇怪的性质，详见<a href="https://en.wikipedia.org/wiki/Planar_graph" target="_blank" rel="external">Wikipedia</a></p>
<p><div style="display:none;" class="copy"><br>    <a href="/2016/09/15/noip-2014-9-27-traffic/traffic0.pas" title="{plain text}">{plain text}</a><br></div><br>```delphi traffic0.pas<br>type<br>    int=longint;<br>    edge=record f,t,next:int end;<br>    arr=array[0..300010] of int;<br>var<br>    g:array[0..2000010] of edge;<br>    l,r,u,d,x,y,head,q:arr;<br>    n,m,i,j,f,t,a,b:int;</p>
<p>procedure add(f,t:int);<br>var m:int;<br>begin<br>    inc(head[0]);m:=head[0];<br>    g[m].f:=f;g[m].t:=t;<br>    g[m].next:=head[f];head[f]:=m;<br>end;</p>
<p>procedure swap(var a,b:int);<br>var tmp:int;<br>begin tmp:=a;a:=b;b:=tmp end;</p>
<p>function com(a,b,s:int):boolean;<br>begin com:=((s=0) and (a<b)) or="" ((s="1)" and="" (a="">b)) end;</b))></p>
<p>procedure qsort(var a:arr;l,r,s:int);<br>var i,j,x:int;<br>begin<br>    i:=l;j:=r;x:=y[a[random(r-l)+l]];<br>    repeat<br>        while com(y[a[i]],x,s) do inc(i);<br>        while com(x,y[a[j]],s) do dec(j);<br>        if i&lt;=j then begin<br>            swap(a[i],a[j]);<br>            inc(i);dec(j);<br>        end;<br>    until i&gt;j;<br>    if i&lt;r then qsort(a,i,r,s);<br>    if l&lt;j then qsort(a,l,j,s);<br>end;</p>
<p>procedure bfs(var d:arr;s,k:int);<br>var i,v,u,h,t:int;<br>begin<br>    h:=1;t:=2;q[h]:=s;d[s]:=k;<br>    while h&lt;&gt;t do begin<br>        v:=q[h];inc(h);i:=head[v];<br>        while i&lt;&gt;0 do begin<br>            u:=g[i].t;<br>            if d[u]=-1 then begin<br>                d[u]:=k;<br>                q[t]:=u;inc(t);<br>            end;<br>            i:=g[i].next;<br>        end;<br>    end;<br>end;</p>
<p>procedure cal(var d:arr);<br>var j:int;<br>begin<br>    fillchar(d,sizeof(d),255);<br>    for j:=1 to r[0] do begin<br>        if d[r[j]]&lt;&gt;-1 then continue;<br>        bfs(d,r[j],j);<br>    end;<br>end;</p>
<p>begin<br>    assign(input,’traffic.in’);reset(input);<br>    assign(output,’traffic.out’);rewrite(output);<br>    read(n,m,a,b);<br>    for i:=1 to n do read(x[i],y[i]);<br>    for i:=1 to m do begin<br>        read(f,t,j);<br>        add(f,t);if j=2 then add(t,f);<br>    end;<br>    for i:=1 to n do<br>        if x[i]=0 then begin inc(l[0]);l[l[0]]:=i end;<br>    qsort(l,1,l[0],1);<br>    fillchar(d,sizeof(d),255);<br>    for i:=1 to l[0] do<br>        if d[l[i]]=-1 then bfs(d,l[i],1);<br>    for i:=1 to n do<br>        if (x[i]=a) and (d[i]=1) then begin<br>            inc(r[0]);r[r[0]]:=i;<br>        end;<br>    m:=head[0];<br>    fillchar(head,sizeof(head),0);<br>    for i:=1 to m do add(g[i].t,g[i].f);<br>    qsort(r,1,r[0],0);cal(d);<br>    qsort(r,1,r[0],1);cal(u);<br>    for i:=1 to l[0] do<br>        if u[l[i]]=-1 then writeln(0)<br>        else writeln(r[0]-u[l[i]]+2-d[l[i]]);<br>    close(input);close(output);<br>end.<br>```</p>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[NOIP模拟赛 人偶师]]></title>
      <url>https://cothrax.github.io/2016/09/15/noip-2014-9-27-alice/</url>
      <content type="html"><![CDATA[<h2 id="描述"><a href="#描述" class="headerlink" title="描述"></a>描述</h2><p>n点m双向边的图，每个点有2个状态：开和关。每次操作改变一个点的状态，以及与其有边直接相连的点的状态。问开启所有点至少需要多少次操作。<br><a id="more"></a></p>
<h2 id="格式"><a href="#格式" class="headerlink" title="格式"></a>格式</h2><h3 id="输入格式"><a href="#输入格式" class="headerlink" title="输入格式"></a>输入格式</h3><p>第一行2个整数n,m。<br>第二行n个整数，第i个数表示第i点的状态，0为关，1为开。<br>第3..m+2行，每行2个整数a,b，表示a和b直接相连，同一条边不会出现多次。</p>
<h3 id="输出格式"><a href="#输出格式" class="headerlink" title="输出格式"></a>输出格式</h3><p>第一行一个整数k表示最少的操作次数，所有数据保证至少有一组可行解。<br>第二行k个整数，表示操作的点的编号。</p>
<h2 id="样例"><a href="#样例" class="headerlink" title="样例"></a>样例</h2><h3 id="样例输入"><a href="#样例输入" class="headerlink" title="样例输入"></a>样例输入</h3><blockquote>
<p>4 3<br>1 1 0 0<br>2 3<br>1 3<br>2 4</p>
</blockquote>
<h3 id="样例输出"><a href="#样例输出" class="headerlink" title="样例输出"></a>样例输出</h3><blockquote>
<p>3<br>1 2 3</p>
</blockquote>
<h2 id="提示​"><a href="#提示​" class="headerlink" title="提示​"></a>提示​</h2><p>对于30%的数据，1&lt;=n&lt;=10，0&lt;=m&lt;=40<br>对于60%的数据，1&lt;=n&lt;=30，0&lt;=m&lt;=100<br>对于100%的数据，1&lt;=n&lt;=40，0&lt;=m&lt;=500</p>
<h2 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h2><p>图上的反转问题，可以联想到如下题目：</p>
<ol>
<li>最小权匹配（状压dp）：<a href="/2016/09/04/欢乐赛-2014-5-31/" title="P3密码锁">P3密码锁</a></li>
<li>部分枚举+贪心：<a href="/2016/08/25/POJ-P3279-Fliptile/" title="关灯游戏">关灯游戏</a></li>
<li>状压dp：<a href="/2016/08/17/JSOI2016-提高2班-位运算/" title="P4黑客的攻击">P4黑客的攻击</a></li>
<li><del>这是线段树：<a href="/2016/08/22/JSOI2016-提高1班-Day6/" title="P3小W开关灯">P3小W开关灯</a></del></li>
</ol>
<p>关于本题，由n≤40<del>很容易</del>是<strong>折半枚举</strong>。<br>方案和状态可以压成int64，于是可以用位运算优化。<br>用hash拉链存第一次dfs的结果，然后第二次反过来dfs。<br>还有就是pascal的一个坑，下面程序的输出结果是-2147483648</p>
<pre><code class="delphi">type int=longint;
var i,a:int64;
begin
    i:=31;a:=1 shl i;
    write(a);
end.
</code></pre>
<p>原因是shl操作时默认参数1为longint，所以会发生溢出，要强转<code>a:=int64(1) shl int64(i)</code>，参考了<a href="https://stackoverflow.com/questions/8127693/how-can-i-get-a-result-larger-than-232-from-shl" target="_blank" rel="external">stackoverflow</a></p>
<dir style="display:none"><a href="/2016/09/15/noip-2014-9-27-alice/alice.pas" title="复制代码">复制代码</a></dir>

<p>```delphi alice.pas<br>uses math;<br>const z=500009;<br>type int=longint;<br>var<br>    h,f:array[0..1500010] of int64;<br>    c,next:array[0..1500010] of int;<br>    head:array[0..z] of int;<br>    g:array[0..41] of int64;<br>    i,j,k,n,m,sz,cnt,mn:int;lb,h0,f0,ans:int64;</p>
<p>function lsh(a,b:int64):int64;<br>begin lsh:=int64(a) shl int64(b) end;</p>
<p>procedure insert(h0,f0:int64;cnt:int);<br>var i:int;<br>begin<br>    i:=h0 mod z;<br>    inc(sz);h[sz]:=h0;f[sz]:=f0;c[sz]:=cnt;<br>    next[sz]:=head[i];head[i]:=sz;<br>end;</p>
<p>function query(h0:int64):int;<br>var i:int;<br>begin<br>    i:=h0 mod z;i:=head[i];<br>    while i&lt;&gt;0 do begin<br>        if h0=h[i] then exit(i);<br>        i:=next[i];<br>    end;<br>    query:=-1;<br>end;</p>
<p>procedure print(ans:int64);<br>begin<br>    while ans&lt;&gt;0 do begin<br>        lb:=ans and (-ans);<br>        write(round(ln(lb)/ln(2))+1,’ ‘);<br>        dec(ans,lb);<br>    end;<br>end;</p>
<p>procedure dfs(v,x:int);<br>var i:int;<br>begin<br>    if (x=0) and (v=k+1) then begin insert(h0,f0,cnt);exit end;<br>    if (x=1) and (v=n+1) then begin<br>        i:=query(h0);<br>        if (i&lt;&gt;-1) and (c[i]+cnt&lt;mn) then begin<br>            mn:=c[i]+cnt;<br>            ans:=f[i] or f0;<br>        end;<br>        exit;<br>    end;<br>    h0:=h0 xor g[v];f0:=f0 or lsh(1,v-1);inc(cnt);<br>    dfs(v+1,x);<br>    h0:=h0 xor g[v];f0:=f0-lsh(1,v-1);dec(cnt);<br>    dfs(v+1,x);<br>end;</p>
<p>begin {main}<br>    assign(input,’alice.in’);reset(input);<br>    assign(output,’alice.out’);rewrite(output);<br>    read(n,m);h0:=0;<br>    for i:=1 to n do begin<br>        read(j);inc(h0,lsh(1,i-1)*j);<br>    end;<br>    for i:=1 to n do g[i]:=lsh(1,i-1);<br>    for i:=1 to m do begin<br>        read(j,k);<br>        inc(g[j],lsh(1,k-1));<br>        inc(g[k],lsh(1,j-1));<br>    end;<br>    k:=n shr 1;f0:=0;cnt:=0;sz:=0;<br>    dfs(1,0);<br>    h0:=lsh(1,n)-1;f0:=0;cnt:=0;mn:=maxlongint;<br>    dfs(k+1,1);</p>
<pre><code>writeln(mn);print(ans);
close(input);close(output);
</code></pre><p>end.<br>```</p>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[NOIP模拟赛 舞蹈课]]></title>
      <url>https://cothrax.github.io/2016/09/15/noip-2014-9-13-dancingLessons/</url>
      <content type="html"><![CDATA[<h2 id="描述"><a href="#描述" class="headerlink" title="描述"></a>描述</h2><p>有 n 个人参加一个舞蹈课。每个人的舞蹈技术由整数 来决定。在舞蹈课的开始,他们从左到右站成一排。当这一排中至少有一对相邻的异性时,舞蹈技术相差最小的那一对会出列并开始跳舞。如果相差最小的不止一对,那么最左边的那一对出列。一对异性出列之后,队伍中的空白按原顺序补上(即:若队伍为 ABCD,那么 BC 出列之后队伍变为 AD)。舞蹈技术相差最小即是 的绝对值最小。<br>你的任务是,模拟以上过程,确定跳舞的配对及顺序。<br><a id="more"></a></p>
<h2 id="格式"><a href="#格式" class="headerlink" title="格式"></a>格式</h2><h3 id="输入格式"><a href="#输入格式" class="headerlink" title="输入格式"></a>输入格式</h3><p>第一行为正整数n(1≤n≤2*10e5):队伍中的人数。下一行包含 n 个字<br>符 B 或者 G,B 代表男,G 代表女。下一行为 n 个整数ai(ai≤10e7)有信息按照从左到右的顺序给出。</p>
<h3 id="输出格式"><a href="#输出格式" class="headerlink" title="输出格式"></a>输出格式</h3><p>第一行:出列的总对数 k。接下来输出 k 行,每行是两个整数。按跳舞顺序输出,两个整数代表这一对舞伴的编号(按输入顺序从左往右 1 至 n 编号)。请先输出较小的整数,再输出较大的整数。</p>
<h2 id="样例"><a href="#样例" class="headerlink" title="样例"></a>样例</h2><h3 id="样例输入"><a href="#样例输入" class="headerlink" title="样例输入"></a>样例输入</h3><blockquote>
<p>4<br>BGBG<br>4 2 4 3</p>
</blockquote>
<h3 id="样例输出"><a href="#样例输出" class="headerlink" title="样例输出"></a>样例输出</h3><blockquote>
<p>2<br>3 4<br>1 2</p>
</blockquote>
<h2 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h2><p>用堆维护最小值，元素的删除用链表维护。<br>关于最小堆中任意元素的删除：</p>
<ol>
<li>将该元素的值设成inf，然后heapify</li>
<li>注意在维护下标映射时，不考虑值为inf的元素</li>
<li>如果堆的size=0或堆顶元素为inf，则已经为空</li>
</ol>
<dir style="display:none"><a href="/2016/09/15/noip-2014-9-13-dancingLessons/dancingLessons.pas" title="复制代码">复制代码</a></dir>

<p>```delphi classroomLessons.pas<br>uses math;<br>const inf=maxlongint shr 2;<br>type<br>    int=longint;<br>    nh=record l,r,d:int end;<br>    nl=record l,r:int end;<br>var<br>    hp:array[0..200010] of nh;<br>    lk:array[0..200010] of nl;<br>    lh,a:array[0..200010] of int;<br>    g:array[0..200010] of char;<br>    ans:array[0..100010,0..1] of int;<br>    n,i,sh,cnt,l1,r1,l2,r2:int;</p>
<p>procedure swap(i,j:int);<br>var tmp:nh;<br>begin<br>    if hp[i].d&lt;&gt;inf then lh[hp[i].l]:=j;<br>    if hp[j].d&lt;&gt;inf then lh[hp[j].l]:=i;<br>    tmp:=hp[i];hp[i]:=hp[j];hp[j]:=tmp;<br>end;<br>function com(p,c:int):boolean;<br>begin<br>    com:=(hp[p].d<hp[c].d) or="" ((hp[p].d="hp[c].d)" and="" (hp[p].l<hp[c].l));="" end;="" procedure="" heapify(i:int);="" var="" l,r,s:int;="" begin="" l:="i" shl="" 1;r:="l" 1;="" if="" (l<="sh)" com(l,i)="" then="" s:="l" else="" (r<="sh)" com(r,s)="" s<="">i then begin swap(s,i);heapify(s) end;<br>end;<br>procedure extract();<br>begin swap(1,sh);dec(sh);heapify(1) end;<br>procedure delete(x:int);<br>var i:int;<br>begin i:=lh[x];hp[i].d:=inf;heapify(i) end;<br>procedure insert(x,y:int);<br>var i:int;<br>begin<br>    inc(sh);lh[x]:=sh;<br>    hp[sh].l:=x;hp[sh].r:=y;<br>    hp[sh].d:=abs(a[x]-a[y]);<br>    i:=sh;<br>    while (i&gt;1) and com(i,i shr 1) do begin<br>        swap(i,i shr 1);i:=i shr 1;<br>    end;<br>end;</hp[c].d)></p>
<p>begin<br>    assign(input,’dancingLessons.in’);reset(input);<br>    assign(output,’dancingLessons.out’);rewrite(output);<br>    readln(n);sh:=0;<br>    for i:=1 to n do read(g[i]);readln;<br>    for i:=1 to n do begin<br>        read(a[i]);<br>        lk[i].l:=i-1;lk[i].r:=i+1;<br>    end;<br>    lk[n].r:=0;lk[0].r:=1;lk[0].l:=n;<br>    for i:=2 to n do<br>        if g[i]&lt;&gt;g[i-1] then insert(i-1,i);<br>    cnt:=0;<br>    while (hp[1].d&lt;&gt;inf) and (sh&lt;&gt;0) do begin<br>        inc(cnt);<br>        l1:=hp[1].l;r1:=hp[1].r;extract;<br>        l2:=lk[l1].l;r2:=lk[r1].r;<br>        if (l2&lt;&gt;0) and (g[l1]&lt;&gt;g[l2]) then delete(l2);<br>        if (r2&lt;&gt;0) and (g[r1]&lt;&gt;g[r2]) then delete(r1);<br>        if (min(l2,r2)&lt;&gt;0) and (g[l2]&lt;&gt;g[r2]) then<br>            insert(l2,r2);<br>        ans[cnt,0]:=l1;ans[cnt,1]:=r1;<br>        lk[l2].r:=r2;lk[r2].l:=l2;<br>    end;<br>    writeln(cnt);<br>    for i:=1 to cnt do writeln(ans[i,0],’ ‘,ans[i,1]);<br>    close(input);close(output);<br>end.<br>```</p>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[NOIP模拟赛 皇帝的烦恼]]></title>
      <url>https://cothrax.github.io/2016/09/14/NOIP%E6%A8%A1%E6%8B%9F%E8%B5%9B-%E7%9A%87%E5%B8%9D%E7%9A%84%E7%83%A6%E6%81%BC/</url>
      <content type="html"><![CDATA[<h2 id="描述"><a href="#描述" class="headerlink" title="描述"></a>描述</h2><p>经过多年的杀戮，秦皇终于统一了中国。为了抵御外来的侵略，他准备在国土边境安置n名将军。不幸的是这n名将军羽翼渐丰，开始展露他们的狼子野心了。他们拒绝述职、拒绝接受皇帝的圣旨。秦皇已经准备好了秘密处决这些无礼的边防大将。不过为防兵变，他决定先授予这些将军一些勋章，为自己赢得战略时间。将军们听说他们即将被授予勋章都很开心，他们纷纷上书表示感谢。第i个将军要求得到ai枚不同颜色的勋章。但是这些将军都很傲气，如果两个相邻的将军拥有颜色相同的勋章他们就会认为皇帝不尊重他们，会立即造反（编号为i的将军和编号为i+1的将军相邻；因为他们驻扎的边境可以类似看成一个圆形，所以编号1和编号n的将军也相邻）。皇帝不得不满足每个将军的要求，但对他们的飞扬跋扈感到很气愤。于是皇帝决定铸造尽量少种类的勋章来满足这些狂妄者的要求。请问他至少要铸造多少种颜色的勋章？<br><a id="more"></a></p>
<h2 id="格式"><a href="#格式" class="headerlink" title="格式"></a>格式</h2><h3 id="输入格式"><a href="#输入格式" class="headerlink" title="输入格式"></a>输入格式</h3><p>第一行有一个整数n(1&lt;=n&lt;=20000)。接下来n行每行一个整数ai，表示第i个将军要求得到多少种勋章。(1&lt;=ai&lt;=100000) </p>
<h3 id="输出格式"><a href="#输出格式" class="headerlink" title="输出格式"></a>输出格式</h3><p>输出一个整数，即最少需要多少种勋章。</p>
<h2 id="样例"><a href="#样例" class="headerlink" title="样例"></a>样例</h2><h3 id="样例输入"><a href="#样例输入" class="headerlink" title="样例输入"></a>样例输入</h3><blockquote>
<p>4 2 2 1 1</p>
</blockquote>
<h3 id="样例输出"><a href="#样例输出" class="headerlink" title="样例输出"></a>样例输出</h3><blockquote>
<p>4</p>
</blockquote>
<h2 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h2><p>首先容易想出答案=相邻两数和的最大值<br>但对于<strong>奇数个数</strong>的情况，由于是一个环，是不满足上述贪心性质的。<br><del>（这样能得60分）</del><br>最小化合法解，很容易想到<strong>二分答案</strong>，但判定解的<strong>dp</strong>很坑：</p>
<ol>
<li>lb[i]：第i个人与第1个人重复徽章数的最小值</li>
<li>ub[i]：…的最大值</li>
</ol>
<p>$O(1)$转移，方程看代码好了<br>注意二分的下界为相邻两数和的最大值。</p>
<dir style="display:none"><a href="/2016/09/14/NOIP模拟赛-皇帝的烦恼/trouble0.pas" title="复制代码">复制代码</a></dir>

<p>```delphi trouble0.pas<br>uses math;<br>type int=longint;<br>var<br>    a,lb,ub:array[0..100010] of int;<br>    n,i,l,r,mid,ans:int;</p>
<p>function jud(x:int):boolean;<br>var i:int;<br>begin<br>    lb[1]:=a[1];ub[1]:=a[1];<br>    for i:=2 to n do begin<br>        ub[i]:=min(a[i],a[1]-lb[i-1]);<br>        lb[i]:=max(0,a[i]-(x-a[1]+(a[i-1]-ub[i-1])));<br>    end;<br>    jud:=lb[n]=0;<br>end;</p>
<p>begin<br>    assign(input,’trouble.in’);reset(input);<br>    assign(output,’trouble.out’);rewrite(output);<br>    read(n);ans:=0;<br>    for i:=1 to n do begin<br>        read(a[i]);<br>        ans:=max(ans,a[i-1]+a[i]);<br>    end;<br>    l:=ans;r:=ans*2;<br>    while l&lt;=r do begin<br>        mid:=(l+r) shr 1;<br>        if jud(mid) then begin ans:=mid;r:=mid-1 end<br>        else l:=mid+1;<br>    end;<br>    write(ans);<br>    close(input);close(output);<br>end.<br>```</p>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[NOIP模拟赛 西行寺幽幽子]]></title>
      <url>https://cothrax.github.io/2016/09/14/NOIP%E6%A8%A1%E6%8B%9F%E8%B5%9B-%E8%A5%BF%E8%A1%8C%E5%AF%BA%E5%B9%BD%E5%B9%BD%E5%AD%90/</url>
      <content type="html"><![CDATA[<h2 id="描述"><a href="#描述" class="headerlink" title="描述"></a>描述</h2><p>在幻想乡,西行寺幽幽子是以贪吃闻名的亡灵。不过幽幽子可不是只会吃,至少她还管理着亡灵界。话说在幽幽子居住的白玉楼有一颗常年不开花的樱树——西行妖。幽幽子决定去收集人间的春度,聚集起来让西行妖开花。很快,作为幽幽子家园艺师的魂魄妖梦收集到了 M 个单位的春度。并且在这段时间里,幽幽子计算出要让西行妖开出一朵花需要 N 个单位的春度。<br>现在幽幽子想要知道,使用所有的春度,能够让西行妖开出多少朵花。<br><a id="more"></a></p>
<h2 id="格式"><a href="#格式" class="headerlink" title="格式"></a>格式</h2><h3 id="输入格式"><a href="#输入格式" class="headerlink" title="输入格式"></a>输入格式</h3><p>第 1 行:一个正整数 M<br>第 2 行:一个正整数 N<br>N,M 的位数不超过 L,L 的范围在题目后面给出</p>
<h3 id="输出格式"><a href="#输出格式" class="headerlink" title="输出格式"></a>输出格式</h3><p>第 1 行:一个整数 ans,表示能开出花的朵数</p>
<h2 id="样例"><a href="#样例" class="headerlink" title="样例"></a>样例</h2><h3 id="样例输入"><a href="#样例输入" class="headerlink" title="样例输入"></a>样例输入</h3><blockquote>
<p>73861758<br>12471</p>
</blockquote>
<h3 id="样例输出"><a href="#样例输出" class="headerlink" title="样例输出"></a>样例输出</h3><blockquote>
<p>5922</p>
</blockquote>
<h2 id="提示​"><a href="#提示​" class="headerlink" title="提示​"></a>提示​</h2><p>对于 60%的数据:L &lt;= 2,000 且 ans &lt;= 2,000<br>对于 100%的数据:L &lt;= 20,000 且 ans &lt;= 2,000,000,000</p>
<h2 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h2><p>双精度除法，但答案在int内，可以用二分+乘法做。<br>题解告诉我还可以用二进制拆分做（就是倍增枚举的思想）</p>
<dir style="display:none"><a href="/2016/09/14/NOIP模拟赛-西行寺幽幽子/spring.pas" title="复制代码">复制代码</a></dir>

<p>```delphi spring.pas<br>uses math;<br>const bs=100000000;p=8;<br>type<br>    int=longint;<br>    big=array[0..5010] of int64;<br>var<br>    n,m:big;<br>    l,r,mid,ans:int64;</p>
<p>function com(a,b:big):int64;<br>var i:int;<br>begin<br>    i:=max(a[0],b[0]);<br>    while (a[i]=b[i]) and (i&gt;0) do dec(i);<br>    com:=a[i]-b[i];<br>end;</p>
<p>function rd():big;<br>var s:ansistring;f,b:int64;i:int;<br>begin<br>    fillchar(rd,sizeof(rd),0);<br>    readln(s);f:=0;b:=1;<br>    for i:=length(s) downto 1 do begin<br>        inc(f,(ord(s[i])-ord(‘0’))<em>b);b:=b</em>10;<br>        if b=bs then begin<br>            inc(rd[0]);rd[rd[0]]:=f;f:=0;b:=1;<br>        end;<br>    end;<br>    if f&lt;&gt;0 then begin<br>        inc(rd[0]);rd[rd[0]]:=f;<br>    end;<br>end;</p>
<p>function mul(a:big;b:int64):big;<br>var i:int;<br>begin<br>    fillchar(mul,sizeof(mul),0);<br>    mul[0]:=a[0];<br>    for i:=1 to a[0] do begin<br>        inc(mul[i],a[i]*b);<br>        inc(mul[i+1],mul[i] div bs);<br>        mul[i]:=mul[i] mod bs;<br>    end;<br>    while mul[mul[0]+1]&gt;0 do begin<br>        inc(mul[0]);<br>        inc(mul[mul[0]+1],mul[mul[0]] div bs);<br>        mul[mul[0]]:=mul[mul[0]] mod bs;<br>    end;<br>end;</p>
<p>begin<br>    assign(input,’spring.in’);reset(input);<br>    assign(output,’spring.out’);rewrite(output);<br>    m:=rd();n:=rd();<br>    l:=1;r:=2000000000;<br>    if com(m,n)<0 then="" begin="" write(0);halt="" end;="" while="" l<="r" do="" mid:="(l+r)" shr="" 1;="" if="" com(m,mul(n,mid))="">=0 then begin ans:=mid;l:=mid+1 end<br>        else r:=mid-1;<br>    end;<br>    write(ans);<br>    close(input);close(output);<br>end.<br>```</0></p>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[NOIP模拟赛 藏妹子之处]]></title>
      <url>https://cothrax.github.io/2016/09/14/NOIP%E6%A8%A1%E6%8B%9F%E8%B5%9B-%E8%97%8F%E5%A6%B9%E5%AD%90%E4%B9%8B%E5%A4%84/</url>
      <content type="html"><![CDATA[<h2 id="描述"><a href="#描述" class="headerlink" title="描述"></a>描述</h2><p>今天CZY又找到了三个妹子，有着收藏爱好的他想要找三个地方将妹子们藏起来，将一片空地抽象成一个R行C列的表格，CZY要选出3个单元格。但要满足如下的两个条件：<br>（1）任意两个单元格都不在同一行。<br>（2）任意两个单元格都不在同一列。<br>选取格子存在一个花费，而这个花费是三个格子两两之间曼哈顿距离的和（如(x1,y1)和(x,y2)的曼哈顿距离为|x1-x2|+|y1-y2|）。狗狗想知道的是，花费在minT到maxT之间的方案数有多少。<br>答案模1000000007。所谓的两种不同方案是指：只要它选中的单元格有一个不同，就认为是不同的方案。<br><a id="more"></a></p>
<h2 id="格式"><a href="#格式" class="headerlink" title="格式"></a>格式</h2><h3 id="输入格式"><a href="#输入格式" class="headerlink" title="输入格式"></a>输入格式</h3><p>一行，4个整数，R、C、minT、maxT。3≤R,C≤4000, 1≤minT≤maxT≤20000。<br>对于30%的数据,  3 ≤ R, C ≤ 70。    </p>
<h3 id="输出格式"><a href="#输出格式" class="headerlink" title="输出格式"></a>输出格式</h3><p> 一个整数，表示不同的选择方案数量模1000000007后的结果。</p>
<h2 id="样例"><a href="#样例" class="headerlink" title="样例"></a>样例</h2><table>
<thead>
<tr>
<th>输入样例</th>
<th>3 3 1 20000</th>
<th>3 3 4 7</th>
<th>4 6 9 12</th>
<th>7 5 13 18</th>
<th>4000 4000 4000  14000</th>
</tr>
</thead>
<tbody>
<tr>
<td>输出样例</td>
<td>6</td>
<td>0</td>
<td>264</td>
<td>1212</td>
<td>859690013</td>
</tr>
</tbody>
</table>
<h2 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h2><p>拿到手DP想了好久。。。结果正解是乱搞<br>考虑曼哈顿距离的数学含义：</p>
<ol>
<li>对于(x1,y1),(x2,y2),(x3,y3)来说（$x_i&lt;x_{i+1}$,y同理），三点的距离和为$2(x3-x1)(y3-y1)$</li>
<li>因此，对于一个矩形r*c，取左上角为(x1,y1)，取右下角为(x3,y3)，在中间（与前两个点行列不同）取点(x2,y2)，那么这三个点的费用是一定的，这个矩形对答案的贡献=(x2,y2)的个数$\cdot P^3_3$</li>
<li>而这样的矩形在整个网格中的位置共有$(n-r+1)(m-c+1)$种</li>
<li>综上，r*c的矩形对答案的总贡献为$6(r-2)(c-2)(n-r+1)(m-c+1)$；这样枚举合法矩形（即曼哈顿距离在[minT,maxT]中）的r和c就能统计出答案。</li>
</ol>
<dir style="display:none"><a href="/2016/09/14/NOIP模拟赛-藏妹子之处/excel.pas" title="复制代码">复制代码</a></dir>

<p><code>delphi excel.pas
uses math;
type int=longint;
const inf=1000000007;
var n,m,i,j,mi,mx:int;ans:qword;
begin
    assign(input,&#39;excel.in&#39;);reset(input);
    assign(output,&#39;excel.out&#39;);rewrite(output);
    read(n,m,mi,mx);
    ans:=0;
    for i:=3 to n do
        for j:=3 to m do
            if (2*(i+j-2)&gt;=mi) and (2*(i+j-2)&lt;=mx) then begin
                ans:=ans+6*(i-2)*(j-2)*(n-i+1)*(m-j+1);
                if ans&gt;inf then ans:=ans mod inf;
            end;
    write(ans);
    close(input);close(output);
end.</code></p>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[NOIP模拟赛 还教室]]></title>
      <url>https://cothrax.github.io/2016/09/12/NOIP%E6%A8%A1%E6%8B%9F%E8%B5%9B-%E8%BF%98%E6%95%99%E5%AE%A4/</url>
      <content type="html"><![CDATA[<h2 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h2><img src="/2016/09/12/NOIP模拟赛-还教室/desc.png" alt="desc.png" title="">
<a id="more"></a>
<img src="/2016/09/12/NOIP模拟赛-还教室/samp.png" alt="samp.png" title="">
<img src="/2016/09/12/NOIP模拟赛-还教室/expl.png" alt="expl.png" title="">
<img src="/2016/09/12/NOIP模拟赛-还教室/data.png" alt="data.png" title="">
<h2 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h2><p>裸的线段树操作，维护区间和sum和平方和squ<br>平均数显然是<span>$\dfrac{\sum_{i=l}^ra[i]}{r-l+1}$</span><!-- Has MathJax --><br>方差可以变形：<br>记<span>$n=r-l+1,su=\sum_{i=l}^ra[i],sq=\sum_{i=l}^ra[i]^2,M=su/n$</span><!-- Has MathJax --><br><span>$V[l,r]=\dfrac{\sum_{i=l}^r(a[i]-M)^2}{n}$</span><!-- Has MathJax --><br><span>$=\dfrac{\sum_{i=l}^ra[i]^2-2\sum_{i=l}^ra[i]M+nM^2}{n}$</span><!-- Has MathJax --><br><span>$=\dfrac{sq-2su\cdot M+n^2M^2}{n}$</span><!-- Has MathJax --><br><span>$=\dfrac{n\cdot sq-su^2}{n^2}$</span><!-- Has MathJax --><br>方差=平方的平均数-平均数的平方</p>
<ol>
<li>开始错用了一个int做中间量结果wa</li>
<li>第二次被int64坑，大量mod和div千万不要用int64，说不准就会出现精度误差，开始int64+gcd最后一个点wa，换成qword就好。</li>
</ol>
<dir style="display:none"><a href="/2016/09/12/NOIP模拟赛-还教室/classroom.pas" title="复制代码">复制代码</a></dir>

<p>```delphi classroom.pas<br>uses math;<br>type int=longint;<br>var<br>    tag:array[0..400010] of qword;<br>    seg:array[0..400010,0..1] of qword;<br>    a:array[0..100010] of int;<br>    n,m,i,c,l,r:int;d,su,sq,g,k:qword;</p>
<p>function min(a,b:qword):qword;<br>begin if a&lt;b then min:=a else min:=b end;</p>
<p>procedure build(i,b,e:int);<br>var mid:int;<br>begin<br>    if b=e then begin seg[i,0]:=a[b];seg[i,1]:=sqr(a[b]);exit end;<br>    mid:=(b+e) shr 1;<br>    build(i shl 1,b,mid);<br>    build(i shl 1 or 1,mid+1,e);<br>    seg[i,0]:=seg[i shl 1,0]+seg[i shl 1 or 1,0];<br>    seg[i,1]:=seg[i shl 1,1]+seg[i shl 1 or 1,1];<br>end;</p>
<p>procedure pushdown(i,b,e:int);<br>var mid:int;<br>    procedure deal(j,b,e:int);<br>    begin<br>        inc(tag[j],tag[i]);<br>        inc(seg[j,1],2<em>tag[i]</em>seg[j,0]+(e-b+1)<em>sqr(tag[i]));<br>        inc(seg[j,0],(e-b+1)</em>tag[i]);<br>    end;<br>begin<br>    mid:=(b+e) shr 1;<br>    deal(i shl 1,b,mid);<br>    deal(i shl 1 or 1,mid+1,e);<br>    tag[i]:=0;<br>end;</p>
<p>function query(i,b,e,l,r,x:int):qword;<br>var mid:int;<br>begin<br>    if (r<b) or="" (e<l)="" then="" exit(0);="" if="" (l<="b)" and="" (e<="r)" exit(seg[i,x]);="" mid:="(b+e)" shr="" 1;="" tag[i]<="">0 then pushdown(i,b,e);<br>    query:=query(i shl 1,b,mid,l,r,x);<br>    inc(query,query(i shl 1 or 1,mid+1,e,l,r,x));<br>end;</b)></p>
<p>procedure modify(i,b,e,l,r,x:int);<br>var mid:int;<br>begin<br>    if (r<b) or="" (e<l)="" then="" exit;="" if="" (l<="b)" and="" (e<="r)" begin="" inc(tag[i],x);="" inc(seg[i,1],2*x*seg[i,0]+(e-b+1)*sqr(x));="" inc(seg[i,0],(e-b+1)*x);="" end;="" mid:="(b+e)" shr="" 1;="" tag[i]<="">0 then pushdown(i,b,e);<br>    modify(i shl 1,b,mid,l,r,x);<br>    modify(i shl 1 or 1,mid+1,e,l,r,x);<br>    seg[i,0]:=seg[i shl 1,0]+seg[i shl 1 or 1,0];<br>    seg[i,1]:=seg[i shl 1,1]+seg[i shl 1 or 1,1];<br>end;</b)></p>
<p>function gcd(a,b:qword):qword;<br>begin if b=0 then gcd:=a else gcd:=gcd(b,a mod b) end;</p>
<p>begin<br>    assign(input,’classroom.in’);reset(input);<br>    assign(output,’classroom.out’);rewrite(output);<br>    read(n,m);<br>    for i:=1 to n do read(a[i]);<br>    build(1,1,n);<br>    for i:=1 to m do begin<br>        read(c,l,r);<br>        case c of<br>            1:begin read(d);modify(1,1,n,l,r,d) end;<br>            2:begin<br>                su:=query(1,1,n,l,r,0);k:=r-l+1;<br>                if min(su,k)=0 then writeln(‘0/1’)<br>                else begin<br>                    g:=gcd(su,k);<br>                    writeln(su div g,’/‘,k div g);<br>                end;<br>            end;<br>            3:begin<br>                su:=query(1,1,n,l,r,0);k:=r-l+1;<br>                sq:=query(1,1,n,l,r,1);d:=k*sq-sqr(su);<br>                if min(d,sqr(k))=0 then writeln(‘0/1’)<br>                else begin<br>                    g:=gcd(d,sqr(k));<br>                    writeln(d div g,’/‘,sqr(k) div g);<br>                end;<br>            end;<br>        end;<br>    end;<br>    close(input);close(output);<br>end.<br>```</p>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[NOIP模拟赛 穿越七色虹]]></title>
      <url>https://cothrax.github.io/2016/09/11/NOIP%E6%A8%A1%E6%8B%9F%E8%B5%9B-%E7%A9%BF%E8%B6%8A%E4%B8%83%E8%89%B2%E8%99%B9/</url>
      <content type="html"><![CDATA[<h2 id="描述"><a href="#描述" class="headerlink" title="描述"></a>描述</h2><img src="/2016/09/11/NOIP模拟赛-穿越七色虹/desc.png" alt="desc.png" title="">
<a id="more"></a>
<h2 id="格式"><a href="#格式" class="headerlink" title="格式"></a>格式</h2><h3 id="输入格式"><a href="#输入格式" class="headerlink" title="输入格式"></a>输入格式</h3><p>第一行两个实数 h、x0,表示身高和目的地横坐标。 接下来七行每行两个实数 xi、ri,表示七座半圆形彩虹的圆心和半径。</p>
<h3 id="输出格式"><a href="#输出格式" class="headerlink" title="输出格式"></a>输出格式</h3><p>输出最小的 r,四舍五入保留 2 位小数。</p>
<h2 id="样例"><a href="#样例" class="headerlink" title="样例"></a>样例</h2><h3 id="样例输入"><a href="#样例输入" class="headerlink" title="样例输入"></a>样例输入</h3><blockquote>
<p>4.0 36.0<br>0.0 4.0<br>6.0 4.0<br>12.0 4.0<br>18.0 4.0<br>24.0 4.0<br>30.0 4.0<br>36.0 4.0</p>
</blockquote>
<h3 id="样例输出"><a href="#样例输出" class="headerlink" title="样例输出"></a>样例输出</h3><blockquote>
<p>1.00</p>
</blockquote>
<h2 id="提示​"><a href="#提示​" class="headerlink" title="提示​"></a>提示​</h2><p>数据范围与约定<br>对于 100% 的数据,满足 0&lt;=xi,x0&lt;=10000,0&lt;h&lt;100。</p>
<h2 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h2><p>二分r+初中几何题<br>确定r后，每个半圆能覆盖的区域都是一个线段，然后排序+扫一边判断，注意终点的判断。<br>另外，用sqrt(n)时要保证n&gt;0</p>
<dir style="display:none"><a href="/2016/09/11/NOIP模拟赛-穿越七色虹/rainbow.pas" title="复制代码">复制代码</a></dir>

<p>```delphi rainbow.pas<br>uses math;<br>type int=longint;<br>const n=7;<br>var<br>    p,a,b,e:array[0..n] of double;<br>    h,t,l,r,mid:double;<br>    i:int;</p>
<p>function com(i,j:int):boolean;<br>begin com:=(b[i]&lt;b[j]) or ((b[i]=b[j]) and (e[i]&lt;e[j])) end;</p>
<p>procedure swap(i,j:int);<br>var tmp:double;<br>begin<br>    tmp:=b[i];b[i]:=b[j];b[j]:=tmp;<br>    tmp:=e[i];e[i]:=e[j];e[j]:=tmp;<br>end;</p>
<p>function check(x:double):boolean;<br>var i,j:int;last:double;<br>begin<br>    for i:=1 to n do begin<br>        b[i]:=p[i]-sqrt(max(0,sqr(a[i]+x)-sqr(h)));<br>        e[i]:=p[i]+sqrt(max(0,sqr(a[i]+x)-sqr(h)));<br>    end;<br>    for i:=1 to n do<br>        for j:=i+1 to n do<br>            if com(j,i) then swap(i,j);<br>    j:=n+1;<br>    for i:=1 to n do if e[i]&gt;=t then begin j:=i;break end;<br>    if j=n+1 then exit(false);<br>    last:=0;<br>    for i:=1 to j do begin<br>        if b[i]&gt;last then exit(false);<br>        last:=max(last,e[i]);<br>    end;<br>    check:=true;<br>end;</p>
<p>begin<br>    assign(input,’rainbow.in’);reset(input);<br>    assign(output,’rainbow.out’);rewrite(output);<br>    read(h,t);<br>    for i:=1 to n do read(p[i],a[i]);<br>    l:=0;r:=1000000;<br>    for i:=1 to 100 do begin<br>        mid:=(l+r)/2;<br>        if check(mid) then r:=mid else l:=mid;<br>    end;<br>    write(r:0:2);<br>    close(input);close(output);<br>end.<br>```</p>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[NOIP模拟赛 梦幻布丁]]></title>
      <url>https://cothrax.github.io/2016/09/11/NOIP%E6%A8%A1%E6%8B%9F%E8%B5%9B-%E6%A2%A6%E5%B9%BB%E5%B8%83%E4%B8%81/</url>
      <content type="html"><![CDATA[<h2 id="描述"><a href="#描述" class="headerlink" title="描述"></a>描述</h2><p>N个布丁摆成一行,进行M次操作.每次将某个颜色的布丁全部变成另一种颜色的,然后再询问当前一共有多少段颜色.例如颜色分别为1,2,2,1的四个布丁一共有3段颜色.</p>
<h2 id="格式"><a href="#格式" class="headerlink" title="格式"></a>格式</h2><h3 id="输入格式"><a href="#输入格式" class="headerlink" title="输入格式"></a>输入格式</h3><p>第一行给出N,M表示布丁的个数和好友的操作次数. 第二行N个数A1,A2…An表示第i个布丁的颜色从第三行起有M行,对于每个操作,若第一个数字是1表示要对颜色进行改变，其后的两个整数X,Y表示将所有颜色为X的变为Y，X可能等于Y. 若第一个数字为2表示要进行询问当前有多少段颜色，这时你应该输出一个整数. 0</p>
<h3 id="输出格式"><a href="#输出格式" class="headerlink" title="输出格式"></a>输出格式</h3><p>针对第二类操作即询问，依次输出当前有多少段颜色.<br><a id="more"></a></p>
<h2 id="样例"><a href="#样例" class="headerlink" title="样例"></a>样例</h2><h3 id="样例输入"><a href="#样例输入" class="headerlink" title="样例输入"></a>样例输入</h3><blockquote>
<p>4 3<br>1 2 2 1<br>2<br>1 2 1<br>2</p>
</blockquote>
<h3 id="样例输出"><a href="#样例输出" class="headerlink" title="样例输出"></a>样例输出</h3><blockquote>
<p>3<br>1</p>
</blockquote>
<h2 id="提示​"><a href="#提示​" class="headerlink" title="提示​"></a>提示​</h2><p>n,m&lt;=100000 x,y&lt;=1000000</p>
<h2 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h2><p><strong>链表+启发式合并</strong><br>启发式合并就是将size小的链表中的元素一个个取出来插进size大的链表，由于每次操作size小的链表，合并后的size至少为原来的两倍。<br>因此，考虑一个元素，它被从一个链表插进另一个链表的次数最多为$O(logN)$次，所以总的复杂度为$O(NlogN)$<br>树、set、并查集等都可以启发式合并。<br>关于本题：<br>将颜色相同的串成链表，记当前的段数为ans；每次把颜色a改成b相当于合并两个链表。<br>暴力修改a和b中size小的那个链表，把它接到大的上面去，检查相邻颜色维护ans。<br>当size[a]&gt;size[b]的时候，会把颜色b修改成a，这与题意不符，因此要用f[i]记录颜色i当前是多少，如在这种情况下f[b]=a,f[a]=b</p>
<dir style="display:none"><a href="/2016/09/11/NOIP模拟赛-梦幻布丁/pudding.pas" title="复制代码">复制代码</a></dir>

<p>```delphi pudding.pas<br>type int=longint;<br>var<br>    h,t,s,f:array[0..1000010] of int;<br>    c,next:array[0..100010] of int;<br>    n,m,i,x,a,b,ans:int;</p>
<p>procedure swap(var a,b:int);<br>var tmp:int;<br>begin tmp:=a;a:=b;b:=tmp end;</p>
<p>procedure merge(a,b:int);<br>var i:int;<br>begin<br>    i:=h[a];<br>    while i&lt;&gt;0 do begin<br>        if c[i-1]=b then dec(ans);<br>        if c[i+1]=b then dec(ans);<br>        i:=next[i];<br>    end;<br>    i:=h[a];<br>    while i&lt;&gt;0 do begin c[i]:=b;i:=next[i] end;<br>    next[t[b]]:=h[a];t[b]:=t[a];inc(s[b],s[a]);<br>    s[a]:=0;h[a]:=0;t[a]:=0;<br>end;</p>
<p>begin<br>    assign(input,’pudding.in’);reset(input);<br>    assign(output,’pudding.out’);rewrite(output);<br>    read(n,m);ans:=0;<br>    for i:=1 to n do begin<br>        read(c[i]);<br>        if c[i]&lt;&gt;c[i-1] then inc(ans);<br>        f[c[i]]:=c[i];<br>        if h[c[i]]=0 then t[c[i]]:=i;<br>        inc(s[c[i]]);next[i]:=h[c[i]];h[c[i]]:=i;<br>    end;<br>    for i:=1 to m do begin<br>        read(x);<br>        if x=1 then begin<br>            read(a,b);<br>            if a=b then continue;<br>            if s[f[a]]&gt;s[f[b]] then swap(f[a],f[b]);<br>            a:=f[a];b:=f[b];<br>            if s[a]=0 then continue;<br>            merge(a,b);<br>        end else writeln(ans);<br>    end;<br>    close(input);close(output);<br>end.<br>```</p>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[NOIP模拟赛 黑魔法师之门]]></title>
      <url>https://cothrax.github.io/2016/09/10/NOIP%E6%A8%A1%E6%8B%9F%E8%B5%9B-%E9%BB%91%E9%AD%94%E6%B3%95%E5%B8%88%E4%B9%8B%E9%97%A8/</url>
      <content type="html"><![CDATA[<h2 id="描述"><a href="#描述" class="headerlink" title="描述"></a>描述</h2><p>经过了 16 个工作日的紧张忙碌,未来的人类终于收集到了足够的能源。然而在与 Violet星球的战争中,由于 Z 副官的愚蠢,地球的领袖 applepi 被邪恶的黑魔法师 Vani 囚禁在了Violet 星球。为了重启 Nescafé这一宏伟的科技工程,人类派出了一支由 XLk、Poet_shy 和lydrainbowcat 三人组成的精英队伍,穿越时空隧道,去往 Violet 星球拯救领袖 applepi。<br>applepi 被囚禁的地点只有一扇门,当地人称它为“黑魔法师之门”。这扇门上画着一张无向无权图,而打开这扇门的密码就是<strong>图中每个点的度数大于零且都是偶数的子图的个数对 1000000009 取模的值</strong>。此处子图 (V, E) 定义为:点集 V 和边集 E 都是原图的任意子集,其中 E 中的边的端点都在 V 中。<br>但是 Vani 认为这样的密码过于简单,因此门上的图是动态的。起初图中只有 N 个顶点而没有边。Vani 建造的门控系统共操作 M 次,每次往图中添加一条边。你必须在每次操作后都填写正确的密码,才能够打开黑魔法师的牢狱,去拯救伟大的领袖 applepi。</p>
<h2 id="格式"><a href="#格式" class="headerlink" title="格式"></a>格式</h2><h3 id="输入格式"><a href="#输入格式" class="headerlink" title="输入格式"></a>输入格式</h3><p>第一行包含两个整数 N 和 M。<br>接下来 M 行,每行两个整数 A 和 B,代表门控系统添加了一条无向边 (A, B)。</p>
<h3 id="输出格式"><a href="#输出格式" class="headerlink" title="输出格式"></a>输出格式</h3><p>输出一共 M 行,表示每次操作后的密码。<br><a id="more"></a></p>
<h2 id="样例"><a href="#样例" class="headerlink" title="样例"></a>样例</h2><h3 id="样例输入"><a href="#样例输入" class="headerlink" title="样例输入"></a>样例输入</h3><blockquote>
<p>4 8<br>3 1<br>3 2<br>2 1<br>2 1<br>1 3<br>1 4<br>2 4<br>2 3</p>
</blockquote>
<h3 id="样例输出"><a href="#样例输出" class="headerlink" title="样例输出"></a>样例输出</h3><blockquote>
<p>0<br>0<br>13<br>7<br>7<br>15<br>31</p>
</blockquote>
<h2 id="提示​"><a href="#提示​" class="headerlink" title="提示​"></a>提示​</h2><h3 id="样例说明"><a href="#样例说明" class="headerlink" title="样例说明"></a>样例说明</h3><p>第三次添加之后,存在一个满足条件的子图 {1, 2, 3}(其中 1, 2, 3 是数据中边的标号)。<br>第四次添加之后,存在三个子图 {1, 2, 3},{1, 2, 4},{3, 4}。<br>„„</p>
<h3 id="数据范围与约定"><a href="#数据范围与约定" class="headerlink" title="数据范围与约定"></a>数据范围与约定</h3><p>对于 30% 的数据,N, M≤10。<br>对于 100% 的数据,N≤200000,M≤300000。</p>
<h2 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h2><p>构造（找规律）后并查集，容易发现一个满足题意的子图是有环的，且都可以看做是多个简单环拼接起来，实际上答案=2^(简单环的个数)-1<br>有以下几种思路：</p>
<ol>
<li>考虑边e(x,y)，如果x和y已经连通，那么将e加进去会形成一个简单环，将这个环加入已有的子图中会构造出新的答案，于是ans=ans*2+1</li>
<li>或者说，由于答案的子图都是由简单环组合出来的，二项式定理可得答案是$\sum_{i=1}^{n}C(n,i)=2^n-1$，同样可以算出来</li>
<li>题解提供了一种奇怪的构造思路：<blockquote>
<p>因为一个环里每个点的度数都是大于零的偶数,我们可以这样来构造答案:每个环有选和不选两种选择,如果选择了该环,那么环上所有边的“选择次数” +1。最后取所有“选择次数”为奇数的边构成一个边集,就是一个答案。可以证明这样构造出来的解不重复且涵盖了所有情况。因此答案就是 2^(图中”元”环的个数)。实现方法非常简单,只需要一个并查集即可。</p>
</blockquote>
</li>
</ol>
<dir style="display:none"><a href="/2016/09/10/NOIP模拟赛-黑魔法师之门/magician.pas" title="复制代码">复制代码</a></dir>

<p>```delphi magician.pas<br>type int=longint;<br>const z=1000000009;<br>var<br>    par:array[0..200010] of int;<br>    n,m,i,ans,x,y:int;</p>
<p>function find(x:int):int;<br>begin<br>    if par[x]=x then find:=x<br>    else begin par[x]:=find(par[x]);find:=par[x] end;<br>end;</p>
<p>procedure union(x,y:int);<br>begin x:=find(x);y:=find(y);par[x]:=y end;</p>
<p>function same(x,y:int):boolean;<br>begin same:=find(x)=find(y) end;</p>
<p>begin<br>    assign(input,’magician.in’);reset(input);<br>    assign(output,’magician.out’);rewrite(output);<br>    read(n,m);<br>    for i:=1 to n do par[i]:=i;<br>    ans:=0;<br>    for i:=1 to m do begin<br>        read(x,y);<br>        if same(x,y) then ans:=(ans*2+1) mod z else union(x,y);<br>        writeln(ans);<br>    end;<br>    close(input);close(output);<br>end.<br>```</p>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[NOIP模拟赛 2014-06-28]]></title>
      <url>https://cothrax.github.io/2016/09/10/NOIP%E6%A8%A1%E6%8B%9F%E8%B5%9B-2014-06-28/</url>
      <content type="html"><![CDATA[<p>三道图论题。</p>
<table>
<thead>
<tr>
<th>题目</th>
<th>思路</th>
</tr>
</thead>
<tbody>
<tr>
<td>魔术球问题弱化版</td>
<td>二分+最大流(匈牙利算法)</td>
</tr>
<tr>
<td>征兵</td>
<td>最大生成树</td>
</tr>
<tr>
<td>坑爹的GPS</td>
<td>三次最短路</td>
</tr>
</tbody>
</table>
<h1 id="P1-魔术球问题弱化版"><a href="#P1-魔术球问题弱化版" class="headerlink" title="P1 魔术球问题弱化版"></a>P1 魔术球问题弱化版</h1><p>假设有 n 根柱子,现要按下述规则在这 n 根柱子中依次放入编号为 1,2,3,…的球。</p>
<ol>
<li>每次只能在某根柱子的最上面放球。</li>
<li>在同一根柱子中,任何 2 个相邻球的编号之和为完全平方数。</li>
</ol>
<p>试设计一个算法,计算出在 n 根柱子上最多能放多少个球。例如,在 4 根柱子上最多可放 11 个球。<br>对于给定的 n,计算在 n 根柱子上最多能放多少个球。<br><a id="more"></a></p>
<h2 id="格式"><a href="#格式" class="headerlink" title="格式"></a>格式</h2><h3 id="输入格式"><a href="#输入格式" class="headerlink" title="输入格式"></a>输入格式</h3><p>第 1 行有 1 个正整数 n,表示柱子数。</p>
<h3 id="输出格式"><a href="#输出格式" class="headerlink" title="输出格式"></a>输出格式</h3><p>一行表示可以放的最大球数</p>
<h2 id="样例"><a href="#样例" class="headerlink" title="样例"></a>样例</h2><h3 id="样例输入"><a href="#样例输入" class="headerlink" title="样例输入"></a>样例输入</h3><blockquote>
<p>4</p>
</blockquote>
<h3 id="样例输出"><a href="#样例输出" class="headerlink" title="样例输出"></a>样例输出</h3><blockquote>
<p>11</p>
</blockquote>
<h2 id="提示​"><a href="#提示​" class="headerlink" title="提示​"></a>提示​</h2><p>题目限制(为什么说弱化版就在这里)<br>N&lt;=60,时限为 3s;比起原题还有弱化在不用打出方案,方案太坑了</p>
<h2 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h2><p>先二分答案，对于给定球数建图：如果i+j(i&lt;j)为完全平方数，从i向j连边。<br>然后求图上的<strong>最小路径覆盖数x</strong>，判断$x\leq n$<br>求DAG上的路径覆盖可以规约为求对应二分图的最大匹配，详见此处：<a href="http://www.cnblogs.com/justPassBy/p/5369930.html" target="_blank" rel="external">http://www.cnblogs.com/justPassBy/p/5369930.html</a><br>上述方法只适用于DAG</p>
<ol>
<li>二分图只能表示简单路径，环会被看成两条简单路径</li>
<li>连通无向图除非是树，必然有环。</li>
</ol>
<p>最好写的匈牙利算法，极限数据1.5s</p>
<dir style="display:none"><a href="/2016/09/10/NOIP模拟赛-2014-06-28/ball.pas" title="复制代码">复制代码</a></dir>

<p>```delphi ball.pas<br>uses math;<br>const eps=0.00000000001;<br>type<br>    int=longint;<br>    edge=record f,t,next:int end;<br>var<br>    g:array[0..200010] of edge;<br>    head,match:array[0..4010] of int;<br>    used:array[0..4010] of boolean;<br>    n,l,r,mid,ans:int;</p>
<p>procedure add(f,t:int);<br>var m:int;<br>begin<br>    inc(head[0]);m:=head[0];<br>    g[m].f:=f;g[m].t:=t;<br>    g[m].next:=head[f];head[f]:=m;<br>end;</p>
<p>function dfs(v:int):boolean;<br>var i,u:int;<br>begin<br>    i:=head[v];<br>    while i&lt;&gt;0 do begin<br>        u:=g[i].t;<br>        if not used[u] then begin<br>            used[u]:=true;<br>            if (match[u]=0) or dfs(match[u]) then begin<br>                match[u]:=v;match[v]:=u;<br>                exit(true);<br>            end;<br>        end;<br>        i:=g[i].next;<br>    end;<br>    exit(false);<br>end;</p>
<p>function check(x:int):boolean;<br>var i,j,cnt:int;<br>begin<br>    fillchar(head,sizeof(head),0);<br>    for i:=1 to x do<br>        for j:=i+1 to x do<br>            if abs(sqrt(i+j)-round(sqrt(i+j)))&lt;eps then begin<br>                add(i,j+x);add(j+x,i);<br>            end;<br>    fillchar(match,[i]=0 then begin<br>            fillchar(used,sizeof(used),false);<br>            if dfs(i) then inc(cnt);<br>        end;<br>    if x-cnt&lt;=n then check:=true else check:=false;<br>end;</p>
<p>begin<br>    assign(input,’ball.in’);reset(input);<br>    assign(output,’ball.out’);rewrite(output);<br>    read(n);<br>    l:=1;r:=2000;<br>    while l&lt;=r do begin<br>        mid:=(l+r) shr 1;<br>        if check(mid) then begin ans:=mid;l:=mid+1 end<br>        else r:=mid-1;<br>    end;<br>    write(ans);<br>    close(input);close(output);<br>end.</p>
<pre><code>
最大流比匈牙利快5倍。。。（可能是我写丑了）
&lt;dir style=&quot;display:none&quot;&gt;<a href="/2016/09/10/NOIP模拟赛-2014-06-28/ball00.pas" title="复制代码">复制代码</a>&lt;/dir&gt;

```delphi ball00.pas
uses math;
const 
    eps=0.00000000001;
    inf=1000000000;
type 
    int=longint;
    edge=record t,c,rev,next:int end;
var 
    g:array[0..200010] of edge;
    head,d,iter,q:array[0..4020] of int;
    n,l,r,mid,ans:int;

procedure add(f,t,c:int);
    procedure adde(f,t,c:int);
    var m:int;
    begin
        m:=head[0];
        g[m].t:=t;g[m].c:=c;
        g[m].next:=head[f];head[f]:=m;
        inc(head[0]);
    end;
begin adde(f,t,c);adde(t,f,0) end;

function bfs(s,t0:int):boolean;
var 
    h,t,i,v,u:int;
begin
    fillchar(d,sizeof(d),255);
    h:=0;t:=1;q[h]:=s;d[s]:=0;
    while h&lt;&gt;t do begin
        v:=q[h];i:=head[v];
        while i&lt;&gt;0 do begin
            u:=g[i].t;
            if (g[i].c&gt;0) and (d[u]=-1) then begin
                d[u]:=d[v]+1;
                q[t]:=u;
                inc(t);if t&gt;4020 then t:=0;
            end;
            i:=g[i].next;
        end;    
        inc(h);if h&gt;4020 then h:=0;
    end;
    bfs:=d[t0]&lt;&gt;-1;
end;

function dfs(v,t,f:int):int;
var u,i,tmp:int;
begin
    if v=t then exit(f);
    dfs:=0;i:=iter[v];
    while i&lt;&gt;0 do begin
        u:=g[i].t;
        if (g[i].c&gt;0) and (d[u]=d[v]+1) then begin
            tmp:=dfs(u,t,min(g[i].c,f-dfs));
            dec(g[i].c,tmp);
            if g[i].c&gt;0 then iter[v]:=i;
            inc(g[i xor 1].c,tmp);
            inc(dfs,tmp);
        end;
        i:=g[i].next;
    end;
    if dfs=0 then d[i]:=-1;
end;

function maxflow(s,t:int):int;
var i:int;
begin
    maxflow:=0;
    while bfs(s,t) do begin
        for i:=1 to t do iter[i]:=head[i];
        inc(maxflow,dfs(s,t,inf));
    end;
end;

function check(x:int):boolean;
var i,j:int;
begin
    fillchar(head,sizeof(head),0);
    for i:=1 to x do
        for j:=i+1 to x do
            if abs(sqrt(i+j)-round(sqrt(i+j)))&lt;eps then
                add(i,j+x,1);
    for i:=1 to x do add(2*x+1,i,1);
    for i:=1 to x do add(i+x,2*x+2,1);
    if x-maxflow(2*x+1,2*x+2)&lt;=n then check:=true 
    else check:=false;
end;

begin
    assign(input,&#39;ball.in&#39;);reset(input);
    assign(output,&#39;ball.out&#39;);rewrite(output);
    read(n);
    l:=1;r:=2000;
    while l&lt;=r do begin
        mid:=(l+r) shr 1;
        if check(mid) then begin ans:=mid;l:=mid+1 end
        else r:=mid-1;
    end;
    write(ans);
    close(input);close(output);
end.
</code></pre><p>其实二分图完全没有用dinic的必要，直接上ford-fulkerson就好了。</p>
<dir style="display:none"><a href="/2016/09/10/NOIP模拟赛-2014-06-28/ball0.pas" title="复制代码">复制代码</a></dir>

<p>```delphi ball0.pas<br>uses math;<br>const<br>    eps=0.00000000001;<br>    inf=1000000000;<br>type<br>    int=longint;<br>    edge=record f,t,c,next:int end;<br>var<br>    g:array[0..200010] of edge;<br>    head,flag:array[0..4020] of int;<br>    n,l,r,cur,mid,ans:int;</p>
<p>procedure add(f,t,c:int);<br>    procedure adde(f,t,c:int);<br>    var m:int;<br>    begin<br>        m:=head[0];<br>        g[m].f:=f;g[m].t:=t;g[m].c:=c;<br>        g[m].next:=head[f];head[f]:=m;<br>        inc(head[0]);<br>    end;<br>begin<br>    adde(f,t,c);adde(t,f,0);<br>end;</p>
<p>function dfs(s,t,f:int):int;<br>var u,i,d:int;<br>begin<br>    if s=t then exit(f);<br>    dfs:=0;<br>    flag[s]:=cur;<br>    i:=head[s];<br>    while i&lt;&gt;0 do begin<br>        u:=g[i].t;<br>        if (flag[u]<cur) and="" (g[i].c="">0) then begin<br>            d:=dfs(u,t,min(f-dfs,g[i].c));<br>            if d&gt;0 then begin<br>                dec(g[i].c,d);<br>                inc(g[i xor 1].c,d);<br>                inc(dfs,d);<br>            end;<br>        end;<br>        i:=g[i].next;<br>    end;<br>end;</cur)></p>
<p>function maxflow(s,t:int):int;<br>var f:int;<br>begin<br>    maxflow:=0;<br>    fillchar(flag,sizeof(flag),0);cur:=0;<br>    while true do begin<br>        inc(cur);<br>        f:=dfs(s,t,inf);<br>        if f=0 then exit(maxflow);<br>        inc(maxflow,f);<br>    end;<br>end;</p>
<p>function check(x:int):boolean;<br>var i,j:int;<br>begin<br>    fillchar(head,sizeof(head),0);<br>    for i:=1 to x do<br>        for j:=i+1 to x do<br>            if abs(sqrt(i+j)-round(sqrt(i+j)))&lt;eps then<br>                add(i,j+x,1);<br>    for i:=1 to x do add(2<em>x+1,i,1);<br>    for i:=1 to x do add(i+x,2</em>x+2,1);<br>    if x-maxflow(2<em>x+1,2</em>x+2)&lt;=n then check:=true<br>    else check:=false;<br>end;</p>
<p>begin<br>    assign(input,’ball.in’);reset(input);<br>    assign(output,’ball.out’);rewrite(output);<br>    read(n);<br>    l:=1;r:=2000;<br>    while l&lt;=r do begin<br>        mid:=(l+r) shr 1;<br>        if check(mid) then begin ans:=mid;l:=mid+1 end<br>        else r:=mid-1;<br>    end;<br>    write(ans);<br>    close(input);close(output);<br>end.</p>
<pre><code>

# P2 征兵
一个国王,他拥有一个国家。最近他因为国库里钱太多了,闲着蛋疼要征集一只部队要保卫
国家。他选定了 N 个女兵和 M 个男兵,但事实上每征集一个兵他就要花 10000RMB,即使国库
里钱再多也伤不起啊。他发现,某男兵和某女兵之间有某种关系(往正常方面想,一共 R 种
关系),这种关系可以使 KING 少花一些钱就可以征集到兵,不过国王也知道,在征兵的时候,
每一个兵只能使用一种关系来少花钱。这时国王向你求助,问他最少要花多少的钱。

## 格式
### 输入格式
第一行:T,一共 T 组数据。
接下来 T 组数据,
第一行包括 N,M,R
接下来的 R 行 包括 Xi,Yi,Vi 表示如果招了第 Xi 个女兵,再招第 Yi 个男兵能省 Vi 元(同样表示如果招了第 Yi 个男兵,再招第 Xi 个女兵能也省 Vi 元)

### 输出格式
共 T 行,表示每组数据的最终花费是多少(因为国库里的钱只有 2^31-1,所以保证最终花费在 maxlongint 范围内)

## 样例
### 样例输入
&gt;2
5 5 8
4 3 6831
1 3 4583
0 0 6592
0 1 3063
3 3 4975
1 3 2049
4 2 2104
2 2 781
5 5 10
2 4 9820
3 2 6236
3 1 8864
2 4 8326
2 0 5156
2 0 1463
4 1 2439
0 4 4373
3 4 8889
2 4 3133

### 样例输出
&gt;71071
54223

## 提示​
数据范围
数据保证 T&lt;=5 ,m,n&lt;=10000,r&lt;=50000,Xi&lt;=m,Yi&lt;=n,Vi&lt;=10000,结果&lt;=2^31-1

## 题解
最大生成树
&lt;dir style=&quot;display:none&quot;&gt;<a href="/2016/09/10/NOIP模拟赛-2014-06-28/conscription.pas" title="复制代码">复制代码</a>&lt;/dir&gt;

```delphi conscription.pas
type 
    int=longint;
    edge=record f,t,w:int end;
var 
    g:array[0..50010] of edge;
    par:array[0..20010] of int;
    n,m,r,i,t:int;ans:int64;

procedure qsort(l,r:int);
var i,j,x:int;tmp:edge;
begin
    i:=l;j:=r;x:=g[random(r-l)+l].w;
    repeat
        while g[i].w&gt;x do inc(i);
        while g[j].w&lt;x do dec(j);
        if i&lt;=j then begin
            tmp:=g[i];g[i]:=g[j];g[j]:=tmp;
            inc(i);dec(j);
        end;
    until i&gt;j;
    if i&lt;r then qsort(i,r);
    if l&lt;j then qsort(l,j);
end;

function find(x:int):int;
begin
    if par[x]=x then find:=x
    else begin
        par[x]:=find(par[x]);
        find:=par[x];
    end;
end;

procedure union(x,y:int);
begin x:=find(x);y:=find(y);par[x]:=y end;

function same(x,y:int):boolean;
begin same:=find(x)=find(y) end;

begin
    read(t);
    repeat

        read(n,m,r);
        for i:=1 to r do begin
            read(g[i].f,g[i].t,g[i].w);
            inc(g[i].t,n);
        end;
        for i:=0 to n+m-1 do par[i]:=i;
        qsort(1,r);ans:=0;
        for i:=1 to r do
            if not same(g[i].f,g[i].t) then begin
                union(g[i].f,g[i].t);
                inc(ans,g[i].w);
            end;
        writeln((n+m)*10000-ans);
        dec(t);
    until t=0;
end.
</code></pre><h1 id="P3-坑爹的-GPS"><a href="#P3-坑爹的-GPS" class="headerlink" title="P3 坑爹的 GPS"></a>P3 坑爹的 GPS</h1><p>有一天,FJ 买了一辆车,但是,他一手下载了两个 GPS 系统。好了现在麻烦的事情来了,GPS有一个功能大概大家也知道,如果 FJ 没有按照 GPS 内置地图的最短路走,GPS 就会报错来骚扰你。现在 FJ 准备从他的农舍(在 1 这个点)开车到他的谷屋(n 这个点)。FJ 给了你两个<br>GPS 系统内置地图的信息,他想知道,他最少会听到多少次报错(如果 FJ 走的路同时不满足两个 GPS,报错次数+2)</p>
<h2 id="格式-1"><a href="#格式-1" class="headerlink" title="格式"></a>格式</h2><h3 id="输入格式-1"><a href="#输入格式-1" class="headerlink" title="输入格式"></a>输入格式</h3><p>第一行:n,k;n 表示有 FJ 的谷屋在哪,同时保证 GPS 内置地图里的点没有超过 n 的点。K 表示 GPS 内置地图里的路有多少条,如果两个点没有连接则表明这不是一条通路。接下来 k 行,每行 4 个数 X,Y,A,B 分别表示从 X 到 Y 在第一个 GPS 地图里的距离是 A,在第二个 GPS 地图里的是 B。注意由于地形的其他因素 GPS 给出的边是有向边。</p>
<h3 id="输出格式-1"><a href="#输出格式-1" class="headerlink" title="输出格式"></a>输出格式</h3><p>输出:一个值,表示 FJ 最少听到的报错次数。</p>
<h2 id="样例-1"><a href="#样例-1" class="headerlink" title="样例"></a>样例</h2><h3 id="样例输入-1"><a href="#样例输入-1" class="headerlink" title="样例输入"></a>样例输入</h3><blockquote>
<p>5 7<br>3 4 7 1<br>1 3 2 20<br>1 4 17 18<br>4 5 25 3<br>1 2 10 13 5 4 14<br>2 4 6 5</p>
</blockquote>
<h3 id="样例输出-1"><a href="#样例输出-1" class="headerlink" title="样例输出"></a>样例输出</h3><blockquote>
<p>1</p>
</blockquote>
<h2 id="提示​-1"><a href="#提示​-1" class="headerlink" title="提示​"></a>提示​</h2><p>FJ 选择的路线是 1 2 4 5,但是 GPS 1 认为的最短路是 1 到 3,所以报错一次,对于剩下的2 4 5,两个 GPS 都不会报错。<br>数据范围<br>N&lt;=10000,至于路有多少条自己算吧。数据保证所有的距离都在 2^31-1 以内。</p>
<h2 id="题解-1"><a href="#题解-1" class="headerlink" title="题解"></a>题解</h2><p>三次最短路：</p>
<ol>
<li>第一个gps从终点反向spfa</li>
<li>第二个gps同理</li>
<li>扫一边所有边构图，边权为该边的报错次数（0..2)，从起点spfa</li>
</ol>
<dir style="display:none"><a href="/2016/09/10/NOIP模拟赛-2014-06-28/gpsduel.pas" title="复制代码">复制代码</a></dir>

<p>```delphi gpsduel.pas<br>uses math;<br>const inf=1000000000;<br>type<br>    int=longint;<br>    edge=record f,t,w,next:int end;<br>    graph=array[0..50010] of edge;<br>    arr=array[0..10010] of int;<br>var<br>    ga,gb,g:graph;<br>    ha,hb,head,da,db,q:arr;<br>    inq:array[0..10010] of boolean;<br>    n,m,i,cnt,f0,t0,a0,b0:int;</p>
<p>procedure add(var g:graph;var head:arr;f0,t0,w0:int);<br>var m:int;<br>begin<br>    inc(head[0]);m:=head[0];<br>    g[m].f:=f0;g[m].t:=t0;g[m].w:=w0;<br>    g[m].next:=head[f0];head[f0]:=m;<br>end;</p>
<p>procedure spfa(g:graph;head:arr;x:int;var d:arr);<br>var h,t,i,v,u:int;<br>begin<br>    fillchar(inq,sizeof(inq),false);<br>    filldword(d,sizeof(d) div 4,inf);<br>    h:=1;t:=2;q[h]:=x;d[x]:=0;inq[x]:=true;<br>    while h&lt;&gt;t do begin<br>        v:=q[h];i:=head[v];<br>        while i&lt;&gt;0 do begin<br>            u:=g[i].t;<br>            if d[u]&gt;d[v]+g[i].w then begin<br>                d[u]:=d[v]+g[i].w;<br>                if not inq[u] then begin<br>                    inq[u]:=true;q[t]:=u;<br>                    inc(t);if t&gt;10010 then t:=0;<br>                end;<br>            end;<br>            i:=g[i].next;<br>        end;<br>        inq[v]:=false;<br>        inc(h);if h&gt;10010 then h:=0;<br>    end;<br>end;</p>
<p>begin<br>    assign(input,’gpsduel.in’);reset(input);<br>    assign(output,’gpsduel.out’);rewrite(output);<br>    read(n,m);<br>    for i:=1 to m do begin<br>        read(f0,t0,a0,b0);<br>        add(ga,ha,t0,f0,a0);<br>        add(gb,hb,t0,f0,b0);<br>    end;<br>    spfa(ga,ha,n,da);spfa(gb,hb,n,db);<br>    for i:=1 to m do begin<br>        cnt:=2;<br>        if da[ga[i].t]=da[ga[i].f]+ga[i].w then dec(cnt);<br>        if db[gb[i].t]=db[gb[i].f]+gb[i].w then dec(cnt);<br>        add(g,head,ga[i].t,gb[i].f,cnt);<br>    end;<br>    spfa(g,head,1,da);<br>    write(da[n]);<br>    close(input);close(output);<br>end.<br>```</p>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[NOIP模拟赛 2014-7-18]]></title>
      <url>https://cothrax.github.io/2016/09/08/NOIP%E6%A8%A1%E6%8B%9F%E8%B5%9B-2014-7-18/</url>
      <content type="html"><![CDATA[<p>一共五道题，有一道裸的二分和一个树形背包没有写。</p>
<table>
<thead>
<tr>
<th>题目</th>
<th>思路</th>
</tr>
</thead>
<tbody>
<tr>
<td>czy的后宫3</td>
<td>无修改莫队/各种数据结构</td>
</tr>
<tr>
<td>czy的后宫4</td>
<td>坑爹dp</td>
</tr>
<tr>
<td>蒟蒻czy又被D飞了</td>
<td>变形背包</td>
</tr>
</tbody>
</table>
<h1 id="P1-czy的后宫4"><a href="#P1-czy的后宫4" class="headerlink" title="P1 czy的后宫4"></a>P1 czy的后宫4</h1><p>上次czy在机房妥善安排了他的后宫之后，他发现可以将他的妹子分为c种，他经常会考虑这样一个问题：在[l,r]的妹子中间，能挑选出多少不同类型的妹子呢？<br>注意：由于czy非常丧尸，所以他要求在所挑选的妹子类型在[l,r]中出现次数为正偶数，你懂得。<br>问题简述:n个数，m次询问，每次问[l,r]区间有多少个数恰好出现正偶数次<br><a id="more"></a></p>
<h2 id="格式"><a href="#格式" class="headerlink" title="格式"></a>格式</h2><h3 id="输入格式"><a href="#输入格式" class="headerlink" title="输入格式"></a>输入格式</h3><p>第一行3个整数，表示n,c,m<br>第二行n个数，每个数Ai在[1,c]之间，表示一个Ai类型的妹子<br>接下来m行，每行两个整数l,r，表示询问[l,r]这个区间的答案</p>
<h3 id="输出格式"><a href="#输出格式" class="headerlink" title="输出格式"></a>输出格式</h3><p>有m行，表示第i次询问的答案</p>
<h2 id="样例"><a href="#样例" class="headerlink" title="样例"></a>样例</h2><h3 id="样例输入"><a href="#样例输入" class="headerlink" title="样例输入"></a>样例输入</h3><blockquote>
<p>5 5 3<br>1 1 2 2 3<br>1 5<br>3 4<br>2 3</p>
</blockquote>
<h3 id="样例输出"><a href="#样例输出" class="headerlink" title="样例输出"></a>样例输出</h3><blockquote>
<p>2<br>1<br>0</p>
</blockquote>
<h2 id="提示​"><a href="#提示​" class="headerlink" title="提示​"></a>提示​</h2><p>共有10组测试数据<br>1-4组n,m=500，2000，5000，10000，c=1000<br>5-7组n,m=20000，30000，40000，c=10000<br>8-10组n,m=50000，80000，100000，c=100000<br>数据保证随机生成</p>
<h2 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h2><p>离线做，裸的无修改莫队</p>
<dir style="display:none"><a href="/2016/09/08/NOIP模拟赛-2014-7-18/harem.pas" title="复制代码">复制代码</a></dir>

<p>```delphi harem.pas<br>uses math;<br>type int=longint;<br>var<br>    n,m,k,b,i,j,l,r,tot:int;<br>    q:array[0..100010,0..3] of int;<br>    a,ans,cnt:array[0..100010] of int;</p>
<p>function com(i,j:int):boolean;<br>begin<br>    com:=(q[i,3]&lt;q[j,3]) or ((q[i,3]=q[j,3]) and (q[i,2]&lt;q[j,2]));<br>end;</p>
<p>procedure qsort(l,r:int);<br>var<br>    tmp:array[0..3] of int;<br>    i,j:int;<br>begin<br>    i:=l;j:=r;q[0]:=q[random(r-l)+l];<br>    repeat<br>        while com(i,0) do inc(i);<br>        while com(0,j) do dec(j);<br>        if i&lt;=j then begin<br>            tmp:=q[i];q[i]:=q[j];q[j]:=tmp;<br>            inc(i);dec(j);<br>        end;<br>    until i&gt;j;<br>    if i&lt;r then qsort(i,r);<br>    if l&lt;j then qsort(l,j);<br>end;</p>
<p>procedure update(i,x:int);<br>begin<br>    if not odd(cnt[i]) and (cnt[i]&lt;&gt;0) then dec(tot);<br>    inc(cnt[i],x);<br>    if not odd(cnt[i]) and (cnt[i]&lt;&gt;0) then inc(tot);<br>end;</p>
<p>begin<br>    assign(input,’harem.in’);reset(input);<br>    assign(output,’harem.out’);rewrite(output);<br>    read(n,k,m);b:=floor(sqrt(n));<br>    for i:=1 to n do read(a[i]);<br>    for i:=1 to m do begin<br>        read(q[i,1],q[i,2]);<br>        q[i,0]:=i;<br>        q[i,3]:=(q[i,1]-1) div b+1;<br>    end;<br>    qsort(1,m);<br>    l:=1;r:=0;tot:=0;<br>    for i:=1 to m do begin<br>        for j:=r+1 to q[i,2] do update(a[j],1);<br>        for j:=r downto q[i,2]+1 do update(a[j],-1);<br>        for j:=l to q[i,1]-1 do update(a[j],-1);<br>        for j:=l-1 downto q[i,1] do update(a[j],1);<br>        l:=q[i,1];r:=q[i,2];<br>        ans[q[i,0]]:=tot;<br>    end;<br>    for i:=1 to m do writeln(ans[i]);<br>    close(input);close(output);<br>end.</p>
<pre><code>
# P2 czy的后宫4
czy有很多妹子，妹子虽然数量很多，但是质量不容乐观，她们的美丽值全部为负数（喜闻乐见）。
czy每天都要带N个妹子到机房，她们都有一个独一无二的美丽值，美丽值为-1到-N之间的整数。他想要把这些妹子排成一个波动序列，这样相对“漂亮”（美丽值的绝对值较小）的妹子可以与她旁边的两个美丽值的绝对值较大的妹子形成鲜明的对比，整个序列相对将更加“美观”（不再那么无法直视）。
一个序列是波动序列仅当序列中的每个数比周围的两个数都大或都小（如果有的话）。
现在czy希望知道，长度为N的波动序列有多少种。两种序列A和B不同当且仅当存在一个i，使得Ai≠Bi。由于这个数目可能很大，你只对它除以P的余数感兴趣。

## 格式
### 输入格式
输入文件czy.in仅含一行，两个正整数N, P。

### 输出格式
输出文件czy.out仅含一行，一个非负整数，表示你所求的答案对P取余之后的结果。
&lt;!--more--&gt;

## 样例
### 样例输入
&gt;4 7

### 样例输出
&gt;3

## 提示​
说明：共有10种可能的序列，它们是：  1324 1423 2143 2314 2413  3142 3241 3412 4132 4231
(忽略负号)  
【数据规模和约定】  
对于20%的数据，满足N≤10；  
对于40%的数据，满足N≤18； 
对于70%的数据，满足N≤550；  
对于100%的数据，满足3≤N≤4200，P≤10^9。

## 题解
异常坑的dp：
1. $f[i,j]$：<span>$a{1..i}$</span><!-- Has MathJax -->的序列以$x\in[1..i]$开头，且<span>$a_1&lt;a_2$</span><!-- Has MathJax -->（序列第一个**上升**）的方案数

2. <span>$g[i,j]$</span><!-- Has MathJax -->：<span>$a{1..i}$</span><!-- Has MathJax -->的序列以$x\in[j..i]$开头，且<span>$a_1&gt;a_2$</span><!-- Has MathJax -->（序列第一个**下降**）的方案数

结论：$$f[i,j]=f[i,j-1]+g[i-1,j]$$
1. $f[i,j-1]$：把$1..j-1$开头的方案加上去
2. $g[i-1,j]$：考虑序列以j开头，要求<span>$a_2&gt;j$</span><!-- Has MathJax -->，则<span>$a_2\in[j+1,i]$</span><!-- Has MathJax -->，从<span>$a_2$</span><!-- Has MathJax -->开始是上升序列，j已经用掉了，剩下<span>$\{1..j-1,j+1..i\}$</span><!-- Has MathJax -->离散为<span>$\{1..i-1\}$</span><!-- Has MathJax -->，原来的j+1离散为1..i-1中的j，所以方案数为$g[i-1,j]$

f和g是对称的：考虑将f的一个序列a中的$a_i$换成$i-a_i+1$，就对应g中的一个序列。

于是：$$f[i,j]=f[i,j-1]+f[i-1,i-j]$$

&lt;dir style=&quot;display:none&quot;&gt;<a href="/2016/09/08/NOIP模拟赛-2014-7-18/czy.pas" title="复制代码">复制代码</a>&lt;/dir&gt;

```delphi czy.pas
type int=longint;
var 
    n,i,j,c,p:int;
    f:array[0..1,0..4210] of int;

begin
    assign(input,&#39;czy.in&#39;);reset(input);
    assign(output,&#39;czy.out&#39;);rewrite(output);
    read(n,p);
    if n=1 then begin write(1);halt end;
    f[1,1]:=1;
    for i:=2 to n do begin
        c:=i and 1;
        for j:=1 to i do begin
            f[c,j]:=f[c,j-1]+f[c xor 1,i-j];
            if f[c,j]&gt;p then f[c,j]:=f[c,j] mod p;
        end;
    end;
    write(f[n and 1,n]*2 mod p);
    close(input);close(output);
end.
</code></pre><h1 id="P5-蒟蒻czy又被D飞了"><a href="#P5-蒟蒻czy又被D飞了" class="headerlink" title="P5 蒟蒻czy又被D飞了"></a>P5 蒟蒻czy又被D飞了</h1><p>机房里的各路巨神天天D蒟蒻CZY，早已是他们的日常任务了。（今天的机房也是很和平呢）<br>这一次他们安排好了一种方式来D蒟蒻Czy。每个人每次都能把Czy D飞一个高度（让Czy的高度+a[i]），由于他们的精力有限，要保留体力应对接下来的战斗，所以他们每个人只会D Czy k[i]次。由于他们每个人的D人能力不同，各有所长，所以他们每个人都在Czy到一定高度h[i]以后良心发现，任由Czy自生自灭，回去玩达尔文进化岛了。<br>所以Czy想知道他的速度是否能达到第二宇宙速度，离开这个可怕的地方。但是Czy太弱了，所以这个问题就交给了未来集训队的你。但是你这么吊，哪里屑解答Czy蒟蒻的问题。于是你打算只告诉他最高会飞到什么高度，让他自己算自己的速度去。</p>
<h2 id="格式-1"><a href="#格式-1" class="headerlink" title="格式"></a>格式</h2><h3 id="输入格式-1"><a href="#输入格式-1" class="headerlink" title="输入格式"></a>输入格式</h3><p>第1行：1个整数N（1&lt;=N&lt;=100）N表示机房里有多少人今天要D 蒟蒻Czy<br>接下里N行，每行描述一个神犇的信息  a[i] h[i] k[i]</p>
<h3 id="输出格式-1"><a href="#输出格式-1" class="headerlink" title="输出格式"></a>输出格式</h3><p>第1行：1个整数H，表示Czy最高会被神犇们D到哪里去<br><!--more--></p>
<h2 id="样例-1"><a href="#样例-1" class="headerlink" title="样例"></a>样例</h2><h3 id="样例输入-1"><a href="#样例输入-1" class="headerlink" title="样例输入"></a>样例输入</h3><blockquote>
<p>7<br>8 35 1<br>5 35 1<br>15 35 1<br>8 35 1<br>10 35 1<br>4 35 1<br>2 35 1</p>
</blockquote>
<h3 id="样例输出-1"><a href="#样例输出-1" class="headerlink" title="样例输出"></a>样例输出</h3><blockquote>
<p>35</p>
</blockquote>
<h2 id="提示​-1"><a href="#提示​-1" class="headerlink" title="提示​"></a>提示​</h2><p>对于100%的数据  1&lt;=k[i]&lt;=30，1&lt;=h[i]&lt;=10000,  1&lt;=a[i]&lt;=200 </p>
<h2 id="题解-1"><a href="#题解-1" class="headerlink" title="题解"></a>题解</h2><p>带限制的背包</p>
<dir style="display:none"><a href="/2016/09/08/NOIP模拟赛-2014-7-18/fly.pas" title="复制代码">复制代码</a></dir>

<p>```delphi fly.pas<br>uses math;<br>type int=longint;<br>var<br>    f:array[0..15010] of boolean;<br>    g:array[0..15010] of int;<br>    a,k,h:array[0..110] of int;<br>    n,i,j,ans:int;</p>
<p>procedure swap(var a,b:int);<br>var tmp:int;<br>begin tmp:=a;a:=b;b:=tmp end;</p>
<p>procedure qsort(l,r:int);<br>var i,j,x:int;<br>begin<br>    i:=l;j:=r;x:=h[random(r-l)+l];<br>    repeat<br>        while h[i]<x do="" inc(i);="" while="" h[j]="">x do dec(j);<br>        if i&lt;=j then begin<br>            swap(a[i],a[j]);<br>            swap(h[i],h[j]);<br>            swap(k[i],k[j]);<br>            inc(i);dec(j);<br>        end;<br>    until i&gt;j;<br>    if i&lt;r then qsort(i,r);<br>    if l&lt;j then qsort(l,j);<br>end;</x></p>
<p>begin<br>    assign(input,’fly.in’);reset(input);<br>    assign(output,’fly.out’);rewrite(output);<br>    read(n);<br>    for i:=1 to n do read(a[i],h[i],k[i]);<br>    qsort(1,n);<br>    fillchar(f,sizeof(f),false);<br>    f[0]:=true;ans:=0;<br>    for i:=1 to n do begin<br>        fillchar(g,sizeof(g),0);<br>        for j:=a[i] to h[i] do<br>            if not f[j] and f[j-a[i]] and<br>                (g[j-a[i]]&lt;k[i]) then begin<br>                f[j]:=true;<br>                g[j]:=g[j-a[i]]+1;<br>                ans:=max(ans,j);<br>            end;<br>    end;<br>    write(ans);<br>    close(input);close(output);<br>end.<br>```</p>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[NOIP模拟赛 混合图]]></title>
      <url>https://cothrax.github.io/2016/09/06/NOIP%E6%A8%A1%E6%8B%9F%E8%B5%9B-%E6%B7%B7%E5%90%88%E5%9B%BE/</url>
      <content type="html"><![CDATA[<h2 id="描述"><a href="#描述" class="headerlink" title="描述"></a>描述</h2><p>Hzwer神犇最近又征服了一个国家，然后接下来却也遇见了一个难题。<br>Hzwer的国家有n个点，m条边，而作为国王，他十分喜欢游览自己的国家。他一般会从任意一个点出发，随便找边走，沿途欣赏路上的美景。但是我们的Hzwer是一个奇怪的人，他不喜欢走到自己以前走过的地方，他的国家本来有p1条有向边，p2条无向边，由于国王奇怪的爱好，他觉得整改所有无向边，使得他们变成有向边，要求整改完以后保证他的国家不可能出现从某个地点出发顺着路走一圈又回来的情况。（注:m=p1+p2.）<br>概述:给你一张混合图，要求你为无向图定向，使得图上没有环。</p>
<h2 id="格式"><a href="#格式" class="headerlink" title="格式"></a>格式</h2><h3 id="输入格式"><a href="#输入格式" class="headerlink" title="输入格式"></a>输入格式</h3><p>第一行3个整数 n,p1,p2，分别表示点数，有向边的数量，无向边的数量。<br>第二行起输入p1行，每行2个整数 a,b 表示a到b有一条有向边。<br>接下来输入p2行,每行2个整数 a,b 表示a和b中间有一条无向边。</p>
<h3 id="输出格式"><a href="#输出格式" class="headerlink" title="输出格式"></a>输出格式</h3><p>对于每条无向边，我们要求按输入顺序输出你定向的结果，也就是如果你输出a b，那表示你将a和b中间的无向边定向为a-&gt;b。<br>注意，也许存在很多可行的解。你只要输出其中任意一个就好。<br><a id="more"></a></p>
<h2 id="样例"><a href="#样例" class="headerlink" title="样例"></a>样例</h2><h3 id="样例输入"><a href="#样例输入" class="headerlink" title="样例输入"></a>样例输入</h3><blockquote>
<p>4 2 3<br>1 2<br>4 3<br>1 3<br>4 2<br>3 2</p>
</blockquote>
<h3 id="样例输出"><a href="#样例输出" class="headerlink" title="样例输出"></a>样例输出</h3><blockquote>
<p>1 3<br>4 2<br>2 3</p>
</blockquote>
<h2 id="提示​"><a href="#提示​" class="headerlink" title="提示​"></a>提示​</h2><p>对于20%的数据 n&lt;=10 p1&lt;=10 p2&lt;=5<br>对于30%的数据 n&lt;=10 p1&lt;=30 p2&lt;=20<br>对于100%的数据 n&lt;=100000 p1&lt;=100000 p2&lt;=100000<br>数据保证至少有一种可行解。</p>
<h2 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h2><p>原有向图先拓扑，记录时间戳。<br>对于一条无向边，时间早的向时间晚的连边：</p>
<ol>
<li>如果两点在同一拓扑分量，那么这是一条后向边，不会改变dag性质</li>
<li>如果处于不同分量，由于一个分量是集中遍历的，分量x的所有点的时间戳肯定都小于分量y，那么只会从x向y连边，不会出现环。</li>
</ol>
<dir style="display:none"><a href="/2016/09/06/NOIP模拟赛-混合图/dizzy.pas" title="复制代码">复制代码</a></dir>

<p>```delphi dizzy.pas<br>type<br>    int=longint;<br>    edge=record t,next:int end;<br>var<br>    g:array[0..100010] of edge;<br>    head,t,ind:array[0..100010] of int;<br>    i,n,m,k,f0,t0,tim:int;</p>
<p>procedure add(f0,t0:int);<br>var m:int;<br>begin<br>    inc(head[0]);m:=head[0];<br>    g[m].t:=t0;<br>    g[m].next:=head[f0];head[f0]:=m;<br>end;</p>
<p>procedure topo(v:int);<br>var i,u:int;<br>begin<br>    inc(tim);t[v]:=tim;<br>    i:=head[v];<br>    while i&lt;&gt;0 do begin<br>        u:=g[i].t;<br>        if t[u]=0 then topo(u);<br>        i:=g[i].next;<br>    end;<br>end;</p>
<p>begin<br>    assign(input,’dizzy.in’);reset(input);<br>    assign(output,’dizzy.out’);rewrite(output);<br>    read(n,m,k);<br>    for i:=1 to m do begin<br>        read(f0,t0);add(f0,t0);inc(ind[t0]);<br>    end;<br>    tim:=0;<br>    for i:=1 to n do<br>        if ind[i]=0 then topo(i);<br>    for i:=1 to k do begin<br>        read(f0,t0);<br>        if t[f0]&lt;t[t0] then writeln(f0,’ ‘,t0)<br>        else writeln(t0,’ ‘,f0);<br>    end;<br>    close(input);close(output);<br>end.<br>```</p>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[NOIP模拟赛 教主的魔法]]></title>
      <url>https://cothrax.github.io/2016/09/06/NOIP%E6%A8%A1%E6%8B%9F%E8%B5%9B-%E6%95%99%E4%B8%BB%E7%9A%84%E9%AD%94%E6%B3%95/</url>
      <content type="html"><![CDATA[<h2 id="描述"><a href="#描述" class="headerlink" title="描述"></a>描述</h2><p>教主最近学会了一种神奇的魔法，能够使人长高。于是他准备演示给XMYZ信息组每个英雄看。于是N个英雄们又一次聚集在了一起，这次他们排成了一列，被编号为1、2、……、N。<br>每个人的身高一开始都是不超过1000的正整数。教主的魔法每次可以把闭区间[L, R]（1≤L≤R≤N）内的英雄的身高全部加上一个整数W。（虽然L=R时并不符合区间的书写规范，但我们可以认为是单独增加第L（R）个英雄的身高）<br>CYZ、光哥和ZJQ等人不信教主的邪，于是他们有时候会问WD闭区间 [L, R] 内有多少英雄身高大于等于C，以验证教主的魔法是否真的有效。<br>WD巨懒，于是他把这个回答的任务交给了你。</p>
<h2 id="格式"><a href="#格式" class="headerlink" title="格式"></a>格式</h2><h3 id="输入格式"><a href="#输入格式" class="headerlink" title="输入格式"></a>输入格式</h3><p> 第1行为两个整数N、Q。Q为问题数与教主的施法数总和。<br> 第2行有N个正整数，第i个数代表第i个英雄的身高。<br> 第3到第Q+2行每行有一个操作：</p>
<ol>
<li>若第一个字母为“M”，则紧接着有三个数字L、R、W。表示对闭区间 [L, R] 内所有英雄的身高加上W。</li>
<li>若第一个字母为“A”，则紧接着有三个数字L、R、C。询问闭区间 [L, R] 内有多少英雄的身高大于等于C。</li>
</ol>
<h3 id="输出格式"><a href="#输出格式" class="headerlink" title="输出格式"></a>输出格式</h3><p>对每个“A”询问输出一行，仅含一个整数，表示闭区间 [L, R] 内身高大于等于C的英雄数。<br><a id="more"></a></p>
<h2 id="样例"><a href="#样例" class="headerlink" title="样例"></a>样例</h2><h3 id="样例输入"><a href="#样例输入" class="headerlink" title="样例输入"></a>样例输入</h3><blockquote>
<p>5 3<br>1 2 3 4 5<br>A 1 5 4<br>M 3 5 1<br>A 1 5 4</p>
</blockquote>
<h3 id="样例输出"><a href="#样例输出" class="headerlink" title="样例输出"></a>样例输出</h3><blockquote>
<p>2<br>3</p>
</blockquote>
<h2 id="提示​"><a href="#提示​" class="headerlink" title="提示​"></a>提示​</h2><p>【输入输出样例说明】<br>原先5个英雄身高为1、2、3、4、5，此时[1, 5]间有2个英雄的身高大于等于4。教主施法后变为1、2、4、5、6，此时[1, 5]间有3个英雄的身高大于等于4。<br>【数据范围】<br>对30%的数据，N≤1000，Q≤1000。<br>对100%的数据，N≤1000000，Q≤3000，1≤W≤1000，1≤C≤1,000,000,000</p>
<h2 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h2><p>首先想到<strong>归并树</strong>，但由于每个节点维护数列，存在mle风险，但最重要的是<strong>它不支持修改</strong>。<br>本题是<strong>数列分块</strong>。</p>
<dir style="display:none"><a href="/2016/09/06/NOIP模拟赛-教主的魔法/magic0.pas" title="复制代码">复制代码</a></dir>

<p>```delphi magic.pas<br>uses math;<br>type int=longint;<br>var<br>    a,b,bl,t:array[0..10000010] of int;<br>    n,q,k,i,l,r,x:int;c:char;</p>
<p>procedure swap(var a,b:int);<br>var tmp:int;<br>begin tmp:=a;a:=b;b:=tmp end;</p>
<p>procedure qsort(l,r:int);<br>var i,j,x:int;<br>begin<br>    i:=l;j:=r;x:=b[random(r-l)+l];<br>    repeat<br>        while b[i]<x do="" inc(i);="" while="" b[j]="">x do dec(j);<br>        if i&lt;=j then begin<br>            swap(b[i],b[j]);<br>            inc(i);dec(j);<br>        end;<br>    until i&gt;j;<br>    if i&lt;r then qsort(i,r);<br>    if l&lt;j then qsort(l,j);<br>end;</x></p>
<p>procedure sort(i:int);<br>var j,l,r:int;<br>begin<br>    l:=(i-1)<em>k+1;r:=min(i</em>k,n);<br>    for j:=l to r do b[j]:=a[j];<br>    qsort(l,r);<br>end;</p>
<p>function bin(i,x:int):int; //max{i|b[i]&lt;x}<br>var l,r,mid:int;<br>begin<br>    l:=(i-1)<em>k+1;r:=min(i</em>k,n);<br>    bin:=l-1;<br>    while l&lt;=r do begin<br>        mid:=(l+r) shr 1;<br>        if b[mid]+t[i]&lt;x then begin bin:=mid;l:=mid+1 end<br>        else r:=mid-1;<br>    end;<br>end;</p>
<p>function query(l,r,x:int):int;<br>var i:int;<br>begin<br>    query:=0;<br>    for i:=l to min(r,bl[l]<em>k) do<br>        if a[i]+t[bl[l]]&gt;=x then inc(query);<br>    if bl[l]&lt;&gt;bl[r] then<br>        for i:=(bl[r]-1)</em>k+1 to r do<br>            if a[i]+t[bl[r]]&gt;=x then inc(query);<br>    for i:=bl[l]+1 to bl[r]-1 do<br>        inc(query,min(i*k,n)-bin(i,x));<br>end;</p>
<p>procedure modify(l,r,x:int);<br>var i:int;<br>begin<br>    for i:=l to min(r,bl[l]<em>k) do inc(a[i],x);<br>    sort(bl[l]);<br>    if bl[l]&lt;&gt;bl[r] then begin<br>        for i:=(bl[r]-1)</em>k+1 to r do inc(a[i],x);<br>        sort(bl[r]);<br>    end;<br>    for i:=bl[l]+1 to bl[r]-1 do inc(t[i],x);<br>end;</p>
<p>begin<br>    assign(input,’magic.in’);reset(input);<br>    assign(output,’magic.out’);rewrite(output);<br>    readln(n,q);k:=floor(sqrt(n));<br>    for i:=1 to n do read(a[i]);readln;<br>    for i:=1 to n do bl[i]:=(i-1) div k+1;<br>    for i:=1 to bl[n] do sort(i);<br>    for i:=1 to q do begin<br>        read(c);readln(l,r,x);<br>        case c of<br>            ‘A’:writeln(query(l,r,x));<br>            ‘M’:modify(l,r,x);<br>        end;<br>    end;<br>    close(input);close(output);<br>end.<br>```</p>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[NOIP模拟赛 路面修整]]></title>
      <url>https://cothrax.github.io/2016/09/06/NOIP%E6%A8%A1%E6%8B%9F%E8%B5%9B-%E8%B7%AF%E9%9D%A2%E4%BF%AE%E6%95%B4/</url>
      <content type="html"><![CDATA[<h2 id="描述"><a href="#描述" class="headerlink" title="描述"></a>描述</h2><p>FJ打算好好修一下农场中某条凹凸不平的土路。按奶牛们的要求，修好后的路面高度应当单调上升或单调下降，也就是说，高度上升与高度下降的路段不能同时出现在修好的路中。 整条路被分成了N段，N个整数A1, … , AN (1 &lt;= N &lt;= 2,000)依次描述了每一段路的高度(0 &lt;= Ai &lt;= 1,000,000,000)。FJ希望找到一个恰好含N个元素的不上升或不下降序列B1, … , BN，作为修过的路中每个路段的高度。由于将每一段路垫高或挖低一个单位的花费相同，修路的总支出可以表示为： |A1 - B1| + |A2 - B2| + … + |AN - BN| 请你计算一下，FJ在这项工程上的最小支出是多少。FJ向你保证，这个支出不会超过2^31-1。</p>
<h2 id="格式"><a href="#格式" class="headerlink" title="格式"></a>格式</h2><h3 id="输入格式"><a href="#输入格式" class="headerlink" title="输入格式"></a>输入格式</h3><p>第1行: 输入1个整数：N<br>第2..N+1行: 第i+1行为1个整数：A_i</p>
<h3 id="输出格式"><a href="#输出格式" class="headerlink" title="输出格式"></a>输出格式</h3><p>第1行: 输出1个正整数，表示FJ把路修成高度不上升或高度不下降的最小花费<br><a id="more"></a></p>
<h2 id="样例"><a href="#样例" class="headerlink" title="样例"></a>样例</h2><h3 id="样例输入"><a href="#样例输入" class="headerlink" title="样例输入"></a>样例输入</h3><blockquote>
<p>7<br>1<br>3<br>2<br>4<br>5<br>3<br>9</p>
</blockquote>
<h3 id="样例输出"><a href="#样例输出" class="headerlink" title="样例输出"></a>样例输出</h3><blockquote>
<p>3</p>
</blockquote>
<h2 id="提示​"><a href="#提示​" class="headerlink" title="提示​"></a>提示​</h2><p>FJ将第一个高度为3的路段的高度减少为2，将第二个高度为3的路段的高度增加到5，总花费为|2-3|+|5-3| = 3，并且各路段的高度为一个不下降序列 1,2,2,4,5,5,9。</p>
<h2 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h2><p><strong>离散化+DP</strong><br>首先高度的范围比较大，先离散化。<br>然后dp，例如第一种，f[i,j]表示1..i满足要求，a[i]高度为j的最小值。<br>方程简单变形后，利用单调的思想优化一下就可以了。<br>第二种情况同理</p>
<dir style="display:none"><a href="/2016/09/06/NOIP模拟赛-路面修整/grading.pas" title="复制代码">复制代码</a></dir>

<p>```delphi grading.pas<br>uses math;<br>type int=longint;<br>const inf:int64=1000000000000;<br>var<br>    a:array[0..2010,0..1] of int64;<br>    //b[i]:a[i]离散后的值;l[i]:i对应的离散值;<br>    b:array[0..2010] of int;<br>    l:array[0..2010] of int64;<br>    f:array[0..1,0..2010] of int64;<br>    i,i0,i1,j,n,m:int;p,ans:int64;</p>
<p>procedure swap(var a,b:int64);<br>var tmp:int;<br>begin tmp:=a;a:=b;b:=tmp end;</p>
<p>procedure qsort(b,e:int);<br>var i,j:int;x:int64;<br>begin<br>    i:=b;j:=e;x:=a[random(e-b)+b,0];<br>    repeat<br>        while a[i,0]<x do="" inc(i);="" while="" a[j,0]="">x do dec(j);<br>        if i&lt;=j then begin<br>            swap(a[i,0],a[j,0]);<br>            swap(a[i,1],a[j,1]);<br>            inc(i);dec(j);<br>        end;<br>    until i&gt;j;<br>    if i&lt;e then qsort(i,e);<br>    if b&lt;j then qsort(b,j);<br>end;</x></p>
<p>begin<br>    assign(input,’grading.in’);reset(input);<br>    assign(output,’grading.out’);rewrite(output);<br>    read(n);<br>    for i:=1 to n do begin<br>        read(a[i,0]);<br>        a[i,1]:=i;<br>    end;<br>    qsort(1,n);<br>    m:=0;l[0]:=0;<br>    for i:=1 to n do begin<br>        if a[i,0]&gt;l[m] then begin inc(m);l[m]:=a[i,0] end;<br>        b[a[i,1]]:=m;<br>    end;<br>    //f[i,j]:=min(f[i-1,k])+a[i]-b[j]<br>    ans:=inf;<br>    for i:=0 to m do f[1,i]:=abs(l[b[1]]-l[i]);<br>    for i:=2 to n do begin<br>        p:=inf;i1:=i mod 2;i0:=1-i1;<br>        for j:=0 to m do begin<br>            p:=min(p,f[i0,j]);<br>            f[i1,j]:=p+abs(l[b[i]]-l[j]);<br>            if i=n then ans:=min(ans,f[i1,j]);<br>        end;<br>    end;<br>    for i:=2 to n do begin<br>        p:=inf;i1:=i mod 2;i0:=1-i1;<br>        for j:=m downto 0 do begin<br>            p:=min(p,f[i0,j]);<br>            f[i1,j]:=p+abs(l[b[i]]-l[j]);<br>            if i=n then ans:=min(ans,f[i1,j]);<br>        end;<br>    end;<br>    write(ans);<br>    close(input);close(output);<br>end.<br>```</p>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[[CodeVS] P1074 食物链]]></title>
      <url>https://cothrax.github.io/2016/09/04/CodeVS-P1074/</url>
      <content type="html"><![CDATA[<h2 id="描述"><a href="#描述" class="headerlink" title="描述"></a>描述</h2><p>动物王国中有三类动物 A,B,C，这三类动物的食物链构成了有趣的环形。A吃B，B吃C，C吃A。<br>现有N个动物，以1－N编号。每个动物都是A,B,C中的一种，但是我们并不知道它到底是哪一种。<br>有人用两种说法对这N个动物所构成的食物链关系进行描述：</p>
<ol>
<li>第一种说法是“1 X Y”，表示X和Y是同类。</li>
<li>第二种说法是“2 X Y”，表示X吃Y。</li>
</ol>
<p>此人对N个动物，用上述两种说法，一句接一句地说出K句话，这K句话有的是真的，有的是假的。当一句话满足下列三条之一时，这句话就是假话，否则就是真话。</p>
<ol>
<li>当前的话与前面的某些真的话冲突，就是假话；</li>
<li>当前的话中X或Y比N大，就是假话；</li>
<li>当前的话表示X吃X，就是假话。</li>
</ol>
<p>你的任务是根据给定的N（1&lt;=N&lt;=50,000）和K句话（0&lt;=K&lt;=100,000），输出假话的总数。</p>
<h2 id="格式"><a href="#格式" class="headerlink" title="格式"></a>格式</h2><h3 id="输入格式"><a href="#输入格式" class="headerlink" title="输入格式"></a>输入格式</h3><p>第一行是两个整数N和K，以一个空格分隔。<br>以下K行每行是三个正整数D，X，Y，两数之间用一个空格隔开，其中 D 表示说法的种类。</p>
<ol>
<li>若D=1，则表示X和Y是同类。</li>
<li>若D=2，则表示X吃Y。</li>
</ol>
<h3 id="输出格式"><a href="#输出格式" class="headerlink" title="输出格式"></a>输出格式</h3><p>只有一个整数，表示假话的数目。<br><a id="more"></a></p>
<h2 id="样例"><a href="#样例" class="headerlink" title="样例"></a>样例</h2><h3 id="样例输入"><a href="#样例输入" class="headerlink" title="样例输入"></a>样例输入</h3><blockquote>
<p>100 7<br>1 101 1<br>2 1 2<br>2 2 3<br>2 3 3<br>1 1 3<br>2 3 1<br>1 5 5</p>
</blockquote>
<h3 id="样例输出"><a href="#样例输出" class="headerlink" title="样例输出"></a>样例输出</h3><blockquote>
<p>3</p>
</blockquote>
<h2 id="提示​"><a href="#提示​" class="headerlink" title="提示​"></a>提示​</h2><p>输入文件<br>对7句话的分析 100 7<br>1 101 1假话<br>2 1 2  真话<br>2 2 3  真话<br>2 3 3  假话<br>1 1 3  假话<br>2 3 1  真话<br>1 5 5  真话<br>NOI 2001 食物链(eat)</p>
<h2 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h2><h3 id="关系并查集"><a href="#关系并查集" class="headerlink" title="关系并查集"></a>关系并查集</h3><p>多年前在luogu上刷到，用了这种奇特的方法。<br>以<strong>命题</strong>作为元素做并查集，在同一集合中的命题同时成立</p>
<ol>
<li>i 表示i属于A</li>
<li>i+n 表示i属于B</li>
<li>i+2n 表示i属于C</li>
</ol>
<p>对于命题1 x y，合并：</p>
<ol>
<li>x和y</li>
<li>x+n和y+n</li>
<li>x+2n和y+2n</li>
</ol>
<p>对于命题2 x y，合并：</p>
<ol>
<li>x和y+n</li>
<li>x+n和y+2n</li>
<li>x+2n和y</li>
</ol>
<p>判断矛盾：</p>
<ol>
<li>超出范围、2 x x命题</li>
<li>第一种命题，如果same(x,y+n)或same(x+n,x)则矛盾</li>
<li>第二中命题，如果same(x,y)或same(x+n,y)则矛盾</li>
</ol>
<dir style="display:none"><a href="/2016/09/04/CodeVS-P1074/p2024.pas" title="复制代码">复制代码</a></dir>

<p>```delphi p2024.pas<br>uses math;<br>var<br>    n,k,ans,i,t,a,b:longint;<br>    par,rank:array[0..150010] of longint;</p>
<p>function find(x:longint):longint;<br>begin<br>    if par[x]=x then find:=x<br>    else begin<br>        par[x]:=find(par[x]);<br>        find:=par[x];<br>    end;<br>end;</p>
<p>procedure unite(x,y:longint);<br>begin<br>    if x=y then exit;<br>    if rank[x]&gt;rank[y] then par[y]:=x<br>    else begin<br>        par[x]:=y;<br>        if rank[x]=rank[y] then inc(rank[y]);<br>    end;<br>end;</p>
<p>function same(x,y:longint):boolean;<br>begin<br>    same:=(find(x)=find(y));<br>end;</p>
<p>begin<br>    read(n,k);<br>    for i:=1 to 3<em>n do begin<br>        par[i]:=i;<br>        rank[i]:=0;<br>    end;<br>    ans:=0;<br>    for i:=1 to k do begin<br>        read(t,a,b);<br>        if (max(a,b)&gt;n) or (min(a,b)&lt;1) then continue;<br>        if t=1 then begin<br>            if same(a,b+n) or same(a,b+2</em>n) then continue;<br>            unite(a,b);<br>            unite(a+n,b+n);<br>            unite(a+2<em>n,b+2</em>n);<br>        end else begin<br>            if same(a,b) or same(a,b+2<em>n) then continue;<br>            unite(a,b+n);<br>            unite(a+n,b+2</em>n);<br>            unite(a+2*n,b);<br>        end;<br>        inc(ans);<br>    end;<br>    write(k-ans);<br>end.</p>
<pre><code>
### 带权并查集
今天再看这道题，发现带权并查集的方法更通用一些。
我们定义向量$\overrightarrow{xy}$表示动物x和动物y的关系（**模3意义下**）：
1. $\overrightarrow{xy}=0$：同类
2. $\overrightarrow{xy}=1$：x吃y
3. $\overrightarrow{xy}=2$：y吃x

这样定义是满足向量性质的，比如$\overrightarrow{xy}=1,\overrightarrow{yz}=1$
那么$\overrightarrow{xz}=\overrightarrow{xy}+\overrightarrow{yz}=2$
表示x吃y，y吃z，那么x被z吃
我们定义并查集元素的权：$d[x]=\overrightarrow{p[x]x}$，其中p[x]为x的父亲

路径压缩时维护权值：记r为当前子树的根，我们把x接到r上，此时的d[x]变成：
$d[x]=\overrightarrow{rx}=\overrightarrow{rp[x]}+\overrightarrow{p[x]x}=d[p[x]]+d[x]$
（此时p[x]已经递归处理过了，于是已经满足p[p[x]]=r）

合并时维护权值：已知$f=\overrightarrow{xy}$，把p[x]接到p[y]上：
$d[p[x]]=\overrightarrow{p[y]p[x]}=\overrightarrow{p[y]y}-\overrightarrow{xy}-\overrightarrow{p[x]x}=d[y]-f-d[x]$

并查集初始化为$p[i]=i,d[i]=0$
然后处理命题：
1. 如果not same(x,y)，将它们合并$union(x,y,\overrightarrow{xy})$
2. 如果same(x,y)那么判断：
   1. 命题1：$d[y]\not\equiv d[x]\ (mod\ 3)$则矛盾
   2. 命题2：由于$\overrightarrow{xy}=1=\overrightarrow{py}-\overrightarrow{px}=d[y]-d[x]$，所以$d[y]-d[x]\not\equiv 1\ (mod\ 3)$则矛盾

&lt;dir style=&quot;display:none&quot;&gt;<a href="/2016/09/04/CodeVS-P1074/1074.pas" title="复制代码">复制代码</a>&lt;/dir&gt;

```delphi 1074.pas
type int=longint;
var 
    n,k,i,a,b,c,ans:int;
    par,d:array[0..50010] of int;

function find(x:int):int;
var old:int;
begin
    if par[x]=x then exit(x)
    else begin
        old:=par[x];
        par[x]:=find(par[x]);
        d[x]:=(d[x]+d[old]) mod 3;
        find:=par[x];
    end;
end;

procedure union(x,y,f:int);
var px,py:int;
begin
    px:=find(x);py:=find(y);
    par[px]:=py;
    d[px]:=(d[y]-f-d[x]+3) mod 3;
end;

function same(x,y:int):boolean;
begin same:=find(x)=find(y) end;

begin
    read(n,k);
    for i:=1 to n do begin
        par[i]:=i;
        d[i]:=0;
    end;
    ans:=0;
    for i:=1 to k do begin
        read(a,b,c);
        if (b&gt;n) or (c&gt;n) then inc(ans)
        else if (a=2) and (b=c) then inc(ans)
        else if same(b,c) then begin
            if (a=1) and (d[b]&lt;&gt;d[c]) then inc(ans);
            if (a=2) and ((d[c]-d[b]+3) mod 3&lt;&gt;1) then inc(ans);
        end else union(b,c,a-1);
    end;
    write(ans);
end.
</code></pre>]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[欢乐赛 2014-5-31]]></title>
      <url>https://cothrax.github.io/2016/09/04/%E6%AC%A2%E4%B9%90%E8%B5%9B-2014-5-31/</url>
      <content type="html"><![CDATA[<table>
<thead>
<tr>
<th style="text-align:center">题目名称</th>
<th style="text-align:center">水灾</th>
<th style="text-align:center">某种数列问题</th>
<th style="text-align:center">密码锁</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">源文件</td>
<td style="text-align:center">sliker.cpp/c/pas</td>
<td style="text-align:center">jx.cpp/c/pas</td>
<td style="text-align:center">password.cpp/c/pas</td>
</tr>
<tr>
<td style="text-align:center">输入文件</td>
<td style="text-align:center">sliker.in</td>
<td style="text-align:center">jx.in</td>
<td style="text-align:center">password.in</td>
</tr>
<tr>
<td style="text-align:center">输出文件</td>
<td style="text-align:center">sliker.out</td>
<td style="text-align:center">jx.out</td>
<td style="text-align:center">password.out</td>
</tr>
</tbody>
</table>
<blockquote>
<p>来源：hzwer.com</p>
</blockquote>
<h1 id="P1-水灾"><a href="#P1-水灾" class="headerlink" title="P1 水灾"></a>P1 水灾</h1><p>大雨应经下了几天雨，却还是没有停的样子。土豪CCY刚从外地赚完1e元回来，知道不久除了自己别墅，其他的地方都将会被洪水淹没。<br>CCY所在的城市可以用一个N*M(N,M&lt;=50)的地图表示，地图上有五种符号：“. * X D S”。其中“X”表示石头，水和人都不能从上面经过。“.”表示平原，CCY和洪水都可以经过。“*”表示洪水开始地方（可能有多个地方开始发生洪水）。“D”表示CCY的别墅。“S”表示CCY现在的位置。<br>CCY每分钟可以向相邻位置移动，而洪水将会在CCY移动之后把相邻的没有的土地淹没（从已淹没的土地）。<br>求CCY回到别墅的最少时间。如果聪哥回不了家，就很可能会被淹死，那么他就要膜拜黄金大神涨RP来呼叫直升飞机，所以输出“ORZ hzwer!!!”。<br><a id="more"></a></p>
<h2 id="格式"><a href="#格式" class="headerlink" title="格式"></a>格式</h2><h3 id="输入格式"><a href="#输入格式" class="headerlink" title="输入格式"></a>输入格式</h3><p>输入文件 sliker.in </p>
<h3 id="输出格式"><a href="#输出格式" class="headerlink" title="输出格式"></a>输出格式</h3><p>输出文件 sliker.out</p>
<h2 id="样例"><a href="#样例" class="headerlink" title="样例"></a>样例</h2><h3 id="样例输入"><a href="#样例输入" class="headerlink" title="样例输入"></a>样例输入</h3><p>样例1</p>
<blockquote>
<p>3 3<br>D.*<br>…<br>.S.</p>
</blockquote>
<p>样例2</p>
<blockquote>
<p>3 3<br>D.*<br>…<br>..S</p>
</blockquote>
<p>样例3</p>
<blockquote>
<p>3 6<br>D…*.<br>.X.X..<br>….S.</p>
</blockquote>
<h3 id="样例输出"><a href="#样例输出" class="headerlink" title="样例输出"></a>样例输出</h3><p>样例1</p>
<blockquote>
<p>3</p>
</blockquote>
<p>样例2</p>
<blockquote>
<p>ORZ hzwer!!!</p>
</blockquote>
<p>样例3</p>
<blockquote>
<p>6</p>
</blockquote>
<h2 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h2><p>比洪水到达时间早就可以走，bfs两次就可以了。<br>审题：洪水不能通过别墅D</p>
<dir style="display:none"><a href="/2016/09/04/欢乐赛-2014-5-31/sliker.pas" title="复制代码">复制代码</a></dir>

<p>```delphi sliker.pas<br>uses math;<br>type<br>    int=longint;<br>    arr=array[0..51,0..51] of int;<br>const<br>    dir:array[0..3,0..1] of int=((0,1),(1,0),(0,-1),(-1,0));<br>    inf=100000000;<br>var<br>    map:array[0..51,0..51] of char;<br>    s:array[0..2510,0..1] of int;<br>    n,m,k,i,j,sx,sy,tx,ty:int;<br>    f,d:arr;</p>
<p>procedure bfs(sx,sy:int;var d:arr;b:boolean);<br>var<br>    h,t,i,nx,ny,x,y:int;<br>    q:array[0..2510,0..1] of int;<br>    used:array[0..51,0..51] of boolean;<br>begin<br>    fillchar(used,sizeof(used),false);<br>    h:=0;t:=1;<br>    q[h,0]:=sx;q[h,1]:=sy;<br>    d[sx,sy]:=0;used[sx,sy]:=true;<br>    while h&lt;&gt;t do begin<br>        x:=q[h,0];y:=q[h,1];<br>        for i:=0 to 3 do begin<br>            nx:=q[h,0]+dir[i,0];ny:=q[h,1]+dir[i,1];<br>            if (nx<1) or(nx="">n) or (ny<1) or="" (ny="">m) then continue;<br>            if used[nx,ny] or (map[nx,ny]=’X’) then continue;<br>            if not b and (map[nx,ny]=’D’) then continue;<br>            used[nx,ny]:=true;<br>            d[nx,ny]:=min(d[nx,ny],d[x,y]+1);<br>            if b and (d[nx,ny]&gt;=f[nx,ny]) then continue;<br>            q[t,0]:=nx;q[t,1]:=ny;inc(t);<br>        end;<br>        inc(h);<br>    end;<br>end;</1)></1)></p>
<p>begin<br>    assign(input,’sliker.in’);reset(input);<br>    assign(output,’sliker.out’);rewrite(output);<br>    readln(n,m);k:=0;<br>    for i:=1 to n do<br>        for j:=1 to m do begin<br>            read(map[i,j]);<br>            case map[i,j] of<br>                ‘S’:begin sx:=i;sy:=j end;<br>                ‘D’:begin tx:=i;ty:=j end;<br>                ‘*’:begin inc(k);s[k,0]:=i;s[k,1]:=j end;<br>            end;<br>            if j=m then readln;<br>        end;<br>    filldword(f,sizeof(f) div 4,inf);<br>    for i:=1 to k do bfs(s[i,0],s[i,1],f,false);<br>    filldword(d,sizeof(d) div 4,inf);<br>    bfs(sx,sy,d,true);<br>    if d[tx,ty]&lt;&gt;inf then write(d[tx,ty])<br>    else write(‘ORZ hzwer!!!’);<br>    close(input);close(output);<br>end.</p>
<pre><code>
# P2 某种数列问题
众所周知，chenzeyu97有无数的妹子(阿掉！&gt;_&lt;)，而且他还有很多恶趣味的问题，继上次纠结于一排妹子的排法以后，今天他有非(chi)常(bao)认(cheng)真(zhe)去研究一个奇怪的问题。有一堆他的妹子站成一排，然后对于每个妹子有一个美丽度，当然美丽度越大越好，chenzeyu97妹子很多，但是质量上不容乐观，经常出现很多美丽度为负数的妹子(喜闻乐见)，chenzeyu97希望从一排妹子里找出3队连续的妹子，使她们的美丽度和最大。注意，一个妹子不能被编入多个队伍而且一定要拿出三队，不然czy会闲着没事做~。
简单滴说就是：
给定一个数列，从中找到3个无交集的连续子数列使其和最大。
## 格式
### 输入格式
第一行一个数n，表示数列长度。
接下来有n行，每行一个数，第i行为第i个数。

### 输出格式
仅有一个数，表示最大和。
&lt;!--more--&gt;

## 样例
### 样例输入
&gt;10
-1
2
3
-4
0
1
-6
-1
1
-2

### 样例输出
&gt;7

## 提示
【样例说明】
第一队妹子取2，3。
第二队妹子取0，1。
第三队妹子取1。

【数据范围】
请大家放心，虽然chenzeyu97妹子无数，但是这次他叫来的个数n是有限的。=v=
对于30%的数据，妹子数不大于200。
对于60%的数据，妹子数不大于2000。
对于100%的数据，妹子数1000000。
而且，由于chenzeyu97没有CCR那样的影响力，所以他的妹子选完的最大美丽度和不超过maxlongint。

## 题解
dp就好，f[i,j] 1..j的mz分i组的最大和，sum[i]前缀和
<span>$f[i,j]=max\{f[i-1,k]+sum[j]-sum[k]\}$</span><!-- Has MathJax -->

每次计算完f[i]，此时f[i,j]指的是第i段数**以a[j]结尾**的最大和，于是还要2..n扫一遍：
<span>$f[i,j]=max(f[i,j],f[i,j-1])$</span><!-- Has MathJax -->

复杂度$O(3N^2)$，尝试优化，我们变形一下：
<span>$f[i,j]=max\{f[i-1,k]-sum[k]\}+sum[j]$</span><!-- Has MathJax -->

然后用**单调栈**维护即可。
此外注意一下端点。


&lt;dir style=&quot;display:none&quot;&gt;<a href="/2016/09/04/欢乐赛-2014-5-31/jx.pas" title="复制代码">复制代码</a>&lt;/dir&gt;

```delphi jx.pas
uses math;
type int=longint;
var
    n,i,j,t:int;
    sum,s:array[0..1000010] of int;
    f:array[0..1000010,0..3] of int;

procedure push(x:int);
begin
    while (t&gt;0) and (s[t]&lt;=x) do dec(t);
    inc(t);s[t]:=x;
end;

begin
    assign(input,&#39;jx.in&#39;);reset(input);
    assign(output,&#39;jx.out&#39;);rewrite(output);
    read(n);
    sum[0]:=0;
    for i:=1 to n do begin
        read(j);
        sum[i]:=sum[i-1]+j;
    end;
    //f[i,j]=max(f[k,j-1]-sum[k])+sum[i]
    f[0,0]:=0;
    for i:=1 to 3 do begin
        t:=0;
        push(f[i-1,i-1]-sum[i-1]);
        for j:=i to n do begin
            f[j,i]:=s[1]+sum[j];
            push(f[j,i-1]-sum[j]);
        end;
        for j:=i+1 to n do
            f[j,i]:=max(f[j,i],f[j-1,i]);
    end;
    write(f[n,3]);
    close(input);close(output);
end.
</code></pre><h1 id="P2-密码锁"><a href="#P2-密码锁" class="headerlink" title="P2 密码锁"></a>P2 密码锁</h1><p>hzwer有一把密码锁，由N个开关组成。一开始的时候，所有开关都是关上的。当且仅当开关x1,x2,x3,…xk为开，其他开关为关时，密码锁才会打开。<br>他可以进行M种的操作，每种操作有一个size[i]，表示，假如他选择了第i种的操作的话，他可以任意选择连续的size[i]个格子，把它们全部取反。（注意，由于黄金大神非常的神，所以操作次数可以无限&gt;_&lt;）<br>本来这是一个无关紧要的问题，但是，黄金大神不小心他的钱丢进去了，没有的钱他哪里能逃过被chenzeyu97 NTR的命运？&gt;_&lt;  于是，他为了虐爆czy，也为了去泡更多的妹子，决定打开这把锁。但是他那么神的人根本不屑这种”水题”。于是，他找到了你。<br>你的任务很简单，求出最少需要多少步才能打开密码锁，或者如果无解的话，请输出-1。</p>
<h2 id="格式-1"><a href="#格式-1" class="headerlink" title="格式"></a>格式</h2><h3 id="输入格式-1"><a href="#输入格式-1" class="headerlink" title="输入格式"></a>输入格式</h3><p>第1行，三个正整数N，K，M，如题目所述。<br>第2行，K个正整数，表示开关x1,x2,x3..xk必须为开，保证x两两不同。<br>第三行，M个正整数，表示size[i]，size[]可能有重复元素。</p>
<h3 id="输出格式-1"><a href="#输出格式-1" class="headerlink" title="输出格式"></a>输出格式</h3><p>输出答案，无解输出-1。<br><!--more--></p>
<h2 id="样例-1"><a href="#样例-1" class="headerlink" title="样例"></a>样例</h2><h3 id="样例输入-1"><a href="#样例输入-1" class="headerlink" title="样例输入"></a>样例输入</h3><p>样例1</p>
<blockquote>
<p>10 8 2<br>1 2 3 5 6 7 8 9<br>3 5</p>
</blockquote>
<p>样例2</p>
<blockquote>
<p>3 2 1<br>1 2<br>3</p>
</blockquote>
<h3 id="样例输出-1"><a href="#样例输出-1" class="headerlink" title="样例输出"></a>样例输出</h3><p>样例1</p>
<blockquote>
<p>2</p>
</blockquote>
<p>样例2</p>
<blockquote>
<p>-1</p>
</blockquote>
<h2 id="提示"><a href="#提示" class="headerlink" title="提示"></a>提示</h2><p>【数据规模】<br>对于50%的数据，1≤N≤20，1≤k≤5，1≤m≤3;<br>对于另外20%的数据，1≤N≤10000，1≤k≤5,1≤m≤30;<br>对于100%的数据，1≤N≤10000，1≤k≤10，1≤m≤100。</p>
<h2 id="题解-1"><a href="#题解-1" class="headerlink" title="题解"></a>题解</h2><p>第一眼看成反转问题，贪心想了好久没有结果。其实是<strong>差分序列+图论建模+bfs+状压DP</strong><br>先把目标序列a变成模2意义下的差分序列b。<br>差分序列b中的元素1最多2k个。题目变成了<strong>把b中的所有元素全变成0的最小操作数</strong><br>每次操作相当于把b[i]和b[size[j]+i]取反：</p>
<ol>
<li>当两个值都是0时，这个操作是多余的</li>
<li>有一个0，一个1时，相当于把1移到0所在的位置</li>
<li>两个都是1时，相当于两个元素1匹配，抵消了。</li>
</ol>
<p>所以b中的所有元素1都要<strong>两两匹配</strong>，把所有元素1作为顶点建图，边权可以用bfs计算出来（g[i,j]=把i移到j的最小操作数）。<br>然后题目就抽象为<strong>一个完全图上的最小权匹配</strong>。<br>因为<strong>顶点数2k≤20</strong>，可以状压DP解决：</p>
<span>$f[S]=min\{f[S-lowbit-j]+g[lowbit,j]\ \ |\ \ j\ \in\ S-lowbit\}$</span><!-- Has MathJax -->
<p>当然闲的蛋疼可以写带花树。</p>
<dir style="display:none"><a href="/2016/09/04/欢乐赛-2014-5-31/password.pas" title="复制代码">复制代码</a></dir>

<p>```delphi password.pas<br>uses math;<br>type int=longint;<br>const<br>    inf=100000000;<br>    maxn=1 shl 20;<br>var<br>    n,k,m,i,j,sz,ans:int;<br>    a,b:array[0..10010] of int;<br>    s:array[0..110] of int;<br>    g:array[0..21,0..21] of int;<br>    f:array[0..maxn+10] of int;</p>
<p>procedure bfs(x:int);<br>var<br>    h,t,i,v,u:int;<br>    q,d:array[0..10010] of int;<br>begin<br>    filldword(d,sizeof(d) div 4,inf);<br>    h:=1;t:=2;d[x]:=0;q[h]:=x;<br>    while h&lt;&gt;t do begin<br>        v:=q[h];<br>        for i:=1 to m do<br>            for j:=-1 to 1 do begin<br>                u:=v+s[i]*j;<br>                if (u<1) or="" (u="">n) then continue;<br>                if d[u]&lt;&gt;inf then continue;<br>                d[u]:=d[v]+1;q[t]:=u;<br>                inc(t);if t&gt;10010 then t:=0;<br>            end;<br>        inc(h);if h&gt;10010 then h:=0;<br>    end;<br>    for i:=1 to n do<br>        if b[i]&lt;&gt;0 then<br>            g[b[x],b[i]]:=d[i];<br>end;</1)></p>
<p>function dp(s:int):int;<br>var x,li,i,lj,j:int;<br>begin<br>    if s=0 then exit(0);<br>    if f[s]&lt;&gt;-1 then exit(f[s]);<br>    f[s]:=inf;<br>    li:=s and (-s);<br>    i:=round(ln(li)/ln(2)+1);<br>    x:=s-li;<br>    while x&lt;&gt;0 do begin<br>        lj:=x and (-x);<br>        j:=round(ln(lj)/ln(2)+1);<br>        if g[i,j]&lt;&gt;inf then<br>            f[s]:=min(f[s],dp(s-li-lj)+g[i,j]);<br>        dec(x,lj);<br>    end;<br>    exit(f[s]);<br>end;</p>
<p>begin<br>    assign(input,’password.in’);reset(input);<br>    assign(output,’password.out’);rewrite(output);<br>    read(n,k,m);<br>    for i:=1 to k do begin<br>        read(j);<br>        a[j]:=1;<br>    end;<br>    for i:=1 to m do read(s[i]);<br>    inc(n);sz:=0;<br>    for i:=n downto 1 do b[i]:=a[i] xor a[i-1];<br>    for i:=1 to n do<br>        if b[i]=1 then begin<br>            inc(sz);b[i]:=sz;<br>        end;<br>    for i:=1 to n do<br>        if b[i]&lt;&gt;0 then bfs(i);<br>    //f[S]=min{f[S-lowbit-(1 shl j)]+d[lb,j]}<br>    fillchar(f,sizeof(f),255);<br>    ans:=dp(1 shl sz-1);<br>    if ans=inf then write(-1) else write(ans);<br>    close(input);close(output);<br>end.<br>```</p>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[NOIP模拟赛 2014-5-24]]></title>
      <url>https://cothrax.github.io/2016/09/03/NOIP%E6%A8%A1%E6%8B%9F%E8%B5%9B-2014-5-24/</url>
      <content type="html"><![CDATA[<p>三道USACO的题目</p>
<table>
<thead>
<tr>
<th style="text-align:center">题目名</th>
<th style="text-align:center">护花</th>
<th style="text-align:center">修建草坪</th>
<th style="text-align:center">虫洞</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">源文件</td>
<td style="text-align:center">flower.cpp/c/pas</td>
<td style="text-align:center">mowlawn.cpp/c/pas</td>
<td style="text-align:center">wormhole.cpp/c/pas</td>
</tr>
<tr>
<td style="text-align:center">输入文件</td>
<td style="text-align:center">flower.in</td>
<td style="text-align:center">mowlawn.in</td>
<td style="text-align:center">wormhole.in</td>
</tr>
<tr>
<td style="text-align:center">输出文件</td>
<td style="text-align:center">flower.out</td>
<td style="text-align:center">mowlawn.out</td>
<td style="text-align:center">Wormhole.out</td>
</tr>
<tr>
<td style="text-align:center">时间限制</td>
<td style="text-align:center">1000MS</td>
<td style="text-align:center">1000MS</td>
<td style="text-align:center">1000MS</td>
</tr>
<tr>
<td style="text-align:center">内存限制</td>
<td style="text-align:center">256MB</td>
<td style="text-align:center">256MB</td>
<td style="text-align:center">256MB</td>
</tr>
<tr>
<td style="text-align:center">测试点</td>
<td style="text-align:center">10</td>
<td style="text-align:center">10</td>
<td style="text-align:center">10</td>
</tr>
<tr>
<td style="text-align:center">测试点分值</td>
<td style="text-align:center">10</td>
<td style="text-align:center">10</td>
<td style="text-align:center">10</td>
</tr>
</tbody>
</table>
<h1 id="P1-护花"><a href="#P1-护花" class="headerlink" title="P1 护花"></a>P1 护花</h1><p>约翰留下他的N(N&lt;=100000)只奶牛上山采木．他离开的时候，她们像往常一样悠闲地在草场里吃草．可是，当他回来的时候，他看到了一幕惨剧：牛们正躲在他的花园里，啃食着他心爱的美丽花朵！为了使接下来花朵的损失最小，约翰赶紧采取行动，把牛们送回牛棚． 牛们从1到N编号．第i只牛所在的位置距离牛棚Ti(1≤Ti≤2000000)分钟的路程，而在约翰开始送她回牛棚之前，她每分钟会啃食Di(1≤Di≤100)朵鲜花．无论多么努力，约翰一次只能送一只牛回棚．而运送第第i只牛事实上需要2Ti分钟，因为来回都需要时间．<br>写一个程序来决定约翰运送奶牛的顺序，使最终被吞食的花朵数量最小．<br><a id="more"></a></p>
<h2 id="格式"><a href="#格式" class="headerlink" title="格式"></a>格式</h2><h3 id="输入格式"><a href="#输入格式" class="headerlink" title="输入格式"></a>输入格式</h3><p>第1行输入N，之后N行每行输入两个整数Ti和Di</p>
<h3 id="输出格式"><a href="#输出格式" class="headerlink" title="输出格式"></a>输出格式</h3><p>一个整数，表示最小数量的花朵被吞食</p>
<h2 id="样例"><a href="#样例" class="headerlink" title="样例"></a>样例</h2><h3 id="样例输入"><a href="#样例输入" class="headerlink" title="样例输入"></a>样例输入</h3><blockquote>
<p>6<br>3 1<br>2 5<br>2 3<br>3 2<br>4 1<br>1 6</p>
</blockquote>
<h3 id="样例输出"><a href="#样例输出" class="headerlink" title="样例输出"></a>样例输出</h3><blockquote>
<p>86</p>
</blockquote>
<h2 id="提示​"><a href="#提示​" class="headerlink" title="提示​"></a>提示​</h2><p>约翰用6，2，3，4，1，5的顺序来运送他的奶牛 </p>
<h2 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h2><p>贪心：考虑牛i和j，如果满足：$$2\times d[i]\cdot t[j]&gt;2\times d[j]\cdot t[i]$$，那么先搬走牛i<br>按这个二元关系qsort就好了。</p>
<dir style="display:none"><a href="/2016/09/03/NOIP模拟赛-2014-5-24/flower.pas" title="复制代码">复制代码</a></dir>

<p>```delphi flower.pas<br>type int=longint;<br>var<br>    a:array[0..100010,0..1] of qword; //0:t;1:d<br>    n,i:int;ans,sum:qword;</p>
<p>function com(i,j:int):boolean;<br>begin com:=a[j,0]<em>a[i,1]&gt;a[i,0]</em>a[j,1] end;</p>
<p>procedure swap(var a,b:qword);<br>var tmp:int;<br>begin tmp:=a;a:=b;b:=tmp end;</p>
<p>procedure qsort(b,e:int);<br>var i,j:int;<br>begin<br>    i:=b;j:=e;a[0]:=a[random(e-b)+b];<br>    repeat<br>        while com(i,0) do inc(i);<br>        while com(0,j) do dec(j);<br>        if i&lt;=j then begin<br>            swap(a[i,0],a[j,0]);swap(a[i,1],a[j,1]);<br>            inc(i);dec(j);<br>        end;<br>    until i&gt;j;<br>    if i&lt;e then qsort(i,e);<br>    if b&lt;j then qsort(b,j);<br>end;</p>
<p>begin<br>    assign(input,’flower.in’);reset(input);<br>    assign(output,’flower.out’);rewrite(output);<br>    read(n);<br>    for i:=1 to n do begin<br>        read(a[i,0],a[i,1]);<br>        a[i,0]:=a[i,0]<em>2;<br>    end;<br>    qsort(1,n);<br>    sum:=0;ans:=0;<br>    for i:=1 to n do sum:=sum+a[i,1];<br>    for i:=1 to n do begin<br>        sum:=sum-a[i,1];<br>        ans:=ans+sum</em>a[i,0];<br>    end;<br>    write(ans);<br>    close(input);close(output);<br>end.</p>
<pre><code>
# P2 修剪草坪
在一年前赢得了小镇的最佳草坪比赛后，FJ变得很懒，再也没有修剪过草坪。现在，新一轮的最佳草坪比赛又开始了，FJ希望能够再次夺冠。
然而，FJ的草坪非常脏乱，因此，FJ只能够让他的奶牛来完成这项工作。FJ有N
(1 &lt;= N &lt;= 100,000)只排成一排的奶牛，编号为1...N。每只奶牛的效率是不同的，奶牛i的效率为E_i(0 &lt;= E_i &lt;= 1,000,000,000)。
靠近的奶牛们很熟悉，因此，如果FJ安排超过K（1&lt;=K&lt;=N）只连续的奶牛，那么，这些奶牛就会罢工去开派对:)。
因此，现在FJ需要你的帮助，计算FJ可以得到的最大效率，并且该方案中没有连续的超过K只奶牛。

## 格式
### 输入格式
* 第一行：空格隔开的两个整数N和K
* 第二到N+1行：第i+1行有一个整数E_i

### 输出格式
* 第一行：一个值，表示FJ可以得到的最大的效率值。
&lt;!--more--&gt;

## 样例
### 样例输入
&gt;5 2
1
2
3
4
5

### 样例输出
&gt;86

## 提示​
输入解释：
FJ有5只奶牛，他们的效率为1，2，3，4，5。他们希望选取效率总和最大的奶牛，但是他不能选取超过2只连续的奶牛
【样例输出】
12
FJ可以选择出了第三只以外的其他奶牛，总的效率为1+2+4+5=12。

## 题解
**划分dp**很容易想：
f[i]前i头牛的最大值，sum[i]前缀和
<span>$f[i]=max\{ f[j-1]+sum[i]-sum[j] \ \ |\ \ i-j\leq m\}$</span><!-- Has MathJax -->

注意预处理i=1..m的$f[i]=sum[i]$
复杂度$O(N^2)$，n有些大，我们变形：
<span>$f[i]=max\{f[j-1]-sum[j]\}+sum[i]$</span><!-- Has MathJax -->

这样用递减的**单调队列**维护值对$(i,f[i-1]-sum[i])$即可

&lt;dir style=&quot;display:none&quot;&gt;<a href="/2016/09/03/NOIP模拟赛-2014-5-24/mowlawn.pas" title="复制代码">复制代码</a>&lt;/dir&gt;

```delphi mowlawn.pas
type int=longint;
var 
    n,m,i,h,t:int;
    a,sum,f:array[0..100010] of int64;
    q:array[0..200010,0..1] of int64;

procedure push(i,x:int64);
begin
    while (h&lt;=t) and (q[t,1]&lt;=x) do dec(t);
    inc(t);q[t,0]:=i;q[t,1]:=x;
end;

procedure pop(i:int64);
begin
    while (h&lt;=t) and (i-q[h,0]&gt;m) do inc(h);
end;

begin
    assign(input,&#39;mowlawn.in&#39;);reset(input);
    assign(output,&#39;mowlawn.out&#39;);rewrite(output);
    read(n,m);
    for i:=1 to n do read(a[i]);
    sum[0]:=0;
    for i:=1 to n do sum[i]:=sum[i-1]+a[i];
    h:=1;t:=0;
    for i:=1 to m do begin
        f[i]:=sum[i];
        push(i,f[i-1]-sum[i]);
    end;
    //f[i]:=max{f[j-1]-sum[j]}+sum[i]
    for i:=m+1 to n do begin
        push(i,f[i-1]-sum[i]);
        pop(i);
        f[i]:=q[h,1]+sum[i];
    end;
    write(f[i]);
    close(input);close(output);
end.
</code></pre><h1 id="P3-虫洞"><a href="#P3-虫洞" class="headerlink" title="P3 虫洞"></a>P3 虫洞</h1><p>John在他的农场中闲逛时发现了许多虫洞。虫洞可以看作一条十分奇特的有向边，并可以使你返回到过去的一个时刻（相对你进入虫洞之前）。John的每个农场有M条小路（无向边）连接着N （从1..N标号）块地，并有W个虫洞（有向边）。其中1&lt;=N&lt;=500,1&lt;=M&lt;=2500,1&lt;=W&lt;=200。 现在John想借助这些虫洞来回到过去（出发时刻之前），请你告诉他能办到吗。 John将向你提供F(1&lt;=F&lt;=5)个农场的地图。没有小路会耗费你超过10000秒的时间，当然也没有虫洞回帮你回到超过10000秒以前。</p>
<h2 id="格式-1"><a href="#格式-1" class="headerlink" title="格式"></a>格式</h2><h3 id="输入格式-1"><a href="#输入格式-1" class="headerlink" title="输入格式"></a>输入格式</h3><ul>
<li>Line 1: 一个整数 F, 表示农场个数。</li>
<li>Line 1 of each farm: 三个整数 N, M, W。</li>
<li>Lines 2..M+1 of each farm: 三个数（S, E, T）。表示在标号为S的地与标号为E的地中间有一条用时T秒的小路。</li>
<li>Lines M+2..M+W+1 of each farm: 三个数（S, E, T）。表示在标号为S的地与标号为E的地中间有一条可以使John到达T秒前的虫洞。</li>
</ul>
<h3 id="输出格式-1"><a href="#输出格式-1" class="headerlink" title="输出格式"></a>输出格式</h3><ul>
<li>Lines 1..F: 如果John能在这个农场实现他的目标，输出”YES”,否则输出”NO”。<!--more-->
</li>
</ul>
<h2 id="样例-1"><a href="#样例-1" class="headerlink" title="样例"></a>样例</h2><h3 id="样例输入-1"><a href="#样例输入-1" class="headerlink" title="样例输入"></a>样例输入</h3><blockquote>
<p>2<br>3 3 1<br>1 2 2<br>1 3 4<br>2 3 1<br>3 1 3<br>3 2 1<br>1 2 3<br>2 3 4<br>3 1 8</p>
</blockquote>
<h3 id="样例输出-1"><a href="#样例输出-1" class="headerlink" title="样例输出"></a>样例输出</h3><blockquote>
<p>NO<br>YES</p>
</blockquote>
<h2 id="题解-1"><a href="#题解-1" class="headerlink" title="题解"></a>题解</h2><p>spfa判个负环就可以了，注意审题，小路是无向边。</p>
<dir style="display:none"><a href="/2016/09/03/NOIP模拟赛-2014-5-24/wormhole.pas" title="复制代码">复制代码</a></dir>

<p>```delphi wormhole.pas<br>type<br>    int=longint;<br>    edge=record t,w,next:int end;<br>var<br>    g:array[0..6010] of edge;<br>    head:array[0..510] of int;<br>    n,m,k,t,i,f0,t0,w0:int;</p>
<p>procedure add(f,t,w:int);<br>var m:int;<br>begin<br>    inc(head[0]);m:=head[0];<br>    g[m].t:=t;g[m].w:=w;<br>    g[m].next:=head[f];head[f]:=m;<br>end;</p>
<p>function spfa():boolean;<br>var<br>    i,v,u,h,t:int;<br>    cnt,q,d:array[0..510] of int;<br>    inq:array[0..510] of boolean;<br>begin<br>    fillchar(d,sizeof(d),0);<br>    filldword(cnt,sizeof(cnt) div 4,1);<br>    fillchar(inq,sizeof(inq),true);<br>    for i:=1 to n do q[i]:=i;<br>    h:=1;t:=n+1;<br>    while h&lt;&gt;t do begin<br>        v:=q[h];<br>        i:=head[v];<br>        while i&lt;&gt;0 do begin<br>            u:=g[i].t;<br>            if d[u]&gt;d[v]+g[i].w then begin<br>                d[u]:=d[v]+g[i].w;<br>                if not inq[u] then begin<br>                    inc(cnt[u]);<br>                    if cnt[u]&gt;n then exit(true);<br>                    q[t]:=u;inq[u]:=true;<br>                    inc(t);if t&gt;510 then t:=0;<br>                end;<br>            end;<br>            i:=g[i].next;<br>        end;<br>        inc(h);if h&gt;510 then h:=0;<br>        inq[v]:=false;<br>    end;<br>    spfa:=false;<br>end;</p>
<p>begin<br>    assign(input,’wormhole.in’);reset(input);<br>    assign(output,’wormhole.out’);rewrite(output);<br>    read(t);<br>    repeat<br>        fillchar(head,sizeof(head),0);<br>        read(n,m,k);<br>        for i:=1 to m do begin<br>            read(f0,t0,w0);<br>            add(f0,t0,w0);add(t0,f0,w0);<br>        end;<br>        for i:=1 to k do begin<br>            read(f0,t0,w0);add(f0,t0,-w0);<br>        end;<br>        if spfa then writeln(‘YES’) else writeln(‘NO’);<br>        dec(t);<br>    until t=0;<br>    close(input);close(output);<br>end.<br>```</p>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[NOIP模拟赛 czy的后宫]]></title>
      <url>https://cothrax.github.io/2016/09/03/NOIP%E6%A8%A1%E6%8B%9F%E8%B5%9B-czy%E7%9A%84%E5%90%8E%E5%AE%AB/</url>
      <content type="html"><![CDATA[<h2 id="描述"><a href="#描述" class="headerlink" title="描述"></a>描述</h2><p>czy要妥善安排他的后宫，他想在机房摆一群妹子，一共有n个位置排成一排，每个位置可以摆妹子也可以不摆妹子。有些类型妹子如果摆在相邻的位置（隔着一个空的位置不算相邻），就不好看了。假定每种妹子数量无限，求摆妹子的方案数。</p>
<h2 id="格式"><a href="#格式" class="headerlink" title="格式"></a>格式</h2><h3 id="输入格式"><a href="#输入格式" class="headerlink" title="输入格式"></a>输入格式</h3><p>输入有m+1行，第一行有两个用空格隔开的正整数n、m，m表示妹子的种类数。接下来的m行，每行有m个字符1或0,若第i行第j列为1，则表示第i种妹子第j种妹子不能排在相邻的位置，输入保证对称。（提示：同一种妹子可能不能排在相邻位置）。</p>
<h3 id="输出格式"><a href="#输出格式" class="headerlink" title="输出格式"></a>输出格式</h3><p>输出只有一个整数，为方案数（这个数字可能很大，请输出方案数除以1000000007的余数。</p>
<a id="more"></a>
<h2 id="样例"><a href="#样例" class="headerlink" title="样例"></a>样例</h2><h3 id="样例输入"><a href="#样例输入" class="headerlink" title="样例输入"></a>样例输入</h3><blockquote>
<p>2 2<br>01<br>10</p>
</blockquote>
<h3 id="样例输出"><a href="#样例输出" class="headerlink" title="样例输出"></a>样例输出</h3><blockquote>
<p>7</p>
</blockquote>
<h2 id="提示​"><a href="#提示​" class="headerlink" title="提示​"></a>提示​</h2><p>【样例说明】<br>七种方案为(空，空)、（空，1）、（1、空）、（2、空）、（空、2）、（1,1）、（2,2）。<br>【数据范围】<br>20%的数据，1＜n≤5,0＜m≤10。<br>60%的数据，1＜n≤200,0＜m≤100。<br>100%的数据，1＜n≤1000000000，0＜m≤100。</p>
<h2 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h2><p>DP：f[i,j]第i个以j结尾的方案数<br>$f[i,j]=\sum f[i-1,k]\ \ |\ \ a[j,k]=0$<br>n有点大，递推矩阵快速幂，注意不放的情况</p>
<dir style="display:none"><a href="/2016/09/03/NOIP模拟赛-czy的后宫/harem.pas" title="复制代码">复制代码</a></dir>

<p>```delphi harem.pas<br>type<br>    int=longint;<br>    mat=array[0..101,0..101] of qword;<br>const z:qword=1000000007;<br>var<br>    m,i,j:int;<br>    n:int64;ans:qword;<br>    a:mat;c:char;</p>
<p>function mul(a,b:mat):mat;<br>var i,j,k:int;<br>begin<br>    fillchar(mul,sizeof(mul),0);<br>    for i:=0 to m do<br>        for j:=0 to m do<br>            for k:=0 to m do<br>                mul[i,j]:=(mul[i,j]+a[i,k]*b[k,j]) mod z;<br>end;</p>
<p>function mpow(a:mat;p:int64):mat;<br>var i:int;<br>begin<br>    fillchar(mpow,sizeof(mpow),0);<br>    for i:=0 to m do mpow[i,i]:=1;<br>    while p&gt;0 do begin<br>        if p and 1=1 then mpow:=mul(mpow,a);<br>        a:=mul(a,a);<br>        p:=p shr 1;<br>    end;<br>end;</p>
<p>begin<br>    assign(input,’harem.in’);reset(input);<br>    assign(output,’harem.out’);rewrite(output);<br>    readln(n,m);<br>    for i:=1 to m do<br>        for j:=1 to m do begin<br>            read(c);<br>            a[i,j]:=1-ord(c)+ord(‘0’);<br>            if j=m then readln;<br>        end;<br>    for i:=0 to m do begin<br>        a[0,i]:=1;a[i,0]:=1;<br>    end;<br>    a:=mpow(a,n);<br>    ans:=0;<br>    for i:=0 to m do<br>        ans:=(ans+a[i,0]) mod z;<br>    write(ans);<br>    close(input);close(output);<br>end.<br>```</p>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[NOIP模拟赛 mex]]></title>
      <url>https://cothrax.github.io/2016/09/02/NOIP%E6%A8%A1%E6%8B%9F%E8%B5%9B-mex/</url>
      <content type="html"><![CDATA[<h2 id="描述"><a href="#描述" class="headerlink" title="描述"></a>描述</h2><img src="/2016/09/02/NOIP模拟赛-mex/1.png" alt="描述" title="描述">
<h2 id="格式"><a href="#格式" class="headerlink" title="格式"></a>格式</h2><h3 id="输入格式"><a href="#输入格式" class="headerlink" title="输入格式"></a>输入格式</h3><img src="/2016/09/02/NOIP模拟赛-mex/2.png" alt="输入" title="输入">
<h3 id="输出格式"><a href="#输出格式" class="headerlink" title="输出格式"></a>输出格式</h3><img src="/2016/09/02/NOIP模拟赛-mex/3.png" alt="输出" title="输出">
<a id="more"></a>
<h2 id="样例"><a href="#样例" class="headerlink" title="样例"></a>样例</h2><h3 id="样例输入"><a href="#样例输入" class="headerlink" title="样例输入"></a>样例输入</h3><blockquote>
<p>7 5<br>0 2 1 0 1 3 2<br>1 3<br>2 3<br>1 4<br>3 6<br>2 7</p>
</blockquote>
<h3 id="样例输出"><a href="#样例输出" class="headerlink" title="样例输出"></a>样例输出</h3><blockquote>
<p>3<br>0<br>3<br>2<br>4</p>
</blockquote>
<h2 id="提示​"><a href="#提示​" class="headerlink" title="提示​"></a>提示​</h2><img src="/2016/09/02/NOIP模拟赛-mex/4.png" alt="提示" title="提示">
<h2 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h2><p>离线+线段树<br>用线段树维护前缀的mex值，离线排序处理查询。</p>
<dir style="display:none"><a href="/2016/09/02/NOIP模拟赛-mex/mex.pas" title="复制代码">复制代码</a></dir>


<p>```delphi mex.pas<br>uses math;<br>type int=longint;<br>const inf=100000000;<br>var<br>    a,head,next,mex,ans:array[0..200010] of int;<br>    flag:array[0..200010] of boolean;<br>    q:array[0..200010,0..2] of int;<br>    sgt:array[0..800010] of int;<br>    n,m,i,j:int;</p>
<p>procedure swap(var a,b:int);<br>var tmp:int;<br>begin tmp:=a;a:=b;b:=tmp end; </p>
<p>procedure qsort(b,e:int);<br>var x,i,j:int;<br>begin<br>    i:=b;j:=e;x:=q[random(e-b)+b,0];<br>    repeat<br>        while q[i,0]<x do="" inc(i);="" while="" q[j,0]="">x do dec(j);<br>        if i&lt;=j then begin<br>            swap(q[i,0],q[j,0]);<br>            swap(q[i,1],q[j,1]);<br>            swap(q[i,2],q[j,2]);<br>            inc(i);dec(j);<br>        end;<br>    until i&gt;j;<br>    if i&lt;e then qsort(i,e);<br>    if b&lt;j then qsort(b,j);<br>end;</x></p>
<p>procedure build(i,b,e:int);<br>var mid:int;<br>begin<br>    if b=e then begin sgt[i]:=mex[b];exit end;<br>    sgt[i]:=inf;<br>    mid:=(b+e) shr 1;<br>    build(i<em>2,b,mid);<br>    build(i</em>2+1,mid+1,e);<br>end;</p>
<p>procedure pushdown(i,b,e:int);<br>begin<br>    if b&lt;e then begin<br>        sgt[i<em>2]:=min(sgt[i</em>2],sgt[i]);<br>        sgt[i<em>2+1]:=min(sgt[i</em>2+1],sgt[i]);<br>    end;<br>    sgt[i]:=inf;<br>end;</p>
<p>procedure update(i,b,e,l,r,x:int);<br>var mid:int;<br>begin<br>    if (r<b) or="" (e<l)="" then="" exit;="" if="" (l<="b)" and="" (e<="r)" begin="" sgt[i]:="min(sgt[i],x);" end;="" sgt[i]<="">inf then pushdown(i,b,e);<br>    mid:=(b+e) shr 1;<br>    update(i<em>2,b,mid,l,r,x);<br>    update(i</em>2+1,mid+1,e,l,r,x);<br>end;</b)></p>
<p>function query(i,b,e,x:int):int;<br>var mid:int;<br>begin<br>    if b=e then exit(sgt[i]);<br>    if sgt[i]&lt;&gt;inf then pushdown(i,b,e);<br>    mid:=(b+e) shr 1;<br>    if x&lt;=mid then query:=query(i<em>2,b,mid,x)<br>    else query:=query(i</em>2+1,mid+1,e,x);<br>end;</p>
<p>begin<br>    assign(input,’mex.in’);reset(input);<br>    assign(output,’mex.out’);rewrite(output);<br>    read(n,m);<br>    for i:=1 to n do read(a[i]);<br>    for i:=1 to m do begin<br>        read(q[i,0],q[i,1]);<br>        q[i,2]:=i;<br>    end;<br>    j:=0;<br>    fillchar(flag,sizeof(flag),false);<br>    for i:=1 to n do begin<br>        flag[a[i]]:=true;<br>        while flag[j] do inc(j);<br>        mex[i]:=j;<br>    end;<br>    fillchar(head,sizeof(head),0);<br>    for i:=n downto 1 do begin<br>        next[i]:=head[a[i]];<br>        head[a[i]]:=i;<br>    end;<br>    for i:=1 to n do if next[i]=0 then next[i]:=n+1;<br>    qsort(1,m);<br>    build(1,1,n);<br>    j:=1;<br>    for i:=1 to m do begin<br>        while j&lt;q[i,0] do begin<br>            update(1,1,n,j,next[j]-1,a[j]);<br>            inc(j);<br>        end;<br>        ans[q[i,2]]:=query(1,1,n,q[i,1]);<br>    end;<br>    for i:=1 to m do writeln(ans[i]);<br>    close(input);close(output);<br>end.<br>```</p>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[NOIP模拟赛 虫洞]]></title>
      <url>https://cothrax.github.io/2016/09/01/NOIP%E6%A8%A1%E6%8B%9F%E8%B5%9B-%E8%99%AB%E6%B4%9E/</url>
      <content type="html"><![CDATA[<h2 id="描述"><a href="#描述" class="headerlink" title="描述"></a>描述</h2><p>N个虫洞，M条单向跃迁路径。从一个虫洞沿跃迁路径到另一个虫洞需要消耗一定量的燃料和1单位时间。虫洞有白洞和黑洞之分。设一条跃迁路径两端的虫洞质量差为delta。</p>
<ol>
<li>从白洞跃迁到黑洞，消耗的燃料值减少delta，若该条路径消耗的燃料值变为负数的话，取为0。</li>
<li>从黑洞跃迁到白洞，消耗的燃料值增加delta。</li>
<li>路径两端均为黑洞或白洞，消耗的燃料值不变化。</li>
</ol>
<p>作为压轴题，自然不会是如此简单的最短路问题，所以每过1单位时间黑洞变为白洞，白洞变为黑洞。在飞行过程中，可以选择在一个虫洞停留1个单位时间，如果当前为白洞，则不消耗燃料，否则消耗s[i]的燃料。现在请你求出从虫洞1到N最少的燃料消耗，保证一定存在1到N的路线。</p>
<h2 id="格式"><a href="#格式" class="headerlink" title="格式"></a>格式</h2><h3 id="输入格式"><a href="#输入格式" class="headerlink" title="输入格式"></a>输入格式</h3><p>第1行：2个正整数N,M<br>第2行：N个整数，第i个为0表示虫洞i开始时为白洞，1表示黑洞。<br>第3行：N个整数，第i个数表示虫洞i的质量w[i]。<br>第4行：N个整数，第i个数表示在虫洞i停留消耗的燃料s[i]。<br>第5..M+4行：每行3个整数，u,v,k，表示在没有影响的情况下，从虫洞u到虫洞v需要消耗燃料k。</p>
<h3 id="输出格式"><a href="#输出格式" class="headerlink" title="输出格式"></a>输出格式</h3><p>一个整数，表示最少的燃料消耗。<br><a id="more"></a></p>
<h2 id="样例"><a href="#样例" class="headerlink" title="样例"></a>样例</h2><h3 id="样例输入"><a href="#样例输入" class="headerlink" title="样例输入"></a>样例输入</h3><blockquote>
<p>4 5<br>1 0 1 0<br>10 10 100 10<br>5 20 15 10<br>1 2 30<br>2 3 40<br>1 3 20<br>1 4 200<br>3 4 200</p>
</blockquote>
<h3 id="样例输出"><a href="#样例输出" class="headerlink" title="样例输出"></a>样例输出</h3><blockquote>
<p>130</p>
</blockquote>
<h2 id="提示​"><a href="#提示​" class="headerlink" title="提示​"></a>提示​</h2><p>【数据范围】<br>对于30%的数据： 1&lt;=N&lt;=100,1&lt;=M&lt;=500<br>对于60%的数据： 1&lt;=N&lt;=1000,1&lt;=M&lt;=5000<br>对于100%的数据： 1&lt;=N&lt;=5000，1&lt;=M&lt;=30000<br>其中20%的数据为1&lt;=N&lt;=3000的链<br>1&lt;=u,v&lt;=N, 1&lt;=k,w[i],s[i]&lt;=200<br>【样例说明】<br>按照1-&gt;3-&gt;4的路线。</p>
<h2 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h2><p>拆点跑最短路</p>
<dir style="display:none"><a href="/2016/09/01/NOIP模拟赛-虫洞/holes0.pas" title="复制代码">复制代码</a></dir>

<p>```delphi holes0.pas<br>uses math;<br>type<br>    int=longint;<br>    edge=record t,w,next:int end;<br>const inf=100000000;<br>var<br>    g:array[0..150010] of edge;<br>    head,s,w,a,q,dist:array[0..10010] of int;<br>    inq:array[0..10010] of boolean;<br>    n,m,i,f0,t0,w0,d:int;</p>
<p>procedure add(f,t,w:int);<br>var m:int;<br>begin<br>    inc(head[0]);m:=head[0];<br>    g[m].t:=t;g[m].w:=w;<br>    g[m].next:=head[f];head[f]:=m;<br>end;</p>
<p>procedure spfa(x:int);<br>var u,v,i,h,t:int;<br>begin<br>    filldword(dist,sizeof(dist) div 4,inf);<br>    fillchar(inq,sizeof(inq),false);<br>    h:=1;t:=2;q[h]:=x;inq[x]:=true;dist[x]:=0;<br>    while h&lt;&gt;t do begin<br>        v:=q[h];<br>        i:=head[v];<br>        while i&lt;&gt;0 do begin<br>            u:=g[i].t;<br>            if dist[v]+g[i].w<dist[u] then="" begin="" dist[u]:="dist[v]+g[i].w;" if="" not="" inq[u]="" inq[u]:="true;q[t]:=u;" inc(t);if="" t="">10010 then t:=0;<br>                end;<br>            end;<br>            i:=g[i].next;<br>        end;<br>        inc(h);if h&gt;10010 then h:=0;<br>        inq[v]:=false;<br>    end;<br>end;</dist[u]></p>
<p>begin<br>    assign(input,’holes.in’);reset(input);<br>    assign(output,’holes.out’);rewrite(output);<br>    read(n,m);<br>    for i:=1 to n do read(a[i]);<br>    for i:=1 to n do read(w[i]);<br>    //i white i+n black<br>    for i:=1 to n do begin<br>        read(s[i]);<br>        add(i,i+n,0);<br>        add(i+n,i,s[i]);<br>    end;<br>    for i:=1 to m do begin<br>        read(f0,t0,w0);<br>        if a[f0]=a[t0] then begin<br>            add(f0,t0+n,w0);<br>            add(f0+n,t0,w0);<br>        end else begin<br>            d:=abs(w[f0]-w[t0]);<br>            add(f0,t0,max(w0-d,0));<br>            add(f0+n,t0+n,w0+d);<br>        end;<br>    end;<br>    spfa(a[1]<em>n+1);<br>    write(min(dist[n],dist[2</em>n]));<br>    close(input);close(output);<br>end.<br>```</p>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[NOIP模拟赛 2014-3-15]]></title>
      <url>https://cothrax.github.io/2016/08/30/NOIP%E6%A8%A1%E6%8B%9F%E8%B5%9B-2014-3-15/</url>
      <content type="html"><![CDATA[<table>
<thead>
<tr>
<th>题目名</th>
<th>高级打字机</th>
<th>不等数列</th>
<th>经营与开发</th>
</tr>
</thead>
<tbody>
<tr>
<td>源文件</td>
<td>type.cpp/c/pas</td>
<td>num.cpp/c/pas</td>
<td>exploit.cpp/c/pas</td>
</tr>
<tr>
<td>输入文件</td>
<td>type.in</td>
<td>num.in</td>
<td>exploit.in</td>
</tr>
<tr>
<td>输出文件</td>
<td>type.out</td>
<td>num.out</td>
<td>exploit.out</td>
</tr>
<tr>
<td>时间限制</td>
<td>1000MS</td>
<td>1000MS</td>
<td>1000MS</td>
</tr>
<tr>
<td>内存限制</td>
<td>256MB</td>
<td>256MB</td>
<td>256MB</td>
</tr>
<tr>
<td>测试点</td>
<td>5+(5)</td>
<td>10</td>
<td>10</td>
</tr>
<tr>
<td>测试点分值</td>
<td>20</td>
<td>10</td>
<td>10</td>
</tr>
</tbody>
</table>
<blockquote>
<p>这套题来源于：<a href="http://hzwer.com/7602.html" target="_blank" rel="external">http://hzwer.com/7602.html</a></p>
</blockquote>
<h1 id="Problem-1-高级打字机"><a href="#Problem-1-高级打字机" class="headerlink" title="Problem 1 高级打字机"></a>Problem 1 高级打字机</h1><p>早苗入手了最新的高级打字机。最新款自然有着与以往不同的功能，那就是它具备撤销功能，厉害吧。<br>请为这种高级打字机设计一个程序，支持如下3种操作：</p>
<ol>
<li>T x：在文章末尾打下一个小写字母x。(type操作)</li>
<li>U x：撤销最后的x次修改操作。（Undo操作）<br>（注意Query操作并不算修改操作）</li>
<li>Q x：询问当前文章中第x个字母并输出。（Query操作）</li>
</ol>
<p>文章一开始可以视为空串。<br><a id="more"></a></p>
<h2 id="格式"><a href="#格式" class="headerlink" title="格式"></a>格式</h2><h3 id="输入格式"><a href="#输入格式" class="headerlink" title="输入格式"></a>输入格式</h3><p>第1行：一个整数n，表示操作数量。<br>以下n行，每行一个命令。保证输入的命令合法。</p>
<h3 id="输出格式"><a href="#输出格式" class="headerlink" title="输出格式"></a>输出格式</h3><p>每行输出一个字母，表示Query操作的答案。</p>
<h2 id="样例"><a href="#样例" class="headerlink" title="样例"></a>样例</h2><h3 id="样例输入"><a href="#样例输入" class="headerlink" title="样例输入"></a>样例输入</h3><blockquote>
<p>7<br>T a<br>T b<br>T c<br>Q 2<br>U 2<br>T c<br>Q 2</p>
</blockquote>
<h3 id="样例输出"><a href="#样例输出" class="headerlink" title="样例输出"></a>样例输出</h3><blockquote>
<p>b<br>c</p>
</blockquote>
<h2 id="提示​"><a href="#提示​" class="headerlink" title="提示​"></a>提示​</h2><p>对于40%的数据 n&lt;=200;<br>对于100%的数据 n&lt;=100000；保证Undo操作不会撤销Undo操作。<br>高级挑战<br>对于200%的数据 n&lt;=100000；Undo操作可以撤销Undo操作。<br>IOI挑战<br>必须使用在线算法完成该题。</p>
<h2 id="水解"><a href="#水解" class="headerlink" title="水解"></a>水解</h2><p>对于100%的数据，直接模拟就好了</p>
<dir style="display:none"><a href="/2016/08/30/NOIP模拟赛-2014-3-15/type.pas" title="复制代码">复制代码</a></dir>

<p>```delphi type.pas<br>type int=longint;<br>var<br>    a:array[0..100010] of char;<br>    i,j,n,p:int;c,x:char;<br>begin<br>    assign(input,’type.in’);reset(input);<br>    assign(output,’type.out’);rewrite(output);<br>    readln(n);<br>    p:=0;<br>    for i:=1 to n do begin<br>        read(c);read(x);<br>        case c of<br>            ‘T’:begin inc(p);readln(a[p]) end;<br>            ‘U’:begin readln(j);dec(p,j) end;<br>            ‘Q’:begin readln(j);writeln(a[j]) end;<br>        end;<br>    end;<br>    close(input);close(output);<br>end.</p>
<pre><code>
## 正解
对于200%的数据，离线做，应用可持久化的版本树
对每次修改操作新建一个版本，用这些版本作为节点建树：（记本次操作为m）
1. T c操作：m向m-1连一条边，边上标记字符c
2. U x操作：m向m-x-1连一条边，边上标记&#39;.&#39;表示是U操作

然后开数组q记录查询操作。
然后从节点0开始dfs一遍就可以了。

&lt;dir style=&quot;display:none&quot;&gt;<a href="/2016/08/30/NOIP模拟赛-2014-3-15/type2.pas" title="复制代码">复制代码</a>&lt;/dir&gt;

```delphi type2.pas
type 
    int=longint;
    edge=record f,t,next:int;c:char end;
var 
    g:array[0..100010] of edge;
    head,cnt,l,r:array[0..100010] of int;
    q:array[0..100010,0..1] of int;
    ans:array[0..100010] of char;
    n,m,k,i,j,sz:int;c,x:char;s:ansistring;

procedure add(f,t:int;c:char);
begin
    inc(sz);
    g[sz].f:=f;g[sz].t:=t;g[sz].c:=c;
    g[sz].next:=head[f];head[f]:=sz;
end;

procedure dfs(v:int);
var i,u:int;
begin
    for i:=l[v] to r[v] do ans[i]:=s[q[i,1]];
    i:=head[v];
    while i&lt;&gt;0 do begin
        u:=g[i].t;
        if g[i].c&lt;&gt;&#39;.&#39; then s:=s+g[i].c;
        dfs(u);
        if g[i].c&lt;&gt;&#39;.&#39; then delete(s,length(s),1);
        i:=g[i].next;
    end;
end;

begin
    assign(input,&#39;type.in&#39;);reset(input);
    assign(output,&#39;type.out&#39;);rewrite(output);
    readln(n);
    m:=0;sz:=0;k:=0;
    fillchar(head,sizeof(head),0);
    fillchar(q,sizeof(q),0);
    for i:=1 to n do begin
        read(c);read(x);
        case c of
            &#39;Q&#39;:begin 
                inc(k);q[k,0]:=m;readln(q[k,1]) end;
            &#39;T&#39;:begin readln(x);inc(m);add(m-1,m,x) end;
            &#39;U&#39;:begin readln(j);inc(m);add(m-j-1,m,&#39;.&#39;) end;
        end;
    end;
    fillchar(cnt,sizeof(cnt),0);
    for i:=1 to k do inc(cnt[q[i,0]]);
    r[0]:=0;l[0]:=1;
    for i:=1 to m do begin
        l[i]:=r[i-1]+1;
        r[i]:=l[i]+cnt[i]-1;
    end;
    dfs(0);
    for i:=1 to k do writeln(ans[i]);
    close(input);close(output);
end.
</code></pre><h1 id="Problem-2-不等数列"><a href="#Problem-2-不等数列" class="headerlink" title="Problem 2 不等数列"></a>Problem 2 不等数列</h1><p>将1到n任意排列，然后在排列的每两个数之间根据他们的大小关系插入“<span>$&gt;$</span><!-- Has MathJax -->”和“<span>$&lt;$</span><!-- Has MathJax -->”。问在所有排列中，有多少个排列恰好有k个“<span>$&lt;$</span><!-- Has MathJax -->”。答案对2012取模。</p>
<h2 id="格式-1"><a href="#格式-1" class="headerlink" title="格式"></a>格式</h2><h3 id="输入格式-1"><a href="#输入格式-1" class="headerlink" title="输入格式"></a>输入格式</h3><p>第一行2个整数n,k。</p>
<h3 id="输出格式-1"><a href="#输出格式-1" class="headerlink" title="输出格式"></a>输出格式</h3><p>一个整数表示答案。</p>
<h2 id="样例-1"><a href="#样例-1" class="headerlink" title="样例"></a>样例</h2><h3 id="样例输入-1"><a href="#样例输入-1" class="headerlink" title="样例输入"></a>样例输入</h3><blockquote>
<p>5 2</p>
</blockquote>
<h3 id="样例输出-1"><a href="#样例输出-1" class="headerlink" title="样例输出"></a>样例输出</h3><blockquote>
<p>66</p>
</blockquote>
<h2 id="提示​-1"><a href="#提示​-1" class="headerlink" title="提示​"></a>提示​</h2><p>对于30%的数据：<span>$n \leq 10$</span><!-- Has MathJax --><br>对于100%的数据：<span>$k &lt; n \leq 1000$</span><!-- Has MathJax --></p>
<h2 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h2><p>DP就好了<br>记f[i,j]是1..i个数的所有排列中，有j个小于号的方案数。<br>考虑将数字i插入1..i-1的某个排列中，因为i比排列中的任何数都要大：</p>
<ol>
<li>插到头位置，会多一个大于号，由f[i-1,j]转移</li>
<li>插到尾位置，会多一个小于号，由f[i-1,j-1]转移</li>
<li>插到中间，一定会变成<span>$a_j&lt;i&gt;a_{j+1}$</span><!-- Has MathJax -->的形式<ol>
<li>如果原来是小于，那么会多一个大于号，由f[i-1,j]转移，共j种</li>
<li>如果原来是大于，会多一个小于号，有f[i-1,j-1]转移，共i-j-1种</li>
</ol>
</li>
</ol>
<p>合并后，方程为：$f[i,j]=f[i-1,j-1]\cdot (i-j)+f[i-1,j]\cdot (j+1)$</p>
<dir style="display:none"><a href="/2016/08/30/NOIP模拟赛-2014-3-15/num.pas" title="复制代码">复制代码</a></dir>

<p>```delphi num.pas<br>type int=longint;<br>var<br>    n,k,i,j:int;<br>    f:array[-1..1010,-1..1010] of int;<br>begin<br>    assign(input,’num.in’);reset(input);<br>    assign(output,’num.out’);rewrite(output);<br>    read(n,k);<br>    f[0,0]:=1;<br>    for i:=1 to n do<br>        for j:=0 to i-1 do<br>            f[i,j]:=(f[i-1,j-1]<em>(i-j)+f[i-1,j]</em>(j+1)) mod 2012;<br>    write(f[n,k]);<br>    close(input);close(output);<br>end.</p>
<pre><code>

# Problem 3 经营与开发
4X概念体系，是指在PC战略游戏中一种相当普及和成熟的系统概念，得名自4个同样以“EX”为开头的英语单词。
eXplore（探索）
eXpand（拓张与发展）
eXploit（经营与开发）
eXterminate（征服）
——维基百科

今次我们着重考虑exploit部分，并将其模型简化：
你驾驶着一台带有钻头（初始能力值w）的飞船，按既定路线依次飞过n个星球。

星球笼统的分为2类：资源型和维修型。（p为钻头当前能力值）
1. 资源型：含矿物质量a[i]，若选择开采，则得到a[i]\*p的金钱，之后钻头损耗k%，即p=p\*(1-0.01k)
2. 维修型：维护费用b[i]，若选择维修，则支付b[i]\*p的金钱，之后钻头修复c%，即p=p\*(1+0.01c)
注：维修后钻头的能力值可以超过初始值（你可以认为是翻修+升级）

请作为舰长的你仔细抉择以最大化收入。

## 格式
### 输入格式
第一行4个整数n,k,c,w。
以下n行，每行2个整数type,x。
type为1则代表其为资源型星球，x为其矿物质含量a[i]；
type为2则代表其为维修型星球，x为其维护费用b[i]；

### 输出格式
一个实数（保留2位小数），表示最大的收入。

## 样例
### 样例输入
&gt;5 50 50 10
1 10
1 20
2 10
2 20
1 30

### 样例输出
&gt;375.00

## 提示​
对于30%的数据 n&lt;=100
另有20%的数据 n&lt;=1000；k=100
对于100%的数据 n&lt;=100000; 0&lt;=k,c,w,a[i],b[i]&lt;=100；保证答案不超过10^9

## 题解
首先很容易看出DP，然后想到变形背包，但问题在于费用的范围未知而且非整数。
这一题应用的**反向处理+贪心状态表示**
首先可以忽略w，默认起始能力值为1，最后答案乘上w就可以了。
记f[i]第i个点能力值为1，**i..n**所能得到的最大收益
倒过来写转移：
1. i为资源：$f[i]=max(f[i+1],f[i+1]*(1-k\%)+a[i])$
2. i为维修：$f[i]=max(f[i+1],f[i+1]*(1+c\%)-b[i])$

答案是$w\cdot f[1]$
&lt;dir style=&quot;display:none&quot;&gt;<a href="/2016/08/30/NOIP模拟赛-2014-3-15/exploit.pas" title="复制代码">复制代码</a>&lt;/dir&gt;

```delphi exploit.pas
uses math;
type int=longint;
var 
    n,w,i:int;
    k,c:double;
    a,t:array[0..100010] of int;
    f:array[0..100010] of double;
begin
    assign(input,&#39;exploit.in&#39;);reset(input);
    assign(output,&#39;exploit.out&#39;);rewrite(output);
    read(n,k,c,w);
    k:=(100-k)/100;c:=(100+c)/100;
    for i:=1 to n do read(t[i],a[i]);
    f[n+1]:=0;
    for i:=n downto 1 do
        if t[i]=1 then 
            f[i]:=max(f[i+1],f[i+1]*k+a[i])
        else 
            f[i]:=max(f[i+1],f[i+1]*c-a[i]);
    write(f[1]*w:0:2);
    close(input);close(output);
end.
</code></pre>]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[雅礼中学2015模拟赛 Day3]]></title>
      <url>https://cothrax.github.io/2016/08/30/%E9%9B%85%E7%A4%BC%E4%B8%AD%E5%AD%A62015%E6%A8%A1%E6%8B%9F%E8%B5%9B-Day3/</url>
      <content type="html"><![CDATA[<table>
<thead>
<tr>
<th>题目名称</th>
<th>A</th>
<th>B</th>
<th>C</th>
</tr>
</thead>
<tbody>
<tr>
<td>源文件</td>
<td>A.c/.cpp/.pas</td>
<td>B.c/.cpp/.pas</td>
<td>C.c/.cpp/.pas</td>
</tr>
<tr>
<td>输入/输出文件名</td>
<td>A.in/.out</td>
<td>B.in/.out</td>
<td>C.in/.out</td>
</tr>
<tr>
<td>测试点数</td>
<td>10</td>
<td>10</td>
<td>10</td>
</tr>
<tr>
<td>每个测试点分值</td>
<td>10</td>
<td>10</td>
<td>10</td>
</tr>
<tr>
<td>单个测试点时限</td>
<td>1s</td>
<td>1s</td>
<td>1s</td>
</tr>
<tr>
<td>空间限制</td>
<td>128MB</td>
<td>128MB</td>
<td>128MB</td>
</tr>
</tbody>
</table>
<h1 id="A"><a href="#A" class="headerlink" title="A"></a>A</h1><p>码零鼠是一只很喜欢mx数学的神犇，上面那个不是ta本人的样子。这天，ta在研究一个神奇的数列，这个数列是这样的：<br><span>$a_0=1$</span><!-- Has MathJax --><br><span>$a_n=a_i+a_j$</span><!-- Has MathJax -->（n≥1；i,j在[0,n-1]内随机）<br>Ta想知道对于给定的n，an的期望值是多少，你能告诉ta吗？<br>出于ta对整数的热爱，你只需要输出答案向下取整后的值<br><a id="more"></a></p>
<h2 id="格式"><a href="#格式" class="headerlink" title="格式"></a>格式</h2><h3 id="输入格式"><a href="#输入格式" class="headerlink" title="输入格式"></a>输入格式</h3><p>一个整数T，表示数据组数<br>每组数据一行，包括一个整数n</p>
<h3 id="输出格式"><a href="#输出格式" class="headerlink" title="输出格式"></a>输出格式</h3><p>一个整数<span>$E(a_n)$</span><!-- Has MathJax --></p>
<h2 id="样例"><a href="#样例" class="headerlink" title="样例"></a>样例</h2><h3 id="样例输入"><a href="#样例输入" class="headerlink" title="样例输入"></a>样例输入</h3><blockquote>
<p>2<br>0<br>1</p>
</blockquote>
<h3 id="样例输出"><a href="#样例输出" class="headerlink" title="样例输出"></a>样例输出</h3><blockquote>
<p>1<br>2</p>
</blockquote>
<h2 id="提示​"><a href="#提示​" class="headerlink" title="提示​"></a>提示​</h2><p>对于前30%的数据T&lt;=10, n&lt;=3000<br>对于前60%的数据T&lt;=100, n&lt;=100000<br>对于100%的数据T &lt;= 10000, 0 &lt;= n &lt;= 2147483647</p>
<h2 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h2><p>结论题，<span>$E(a_n)=n+1$</span><!-- Has MathJax -->，方便起见，下文<span>$a_n=E(a_n)$</span><!-- Has MathJax --></p>
<p>期望值定义得：<span>$a_n=\sum_{i=0}^{n-1}\sum_{j=0}^{n-1}\dfrac{a_i+a_j}{n^2}$</span><!-- Has MathJax --></p>
<p>合并同类项：<span>$a_n=\dfrac{2}{n}\sum_{i=0}^{n-1}a_i$</span><!-- Has MathJax --></p>
<p>又：<span>$a_{n-1}=\dfrac{2}{n-1}\sum_{i=0}^{n-2}a_i$</span><!-- Has MathJax --></p>
<p>变形得：<span>$\sum_{i=0}^{n-2}a_i=\dfrac{(n-1)a_{n-1}}{2}$</span><!-- Has MathJax --></p>
<p>上式带入$a_n$的式子：<span>$a_n=\dfrac{2}{n}(\dfrac{(n-1)a_{n-1}}{2}+a_{n-1})$</span><!-- Has MathJax --></p>
<p>合并变形后：<span>$\dfrac{a_n}{n+1}=\dfrac{a_{n-1}}{n}=\frac{a_0}{1}=1$</span><!-- Has MathJax --></p>
<p>所以<span>$a_n=n+1$</span><!-- Has MathJax --></p>
<p>ps:如果不会证的话，写几个找找规律吧。</p>
<dir style="display:none"><a href="/2016/08/30/雅礼中学2015模拟赛-Day3/A.pas" title="复制代码">复制代码</a></dir>

<p>```delphi A.pas<br>var t,n:qword;<br>begin<br>    assign(input,’A.in’);reset(input);<br>    assign(output,’A.out’);rewrite(output);<br>    read(t);<br>    repeat<br>        read(n);<br>        writeln(n+1);<br>        t:=t-1;<br>    until t=0;<br>    close(input);close(output);<br>end.</p>
<pre><code>
# B
泡泡鱼是一条调皮的鱼，ta的家住在一片珊瑚礁上。在ta的眼里，这些珊瑚礁的形态可以脑补成一个n个节点，m条边的带权图，在海水的腐蚀下，这些珊瑚礁形成了许多的环，ta想考考你能不能找出这些环中，权值的平均值最小的环。泡泡鱼这么聪明，ta当然知道答案，调皮的ta对你说，如果你算错了，就要吃ta下的蛋。因为ta很调皮，ta把图变成了有向图，还有可能用无环图坑你。为代表你知道，你只需告诉ta最小的平均权值即可。

## 格式
### 输入格式
共m+1行。
第1行，2个整数n和m，表示珊瑚礁的点数和边数。
第2~m+1行，每行3个正整数u，v，w，表示u与v之间有一条权值为w的有向边。

### 输出格式
如果输入数据无环，输出”PaPaFish is laying egg!”。（不含引号）
否则输出一个浮点数ans， 表示所有环中，权值的平均值最小的环的平均权值。答案保留2位小数。
&lt;!--more--&gt;

## 样例
### 样例输入
&gt;2 2
1 2 2
2 1 3

### 样例输出
&gt;2.50

## 提示​
对于前40%的数据n &lt;= 50, m &lt;= 5000
对于100%的数据1 &lt;= n &lt;= 1000, 1 &lt;= m &lt;= 10000, 0 &lt;= w &lt;= 10000000

## 题解
先yy了一个找环的方法：先tarjan找出强连通分量，然后dfs找环。
骗60分，虽然这个方法是错的，比如下面这个分量，3个环中dfs最多找到2个。
<img src="/2016/08/30/雅礼中学2015模拟赛-Day3/g.png" alt="g.png" title="">
正解是**二分+判负环**
二分最小平均值mid，将所有边都减去mid，如果这个值比最小的平均值大，此时图中一定有负圈，用spfa判断。
ps: spfa判负圈比bellman快一些，但最慢的点还是跑了很久。

&lt;dir style=&quot;display:none&quot;&gt;<a href="/2016/08/30/雅礼中学2015模拟赛-Day3/B.pas" title="复制代码">复制代码</a>&lt;/dir&gt;

```delphi B.pas
uses math;
const eps=0.000000000001;
type 
    int=longint;
    edge=record f,t,next:int;w:double end;
var 
    n,m,i,f0,t0,w0:int;l,r,mid:double;
    g:array[0..10010] of edge;
    head,cnt:array[0..1010] of int;
    q:array[0..10010] of int;
    d:array[0..1010] of double;
    inq:array[0..1010] of boolean;

procedure add(f0,t0:int;w0:double);
var m:int;
begin
    inc(head[0]);m:=head[0];
    g[m].f:=f0;g[m].t:=t0;g[m].w:=w0;
    g[m].next:=head[f0];head[f0]:=m;
end;

function spfa(x:double):boolean;
var i,v,u,h,t:int;
begin
    fillchar(d,sizeof(d),0);
    fillchar(inq,sizeof(inq),true);
    filldword(cnt,sizeof(cnt) shr 1,1);
    for i:=1 to n do q[i]:=i;
    h:=1;t:=n+1;
    while h&lt;&gt;t do begin
        v:=q[h];inq[v]:=false;
        inc(h);if h&gt;10010 then h:=0;
        i:=head[v];
        while i&lt;&gt;0 do begin
            u:=g[i].t;
            if d[u]&gt;d[v]+g[i].w-x then begin
                d[u]:=d[v]+g[i].w-x;
                if not inq[u] then begin
                    inq[u]:=true;q[t]:=u;
                    inc(t);if t&gt;10010 then t:=0;
                    inc(cnt[u]);
                    if cnt[u]&gt;n then exit(true);
                end;
            end;
            i:=g[i].next;
        end;
    end;
    spfa:=false;
end;

begin
    assign(input,&#39;B.in&#39;);reset(input);
    assign(output,&#39;B.out&#39;);rewrite(output);
    read(n,m);
    l:=0;r:=0;
    for i:=1 to m do begin
        read(f0,t0);read(w0);
        r:=max(r,w0);
        add(f0,t0,w0);
    end;
    r:=r+1;
    if not spfa(r) then begin 
        write(&#39;PaPaFish is laying egg!&#39;);
        halt;
    end;
    while r-l&gt;0.0001 do begin
        mid:=(l+r)/2;
        if spfa(mid) then r:=mid else l:=mid;
    end;
    write(r:0:2);
    close(input);close(output);
end.
</code></pre><h1 id="C"><a href="#C" class="headerlink" title="C"></a>C</h1><blockquote>
<p>还没写</p>
</blockquote>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[[JSOI2016] 提高1班 Day3 resistor]]></title>
      <url>https://cothrax.github.io/2016/08/29/JSOI2016-%E6%8F%90%E9%AB%981%E7%8F%AD-Day3-resistor/</url>
      <content type="html"><![CDATA[<h2 id="描述"><a href="#描述" class="headerlink" title="描述"></a>描述</h2><p>物理课上老师让小 w 测一个电路板的电阻,小 w 用欧姆表很快就得到了答案。但是,欧姆表巨大的误差是令小 w 无法容忍的,于是他决定用数学方法准确算出总电阻。<br>电路板一共有 N 个连接点,M 个电阻,小 w 需要算出 1 号连接点和 N 号连接点的总电阻。</p>
<h2 id="格式"><a href="#格式" class="headerlink" title="格式"></a>格式</h2><h3 id="输入格式"><a href="#输入格式" class="headerlink" title="输入格式"></a>输入格式</h3><p>多组数据,输入直到文件结束<br>每组数据第一行两个整数 N,M<br>接下来 M 行,每行三个非负整数 X,Y,R,表示电阻连接的两接点和阻值(X 与 Y 可能相等)。</p>
<h3 id="输出格式"><a href="#输出格式" class="headerlink" title="输出格式"></a>输出格式</h3><p>每组数据输出一行,一个实数,四舍五入到小数点后两位。<br><a id="more"></a></p>
<h2 id="样例"><a href="#样例" class="headerlink" title="样例"></a>样例</h2><h3 id="样例输入"><a href="#样例输入" class="headerlink" title="样例输入"></a>样例输入</h3><blockquote>
<p>2 1<br>1 2 1</p>
</blockquote>
<h3 id="样例输出"><a href="#样例输出" class="headerlink" title="样例输出"></a>样例输出</h3><blockquote>
<p>1.00</p>
</blockquote>
<h2 id="提示​"><a href="#提示​" class="headerlink" title="提示​"></a>提示​</h2><p>对于 20%的数据 N=2<br>对于另外 30%的数据 M=N-1 且任意两个连接点间的电阻不是无穷大。<br>对于 100%的数据保证 1&lt;N&lt;=100<br>数据保证不出现电阻无穷大的情况。</p>
<h2 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h2><p>这是一道<strong>物理题</strong>orz，好像bzoj上有原题：2419 电阻<br>记点i的电势是$E(i)$，那么设$E(1)=1,E(n)=0$，然后用<strong>高斯消元</strong>解方程组。<br>方程组这样列：除了1和n外，所有点的<strong>流入电流=流出电流</strong>，第i个方程就是：<br>$$\sum\dfrac{E(j)-E(i)}{R(i,j)}=0$$<br>然后第一个方程改成：$E(1)=1$，第n个改成$E(n)=0$<br>这样算出所有点的电势，进而我们能求出<strong>等效电流</strong>=流入终点的电流之和：（其中k指与点n有直接连边的点）<br>$$I=\sum \frac{E(k)-0}{R(n,k)}$$<br>因为1和n的电势差是1，答案就是$|1/I|$</p>
<dir style="display:none"><a href="/2016/08/29/JSOI2016-提高1班-Day3-resistor/resistor.pas" title="复制代码">复制代码</a></dir>

<p>```delphi resistor.pas<br>type int=longint;<br>const eps=0.0000000001;<br>var<br>    g,g0:array[0..110,0..110] of double;<br>    tmp:array[0..110] of double;<br>    n,m,i,j,k,r,p:int;<br>    f:double;</p>
<p>procedure inc(var a:double;b:double);<br>begin a:=a+b end;</p>
<p>begin<br>    assign(input,’resistor.in’);reset(input);<br>    assign(output,’resistor.out’);rewrite(output);<br>    while not eof do begin<br>        readln(n,m);<br>        fillchar(g,sizeof(g),0);<br>        for i:=1 to m do begin<br>            readln(j,k,r);<br>            inc(g[j,k],1/r);inc(g[j,j],-1/r);<br>            inc(g[k,j],1/r);inc(g[k,k],-1/r);<br>        end;<br>        g0:=g;<br>        for i:=1 to n do begin<br>            g[1,i]:=0;g[n,i]:=0;<br>        end;<br>        g[1,1]:=1;g[1,n+1]:=1;<br>        g[n,n]:=1;g[n,n+1]:=0;<br>        for i:=1 to n do begin<br>            p:=i;<br>            for j:=i+1 to n do<br>                if abs(g[j,i])&gt;abs(g[p,i]) then p:=j;<br>            tmp:=g[i];g[i]:=g[p];g[p]:=tmp;<br>            for j:=i+1 to n+1 do g[i,j]:=g[i,j]/g[i,i];<br>            for j:=1 to n do<br>                if j&lt;&gt;i then<br>                    for k:=i+1 to n+1 do<br>                        inc(g[j,k],-g[j,i]<em>g[i,k]);<br>        end;<br>        f:=0;<br>        for i:=1 to n do<br>            if abs(g0[n,i])&gt;eps then inc(f,g[i,n+1]</em>g0[n,i]);<br>        writeln(round(abs(1/f)*100)/100:0:2);<br>    end;<br>    close(input);close(output);<br>end.<br>```<br>还可以设电流为1，第n点电势为0，这样求出点1的电势就是答案，好像还是基尔霍夫矩阵什么的，详见此处：<a href="http://blog.lightning34.cn/?p=237" target="_blank" rel="external">http://blog.lightning34.cn/?p=237</a></p>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[[JSOI2016] 提高1班 Day3 separate]]></title>
      <url>https://cothrax.github.io/2016/08/29/JSOI2016-%E6%8F%90%E9%AB%981%E7%8F%AD-Day3-separate/</url>
      <content type="html"><![CDATA[<h2 id="描述"><a href="#描述" class="headerlink" title="描述"></a>描述</h2><p>小 w 是扬中的高一新生。俗话说新官上任三把火,作为班长,第一件事自然是要给全班分座位。<br>这可不是一件简单的任务。大家都知道学霸是一种环境不友好型生物,所以在一个组里,学霸会对同组的学渣造成巨大伤害。<br>具体来说,我们定义一个组的不和谐度为本组的最高成绩与最低成绩差的平方。如一个组内的分数为 4 7 10 1,那么不和谐度为(10-1)^2=81。<br>现在,班主任给小 w 全班的成绩和要求分的组数,求全班所有小组的不和谐度<strong>之和</strong>的最小值。</p>
<h2 id="格式"><a href="#格式" class="headerlink" title="格式"></a>格式</h2><h3 id="输入格式"><a href="#输入格式" class="headerlink" title="输入格式"></a>输入格式</h3><p>多组测试数据。<br>每组测试数据,第一行两个整数 N,M,N 是全班人数,M 是组数<br>第二行 N 个整数表示全班成绩。</p>
<h3 id="输出格式"><a href="#输出格式" class="headerlink" title="输出格式"></a>输出格式</h3><p>每组测试数据,一行一个整数 S 表示全班所有小组的不和谐度<strong>之和</strong>的最小值。<br>答案保证在 32 位有符号整型范围内。<br><a id="more"></a></p>
<h2 id="样例"><a href="#样例" class="headerlink" title="样例"></a>样例</h2><h3 id="样例输入"><a href="#样例输入" class="headerlink" title="样例输入"></a>样例输入</h3><blockquote>
<p>2<br>3 2<br>1 2 4<br>4 2<br>4 7 10 1</p>
</blockquote>
<h3 id="样例输出"><a href="#样例输出" class="headerlink" title="样例输出"></a>样例输出</h3><blockquote>
<p>Case 1: 1<br>Case 2: 18</p>
</blockquote>
<h2 id="提示​"><a href="#提示​" class="headerlink" title="提示​"></a>提示​</h2><p>对于 30%数据,M&lt;=N&lt;=10<br>对于 80%数据,M&lt;=N&lt;=100<br>对于 100%数据,M&lt;=N&lt;=5000</p>
<h2 id="水解"><a href="#水解" class="headerlink" title="水解"></a>水解</h2><p>首先，题意有点问题，“之和”二字是我后加的。<br>先qsort，很容易想到<strong>dp</strong>，记f[i,j]为1..j个人分i组的最小值<br>$f[i,j]=f[i-1,k-1]+(a[k]-a[j])^2$<br>把状态维（1..j个人）放在第二个位置确实不爽，但这是为了用<strong>滚动数组</strong>。<br>复杂度$O(MN^2)$，80分到手。</p>
<dir style="display:none"><a href="/2016/08/29/JSOI2016-提高1班-Day3-separate/separate.pas" title="复制代码">复制代码</a></dir>

<p>```delphi separate.pas<br>uses math;<br>type int=longint;<br>const inf=1000000000;<br>var<br>    n,m,i,j,k,p,c,t,t0:int;<br>    a:array[0..5010] of int;<br>    f:array[0..1,0..5010] of int;</p>
<p>procedure swap(var a,b:int);<br>var tmp:int;<br>begin tmp:=a;a:=b;b:=tmp end;</p>
<p>procedure qsort(b,e:int);<br>var i,j,x:int;<br>begin<br>    i:=b;j:=e;x:=a[random(e-b)+b];<br>    repeat<br>        while a[i]<x do="" inc(i);="" while="" a[j]="">x do dec(j);<br>        if i&lt;=j then begin<br>            swap(a[i],a[j]);<br>            inc(i);dec(j);<br>        end;<br>    until i&gt;j;<br>    if i&lt;e then qsort(i,e);<br>    if b&lt;j then qsort(b,j);<br>end;</x></p>
<p>begin<br>    assign(input,’separate.in’);reset(input);<br>    assign(output,’separate.ans’);rewrite(output);<br>    read(t0);<br>    for t:=1 to t0 do begin<br>        read(n,m);<br>        for i:=1 to n do read(a[i]);<br>        qsort(1,n);<br>        filldword(f,sizeof(f) div 4,inf);<br>        f[0,0]:=0;p:=1;c:=0;<br>        for i:=1 to m do begin<br>            swap(p,c);<br>            filldword(f[c],sizeof(f[c]) div 4,inf);<br>            for j:=1 to n do<br>                for k:=1 to j do<br>                    f[c,j]:=min(f[c,j],f[p,k-1]+sqr(a[k]-a[j]));<br>        end;<br>        writeln(‘Case ‘,t,’: ‘,f[c,n]);<br>    end;<br>    close(input);close(output);<br>end.</p>
<pre><code>
## 正解
斜率优化dp，详见神犇的讲解：http://www.cnblogs.com/ka200812/archive/2012/08/03/2621345.html

关于本题，我简单推一遍：
$$f[i,j]=min(f[i-1,k-1]+(a[k]-a[j])^2)$$
设<span>$k&gt;t$</span><!-- Has MathJax -->，若从k转移更优，则：
$$f[i-1,k-1]+(a[k]-a[j])^2&lt;f[i-1,t-1]+(a[t]-a[j])^2$$
变形后：$$\dfrac{(f[i-1,k-1]+a[k]^2)-(f[i-1,t-1]+a[t]^2)}{a[k]-a[t]}&lt;2a[j]$$
记$$x(k)=a[k],y(k)=f[i-1,k-1]+a[k]^2$$
则上式变形为：$$\dfrac{y(k)-y(t)}{x(k)-x(t)}&lt;2a[j]$$
把k和t看成点，左边就是$kt$的斜率，记为$g(k,t)$，当$g(k,t)&lt;2a[j]$时k优于t

用**单调队列**维护：
**从头出队**：满足上面的情况，t出队

**从尾出队**：设<span>$k&lt;t&lt;l$</span><!-- Has MathJax -->，若<span>$g(l,t)&lt;g(t,k)$</span><!-- Has MathJax -->，那么t一定不是最优解，分类讨论：
1. 若<span>$g(t,k)&lt;2a[j]$</span><!-- Has MathJax -->，那么t不比k优
2. 若<span>$g(t,k)&gt;2a[j]$</span><!-- Has MathJax -->，则<span>$g(l,t)&lt;2a[j]$</span><!-- Has MathJax -->，l比t优

所以存在上述情况，t出队

注意点：
1. g(k,t)和g(t,k)是不等价的（虽然算出来是一样的），因为我们默认**k&gt;t**，**要保证x坐标递增**（所以数组a要qsort，单调队列中的标号也是递增的）
2. 当i&gt;j时f[i,j]是不存在的
3. 注意端点，方程不能写成<span>$f[i-1,k]+(a[k+1]-a[j])^2$</span><!-- Has MathJax -->，因为有可能k=n，而又有多组数据，会wa。
4. 算坐标时longint会爆
5. 最好把上面推导中的小于改成**小于等于**，原因是什么我也不知道

在ubuntu下测最后一点tle，试了一下标程也是，那开个inline吧==。

&lt;dir style=&quot;display:none&quot;&gt;<a href="/2016/08/29/JSOI2016-提高1班-Day3-separate/0separate.pas" title="复制代码">复制代码</a>&lt;/dir&gt;

```delphi separate.pas
{$inline on}
uses math;
type int=longint;
var 
    n,m,i,j,h,t,t0,t1,p,c:int;
    a,q:array[0..5010] of int;
    x,y:array[0..5010] of qword;
    f:array[0..1,0..5010] of int;

procedure swap(var a,b:int);
var tmp:int;
begin tmp:=a;a:=b;b:=tmp end;

procedure qsort(b,e:int);
var i,j,x:int;
begin
    i:=b;j:=e;x:=a[random(e-b)+b];
    repeat
        while a[i]&lt;x do inc(i);
        while a[j]&gt;x do dec(j);
        if i&lt;=j then begin
            swap(a[i],a[j]);
            inc(i);dec(j);
        end;
    until i&gt;j;
    if i&lt;e then qsort(i,e);
    if b&lt;j then qsort(b,j);
end;

function better(i,j,k:int):boolean;inline;
begin
    //i&gt;j&gt;k, g[i,j]&lt;=g[j,k]
    better:=(y[i]-y[j])*(x[j]-x[k])&lt;=(y[j]-y[k])*(x[i]-x[j]);
end;

function check(i,j,k:int):boolean;inline;
begin
    //j&gt;k,g[j,k]&lt;=2*a[i]
    check:=(y[j]-y[k])&lt;=2*a[i]*(x[j]-x[k]);
end;

begin
    assign(input,&#39;separate.in&#39;);reset(input);
    assign(output,&#39;separate.out&#39;);rewrite(output);
    read(t0);
    for t1:=1 to t0 do begin
        read(n,m);
        for i:=1 to n do read(a[i]);
        qsort(1,n);
        for i:=1 to n do f[1,i]:=sqr(a[i]-a[1]);
        p:=0;c:=1;
        for i:=2 to m do begin
            p:=1-p;c:=1-c;
            h:=0;t:=0;q[h]:=i-1;
            for j:=i to n do begin
                x[j]:=a[j];
                y[j]:=f[p,j-1]+sqr(a[j]);
                while (h&lt;t) and better(j,q[t],q[t-1]) do dec(t);
                inc(t);q[t]:=j;
                while (h&lt;t) and check(j,q[h+1],q[h]) do inc(h);
                f[c,j]:=f[p,q[h]-1]+sqr(a[q[h]]-a[j]);
            end;
        end;
        writeln(&#39;Case &#39;,t1,&#39;: &#39;,f[c,n]);
    end;
    close(input);close(output);
end.
</code></pre>]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[雅礼中学2015模拟赛 chain]]></title>
      <url>https://cothrax.github.io/2016/08/28/%E9%9B%85%E7%A4%BC%E4%B8%AD%E5%AD%A62015%E6%A8%A1%E6%8B%9F%E8%B5%9B-chain/</url>
      <content type="html"><![CDATA[<h2 id="描述"><a href="#描述" class="headerlink" title="描述"></a>描述</h2><p>PCY 最近在努力地学习生物。看到食物链这一节的时候,他迷茫了。<br>生态系统中的生物种类众多,亦于生态系统分别扮演着不同的角色,但根据它们能量和物质中所引起的作用,可以被分类为生产者、消费者和分解者三个类别。最底层是“生产者”,是以阳光来行使光合作用,自行用水和二氧化碳等无机物合成有机物的绿色植物;再上层是各级“消费者”,要依赖生产者供应物质和能量;当消费者死亡以后,“分解者”会以他们的尸体为食物。<br>生物必修二曾写道,“两个营养级之间的能量传递效率为 10% ~ 20%”。<br>PCY 说,“那些错综复杂的食物网我根本看不清楚”,于是我们将问题简化,每一个物种只存在唯一一个的捕食者(形成捕食关系),给出这些捕食关系,和每个物种所拥有的能量。求出整个食物网中食物链的数量和处在最高营养级的物种的能量。(某一物种的能量 = 摄入食物的能量 * 传递效率 + 自身能量),不考虑能量损耗,为了避免精度误差,能量效率按均为整数计算。也就是说,一个物种被吃了以后他的能量就成了他的数倍了。</p>
<h2 id="格式"><a href="#格式" class="headerlink" title="格式"></a>格式</h2><h3 id="输入格式"><a href="#输入格式" class="headerlink" title="输入格式"></a>输入格式</h3><p>第一行为 n ,代表物种数量(物种按 1 … n 编号)<br>接下来 n - 1 行,每一行三个整数 x,y,z ,代表 y 被 x 捕食,且两个物种之间能量传递的效率为<br>z(1 &lt;= x, y &lt;= n,x ≠ y)<br>接下来 n 行,每行一个整数 w ,代表 1 … n 号物种的能量</p>
<h3 id="输出格式"><a href="#输出格式" class="headerlink" title="输出格式"></a>输出格式</h3><p>共两行,第一行一个整数,代表食物链的总数,第二行一个整数,代表最高营养级的物种的能量。能量对 32416190071 取模。<br><a id="more"></a></p>
<h2 id="样例"><a href="#样例" class="headerlink" title="样例"></a>样例</h2><h3 id="样例输入"><a href="#样例输入" class="headerlink" title="样例输入"></a>样例输入</h3><p>样例1</p>
<blockquote>
<p>5<br>1 3 2<br>1 2 2<br>2 4 2<br>2 5 2<br>1 2 3 4 5</p>
</blockquote>
<p>样例2</p>
<blockquote>
<p>5<br>1 2 1<br>2 3 2<br>3 4 3<br>4 5 4<br>5 5 5 5 5</p>
</blockquote>
<h3 id="样例输出"><a href="#样例输出" class="headerlink" title="样例输出"></a>样例输出</h3><p>样例1</p>
<blockquote>
<p>3<br>47</p>
</blockquote>
<p>样例2</p>
<blockquote>
<p>1<br>170</p>
</blockquote>
<h2 id="提示​"><a href="#提示​" class="headerlink" title="提示​"></a>提示​</h2><p>对于前 30%的数据, n &lt;= 10<br>对于前 50%的数据, n &lt;= 10000 ,保证数据随机, w &lt;= 2 * 10 ^ 9<br>对于后 50%的数据, n &lt;= 2000000,w &lt;= 10 ^ 4,z &lt;= 10 ^ 5<br>内存限制 256M ,时间限制 1s ,必要时请手写人工栈</p>
<h2 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h2><p>这本来是一道很水的<strong>树形DP</strong><br>第一问就是叶节点的个数<br>第二问：记f[v]是节点v的能量，那么f[v]=sum(f[u]*e(v,u))+w[v]（u是v的儿子）<br>然后有了两个问题：</p>
<ol>
<li><strong>爆栈</strong>：手写一个人工栈。因为是f[v]是回溯更新得到的，我们先从根bfs得到拓扑序，然后逆着拓扑序用循环处理dp（就是从最深的叶节点向上更新，一直到根）。ps：如果是用父节点更新子节点的话，直接用bfs处理dp就好了</li>
<li>pascal党的杯具：<strong>int64的bug</strong>，好像int64的底层是用浮点数trunc出来的，对它大量取模（尤其是模数也是int64时）出现了精度误差，我们用qword替代int64来做。</li>
</ol>
<p>读入和取模的常数都很大，在ubuntu下测好像tle了，pascal没有读入优化（杯具），不过std好像也tle了</p>
<dir style="display:none"><a href="/2016/08/28/雅礼中学2015模拟赛-chain/chain.pas" title="复制代码">复制代码</a></dir>

<p>```delphi chain.pas<br>const z:qword=32416190071;<br>type<br>    int=longint;<br>    edge=record t,w,next:int end;<br>var<br>    n,i,j,f0,t0,w0,r,h,t,v,u,cnt,sz:int;<br>    g:array[0..2000010] of edge;<br>    head,q,ind,w:array[0..2000010] of int;<br>    f:array[0..2000010] of qword;</p>
<p>procedure add(f,t,w:int);<br>begin<br>    inc(sz);<br>    g[sz].t:=t;g[sz].w:=w;<br>    g[sz].next:=head[f];head[f]:=sz;<br>end;</p>
<p>begin<br>    assign(input,’chain.in’);reset(input);<br>    assign(output,’chain.out’);rewrite(output);<br>    read(n);sz:=0;<br>    for i:=1 to n-1 do begin<br>        read(f0,t0,w0);<br>        add(f0,t0,w0);inc(ind[t0]);<br>    end;<br>    for i:=1 to n do read(w[i]);<br>    for i:=1 to n do<br>        if ind[i]=0 then begin r:=i;break end;<br>    h:=1;t:=2;q[h]:=r;cnt:=0;<br>    while h&lt;&gt;t do begin<br>        v:=q[h];inc(h);<br>        i:=head[v];<br>        if i=0 then inc(cnt);<br>        while i&lt;&gt;0 do begin<br>            u:=g[i].t;<br>            q[t]:=u;inc(t);<br>            i:=g[i].next;<br>        end;<br>    end;<br>    for i:=t-1 downto 1 do begin<br>        v:=q[i];<br>        f[v]:=w[v];<br>        j:=head[v];<br>        while j&lt;&gt;0 do begin<br>            u:=g[j].t;<br>            inc(f[v],f[u]*g[j].w);<br>            if f[v]&gt;=z then f[v]:=f[v] mod z;<br>            j:=g[j].next;<br>        end;<br>    end;<br>    writeln(cnt);write(f[r]);<br>    close(input);close(output);<br>end.<br>```</p>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[雅礼中学2015模拟赛 prefix]]></title>
      <url>https://cothrax.github.io/2016/08/28/%E9%9B%85%E7%A4%BC%E4%B8%AD%E5%AD%A62015%E6%A8%A1%E6%8B%9F%E8%B5%9B-prefix/</url>
      <content type="html"><![CDATA[<h2 id="描述"><a href="#描述" class="headerlink" title="描述"></a>描述</h2><p>PCY 学生物学累了。突然看到地上有一本笔记本。<br>上面写着“ isdashagaydashisorisdashnot … ”之类的字眼,独具慧眼的他发现这些字符串中有着大<br>秘密!类似“ isdash ”这样的前缀在字符串中出现的次数不止一次!他觉得这其中一定有蹊跷,于是<br>开始一个一个数前缀出现的次数。<br>虽然他早已经从逐字符匹配转换到了多行同时匹配模式,但是这小小的练习本上几十万个字符还<br>是让他措手不及。你能帮助他吗?他想知道所有长度为偶数的前缀在整个字符串出现的次数和。</p>
<h2 id="格式"><a href="#格式" class="headerlink" title="格式"></a>格式</h2><h3 id="输入格式"><a href="#输入格式" class="headerlink" title="输入格式"></a>输入格式</h3><p>共一行,一个字符串 s</p>
<h3 id="输出格式"><a href="#输出格式" class="headerlink" title="输出格式"></a>输出格式</h3><p>共一行,输出一个整数,代表长度为偶数的前缀在整个字符串出现的次数和。<br><a id="more"></a></p>
<h2 id="样例"><a href="#样例" class="headerlink" title="样例"></a>样例</h2><h3 id="样例输入"><a href="#样例输入" class="headerlink" title="样例输入"></a>样例输入</h3><p>样例1</p>
<blockquote>
<p>abababc</p>
</blockquote>
<p>样例2</p>
<blockquote>
<p>isdashagayisdashagaydashisnotagaydashisnotagay</p>
</blockquote>
<h3 id="样例输出"><a href="#样例输出" class="headerlink" title="样例输出"></a>样例输出</h3><p>样例1</p>
<blockquote>
<p>6</p>
</blockquote>
<p>样例2</p>
<blockquote>
<p>30</p>
</blockquote>
<h2 id="提示​"><a href="#提示​" class="headerlink" title="提示​"></a>提示​</h2><p>对于 30%的数据, |S| &lt;= 100 ,保证数据随机<br>对于 100%的数据, |S| &lt;= 200000<br>内存限制 256M ,时间限制 1s</p>
<h2 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h2><p>KMP+DP，KMP是一个无比神奇的算法</p>
<ol>
<li>orz D.E.Knuth</li>
<li>orz J.H.Morris</li>
<li>orz V.R.Pratt</li>
</ol>
<p>这一题应用了经典kmp中<strong>前缀匹配后缀</strong>的思想。<br>考虑kmp中的next数组，next[i]实际上是使得s[1..k]=s[i-k+1..i]的最大k。<br>于是定义f[i]：s[1..i]中，对于一个<strong>偶数</strong>前缀[1..j]，使得[1..j]=[i-j+1..i]的所有j的个数。（就是与后缀匹配的偶数前缀的数量）<br>那么：<br>f[i]=f[next[i]]+1（i为偶数）<br>f[i]=f[next[i]]（i为奇数）<br>答案是sum(f[i])</p>
<dir style="display:none"><a href="/2016/08/28/雅礼中学2015模拟赛-prefix/prefix.pas" title="复制代码">复制代码</a></dir>

<p>```delphi prefix.pas<br>type int=longint;<br>var<br>    p,f:array[0..200010] of int;<br>    s:ansistring;<br>    n,i,j,ans:int;</p>
<p>begin<br>    assign(input,’prefix.in’);reset(input);<br>    assign(output,’prefix.out’);rewrite(output);<br>    readln(s);n:=length(s);<br>    p[1]:=0;j:=0;<br>    for i:=2 to n do begin<br>        while (j&gt;0) and (s[j+1]&lt;&gt;s[i]) do j:=p[j];<br>        if s[j+1]=s[i] then inc(j);<br>        p[i]:=j;<br>    end;<br>    ans:=0;<br>    fillchar(f,sizeof(f),0);<br>    for i:=2 to n do begin<br>        if (i and 1)=0 then inc(f[i]);<br>        inc(f[i],f[p[i]]);<br>        inc(ans,f[i]);<br>    end;<br>    write(ans);<br>    close(input);close(output);<br>end.<br>```</p>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[[JSOI2016] 提高1班 Day3 message]]></title>
      <url>https://cothrax.github.io/2016/08/28/JSOI2016-%E6%8F%90%E9%AB%981%E7%8F%AD-Day3-message/</url>
      <content type="html"><![CDATA[<h2 id="描述"><a href="#描述" class="headerlink" title="描述"></a>描述</h2><p>体育老师又向班主任打小报告了。<br>悲剧的是体育老师并不记得是哪些人在体育课上捣乱，他只记得捣乱的人在队里是连续的一段，并且他知道一共有多少人捣乱以及这些人的身高比较信息。他向班主任提供了这些信息，希望能找出捣乱的人。<br>作为班主任的得力小助手，这任务自然又落到了小w的头上。<br>小w记得全班体育课的队形以及各个位置上人的身高，他要找出捣乱的是哪一段人。当然他知道可能找到不止一段人，请按从小至大的顺序输出所有可能。<br>身高比较信息：体育老师记得的是相对身高，比如他记得他告诉班主任捣乱的人身高分别是1 4 4 3 2 1，那么我们能知道第一个人比第二个人矮，第二个人和第三个人一样高等等诸如此类。</p>
<h2 id="格式"><a href="#格式" class="headerlink" title="格式"></a>格式</h2><h3 id="输入格式"><a href="#输入格式" class="headerlink" title="输入格式"></a>输入格式</h3><p>第一行两个整数N，K。N表示全班人数，K表示捣乱的人数。<br>第二行至第N+1行每行一个正整数表示各个人的身高。<br>第N+2行至第N+K+1行每行一个正整数表示捣乱的人的身高信息。</p>
<h3 id="输出格式"><a href="#输出格式" class="headerlink" title="输出格式"></a>输出格式</h3><p>第一行一个整数T表示可能的方案数。<br>第二行至第T+1行每行一个数表示每段的起始位置。<br><a id="more"></a></p>
<h2 id="样例"><a href="#样例" class="headerlink" title="样例"></a>样例</h2><h3 id="样例输入"><a href="#样例输入" class="headerlink" title="样例输入"></a>样例输入</h3><blockquote>
<p>9 6<br>5<br>6<br>2<br>10<br>10<br>7<br>3<br>2<br>9<br>1<br>4<br>4<br>3<br>2<br>1</p>
</blockquote>
<h3 id="样例输出"><a href="#样例输出" class="headerlink" title="样例输出"></a>样例输出</h3><blockquote>
<p>1<br>3</p>
</blockquote>
<h2 id="提示​"><a href="#提示​" class="headerlink" title="提示​"></a>提示​</h2><p>对于20%的数据，N&lt;=1000<br>对于另外50%的数据，保证每个人的身高不超过2<br>对于100%的数据，N&lt;=100000，K&lt;=25000</p>
<h2 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h2><p>首先，数据范围是错的，实际上100%的K&lt;=N<br><strong>kmp+树状数组</strong><br>关于经典的kmp可以看这里：<a href="http://www.matrix67.com/blog/archives/115" target="_blank" rel="external">http://www.matrix67.com/blog/archives/115</a><br>这一题的匹配方式不是相等，而是满足相对关系，可以得到：<br>a[i..j]中小于a[j+1]的数和b[k..l]中小于b[l+1]的数个数相同，小于等于的个数也相同时，a[i..j]和b[k..l]是匹配的。<br>用树状数组维护这些值，然后注意一下端点的细节。</p>
<dir style="display:none"><a href="/2016/08/28/JSOI2016-提高1班-Day3-message/message.pas" title="复制代码">复制代码</a></dir>

<p>```delphi message.pas<br>type int=longint;<br>var<br>    a,bit,b,p,lb,ub,opt:array[0..100010] of int;<br>    n,k,i,j,l,cnt:int;</p>
<p>function lowbit(x:int):int;<br>begin lowbit:=x and (-x) end;</p>
<p>procedure add(x,k:int);<br>begin<br>    if x=0 then exit;<br>    while x&lt;=100010 do begin<br>        inc(bit[x],k);<br>        inc(x,lowbit(x));<br>    end;<br>end;</p>
<p>function sum(x:int):int;<br>begin<br>    sum:=0;<br>    while x&gt;0 do begin<br>        inc(sum,bit[x]);<br>        dec(x,lowbit(x));<br>    end;<br>end;</p>
<p>begin<br>    assign(input,’message.in’);reset(input);<br>    assign(output,’message.out’);rewrite(output);<br>    read(n,k);<br>    for i:=1 to n do read(a[i]);<br>    for i:=1 to k do read(b[i]);<br>    fillchar(bit,sizeof(bit),0);<br>    for i:=1 to k do begin<br>        add(b[i],1);<br>        ub[i]:=sum(b[i]);<br>        lb[i]:=sum(b[i]-1);<br>    end;<br>    fillchar(bit,sizeof(bit),0);<br>    p[1]:=0;j:=0;<br>    for i:=2 to k do begin<br>        add(b[i],1);<br>        while (j&lt;&gt;0) and ((lb[j+1]&lt;&gt;sum(b[i]-1)) or<br>            (ub[j+1]&lt;&gt;sum(b[i]))) do begin<br>            for l:=i-j to i-p[j]-1 do add(b[l],-1);<br>            j:=p[j];<br>        end;<br>        if (lb[j+1]=sum(b[i]-1)) and (ub[j+1]=sum(b[i])) then inc(j);<br>        p[i]:=j<br>    end;<br>    fillchar(bit,sizeof(bit),0);<br>    j:=0;cnt:=0;<br>    for i:=1 to n do begin<br>        add(a[i],1);<br>        while (j&lt;&gt;0) and ((lb[j+1]&lt;&gt;sum(a[i]-1)) or<br>            (ub[j+1]&lt;&gt;sum(a[i]))) do begin<br>            for l:=i-j to i-p[j]-1 do add(a[l],-1);<br>            j:=p[j];<br>        end;<br>        if (lb[j+1]=sum(a[i]-1)) and (ub[j+1]=sum(a[i])) then inc(j);<br>        if j=k then begin<br>            inc(cnt);opt[cnt]:=i-j+1;<br>            for l:=i-j+1 to i-p[j] do add(a[l],-1);<br>            j:=p[j];<br>        end;<br>    end;<br>    writeln(cnt);<br>    for i:=1 to cnt do writeln(opt[i]);<br>    close(input);close(output);<br>end.<br>```</p>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[雅礼中学2015模拟赛 motor]]></title>
      <url>https://cothrax.github.io/2016/08/28/%E9%9B%85%E7%A4%BC%E4%B8%AD%E5%AD%A62015%E6%A8%A1%E6%8B%9F%E8%B5%9B-motor/</url>
      <content type="html"><![CDATA[<h2 id="描述"><a href="#描述" class="headerlink" title="描述"></a>描述</h2><p>在你的强力援助下,PCY 成功完成了之前的所有任务,他觉得,现在正是出去浪的大好时光。于是,他来到高速公路上,找到一辆摩的前往几千公里以外他心仪的那家黄焖鸡米饭。由于 PCY 的品味异于常人,途经几百个城市的黄焖鸡米饭他都不屑一顾,他只愿意前往他心中最好的那家,但是为了一碗二十块钱的黄焖鸡米饭,他不愿意花上几千块的路费,他希望路费尽量少。高速路上的警察叔叔被他的行为所打动,于是在多方协调下,最多 K 条城市之间的高速收费站愿意免费为 PCY 放行(可以任意选择)。<br>显然,PCY 已经筋疲力尽,不想再动用自己的数学天才来计算他可以花费的最小路费,因此他希望你可以帮他最后一次,他说他可以请你吃大碗的黄焖鸡米饭,还可以加一瓶豆奶。<br>现在给你 N 个城市(编号为 0 … N - 1 ), M 条道路,和每条高速公路的花费 Wi ,以及题目所描述的 K。PCY 想从城市 S 到城市 T, 因为他对 T 城市的黄焖鸡米饭情有独钟。</p>
<h2 id="格式"><a href="#格式" class="headerlink" title="格式"></a>格式</h2><h3 id="输入格式"><a href="#输入格式" class="headerlink" title="输入格式"></a>输入格式</h3><p>第一行,三个整数 N,M,K ,如题意所描述<br>第二行,两个整数 S,T ,代表出发城市和目标城市编号<br>接下来 M 行,每行三个整数 X,Y,W ,代表 X 和 Y 城市之间的高速公路收费为 W 元</p>
<h3 id="输出格式"><a href="#输出格式" class="headerlink" title="输出格式"></a>输出格式</h3><p>共一行,输出一个整数,代表 PCY 最少需要花费的路费。<br><a id="more"></a></p>
<h2 id="样例"><a href="#样例" class="headerlink" title="样例"></a>样例</h2><h3 id="样例输入"><a href="#样例输入" class="headerlink" title="样例输入"></a>样例输入</h3><p>样例1</p>
<blockquote>
<p>3 3 1<br>1 3<br>0 1 50<br>1 2 30<br>1 3 50 </p>
</blockquote>
<p>样例2</p>
<blockquote>
<p>5 6 1<br>0 4<br>2 3 5<br>0 1 15<br>1 2 5<br>3 4 5<br>2 3 3<br>0 2 1005</p>
</blockquote>
<h3 id="样例输出"><a href="#样例输出" class="headerlink" title="样例输出"></a>样例输出</h3><p>样例1</p>
<blockquote>
<p>8</p>
</blockquote>
<p>样例2</p>
<blockquote>
<p>0</p>
</blockquote>
<h2 id="提示​"><a href="#提示​" class="headerlink" title="提示​"></a>提示​</h2><p>对于 10%的数据, N &lt;= 100,K = 0<br>对于 30%的数据, N &lt;= 5,M &lt;= 10,K &lt;= 2<br>对于 100%的数据, N &lt;= 10000,M &lt;= 50000,K &lt;= 10,Wi &lt;= 10000<br>内存限制 256M ,时间限制 1s</p>
<h2 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h2><p><strong>分层图</strong>入门题，考虑到k很小，我们把图复制k层，层i实际含义是有i条公路免费放行后的状态，在每层之间连边：<br>若原图中有边e(u,v)=w，那在在层i-1和层i间连边：e(g[i-1,u],g[i,v])=0，这样只能从上一层走到下一层。<br>这样，答案就是dist[g[0,s],g[k,t]]<br>注意题目是<strong>无向图</strong>，以及spfa会tle，用<strong>heap+dijkstra</strong></p>
<dir style="display:none"><a href="/2016/08/28/雅礼中学2015模拟赛-motor/motor2.pas" title="复制代码">复制代码</a></dir>

<p>```delphi motor2.pas<br>uses math;<br>const inf=1000000000;<br>type<br>    int=longint;<br>    edge=record t,w,next:int end;<br>var<br>    g:array[0..2500010] of edge;<br>    head,d:array[0..110010] of int;<br>    n,m,k,s0,t0,f,t,w,i,j,sz:int;</p>
<p>procedure add(f,t,w:int);<br>var m:int;<br>begin<br>    inc(sz);m:=sz;<br>    g[m].t:=t;g[m].w:=w;<br>    g[m].next:=head[f];head[f]:=m;<br>end;</p>
<p>procedure dijkstra(x:int);<br>var<br>    h:array[0..110010,0..1] of int;<br>    l:array[0..110010] of int;<br>    i,v,u,sz:int;</p>
<pre><code>procedure swap(i,j:int);
var tmp:int;
begin
    l[h[i,0]]:=j;l[h[j,0]]:=i;
    tmp:=h[i,0];h[i,0]:=h[j,0];h[j,0]:=tmp;
    tmp:=h[i,1];h[i,1]:=h[j,1];h[j,1]:=tmp;
end;
procedure heapify(i:int);
var l,r,s:int;
begin
    l:=i*2;r:=l+1;
    if (l&lt;=sz) and (h[l,1]&lt;h[i,1]) then s:=l else s:=i;
    if (r&lt;=sz) and (h[r,1]&lt;h[s,1]) then s:=r;
    if i&lt;&gt;s then begin
        swap(i,s);
        heapify(s);
    end;
end;
procedure extract();
begin
    swap(1,sz);
    dec(sz);
    heapify(1);
end;
procedure reduceto(i,k:int);
begin
    h[i,1]:=k;
    while (i&gt;1) and (h[i,1]&lt;h[i div 2,1]) do begin
        swap(i,i div 2);
        i:=i div 2;
    end;
end;
procedure insert(x,k:int);
begin
    inc(sz);
    h[sz,0]:=x;h[sz,1]:=inf;l[x]:=sz;
    reduceto(sz,k);
end;
</code></pre><p>begin<br>    sz:=0;<br>    for i:=0 to (k+1)*n do<br>        if i=x then insert(i,0) else insert(i,inf);<br>    while sz&gt;0 do begin<br>        v:=h[1,0];d[v]:=h[1,1];extract;<br>        i:=head[v];<br>        while i&lt;&gt;0 do begin<br>            u:=g[i].t;<br>            if (l[u]&lt;=sz) and (h[l[u],1]&gt;g[i].w+d[v]) then<br>                reduceto(l[u],g[i].w+d[v]);<br>            i:=g[i].next;<br>        end;<br>    end;<br>end;</p>
<p>begin<br>    assign(input,’motor.in’);reset(input);<br>    assign(output,’motor.out’);rewrite(output);<br>    read(n,m,k,s0,t0);sz:=0;<br>    for i:=1 to m do begin<br>        read(f,t,w);<br>        add(f,t,w);add(t,f,w);<br>        for j:=1 to k do begin<br>            add(f+j<em>n,t+j</em>n,w);<br>            add(t+j<em>n,f+j</em>n,w);<br>            add(f+(j-1)<em>n,t+j</em>n,0);<br>            add(t+(j-1)<em>n,f+j</em>n,0);<br>        end;<br>    end;<br>    dijkstra(s0);<br>    write(d[t0+k*n]);<br>    close(input);close(output);<br>end.<br>```</p>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[雅礼中学2015模拟赛 Day1]]></title>
      <url>https://cothrax.github.io/2016/08/25/%E9%9B%85%E7%A4%BC%E4%B8%AD%E5%AD%A62015%E6%A8%A1%E6%8B%9F%E8%B5%9B-Day1/</url>
      <content type="html"><![CDATA[<table>
<thead>
<tr>
<th>题目名称</th>
<th>源程序</th>
<th>输入/输出</th>
<th>空间限制</th>
<th>时间限制</th>
</tr>
</thead>
<tbody>
<tr>
<td>小W的动漫</td>
<td>t1.c/cpp/pas</td>
<td>t1.in/out</td>
<td>256MB</td>
<td>1s</td>
</tr>
<tr>
<td>PS的烦恼</td>
<td>t2.c/cpp/pas</td>
<td>t2.in/out</td>
<td>256MB</td>
<td>1s</td>
</tr>
<tr>
<td>小A做CF</td>
<td>t3.c/cpp/pas</td>
<td>t3.in/out</td>
<td>256MB</td>
<td>1s</td>
</tr>
</tbody>
</table>
<p>三道数学题orz</p>
<h1 id="P1-小W的动漫"><a href="#P1-小W的动漫" class="headerlink" title="P1 小W的动漫"></a>P1 小W的动漫</h1><p>小W最近迷上了日本动漫，每天都有无数部动漫的更新等着他去看，所以他必须将所有的动漫排个顺序，当然，虽然有无数部动漫，但除了1号动漫，每部动漫都有且仅有一部动漫是它的前传（父亲），也就是说，所有的动漫形成一个树形结构。而动漫的顺序必须满足一下两个限制：</p>
<ol>
<li>一部动漫的所有后继（子孙）都必须排在它的后面；</li>
<li>对于同一部动漫的续集（孩子），小W喜爱度高的须排在前面。</li>
</ol>
<p>光排序小W还不爽，他想知道一共有多少种排序方案，并且输出它mod 10007的答案。</p>
<h2 id="格式"><a href="#格式" class="headerlink" title="格式"></a>格式</h2><h3 id="输入格式"><a href="#输入格式" class="headerlink" title="输入格式"></a>输入格式</h3><p>第一行表示T表示数据组数。接下来每组数据第一行n表示有多少部动漫等待排序，接下来n行每行第一个数tot表示这部动漫有多少部续集，接下来tot个数按照小W喜爱从大到小给出它的续集的编号。</p>
<h3 id="输出格式"><a href="#输出格式" class="headerlink" title="输出格式"></a>输出格式</h3><p>每组数据一行数ans，表示答案mod 10007的结果。</p>
<a id="more"></a>
<h2 id="样例"><a href="#样例" class="headerlink" title="样例"></a>样例</h2><h3 id="样例输入"><a href="#样例输入" class="headerlink" title="样例输入"></a>样例输入</h3><blockquote>
<p>1<br>5<br>3 4 3 2<br>0<br>1 5<br>0<br>0</p>
<h3 id="样例输出"><a href="#样例输出" class="headerlink" title="样例输出"></a>样例输出</h3><p>2</p>
</blockquote>
<h2 id="提示​"><a href="#提示​" class="headerlink" title="提示​"></a>提示​</h2><p>30%的数据： n&lt;=10<br>60%的数据： n&lt;=100<br>100%的数据： n&lt;=1000</p>
<h2 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h2><p><strong>树形DP+组合数</strong><br>先多叉转二叉，兄弟节点按喜欢程度的顺序排列。<br>f[v]为子树v的方案数<br>ch为v的子节点（左节点），br为兄弟节点（右节点）<br>用sz[v]统计子树v的节点数<br>子树v的序列，可以看成合并子树br的序列和子树ch的序列得到的：<br>$f[v]=C(sz[br]+sz[ch],sz[ch])\cdot f[ch]\cdot f[br]$</p>
<dir style="display:none"><a href="/2016/08/25/雅礼中学2015模拟赛-Day1/t1.pas" title="复制代码">复制代码</a></dir>

<p>```delphi t1.pas<br>uses math;<br>const z=10007;<br>type int=longint;<br>var<br>    ch,br,s,sz,f:array[0..1010] of int;<br>    c:array[-1..1010,-1..1010] of int;<br>    n,i,j,k,t:int;</p>
<p>procedure add(p,c:int);<br>begin<br>    br[c]:=ch[p];<br>    ch[p]:=c;<br>end;    </p>
<p>procedure dp(v:int);<br>var sc,sb:int;<br>begin<br>    if v=0 then exit;<br>    dp(ch[v]);sc:=sz[ch[v]];<br>    dp(br[v]);sb:=sz[br[v]];<br>    sz[v]:=sc+sb+1;<br>    f[v]:=(c[sc+sb,sc]<em>f[ch[v]] mod z)</em>f[br[v]] mod z;<br>end;    </p>
<p>begin<br>    assign(input,’t1.in’);reset(input);<br>    assign(output,’t1.out’);rewrite(output);<br>    read(t);<br>    c[0,0]:=1;<br>    for i:=1 to 1000 do<br>        for j:=0 to i do<br>            c[i,j]:=(c[i-1,j-1]+c[i-1,j]) mod z;<br>    repeat<br>        read(n);<br>        fillchar(ch,sizeof(ch),0);<br>        fillchar(br,sizeof(br),0);<br>        for i:=1 to n do begin<br>            read(k);<br>            for j:=1 to k do read(s[j]);<br>            for j:=k downto 1 do add(i,s[j]);<br>        end;<br>        f[0]:=1;<br>        dp(1);<br>        writeln(f[1]);<br>        dec(t);<br>    until t=0;<br>    close(input);close(output);<br>end.</p>
<pre><code>
# P2 PS的烦恼
话说PS总是有着各种各样的烦恼，这天，他又在为自己失败的感情史烦恼着。这时，他心中的女神，魔法少女小圆从天而降，她对他说，如果你能帮我解决一个问题，我就让你永远没有烦恼。
问题是这样的：
寻找一个最大的k，使得存在一个x使得x^k=y，那么f(y)=k，即y最多可以开k次方根。
小圆的要求是求出从a到b的f值之和（包括a和b）。

## 格式
### 输入格式
多组数据，每组数据一行包含两个数a,b，文件以0 0（不需要输出）结尾。

### 输出格式
每组数据一行表示这一段f值之和。
&lt;!--more--&gt;

## 样例
### 样例输入
&gt;2 10
248832 248832
0 0

### 样例输出
&gt;13
5

## 提示​
30%的数据满足：a&lt;=1000 b&lt;=1000
100%的数据满足：2&lt;=a&lt;=b&lt;=10^18

## 题解
枚举指数k，$x^k\in [a,b]$的x的个数<span>$=\left \lfloor  b^{1/k}\right \rfloor -\left \lceil a^{1/k}\right \rceil+1$</span><!-- Has MathJax -->
$x^y=e^{ln(x^y)}=e^{y\cdot ln(x)}$，可以用`exp(y*ln(x))`得到。
注意精度！
1. k=1用b-a+1单独算
2. 重写floor和ceil，当`k-round(k)&lt;eps`时，`floor(k)=ceil(k)=k`

&lt;dir style=&quot;display:none&quot;&gt;<a href="/2016/08/25/雅礼中学2015模拟赛-Day1/t2.pas" title="复制代码">复制代码</a>&lt;/dir&gt;

```delphi t2.pas
uses math;
const eps:double=0.000000001;
type int=longint;
var 
    a,b,lim,ans:int64;i,j:int;
    g,f:array[0..100] of int64;

function fl(a:double):int64;
begin
    if abs(a-round(a))&lt;eps then exit(round(a))
    else exit(floor(a));
end;

function ce(a:double):int64;
begin
    if abs(a-round(a))&lt;eps then exit(round(a))
    else exit(ceil(a));
end;

begin
    assign(input,&#39;t2.in&#39;);reset(input);
    assign(output,&#39;t2.out&#39;);rewrite(output);
    read(a,b);
    while (a&lt;&gt;0) and (b&lt;&gt;0) do begin
        fillchar(g,sizeof(g),0);
        fillchar(f,sizeof(f),0);
        lim:=floor(ln(b)/ln(2));
        f[1]:=b-a+1;
        for i:=2 to lim do
            f[i]:=fl(exp(1/i*ln(b)))-ce(exp(1/i*ln(a)))+1;
        for i:=lim downto 1 do begin
            g[i]:=f[i];j:=2*i;
            while j&lt;=lim do begin
                dec(g[i],g[j]);
                inc(j,i);
            end;
        end;
        ans:=0;
        for i:=1 to lim do inc(ans,g[i]*i);
        writeln(ans);
        read(a,b);
    end;
    close(input);close(output);
end.
</code></pre><h1 id="P3-小A做CF"><a href="#P3-小A做CF" class="headerlink" title="P3 小A做CF"></a>P3 小A做CF</h1><p>目标rating超过CLJ的小A最近在疯狂做CF，话说这次CF在赛前十分钟出了个相当奇葩的预选题，要求十分钟内必须做出这道题才能参加这次CF。<br>这道题是这样的，给你一个N*N的矩阵，每行有一个障碍，数据保证任意两个障碍不在同一行，任意两个障碍不在同一列，要求你在这个矩阵上放N枚棋子（障碍的位置不能放棋子），要求你放N个棋子也满足每行只有一枚棋子，每列只有一枚棋子的限制，求有多少种方案。<br>最近被各种神题折磨得死去活来，走火入魔的小A一下被这个超级水题给卡住了，但是这次是超过CLJ的最佳机会，于是，心急火燎的他找到了你，请你带他顺利参加这次CF正赛吧。</p>
<h2 id="格式-1"><a href="#格式-1" class="headerlink" title="格式"></a>格式</h2><h3 id="输入格式-1"><a href="#输入格式-1" class="headerlink" title="输入格式"></a>输入格式</h3><p>第一行一个N，接下来一个N*N的矩阵。</p>
<h3 id="输出格式-1"><a href="#输出格式-1" class="headerlink" title="输出格式"></a>输出格式</h3><p>合法方案数。<br><!--more--></p>
<h2 id="样例-1"><a href="#样例-1" class="headerlink" title="样例"></a>样例</h2><h3 id="样例输入-1"><a href="#样例输入-1" class="headerlink" title="样例输入"></a>样例输入</h3><blockquote>
<p>2<br>0 1<br>1 0</p>
</blockquote>
<h3 id="样例输出-1"><a href="#样例输出-1" class="headerlink" title="样例输出"></a>样例输出</h3><blockquote>
<p>1</p>
</blockquote>
<h2 id="提示​-1"><a href="#提示​-1" class="headerlink" title="提示​"></a>提示​</h2><p>20%的数据保证： N&lt;=10<br>60%的数据保证： N&lt;=20<br>100%的数据保证： N&lt;=200</p>
<h2 id="题解-1"><a href="#题解-1" class="headerlink" title="题解"></a>题解</h2><p>我的组合数学好烂啊QAQ。这是<strong>错排计数+高精度</strong><br>我们发现交换任意两行或两列对答案是没有影响的，所以可以把所有障碍换到主对角线上，这样就变成了错排计数。</p>
<blockquote>
<p>考虑一个有n个元素的排列，若一个排列中所有的元素都不在自己原来的位置上，那么这样的排列就称为原排列的一个错排。 –Wikipedia</p>
</blockquote>
<p>记f[i]是序列1..i的错排数，考虑两种情况</p>
<ol>
<li>1放在了k位置，k放在了1位置，那么就变成了f[i-2]</li>
<li>1放在了k位置，k没有放在1位置，这变成了f[i-1]</li>
</ol>
<p>而k的选取有i-1种，于是$f[i]=(i-1)(f[i-1]+f[i-2])$<br>然后上高精度。<br>答案与障碍的位置一点关系也没有。</p>
<dir style="display:none"><a href="/2016/08/25/雅礼中学2015模拟赛-Day1/t3.pas" title="复制代码">复制代码</a></dir>

<p>```delphi t3.pas<br>uses math;<br>const<br>    bs=100000000;<br>    k=8;<br>type<br>    int=longint;<br>    big=array[0..500] of int64;</p>
<p>function add(a,b:big):big;<br>var i:int;<br>begin<br>    fillchar(add,sizeof(add),0);<br>    add[0]:=max(a[0],b[0]);<br>    for i:=1 to add[0] do begin<br>        inc(add[i],a[i]+b[i]);<br>        inc(add[i+1],add[i] div bs);<br>        add[i]:=add[i] mod bs;<br>    end;<br>    if add[add[0]+1]&gt;0 then inc(add[0]);<br>end;</p>
<p>function mul(a:big;b:int):big;<br>var i:int;<br>begin<br>    fillchar(mul,sizeof(mul),0);<br>    mul[0]:=a[0];<br>    for i:=1 to mul[0] do begin<br>        inc(mul[i],a[i]*b);<br>        inc(mul[i+1],mul[i] div bs);<br>        mul[i]:=mul[i] mod bs;<br>    end;<br>    while mul[mul[0]+1]&gt;0 do inc(mul[0]);<br>end;</p>
<p>procedure print(a:big);<br>var i,j,x:int;<br>begin<br>    //if a[0]=0 then begin write(0);exit end;<br>    write(a[a[0]]);<br>    for i:=a[0]-1 downto 1 do begin<br>        if a[i]=0 then x:=1 else x:=floor(ln(a[i])/ln(10))+1;<br>        for j:=1 to k-x do write(0);<br>        write(a[i]);<br>    end;<br>end;</p>
<p>var<br>    n,i:int;<br>    f:array[0..2] of big;<br>begin<br>    assign(input,’t3.in’);reset(input);<br>    assign(output,’t3.out’);rewrite(output);<br>    read(n);<br>    f[1][0]:=0;<br>    f[2][0]:=1;f[2][1]:=1;<br>    for i:=3 to n do<br>        f[i mod 3]:=mul(add(f[(i-1) mod 3],f[(i-2) mod 3]),i-1);<br>    print(f[n mod 3]);<br>    close(input);close(output);<br>end.<br>```</p>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[[POJ] P3279 Fliptile]]></title>
      <url>https://cothrax.github.io/2016/08/25/POJ-P3279-Fliptile/</url>
      <content type="html"><![CDATA[<h2 id="描述"><a href="#描述" class="headerlink" title="描述"></a>描述</h2><p>Farmer John knows that an intellectually satisfied cow is a happy cow who will give more milk. He has arranged a brainy activity for cows in which they manipulate an M × N grid (1 ≤ M ≤ 15; 1 ≤ N ≤ 15) of square tiles, each of which is colored black on one side and white on the other side.</p>
<p>As one would guess, when a single white tile is flipped, it changes to black; when a single black tile is flipped, it changes to white. The cows are rewarded when they flip the tiles so that each tile has the white side face up. However, the cows have rather large hooves and when they try to flip a certain tile, they also flip all the adjacent tiles (tiles that share a full edge with the flipped tile). Since the flips are tiring, the cows want to minimize the number of flips they have to make.</p>
<p>Help the cows determine the minimum number of flips required, and the locations to flip to achieve that minimum. If there are multiple ways to achieve the task with the minimum amount of flips, return the one with the least lexicographical ordering in the output when considered as a string. If the task is impossible, print one line with the word “IMPOSSIBLE”.</p>
<h2 id="格式"><a href="#格式" class="headerlink" title="格式"></a>格式</h2><h3 id="输入格式"><a href="#输入格式" class="headerlink" title="输入格式"></a>输入格式</h3><p>Line 1: Two space-separated integers: M and N<br>Lines 2..M+1: Line i+1 describes the colors (left to right) of row i of the grid with N space-separated integers which are 1 for black and 0 for white</p>
<h3 id="输出格式"><a href="#输出格式" class="headerlink" title="输出格式"></a>输出格式</h3><p>Lines 1..M: Each line contains N space-separated integers, each specifying how many times to flip that particular location.<br><a id="more"></a></p>
<h2 id="样例"><a href="#样例" class="headerlink" title="样例"></a>样例</h2><h3 id="样例输入"><a href="#样例输入" class="headerlink" title="样例输入"></a>样例输入</h3><blockquote>
<p>4 4<br>1 0 0 1<br>0 1 1 0<br>0 1 1 0<br>1 0 0 1</p>
</blockquote>
<h3 id="样例输出"><a href="#样例输出" class="headerlink" title="样例输出"></a>样例输出</h3><blockquote>
<p>0 0 0 0<br>1 0 0 1<br>1 0 0 1<br>0 0 0 0</p>
</blockquote>
<h2 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h2><p>这些牛玩的是ubuntu自带的小游戏叫关灯。<br>这是一个二维的反转问题，这在<a href="/2016/08/23/JSOI2016-提高2班-贪心/" title="贪心P2">贪心P2</a>中提到过。<br>考察点(i,j)，可以反转它的格子有5个，不便于处理，我么可以先枚举第一行的翻转方法，让后for i=2..n for j=1..m逐格枚举，这样每个格子是否要翻转就唯一确定了。<br>比如说(2,2)，由于(1,i)已知，(2,1)已经考察过了，能翻转(1,2)的只有(2,2)，于是如果(1,2)=1，那(2,2)就要翻转。<br>当全部考虑过后，如果发现最后一行还有为1个格子，那就无解。<br>另外第一行的方法可以用位运算表示。<br>可以用ac的程序玩游戏啦。<br><img src="/2016/08/25/POJ-P3279-Fliptile/game.png" alt="game.png" title=""></p>
<dir style="display:none"><a href="/2016/08/25/POJ-P3279-Fliptile/3279.pas" title="复制代码">复制代码</a></dir>

<p>```delphi 3279.pas<br>type int=longint;<br>const d:array[0..4,0..1] of int=<br>    ((0,0),(0,1),(1,0),(-1,0),(0,-1));<br>var<br>    n,m,j,k,x,ans,cnt:int;i:int;<br>    mat,tmp,opt,cur:array[0..16,0..16] of int;</p>
<p>function min(a,b:int):int;<br>begin if a&lt;b then min:=a else min:=b end;</p>
<p>procedure flip(x,y:int);<br>var i:int;p:^int;<br>begin<br>    inc(cnt);inc(cur[x,y]);<br>    for i:=0 to 4 do begin<br>        p:=@mat[x+d[i,0],y+d[i,1]];<br>        p^:=1-p^;<br>    end;<br>end;</p>
<p>begin<br>    read(n,m);<br>    for i:=1 to n do<br>        for j:=1 to m do read(mat[i,j]);</p>
<pre><code>tmp:=mat;ans:=maxlongint;
for i:=0 to 1 shl m-1 do begin
    j:=i;cnt:=0;
    fillchar(cur,sizeof(cur),0);
    while j&lt;&gt;0 do begin
        x:=j and (-j);
        flip(1,round(ln(x)/ln(2))+1);
        dec(j,x);
    end;
    for j:=2 to n do
        for k:=1 to m do
            if mat[j-1,k]=1 then flip(j,k);

    for j:=1 to m do
        if mat[n,j]=1 then begin 
            cnt:=maxlongint;
            break; 
        end;
    if cnt&lt;ans then begin ans:=cnt;opt:=cur end;
    mat:=tmp;
end; 

if ans=maxlongint then write(&#39;IMPOSSIBLE&#39;)
else 
    for i:=1 to n do begin
        for j:=1 to m do write(opt[i,j],&#39; &#39;);
        writeln;
    end;
</code></pre><p>end.<br>```</p>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[[JSOI2016] 提高2班 DP]]></title>
      <url>https://cothrax.github.io/2016/08/24/JSOI2016-%E6%8F%90%E9%AB%982%E7%8F%AD-DP/</url>
      <content type="html"><![CDATA[<h1 id="P1-飞扬的小鸟"><a href="#P1-飞扬的小鸟" class="headerlink" title="P1 飞扬的小鸟"></a>P1 飞扬的小鸟</h1><p>Flappy Bird 是一款风靡一时的休闲手机游戏。玩家需要不断控制点击手机屏幕的频率来调节小鸟的飞行高度，让小鸟顺利通过画面右方的管道缝隙。如果小鸟一不小心撞到了水管或者掉在地上的话，便宣告失败。<br><img src="/2016/08/24/JSOI2016-提高2班-DP/noip2014tgd1p3i1.jpg" alt="noip2014tgd1p3i1.jpg" title=""><br>为了简化问题，我们对游戏规则进行了简化和改编：</p>
<ol>
<li>游戏界面是一个长为 n，高为 m 的二维平面，其中有k 个管道（忽略管道的宽度）。</li>
<li>小鸟始终在游戏界面内移动。小鸟从游戏界面最左边 任意整数高度位置出发，到达游戏界面最右边时，游戏完成。</li>
<li>小鸟每个单位时间沿横坐标方向右移的距离为 1，竖直移动的距离由玩家控制。如果点击屏幕，小鸟就会上升一定高度 X，每个单位时间可以点击多次，效果叠加； 如果不点击屏幕，小鸟就会下降一定高度 Y。小鸟位于横坐标方向不同位置时，上 升的高度 X 和下降的高度 Y 可能互不相同。</li>
<li>小鸟高度等于 0 或者小鸟碰到管道时，游戏失败。小鸟高度为 m 时，无法再上升。</li>
</ol>
<p>现在，请你判断是否可以完成游戏。如果可以，输出最少点击屏幕数；否则，输出小鸟最多可以通过多少个管道缝隙。</p>
<h2 id="格式"><a href="#格式" class="headerlink" title="格式"></a>格式</h2><h3 id="输入格式"><a href="#输入格式" class="headerlink" title="输入格式"></a>输入格式</h3><p>第 1 行有 3 个整数 n，m，k，分别表示游戏界面的长度，高度和水管的数量，每两个 整数之间用一个空格隔开；<br>接下来的 n 行，每行 2 个用一个空格隔开的整数 X 和 Y，依次表示在横坐标位置 0~n-1 上玩家点击屏幕后，小鸟在下一位置上升的高度 X，以及在这个位置上玩家不点击屏幕时， 小鸟在下一位置下降的高度 Y。<br>接下来 k 行，每行 3 个整数 P，L，H，每两个整数之间用一个空格隔开。每行表示一个管道，其中 P 表示管道的横坐标，L 表示此管道缝隙的下边沿高度为 L，H 表示管道缝隙上边沿的高度（输入数据保证 P 各不相同，但不保证按照大小顺序给出）。</p>
<h3 id="输出格式"><a href="#输出格式" class="headerlink" title="输出格式"></a>输出格式</h3><p>共两行。<br>第一行，包含一个整数，如果可以成功完成游戏，则输出 1，否则输出 0。 第二行，包含一个整数，如果第一行为 1，则输出成功完成游戏需要最少点击屏幕数，否则，输出小鸟最多可以通过多少个管道缝隙。<br><a id="more"></a></p>
<h2 id="样例"><a href="#样例" class="headerlink" title="样例"></a>样例</h2><h3 id="样例输入"><a href="#样例输入" class="headerlink" title="样例输入"></a>样例输入</h3><blockquote>
<p>10 10 6<br>3 9<br>9 9<br>1 2<br>1 3<br>1 2<br>1 1<br>2 1<br>2 1<br>1 6<br>2 2<br>1 2 7<br>5 1 5<br>6 3 5<br>7 5 8<br>8 7 9<br>9 1 3</p>
</blockquote>
<h3 id="样例输出"><a href="#样例输出" class="headerlink" title="样例输出"></a>样例输出</h3><blockquote>
<p>1<br>6</p>
</blockquote>
<h2 id="提示​"><a href="#提示​" class="headerlink" title="提示​"></a>提示​</h2><p>对于 30%的数据：5≤n≤10，5≤m≤10，k=0，保证存在一组最优解使得同一单位时间最多点击屏幕 3 次；<br>对于 50%的数据：5≤n≤20，5≤m≤10，保证存在一组最优解使得同一单位时间最多点击屏幕 3 次；<br>对于 70%的数据：5≤n≤1000，5≤m≤100；<br>对于 100%的数据：<span>$5&le;n&le;10000,5&le;m&le;1000,0&le;k&lt;n,$</span><!-- Has MathJax --><br><span>$0&lt;X&lt;m,0&lt;Y&lt;m,0&lt;P&lt;n,0&le;L&lt;H&le;m,L+1&lt;H$</span><!-- Has MathJax -->。</p>
<p>如下图所示，蓝色直线表示小鸟的飞行轨迹，红色直线表示管道。<br><img src="/2016/08/24/JSOI2016-提高2班-DP/noip2014tgd1p3i2.png" alt="noip2014tgd1p3i2.png" title=""></p>
<p>NOIP2014 提高组 Day1</p>
<h2 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h2><p>变形背包，几个注意点</p>
<ol>
<li>顶端要特判一下</li>
<li>以下方案是<strong>不可行</strong>的：对于第i列，<strong>只</strong>对不被管道覆盖的点做背包。<br>因为用了完全背包的$O(N^2)$优化，被管道覆盖的点是有可能作为中间值出现的，所以正确的方案是：<strong>先该列对所有做背包，然后把被管道覆盖的点标记为inf。</strong></li>
</ol>
<dir style="display:none"><a href="/2016/08/24/JSOI2016-提高2班-DP/pp1907.pas" title="复制代码">复制代码</a></dir>

<p>```delphi pp1907.pas<br>uses math;<br>type int=longint;<br>const inf=1000000000;<br>var<br>    n,m,k,i,i1,i0,j,cnt,ans:int;<br>    x,y,lb,ub:array[0..10010] of int;<br>    flag:array[0..10010] of boolean;b:boolean;<br>    f:array[0..1,0..1010] of int;</p>
<p>begin<br>    read(n,m,k);<br>    for i:=1 to n do begin<br>        read(x[i],y[i]);<br>        lb[i]:=0;ub[i]:=m+1;<br>    end;<br>    fillchar(flag,sizeof(flag),false);<br>    for i:=1 to k do begin<br>        read(j);read(lb[j],ub[j]);<br>        flag[j]:=true;<br>    end;</p>
<pre><code>filldword(f[0],sizeof(f[0]) div 4,inf);
for i:=1 to m do f[0,i]:=0;
cnt:=0;
for i:=1 to n do begin
    i1:=i mod 2;i0:=1-i1;
    filldword(f[i1],sizeof(f[i1]) div 4,inf);
    for j:=1+x[i] to m do //完全背包（上升）
        f[i1,j]:=min(f[i1,j],min(f[i1,j-x[i]],f[i0,j-x[i]])+1);
    for j:=0 to x[i] do //特判顶点
        f[i1,m]:=min(f[i1,m],min(f[i0,m-j],f[i1,m-j])+1);
    for j:=1 to m-y[i] do //01背包（下落）
        f[i1,j]:=min(f[i1,j],f[i0,j+y[i]]);
    //不可达的点标记为inf
    for j:=1 to lb[i] do f[i1,j]:=inf;
    for j:=ub[i] to m do f[i1,j]:=inf;
    //判无解，和cnt更新
    b:=false;
    for j:=1 to m do
        if f[i1,j]&lt;&gt;inf then begin b:=true;break end;
    if not b then break
    else if flag[i] then inc(cnt);
end;
if b then begin
    ans:=inf;i1:=n mod 2;
    for i:=1 to m do ans:=min(ans,f[i1,i]);
    writeln(1);write(ans);
end else begin
    writeln(0);write(cnt);
end;
</code></pre><p>end.</p>
<pre><code>
# P2 Sanguo
After East Han dynasty, China was divided into several states. Wei, Wu, and Shu are the greatest three states among them. This was the era of Sanguo. During this period, wars frequently happened between states. Zhuge Liang, the commander and strategist of Shu, wanted to enlarge Shu&#39;s power. He was considering conquering N cities. However, these cities must be defeated in a specified order. City-X could be defeated only after City-1, City-2, City-3 ... City-(X-1) had been defeated. However, passing through the cities that had not been defeated was eligible. Zhuge wanted to use three generals, Guan Yu, Zhang Fei, and Zhao yun, each of whom should lead an army. The three armies, started from Yizhou, which was numbered with City-0. After conquered all the N cities (each cities must be conquered at least by one army), they had to return to Yizhou.
The N cities and Yizhou were connected by M bi-directed roads. To travel from city to city was a very boring and expensive thing. So Zhuge wanted to minimize the total length of the three armies&#39; traveling. You were hired to help him to compute the minimum total length of the traveling.

## 格式
### 输入格式
Line1: two integers N and M. N is the number of cities Zhuge wanted to conquer, and M is the number of roads between the N + 1 cities.
Line2...Line(M+1): each line contain 3 integers, X, Y, Len, indicating a road between City-X and City-Y, with the length of Len.
You can suppose that all the N + 1 cities are connected.
N ≤ 500, M ≤ 20000, Len ≤ 1000

### 输出格式
Line1: an integer, which is the minimum total length of the three armies&#39; traveling.
&lt;!--more--&gt;

## 样例
### 样例输入
&gt;5 15
5 5 48
1 4 658
4 0 843
1 4 41
1 4 330
5 2 864
4 2 115
4 0 303
2 3 685
0 0 879
1 5 649
2 4 942
4 0 379
5 2 769
5 1 856

### 样例输出
&gt;3668

## 题解
**图上DP+floyd+滚动数组**
跑floyd得任意两点最短路d[i,j]。
$f[i,j,k]$表示已经1..i的城市，三支部队分别在i,j,k(j,k&lt;=i)的最小路程。
$f[0,0,0]=0$
$f[i+1,j,k]=min(f[i+1,j,k],f[i,j,k]+d[i,i+1])$
$f[i+1,i,k]=min(f[i+1,i,k],f[i,j,k]+d[j,i+1])$
$f[i+1,i,j]=min(f[i+1,i,j],f[i,j,k]+d[k,i+1])$
<span>$ans=min\{f[n,j,k]+d[n,0]+d[j,0]+d[k,0]\}$</span><!-- Has MathJax -->
滚动数组注意每次用的时候，要**初始化**。
&lt;dir style=&quot;display:none&quot;&gt;<a href="/2016/08/24/JSOI2016-提高2班-DP/3368.pas" title="复制代码">复制代码</a>&lt;/dir&gt;

```delphi 3368.pas
uses math;
const inf=100000000;
type int=longint;
var n,m,i,j,k,tmp,ans,i0,i1:int;
    d:array[0..510,0..510] of int;
    f:array[0..1,0..510,0..510] of int;

begin
    read(n,m);
    filldword(d,sizeof(d) div 4,inf);
    for i:=1 to m do begin
        read(j,k,tmp);
        d[j,k]:=min(d[j,k],tmp);d[k,j]:=d[j,k];
    end;
    for i:=0 to n do d[i,i]:=0;
    for k:=0 to n do
        for i:=0 to n do
            for j:=0 to n do
                d[i,j]:=min(d[i,j],d[i,k]+d[k,j]);

    filldword(f,sizeof(f) div 4,inf);
    f[0,0,0]:=0;
    for i:=0 to n do begin
        i0:=i mod 2;i1:=1-i0;
        filldword(f[i1],sizeof(f[i1]) div 4,inf);
        for j:=0 to i do
            for k:=0 to i do begin
                f[i1,j,k]:=min(f[i1,j,k],f[i0,j,k]+d[i,i+1]);
                f[i1,i,k]:=min(f[i1,i,k],f[i0,j,k]+d[j,i+1]);
                f[i1,j,i]:=min(f[i1,j,i],f[i0,j,k]+d[k,i+1]);
            end;
    end;
    ans:=inf;i0:=n mod 2;
    for i:=0 to n do
        for j:=0 to n do
            ans:=min(ans,f[i0,i,j]+d[0,n]+d[i,0]+d[j,0]);
    write(ans);
end.
</code></pre><h1 id="P3-子矩阵"><a href="#P3-子矩阵" class="headerlink" title="P3 子矩阵"></a>P3 子矩阵</h1><p>给出如下定义：</p>
<ol>
<li>子矩阵：从一个矩阵当中选取某些行和某些列交叉位置所组成的新矩阵（保持行与 列的相对顺序）被称为原矩阵的一个子矩阵。<br>例如，下面左图中选取第 2、4 行和第 2、4、5 列交叉位置的元素得到一个 2*3 的子矩阵如右图所示。<img src="/2016/08/24/JSOI2016-提高2班-DP/noip2014pjp4.png" alt="noip2014pjp4.png" title=""></li>
<li>相邻的元素：矩阵中的某个元素与其上下左右四个元素（如果存在的话）是相邻的。</li>
<li>矩阵的分值：矩阵中每一对相邻元素之差的绝对值之和。</li>
</ol>
<p>本题任务：给定一个 n 行 m 列的正整数矩阵，请你从这个矩阵中选出一个 r 行 c 列的 子矩阵，使得这个子矩阵的分值最小，并输出这个分值。</p>
<h2 id="格式-1"><a href="#格式-1" class="headerlink" title="格式"></a>格式</h2><h3 id="输入格式-1"><a href="#输入格式-1" class="headerlink" title="输入格式"></a>输入格式</h3><p>第一行包含用空格隔开的四个整数 n，m，r，c，意义如问题描述中所述，每两个整数之间用一个空格隔开。<br>接下来的 n 行，每行包含 m 个用空格隔开的整数，用来表示问题描述中那个 n 行 m 列的矩阵。</p>
<h3 id="输出格式-1"><a href="#输出格式-1" class="headerlink" title="输出格式"></a>输出格式</h3><p>输出共 1 行，包含 1 个整数，表示满足题目描述的子矩阵的最小分值。<br><!--more--></p>
<h2 id="样例-1"><a href="#样例-1" class="headerlink" title="样例"></a>样例</h2><h3 id="样例输入-1"><a href="#样例输入-1" class="headerlink" title="样例输入"></a>样例输入</h3><blockquote>
<p>5 5 2 3<br>9 3 3 3 9<br>9 4 8 7 4<br>1 7 4 6 6<br>6 8 5 6 9<br>7 4 5 6 1</p>
<p>7 7 3 3<br>7 7 7 6 2 10 5<br>5 8 8 2 1 6 2<br>2 9 5 5 6 1 7<br>7 9 3 6 1 7 8<br>1 9 1 4 7 8 8<br>10 5 9 1 1 8 10<br>1 3 1 5 4 8 6</p>
</blockquote>
<h3 id="样例输出-1"><a href="#样例输出-1" class="headerlink" title="样例输出"></a>样例输出</h3><blockquote>
<p>6</p>
<p>16</p>
</blockquote>
<h3 id="提示"><a href="#提示" class="headerlink" title="提示"></a>提示</h3><p>对于 50%的数据，1 ≤ n ≤ 12, 1 ≤ m ≤ 12, 矩阵中的每个元素 1 ≤ a[i][j] ≤20；<br>对于 100%的数据，1 ≤ n ≤ 16, 1 ≤ m ≤ 16, 矩阵中的每个元素 1 ≤ a[i][j] ≤1000,1 ≤ r ≤ n, 1 ≤ c ≤ m。<br>时间限制：每一组测试数据1s。</p>
<p>NOIP2014 普及组</p>
<h2 id="题解-1"><a href="#题解-1" class="headerlink" title="题解"></a>题解</h2><p>怎么普及组的DP写了这么久。。。<br>先<strong>dfs</strong>枚举选的<strong>行</strong><br>再在<strong>列</strong>上<strong>DP</strong><br>乍一看似乎是01背包，但发现前一列的选取对后一列是有影响的，所以不是。</p>
<p>f[i,j]选了i列，最后一列是j时的最小值<br>cal(i,j)：第i列和第j列放一起，在已知选的是哪几行时，横向相邻能产生的分值<br>v[i]：在已知选的哪几行时，第i列纵向相邻能产生的分值<br>方程长这样：$f[i,j]=f[i,k]+cal(k,i)+v[j] 0≤k≤j-1$<br>特别的$cal(0,i)=0$<br>答案是<span>$min\{f[c,i]\}$</span><!-- Has MathJax --></p>
<dir style="display:none"><a href="/2016/08/24/JSOI2016-提高2班-DP/p1914.pas" title="复制代码">复制代码</a></dir>

<p>```delphi p1914.pas<br>uses math;<br>type int=longint;<br>const inf=100000000;<br>var<br>    n,m,r,c,i,j,ans:int;<br>    mat:array[0..17,0..17] of int;<br>    s:array[0..17] of int;</p>
<p>function cal(a,b:int):int;<br>var i:int;<br>begin<br>    if min(a,b)=0 then exit(0);<br>    cal:=0;<br>    for i:=1 to r do<br>        inc(cal,abs(mat[s[i],a]-mat[s[i],b]));<br>end;</p>
<p>procedure dp();<br>var<br>    i,j,k,tmp:int;<br>    f:array[0..17,0..17] of int;<br>    v:array[0..17] of int;<br>begin<br>    fillchar(v,sizeof(v),0);<br>    for i:=1 to m do begin<br>        v[i]:=0;<br>        for j:=2 to r do<br>            inc(v[i],abs(mat[s[j],i]-mat[s[j-1],i]));<br>    end;<br>    filldword(f,sizeof(f) div 4,inf);<br>    f[0,0]:=0;<br>    for i:=1 to c do<br>        for j:=i to m do<br>            for k:=0 to j-1 do<br>                f[i,j]:=min(f[i,j],f[i-1,k]+cal(j,k)+v[j]);<br>    tmp:=inf;<br>    for i:=1 to n do tmp:=min(tmp,f[c,i]);<br>    ans:=min(tmp,ans);<br>end;</p>
<p>procedure dfs(i,j:int);<br>begin<br>    if j&gt;r then exit;<br>    if i=n+1 then begin<br>        if j=r then dp();<br>        exit;<br>    end;<br>    s[j+1]:=i;<br>    dfs(i+1,j+1);<br>    dfs(i+1,j);<br>end;</p>
<p>begin<br>    read(n,m,r,c);<br>    for i:=1 to n do<br>        for j:=1 to n do read(mat[i,j]);<br>    ans:=inf;<br>    dfs(1,0);<br>    write(ans);<br>end.<br>```</p>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[[JSOI2016] 提高2班 贪心]]></title>
      <url>https://cothrax.github.io/2016/08/23/JSOI2016-%E6%8F%90%E9%AB%982%E7%8F%AD-%E8%B4%AA%E5%BF%83/</url>
      <content type="html"><![CDATA[<p>贪心考的是RP，想对贪心策略就A了，想不到只有乱搞了。</p>
<h1 id="P1-拼点游戏"><a href="#P1-拼点游戏" class="headerlink" title="P1 拼点游戏"></a>P1 拼点游戏</h1><p>C和S两位同学一起玩拼点游戏。有一堆白色卡牌和一堆蓝色卡牌，每张卡牌上写了一个整数点数。C随机抽取n张白色卡牌，S随机抽取n张蓝色卡牌，他们进行n回合拼点，每次两人各出一张卡牌，点数大者获得三颗巧克力，小者获得一颗巧克力，如果点数相同，每人各得二颗巧克力，使用过的卡牌不得重复使用。已知C和S取到的卡牌点数，请编程计算S最多和最少能得到多少颗巧克力。</p>
<h2 id="格式"><a href="#格式" class="headerlink" title="格式"></a>格式</h2><h3 id="输入格式"><a href="#输入格式" class="headerlink" title="输入格式"></a>输入格式</h3><p>输入包含多组测试数据。<br>每组测试数据的第一行是一个整数n(1&lt;=n&lt;=1000)，接下来一行是n个整数，表示C抽到的白色卡牌的点数，下一行也是n个整数，表示S抽到的蓝色卡牌的点数。<br>输入的最后以一个0表示结束。</p>
<h3 id="输出格式"><a href="#输出格式" class="headerlink" title="输出格式"></a>输出格式</h3><p>对每组数据，输出一行，内容是两个整数用空格格开，分别表示S最多和最少可获得的巧克力数。<br><a id="more"></a></p>
<h2 id="样例"><a href="#样例" class="headerlink" title="样例"></a>样例</h2><h3 id="样例输入"><a href="#样例输入" class="headerlink" title="样例输入"></a>样例输入</h3><blockquote>
<p>3<br>92 83 71<br>95 87 74<br>2<br>20 20<br>20 20<br>2<br>20 19<br>22 18<br>0</p>
</blockquote>
<h3 id="样例输出"><a href="#样例输出" class="headerlink" title="样例输出"></a>样例输出</h3><blockquote>
<p>9 5<br>4 4<br>4 4</p>
</blockquote>
<h2 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h2><p>第一个想到的是二分图匹配，但n≤1000 KM算法的复杂度是无法承受的。<br>其实是贪心，类似于田忌赛马。</p>
<ol>
<li>S的最小牌x&gt;C的最小牌y，先得3分。因为比x大的牌一定比x有更广的适用性，保留一定是更优的</li>
<li>S的最大牌x&gt;C的最大牌y，先得3分。因为如果s次大牌z比y小，不选x的话只能得1分，如果z也比y大，由于y是C的最大牌，取x和z是等价的。</li>
<li>上述都不满足，取S的最小牌消耗Y的最大牌</li>
</ol>
<p>最小得分就是4*n（总得分）-C的最大得分</p>
<dir style="display:none"><a href="/2016/08/23/JSOI2016-提高2班-贪心/2986.pas" title="复制代码">复制代码</a></dir>

<p>```delphi 2986.pas<br>type<br>    int=longint;<br>    arr=array[0..1010] of int;<br>var<br>    n,i:int;<br>    a,b:arr;</p>
<p>procedure swap(var a,b:int);<br>var tmp:int;<br>begin tmp:=a;a:=b;b:=tmp end;</p>
<p>procedure qsort(var a:arr;b,e:int);<br>var i,j,x:int;<br>begin<br>    i:=b;j:=e;x:=a[random(e-b)+b];<br>    repeat<br>        while a[i]<x do="" inc(i);="" while="" a[j]="">x do dec(j);<br>        if i&lt;=j then begin<br>            swap(a[i],a[j]);<br>            inc(i);dec(j);<br>        end;<br>    until i&gt;j;<br>    if i&lt;e then qsort(a,i,e);<br>    if b&lt;j then qsort(a,b,j);<br>end;</x></p>
<p>function solve(a,b:arr):int;<br>var la,lb,ra,rb,ans:int;<br>begin<br>    la:=1;lb:=1;ra:=n;rb:=n;ans:=0;<br>    while (la&lt;=ra) and (lb&lt;=rb) do begin<br>        if a[la]&lt;b[lb] then begin inc(ans,3);inc(la);inc(lb) end<br>        else if a[ra]&lt;b[rb] then begin inc(ans,3);dec(ra);dec(rb) end<br>        else if a[ra]=b[lb] then begin inc(ans,2);dec(ra);inc(lb) end<br>        else begin inc(ans);dec(ra);inc(lb) end;<br>    end;<br>    solve:=ans;<br>end;</p>
<p>begin<br>    read(n);<br>    while n&lt;&gt;0 do begin<br>        for i:=1 to n do read(a[i]);<br>        for i:=1 to n do read(b[i]);<br>        qsort(a,1,n);<br>        qsort(b,1,n);<br>        writeln(solve(a,b),’ ‘,4*n-solve(b,a));<br>        read(n);<br>    end;<br>end.</p>
<pre><code>

# P2 特殊密码锁
有一种特殊的二进制密码锁，由n个相连的按钮组成（n&lt;30），按钮有凹/凸两种状态，用手按按钮会改变其状态。
然而让人头疼的是，当你按一个按钮时，跟它相邻的两个按钮状态也会反转。当然，如果你按的是最左或者最右边的按钮，该按钮只会影响到跟它相邻的一个按钮。
当前密码锁状态已知，需要解决的问题是，你至少需要按多少次按钮，才能将密码锁转变为所期望的目标状态。

## 格式
### 输入格式
两行，给出两个由0、1组成的等长字符串，表示当前/目标密码锁状态，其中0代表凹，1代表凸。

### 输出格式
至少需要进行的按按钮操作次数，如果无法实现转变，则输出impossible。
&lt;!--more--&gt;

## 样例
### 样例输入
&gt;011
000

### 样例输出
&gt;1

## 题解
这是一个简单的反转问题
基于以下事实：
1. 按按钮的顺序是没有影响的
2. 对于一个按钮被反转多次是多余的

所以，从左到右扫一边，遇到不同的按钮i，将i..i+2反转，到n时如果不同说明无解。
还有一个细节，因为按第1个按钮会影响到第0个按钮，而第0个按钮的状态我们是不知道的，因此即使1..2个按钮的状态是正确的，我们也要尝试一下按第一个按钮，看看有没有更优解。

&lt;dir style=&quot;display:none&quot;&gt;<a href="/2016/08/23/JSOI2016-提高2班-贪心/8469.pas" title="复制代码">复制代码</a>&lt;/dir&gt;

```delphi 8469.pas
uses math;
type int=longint;
var n,ans:int;
    s,d:string;

procedure flip(var s:string;i:int);
begin
    s[i]:=chr(ord(&#39;1&#39;)+ord(&#39;0&#39;)-ord(s[i]));
end;

function solve(s,d:string):int;
var i,j:int;
begin
    i:=1;solve:=0;
    while i&lt;=n do begin
        while (s[i]=d[i]) and (i&lt;=n) do inc(i);
        if i&lt;n then begin
            for j:=i to min(i+2,n) do flip(s,j);
            inc(solve);
        end;
        inc(i);
    end;
    for i:=1 to n do
        if s[i]&lt;&gt;d[i] then exit(maxlongint);
end;

begin
    readln(s);readln(d);
    n:=length(s);
    ans:=solve(s,d);
    flip(s,1);flip(s,2);
    ans:=min(ans,solve(s,d)+1);
    if ans=maxlongint then write(&#39;impossible&#39;) else write(ans);
end.
</code></pre><h1 id="P3-电池的寿命"><a href="#P3-电池的寿命" class="headerlink" title="P3 电池的寿命"></a>P3 电池的寿命</h1><p>小S新买了一个掌上游戏机，这个游戏机由两节5号电池供电。为了保证能够长时间玩游戏，他买了很多5号电池，这些电池的生产商不同，质量也有差异，因而使用寿命也有所不同，有的能使用5个小时，有的可能就只能使用3个小时。显然如果他只有两个电池一个能用5小时一个能用3小时，那么他只能玩3个小时的游戏，有一个电池剩下的电量无法使用，但是如果他有更多的电池，就可以更加充分地利用它们，比如他有三个电池分别能用3、3、5小时，他可以先使用两节能用3个小时的电池，使用半个小时后再把其中一个换成能使用5个小时的电池，两个半小时后再把剩下的一节电池换成刚才换下的电池（那个电池还能用2.5个小时），这样总共就可以使用5.5个小时，没有一点浪费。<br>现在已知电池的数量和电池能够使用的时间，请你找一种方案使得使用时间尽可能的长。</p>
<h2 id="格式-1"><a href="#格式-1" class="headerlink" title="格式"></a>格式</h2><h3 id="输入格式-1"><a href="#输入格式-1" class="headerlink" title="输入格式"></a>输入格式</h3><p>输入包含多组数据。每组数据包括两行，第一行是一个整数N (2 ≤ N ≤ 1000)，表示电池的数目，接下来一行是N个正整数表示电池能使用的时间。</p>
<h3 id="输出格式-1"><a href="#输出格式-1" class="headerlink" title="输出格式"></a>输出格式</h3><p>输入包含多组数据。每组数据包括两行，第一行是一个整数N (2 ≤ N ≤ 1000)，表示电池的数目，接下来一行是N个正整数表示电池能使用的时间。<br><!--more--></p>
<h2 id="样例-1"><a href="#样例-1" class="headerlink" title="样例"></a>样例</h2><h3 id="样例输入-1"><a href="#样例输入-1" class="headerlink" title="样例输入"></a>样例输入</h3><blockquote>
<p>2<br>3 5<br>3<br>3 3 5</p>
</blockquote>
<h3 id="样例输出-1"><a href="#样例输出-1" class="headerlink" title="样例输出"></a>样例输出</h3><blockquote>
<p>3.0<br>5.5</p>
</blockquote>
<h2 id="题解-1"><a href="#题解-1" class="headerlink" title="题解"></a>题解</h2><p>记最长的电池长为mxl，所有电池长度加起来为sum<br>如果mxl&lt;=sum/2，那么答案是sum/2<br>否则答案是sum-mxl</p>
<dir style="display:none"><a href="/2016/08/23/JSOI2016-提高2班-贪心/2469.pas" title="复制代码">复制代码</a></dir>

<p>```delphi 8469.pas<br>uses math;<br>type int=longint;<br>var n,i,j,sum,mxl:int;</p>
<p>begin<br>    while not eof do begin<br>        readln(n);<br>        mxl:=0;sum:=0;<br>        for i:=1 to n do begin<br>            read(j);<br>            mxl:=max(mxl,j);<br>            inc(sum,j);<br>        end;<br>        readln;<br>        writeln(min((sum-mxl)/1,sum/2):0:1);<br>    end;<br>end.</p>
<pre><code>
# P4 积木大赛
春春幼儿园举办了一年一度的“积木大赛”。今年比赛的内容是搭建一座宽度为 n 的大厦，大厦可以看成由 n 块宽度为1的积木组成，第𝑖块积木的最终高度需要是hi。
在搭建开始之前，没有任何积木（可以看成 n 块高度为 0 的积木）。接下来每次操作，小朋友们可以选择一段连续区间[L,R]，然后将第 L 块到第 R 块之间（含第 L 块和第 R 块）所有积木的高度分别增加1。
小 M 是个聪明的小朋友，她很快想出了建造大厦的最佳策略，使得建造所需的操作次数最少。但她不是一个勤于动手的孩子，所以想请你帮忙实现这个策略，并求出最少的操作次数。

## 格式
### 输入格式
输入包含两行，第一行包含一个整数 n，表示大厦的宽度。
第二行包含 n 个整数，第i个整数为hi。

### 输出格式
仅一行，即建造所需的最少操作数。 
&lt;!--more--&gt;

## 样例
### 样例输入
&gt;5
2 3 4 1 2

### 样例输出
&gt;5

### 提示
每个测试点1s。
其中一种可行的最佳方案,依次选择 [1,5] [1,3] [2,3] [3,3] [5,5]
对于 30%的数据，有1 ≤ n ≤ 10;
对于 70%的数据，有1 ≤ n ≤ 1000;
对于 100%的数据，有1 ≤ n ≤ 100000，0 ≤ hi ≤ 10000。


## 题解
显然我们希望一个区间尽量地长。
对于一块的高度h(i)
如果h(i+1)&lt;=h(i)，覆盖1..i的区间一定能覆盖h(i)，不用增加新区间。
否则，要覆盖h(i+1)-h(i)的高度差，新区间数=高度差。

&lt;dir style=&quot;display:none&quot;&gt;<a href="/2016/08/23/JSOI2016-提高2班-贪心/p1844.pas" title="复制代码">复制代码</a>&lt;/dir&gt;

```delphi p1844.pas
uses math;
var n,i,j,last,ans:longint;
begin
    read(n);
    ans:=0;last:=0;
    for i:=1 to n do begin
        read(j);
        inc(ans,max(0,j-last));
        last:=j;
    end;
    write(ans);
end.
</code></pre><h1 id="P5-国王游戏"><a href="#P5-国王游戏" class="headerlink" title="P5 国王游戏"></a>P5 国王游戏</h1><p>恰逢H国国庆，国王邀请n位大臣来玩一个有奖游戏。首先，他让每个大臣在左、右手上面分别写下一个整数，国王自己也在左、右手上各写一个整数。然后，让这n位大臣排成一排，国王站在队伍的最前面。排好队后，所有的大臣都会获得国王奖赏的若干金币，每位大臣获得的金币数分别是：排在该大臣前面的所有人的左手上的数的乘积除以他自己右手上的数，然后向下取整得到的结果。<br>国王不希望某一个大臣获得特别多的奖赏，所以他想请你帮他重新安排一下队伍的顺序，使得获得奖赏最多的大臣，所获奖赏尽可能的少。注意，国王的位置始终在队伍的最前面。 </p>
<h2 id="格式-2"><a href="#格式-2" class="headerlink" title="格式"></a>格式</h2><h3 id="输入格式-2"><a href="#输入格式-2" class="headerlink" title="输入格式"></a>输入格式</h3><p>第一行包含一个整数n，表示大臣的人数。<br>第二行包含两个整数a和b，之间用一个空格隔开，分别表示国王左手和右手上的整数。接下来n行，每行包含两个整数a和b，之间用一个空格隔开，分别表示每个大臣左手和右手上的整数。 </p>
<h3 id="输出格式-2"><a href="#输出格式-2" class="headerlink" title="输出格式"></a>输出格式</h3><p>输出只有一行，包含一个整数，表示重新排列后的队伍中获奖赏最多的大臣所获得的金币数。<br><!--more--></p>
<h2 id="样例-2"><a href="#样例-2" class="headerlink" title="样例"></a>样例</h2><h3 id="样例输入-2"><a href="#样例输入-2" class="headerlink" title="样例输入"></a>样例输入</h3><blockquote>
<p>3<br>1 1<br>2 3<br>7 4<br>4 6 </p>
</blockquote>
<h3 id="样例输出-2"><a href="#样例输出-2" class="headerlink" title="样例输出"></a>样例输出</h3><blockquote>
<p>2</p>
</blockquote>
<h3 id="提示"><a href="#提示" class="headerlink" title="提示"></a>提示</h3><p>每个测试点1s<br>对于20%的数据，有1≤ n≤ 10，0 &lt; a×b &lt; 8；<br>对于40%的数据，有1≤ n≤20，0 &lt; a×b &lt; 8；<br>对于60%的数据，有1≤ n≤100；<br>对于60%的数据，保证答案不超过10^9；<br>对于100%的数据，有1 ≤ n ≤1,000，0 &lt; a、b &lt; 10000。<br>Noip2012提高组复赛Day1T2</p>
<h2 id="题解-2"><a href="#题解-2" class="headerlink" title="题解"></a>题解</h2><p>首先这题是一个很隐蔽的<strong>贪心</strong>，能不能看出来要看水（R）平（P）<br>其实数据范围中给了暗示：<strong>a×b</strong><br>记相邻的两个人左右手为(a,b)和(A,B)，记这两个人之前的人左手乘积S<br>(a,b)在前，最多金币值为a1=max(S/b,S×a/B)<br>(A,B)在前，最多为a2=max(S/B,S×A/b)<br>显然：S/B&lt;S×a/B，S/b&lt;S×A/b<br>要使得a1&lt;a2，则S×a/B&lt;S×A/b<br>变形后：a×b&lt;A×B<br>所以<strong>左右手乘积</strong>大的人，排在前面得到的金币数多，为了使得金币数最大值最小，按左右手乘积<strong>升序排列</strong>，然后上<strong>高精度</strong>。<br>注意：print时对a[i]用ln算位数，<strong>要确保a[i]≠0</strong>，否则RE</p>
<dir style="display:none"><a href="/2016/08/23/JSOI2016-提高2班-贪心/p1779.pas" title="复制代码">复制代码</a></dir>

<p>```delphi p1779.pas<br>uses math;<br>type<br>    big=array[0..1010] of int64;<br>    int=longint;<br>const<br>    bs:int64=100000000;<br>    k=8;<br>var<br>    a:array[0..1010,0..1] of int;<br>    n,i:int;<br>    tmp,ans,prob:big;</p>
<p>procedure swap(var a,b:int);<br>var tmp:int;<br>begin tmp:=a;a:=b;b:=tmp end;</p>
<p>procedure qsort(b,e:int);<br>var i,j:int;<br>begin<br>    i:=b;j:=e;a[0]:=a[random(e-b)+b];<br>    repeat<br>        while a[i,0]<em>a[i,1]&lt;a[0,0]</em>a[0,1] do inc(i);<br>        while a[j,0]<em>a[j,1]&gt;a[0,0]</em>a[0,1] do dec(j);<br>        if i&lt;=j then begin<br>            swap(a[i,0],a[j,0]);swap(a[i,1],a[j,1]);<br>            inc(i);dec(j);<br>        end;<br>    until i&gt;j;<br>    if i&lt;e then qsort(i,e);<br>    if b&lt;j then qsort(b,j);<br>end;</p>
<p>function com(a,b:big):int64;<br>var i:int;<br>begin<br>    i:=max(a[0],b[0]);<br>    while (a[i]=b[i]) and (i&gt;0) do dec(i);<br>    com:=a[i]-b[i];<br>end;</p>
<p>function mul(a:big;b:int):big;<br>var i:int;<br>begin<br>    fillchar(mul,sizeof(mul),0);<br>    for i:=1 to a[0] do begin<br>        inc(mul[i],a[i]*b);<br>        inc(mul[i+1],mul[i] div bs);<br>        mul[i]:=mul[i] mod bs;<br>    end;<br>    mul[0]:=a[0];<br>    while mul[mul[0]+1]&gt;0 do inc(mul[0]);<br>end;</p>
<p>function sdiv(a:big;b:int):big;<br>var m:int64;i:int;<br>begin<br>    fillchar(sdiv,sizeof(sdiv),0);<br>    m:=0;<br>    sdiv[0]:=a[0];<br>    for i:=a[0] downto 1 do begin<br>        sdiv[i]:=(m<em>bs+a[i]) div b;<br>        m:=(m</em>bs+a[i]) mod b;<br>    end;<br>    while (sdiv[sdiv[0]]=0) and (sdiv[0]&gt;0) do dec(sdiv[0]);<br>end;</p>
<p>procedure print(a:big);<br>var i,j,x:int;<br>begin<br>    if a[0]=0 then begin write(0);exit end;<br>    write(a[a[0]]);<br>    for i:=a[0]-1 downto 1 do begin<br>        if a[i]=0 then x:=1 else x:=floor(ln(a[i])/ln(10))+1;<br>        for j:=1 to k-x do write(0);<br>        write(a[i]);<br>    end;<br>end;</p>
<p>begin<br>    assign(input,’p1779.in’);reset(input);<br>    read(n);inc(n);<br>    for i:=1 to n do read(a[i,0],a[i,1]);<br>    qsort(2,n);<br>    ans[0]:=0;prob[0]:=1;prob[1]:=a[1,0];<br>    for i:=2 to n do begin<br>        tmp:=sdiv(prob,a[i,1]);<br>        if com(tmp,ans)&gt;0 then ans:=tmp;<br>        prob:=mul(prob,a[i,0]);<br>    end;<br>    print(ans);<br>    close(output);<br>end.<br>```</p>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[折腾Ubuntu]]></title>
      <url>https://cothrax.github.io/2016/08/22/%E6%8A%98%E8%85%BEUbuntu/</url>
      <content type="html"><![CDATA[<p>noi_linux所用的ubuntu版本已经不被官方支持了，于是apt-get都无法正常工作，旧版的firefox无法解析各大OJ的css3/h5，于是试试Ubuntu。<br>以此日志记录一个下午的各种BUG和解决方案。</p>
<h2 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h2><p>之前用U盘启动盘装Linux失败了无数次，症状是进了loading界面，然后黑屏，光标闪了几秒后系统就休眠了，风扇还在转但不见动静。<br>我的解决方案是：</p>
<ol>
<li>换低版本的Ubuntu，用了32位的Ubuntu 14。</li>
<li>用Win32 Disk Imager。之前用的UltraISO和Universal USB Installer都失败了。</li>
<li>经过前面的步骤，能进选择界面了，然后按F6，把<code>nomodeset</code>选上，就可以install Ubuntu了。<a id="more"></a>
</li>
</ol>
<h2 id="使用"><a href="#使用" class="headerlink" title="使用"></a>使用</h2><h3 id="GMONE"><a href="#GMONE" class="headerlink" title="GMONE"></a>GMONE</h3><p>noi_linux的桌面是gnome，而ubuntu 14默认桌面的unity。</p>
<pre><code class="bash">apt-get install gnome
</code></pre>
<p>然后注销，在登陆时选一下就可以了。</p>
<h3 id="切换root"><a href="#切换root" class="headerlink" title="切换root"></a>切换root</h3><p>每次都要sudo很不爽，于是切换到root，passwd后设置新的root密码，su后输入密码就可以了</p>
<pre><code class="bash">sudo passwd
su
</code></pre>
<p><strong>下文的命令都是以root执行的</strong></p>
<p>还可以切换回普通用户，两个都可以</p>
<pre><code class="bash">exit
su user_name
</code></pre>
<h3 id="改hosts"><a href="#改hosts" class="headerlink" title="改hosts"></a>改hosts</h3><p>科学上网可以用vpn，当然如果需求比较低的话，性价比最高的是hosts<br>linux的hosts的位置是<code>/etc/hosts</code><br>记得刷新dns</p>
<pre><code class="bash">/etc/init.d/networking restart
</code></pre>
<h3 id="安装Node-js等"><a href="#安装Node-js等" class="headerlink" title="安装Node.js等"></a>安装Node.js等</h3><p>这篇日志发自Ubuntu，要用Hexo就需要Node.js</p>
<pre><code class="bash">apt-get update  
apt-get install -y python-software-properties software-properties-common  
add-apt-repository ppa:chris-lea/node.js
apt-get update  
apt-get install nodejs
</code></pre>
<h4 id="npm换源"><a href="#npm换源" class="headerlink" title="npm换源"></a>npm换源</h4><pre><code class="bash">npm config set registry http://registry.cnpmjs.org
npm info express
</code></pre>
<h4 id="装GIT和HEXO"><a href="#装GIT和HEXO" class="headerlink" title="装GIT和HEXO"></a>装GIT和HEXO</h4><p><code>-g</code>选项指默认安装到<code>/usr/lib/node_modules/npm</code>下</p>
<pre><code class="bash">apt-get install git-core
npm install -g hexo
npm install -g hexo-math
</code></pre>
<h4 id="更新node-js"><a href="#更新node-js" class="headerlink" title="更新node.js"></a>更新node.js</h4><p>然后似乎报了<code>TypeError: Object #&lt;Object&gt; has no method &#39;parse&#39;</code>错误，google了一下好像是因为node版本低了，于是</p>
<pre><code class="bash">npm cache clean -f
npm install -g n
n stable
</code></pre>
<h3 id="添加path"><a href="#添加path" class="headerlink" title="添加path"></a>添加path</h3><p>因为没有忘记加<code>-g</code>，报<code>Hexo command not found</code>，于是手动将hexo的bin加到path里，gedit打开后添加<code>PATH=$PATH:$HOME/bin:/home/cothrax/Hexo/node_modules/hexo/bin</code></p>
<pre><code class="bash">gedit ~/.bash_profile
source ~/.bash_profile
</code></pre>
<h3 id="设置命令别名"><a href="#设置命令别名" class="headerlink" title="设置命令别名"></a>设置命令别名</h3><p>有些命令很长每次都要敲不方便，于是再<code>~/</code>下：</p>
<pre><code class="bash">touch .bash_aliases
gedit .bash_aliases
source .bash_aliases
</code></pre>
<p>编辑时写入alias，比如：</p>
<pre><code class="bash">alias chrome=&#39;chromium-browser &amp;&#39;
alias ff=&#39;firefox &amp;&#39;
alias en=&#39;firefox https://app.yinxiang.com/Home.action &amp;&#39;
alias opdir=&#39;nautilus&#39;
</code></pre>
<h3 id="设置环境变量"><a href="#设置环境变量" class="headerlink" title="设置环境变量"></a>设置环境变量</h3><p>每次都要敲很长的路径名，不如设一下环境变量，同样在<code>~/.bash_aliases</code>写入，如：</p>
<pre><code class="bash">export BLOG=&#39;/home/wd/Hexo/&#39;
export POST=&#39;/home/wd/Hexo/source/_posts/&#39;
</code></pre>
<h3 id="安装Brother打印机驱动"><a href="#安装Brother打印机驱动" class="headerlink" title="安装Brother打印机驱动"></a>安装Brother打印机驱动</h3><p>Brother提供了LINUX版本的驱动，到官网找Driver Install Tool，或者google设备号就能找到。<br>比如我的港版L2700D在：<a href="http://support.brother.com/g/b/downloadlist.aspx?c=hk&amp;lang=en&amp;prod=mfcl2700d_as&amp;os=128" target="_blank" rel="external">http://support.brother.com/g/b/downloadlist.aspx?c=hk&amp;lang=en&amp;prod=mfcl2700d_as&amp;os=128</a><br>然后root身份运行脚本就可以了，先输入设备好查询deb包，然后N个y同意协议，然后问你要不要specify device URI，选n就好了（不是那是什么），然后test page就打印出来了。</p>
<h3 id="切换应用程序快捷键"><a href="#切换应用程序快捷键" class="headerlink" title="切换应用程序快捷键"></a>切换应用程序快捷键</h3><p>gnome compiz下这个快捷键似乎坏了，系统设置里选了也没用。</p>
<pre><code class="bash">sudo apt-get install compizconfig-settings-manager
</code></pre>
<p>应用程序-&gt;系统工具-&gt;Preference -&gt; CompizConfig Setting Manager，点左侧 窗口管理，勾选右面的“static application switch”</p>
<h2 id="升级"><a href="#升级" class="headerlink" title="升级"></a>升级</h2><p>装了14想升到16，于是</p>
<pre><code class="bash">sudo apt-get update
sudo apt-get dist-upgrade
sudo reboot
sudo update-manager –d
</code></pre>
<p>当然以上操作也可以在图形界面下完成，系统工具里有软件包更新，Administration里有软件更新器<br>然后重启后，再进ubuntu时黑屏了，都做好重装的准备了，然后在win下把easybcd的ubuntu引导删掉重加一下就好了。</p>
<h2 id="其他"><a href="#其他" class="headerlink" title="其他"></a>其他</h2><h3 id="USB容量丢失"><a href="#USB容量丢失" class="headerlink" title="USB容量丢失"></a>USB容量丢失</h3><p>原来30G的U盘做了启动盘后还剩1.03G囧。<br>找Win下的磁盘管理却不能删除卷，然后用<a href="http://www.diskgenius.cn/download.php" target="_blank" rel="external">Disk Genius</a>解决啦。</p>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[[JSOI2016] 提高1班 Day6]]></title>
      <url>https://cothrax.github.io/2016/08/22/JSOI2016-%E6%8F%90%E9%AB%981%E7%8F%AD-Day6/</url>
      <content type="html"><![CDATA[<table>
<thead>
<tr>
<th style="text-align:center">题目名称</th>
<th style="text-align:center">小W买礼物</th>
<th style="text-align:center">小W理笔记</th>
<th style="text-align:center">小W开关灯</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">存盘文件名</td>
<td style="text-align:center">bday</td>
<td style="text-align:center">note</td>
<td style="text-align:center">lites</td>
</tr>
<tr>
<td style="text-align:center">输入文件名</td>
<td style="text-align:center">bday.in</td>
<td style="text-align:center">note.in</td>
<td style="text-align:center">lites.in</td>
</tr>
<tr>
<td style="text-align:center">输出文件名</td>
<td style="text-align:center">bday.out</td>
<td style="text-align:center">note.out</td>
<td style="text-align:center">lites.out</td>
</tr>
<tr>
<td style="text-align:center">时限</td>
<td style="text-align:center">3s</td>
<td style="text-align:center">1s</td>
<td style="text-align:center">1s</td>
</tr>
<tr>
<td style="text-align:center">内存限制</td>
<td style="text-align:center">64MB</td>
<td style="text-align:center">256MB</td>
<td style="text-align:center">256MB</td>
</tr>
</tbody>
</table>
<h1 id="P1-小W买礼物"><a href="#P1-小W买礼物" class="headerlink" title="P1 小W买礼物"></a>P1 小W买礼物</h1><p>小W 今天很高兴，因为商店给OIer 们发购物券了。小W 得到了一些价值不菲的SHOP<br>购物券，所以他决定买N 件礼物送给小M。<br>当小W 选好了N 件礼物，高兴地去结账时，他突然发现SHOP 对购物券的使用有非常奸<br>商（天下哪有免费的购物券？）的规定：一次只允许使用一张、不找零、不与现金混用。小<br>W 身上根本没有现金，并且他不愿意全部放弃挑选好的礼物。这就意味着，他只能通过这些<br>购物券结账，而且这张购物券所购买的物品的总价格，必须精确的等于这张购物券的面额。<br>怎么样才能顺利的买回这N 件礼物中的部分或全部送给小M 呢？<br>你的任务就是帮助小W 确定是否存在一个购买方案。小W 会告诉你每张购物券的面额以<br>及所有商品的价格，对每张购物券，你只需要确定能否找到一种选礼物方案，使得选出来的<br>礼物的价格总和正好是这张购物券的面额即可。</p>
<h2 id="格式"><a href="#格式" class="headerlink" title="格式"></a>格式</h2><h3 id="输入格式"><a href="#输入格式" class="headerlink" title="输入格式"></a>输入格式</h3><p>输入文件bday.in 中有多组数据，每组数据的第一行为两个整数N 和M，分别表示小W<br>一共挑选了N 件礼物以及小W 的一张购物券的面额为M。接下来一行有N 个用空格隔开的正<br>整数，第I 个数表示第I 个礼物的价格。<br>输入数据以0 0 结束。</p>
<h3 id="输出格式"><a href="#输出格式" class="headerlink" title="输出格式"></a>输出格式</h3><p>输出文件bday.out 包含若干行，每行一个单词“YES”或者“NO”，分别代表存在一个<br>购买方案和不存在一个购买方案。</p>
<a id="more"></a>
<h2 id="样例"><a href="#样例" class="headerlink" title="样例"></a>样例</h2><h3 id="样例输入"><a href="#样例输入" class="headerlink" title="样例输入"></a>样例输入</h3><blockquote>
<p>10 2000<br>1000 100 200 300 400 500 700 600 900 800<br>10 2290<br>1000 100 200 300 400 500 700 600 900 800<br>0 0</p>
</blockquote>
<h3 id="样例输出"><a href="#样例输出" class="headerlink" title="样例输出"></a>样例输出</h3><blockquote>
<p>YES<br>NO</p>
</blockquote>
<h2 id="提示"><a href="#提示" class="headerlink" title="提示"></a>提示</h2><p>对于30%的输入文件，所有的N≤20。<br>对于100%的输入文件，所有的N≤40，并且M 和物品的总价值不超过2^31-1，测试组<br>数不超过10 组，不少于5 组。</p>
<h2 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h2><p>m很大，背包显然不行，考虑到n很小，<strong>折半枚举</strong>。<br>记k=n div 2<br>枚举1..k的所有组合存入<strong>hash表</strong><br>枚举k+1..n的所有组合，对于每一个组合w查询hash表中m-w的值是否存在。<br>hash不要开太大，小心MLE，可以用拉链+数组模拟指针来实现。<br>当然也可以不用hash，前一半存入数组，排序，在枚举后一半时<strong>二分查找</strong></p>
<p>自己的错误点</p>
<ol>
<li>所有物品都枚举完后（x=k+1/x=n+1）才能插入/查询hash。</li>
<li>习惯用h[0]保存表的大小，但hash值=k mod sz是有可能为0的，所以不行。</li>
</ol>
<dir style="display:none"><a href="/2016/08/22/JSOI2016-提高1班-Day6/bday.pas" title="复制代码">复制代码</a></dir>

<p>```delphi bday.pas<br>const<br>    maxn=1024*1024+10;<br>    sz=500009;<br>type<br>    int=longint;<br>    node=record i,next:int end;<br>var<br>    h:array[0..sz] of int;<br>    t:array[0..maxn] of node;<br>    a:array[0..41] of int;<br>    n,m,hsz,i,k:int;flag:boolean;</p>
<p>function hash(k:int):int;<br>begin hash:=k mod sz end;</p>
<p>procedure insert(k:int);<br>var j:int;<br>begin<br>    inc(hsz);<br>    j:=hash(k);<br>    t[hsz].next:=h[j];t[hsz].i:=k;<br>    h[j]:=hsz;<br>end;</p>
<p>function query(k:int):boolean;<br>var i:int;<br>begin<br>    if k<0 then="" exit(false);="" i:="h[hash(k)];" while="" i<="">0 do begin<br>        if t[i].i=k then exit(true);<br>        i:=t[i].next;<br>    end;<br>    query:=false;<br>end;</0></p>
<p>procedure dfs(x,w,s:int);<br>begin<br>    if flag then exit;<br>    if (s=0) and (x=k+1) then begin insert(w);exit end;<br>    if (s=1) and (x=n+1) then begin<br>        if query(m-w) then flag:=true;<br>        exit;<br>    end;<br>    dfs(x+1,w+a[x],s);<br>    dfs(x+1,w,s);<br>end;</p>
<p>begin<br>    assign(input,’bday.in’);reset(input);<br>    assign(output,’bday.out’);rewrite(output);<br>    read(n,m);<br>    while (n&lt;&gt;0) and (m&lt;&gt;0) do begin<br>        k:=n div 2;<br>        for i:=1 to n do read(a[i]);<br>        fillchar(h,sizeof(h),0);hsz:=0;<br>        flag:=false;<br>        dfs(1,0,0);dfs(k+1,0,1);<br>        if flag then writeln(‘YES’) else writeln(‘NO’);<br>        read(n,m);<br>    end;<br>    close(input);close(output);<br>end.</p>
<pre><code>
# P2 小W 理笔记
小W 由于购物浪费了太多时间，导致他外语课都没有好好听。为什么是外语课？不是英
语课？因为小W 肯定会好好听英语课。由于没有好好听课， 小W 的笔记全都记的杂乱无章，
出现了好多错误的地方。 小W 的笔记是如此的糟糕，以至于他只记了一句例句，而且自己
还不知道是什么意思……然后在老师讲语法的时候， 小W 又零星的记了几个字母对，老师
说：这几个字母对是绝对不能相邻的，而且相邻是不关心字母的顺序的，比如老师说，‘ab’
不能相邻，那么相同的，‘ba’也不能相邻。
现在小W 到家了，打开了上课的笔记，然后他发现笔记有很多自相矛盾的地方：为什
么下面的不能相邻的字母对会出现在上面的例句里面呢？纠结再三， 小W 觉得下面的东西
相对比较简单，所以记错的概率比较小……他决定在上面的例句里面擦掉几个字母，使得句
子变得合法。
但是小W 还要把礼物送给小M，来不及整理笔记了，就把这个艰巨的任务留给了大家，
请问大家， 小W 最少要擦掉几个字母，才能使得上面的例句合法？


## 格式
### 输入格式
第一行：一个整数 N。
第二行：一个长度为 N 的字符串，只包含小写字母，代表小W 记下的例句。
第三行：一个整数 M，代表不能相邻的字母对的个数。
接下来 M 行：每行两个小写字母，代表不能相邻的字母对，因为小W 太不认真了，所以可
能有重复。

### 输出格式
一行一个整数：最少要擦除的字母数。

## 样例
### 样例输入
&gt;4
jsoi
2
oi
mo

### 样例输出
&gt;1

## 提示
对于10%的数据，M=0
对于另外30%的数据，N≤1000
对于100%的数据，N≤100000，M≤400

## 题解
开始以为是什么高深的图论题，结果是DP囧。
首先很容易想到线性DP：f[i]为1..i个字符，以s[i]结尾，形成合法字串的最少擦去数。
$f[i]=f[j]+i-j$（s[i]与s[j]不排斥）
但$O(N^2)$是会TLE的
然后考虑到字母总共只有26个，于是有另一种DP法：记f[i,c]是1..i个字符中，以字母c结尾，形成合法串的最小擦去数。
然后根据排斥关系f[i]可以通过f[i-1]转移得到。
还要注意一下初始化。

&lt;dir style=&quot;display:none&quot;&gt;<a href="/2016/08/22/JSOI2016-提高1班-Day6/note.pas" title="复制代码">复制代码</a>&lt;/dir&gt;

```delphi note.pas
uses math;
const inf=100000000;
type int=longint;
var 
    n,m,i,ans:int;s:ansistring;c1,c2:char;
    f:array[0..100010,&#39;a&#39;..&#39;z&#39;] of int;
    g:array[&#39;a&#39;..&#39;z&#39;,&#39;a&#39;..&#39;z&#39;] of boolean;


begin
    assign(input,&#39;note.in&#39;);reset(input);
    assign(output,&#39;note.out&#39;);rewrite(output);
    filldword(f,sizeof(f) div 4,inf);
    fillchar(g,sizeof(g),true);
    readln(n);readln(s);readln(m);
    if m=0 then begin write(0);halt end;
    for i:=1 to m do begin
        readln(c1,c2);
        g[c1,c2]:=false;g[c2,c1]:=false;
    end;

    for i:=1 to n do f[i,s[i]]:=i-1;
    for i:=2 to n do
        for c1:=&#39;a&#39; to &#39;z&#39; do begin
            if s[i]=c1 then
                for c2:=&#39;a&#39; to &#39;z&#39; do
                    if g[c1,c2] then
                        f[i,c1]:=min(f[i,c1],f[i-1,c2]);
            f[i,c1]:=min(f[i,c1],f[i-1,c1]+1);
        end;
    ans:=n;
    for c1:=&#39;a&#39; to &#39;z&#39; do
        ans:=min(ans,f[n,c1]);
    write(ans);
    close(input);close(output);
end.
</code></pre><h1 id="P3-小W-开关灯"><a href="#P3-小W-开关灯" class="headerlink" title="P3 小W 开关灯"></a>P3 小W 开关灯</h1><p>晚上到家小W 通过开关灯来保持自己神经的兴奋以便清醒地理笔记。<br>N(2≤N≤100,000)盏灯被连续的编号为1..N。刚回到家的时候,所有的灯都是关闭的。<br>小W 通过N 个按钮来控制灯的开关， 按第i 个按钮可以改变第 i 盏灯的状态。<br>小W 发出 M (1≤M≤100,000)条指令,每个指令都是两个整数中的一个(0 或1)。<br>第 1 种指令(用 0 表示)包含两个数字Si 和Ei(1≤Si≤Ei≤N)，它们表示起始开<br>关和终止开关。小W 需要把从 Si 到 Ei 之间的按钮都按一次,就可以完成这个指令。<br>第2 种指令(用 1 表示)同样包含两个数字Si 和Ei(1≤Si≤Ei≤N),不过这种指令<br>是询问从Si 到Ei 之间的灯有多少是亮着的。<br>请你帮助小W 得到正确的答案。</p>
<h2 id="格式-1"><a href="#格式-1" class="headerlink" title="格式"></a>格式</h2><h3 id="输入格式-1"><a href="#输入格式-1" class="headerlink" title="输入格式"></a>输入格式</h3><p>第 1 行: 用空格隔开的两个整数 N 和 M。<br>第 2..M+1 行: 每行表示一个操作, 有三个用空格分开的整数: 指令号, Si 和 Ei。</p>
<h3 id="输出格式-1"><a href="#输出格式-1" class="headerlink" title="输出格式"></a>输出格式</h3><p>对于每一次询问, 输出一行表示询问的结果。</p>
<h2 id="样例-1"><a href="#样例-1" class="headerlink" title="样例"></a>样例</h2><h3 id="样例输入-1"><a href="#样例输入-1" class="headerlink" title="样例输入"></a>样例输入</h3><blockquote>
<p>4 5<br>0 1 2<br>0 2 4<br>1 2 3<br>0 2 4<br>1 1 4</p>
</blockquote>
<h3 id="样例输出-1"><a href="#样例输出-1" class="headerlink" title="样例输出"></a>样例输出</h3><blockquote>
<p>1<br>2</p>
</blockquote>
<h2 id="提示-1"><a href="#提示-1" class="headerlink" title="提示"></a>提示</h2><p><strong>【样例解释】</strong><br>一共有 4 盏灯， 5 个指令。 下面是执行的情况:<br>1 2 3 4<br>Init: O O O O O = 关 + = 开<br>0 1 2 -&gt; + + O O 改变灯 1 和 2 的状态<br>0 2 4 -&gt; + O + +<br>1 2 3 -&gt; 1 输出在 2..3 的范围内有多少灯是亮的<br>0 2 4 -&gt; + + O O 改变灯 2 ,3 和 4 的状态<br>1 1 4 -&gt; 2 输出在 1..4 的范围内有多少灯是亮的<br><strong>【数据规模】</strong><br>对于 20%的数据: 1≤N,M≤100<br>对于 40%的数据: 1≤N,M≤10000<br>对于另外30%的数据: 只有最后一组是1 指令，前M-1 组为0 指令<br>对于100%的数据： 1≤N,M≤100000</p>
<h2 id="题解-1"><a href="#题解-1" class="headerlink" title="题解"></a>题解</h2><p>这是道很水的线段树操作。</p>
<dir style="display:none"><a href="/2016/08/22/JSOI2016-提高1班-Day6/lites.pas" title="复制代码">复制代码</a></dir>

<p>```delphi lites.pas<br>type int=longint;<br>var<br>    sgt,tag:array[0..400010] of int;<br>    n,m,i,j,x,y:int;</p>
<p>procedure putdown(i,b,e:int);<br>var mid:int;<br>begin<br>    if b&lt;e then begin<br>        mid:=(b+e) shr 1;<br>        tag[i<em>2]:=1-tag[i</em>2];sgt[i<em>2]:=mid-b+1-sgt[i</em>2];<br>        tag[i<em>2+1]:=1-tag[i</em>2+1];sgt[i<em>2+1]:=e-mid-sgt[i</em>2+1];<br>    end;<br>    tag[i]:=0;<br>end;</p>
<p>function query(i,b,e,l,r:int):int;<br>var mid:int;<br>begin<br>    if (r<b) or="" (l="">e) then exit(0);<br>    if (l&lt;=b) and (e&lt;=r) then exit(sgt[i]);<br>    mid:=(b+e) shr 1;<br>    if tag[i]=1 then putdown(i,b,e);<br>    query:=query(i<em>2,b,mid,l,r)+query(i</em>2+1,mid+1,e,l,r);<br>end;</b)></p>
<p>procedure insert(i,b,e,l,r:int);<br>var mid:int;<br>begin<br>    if (r<b) or="" (l="">e) then exit;<br>    if (l&lt;=b) and (e&lt;=r) then begin<br>        sgt[i]:=e-b+1-sgt[i];<br>        tag[i]:=1-tag[i];<br>        exit;<br>    end;<br>    mid:=(b+e) shr 1;<br>    if tag[i]=1 then putdown(i,b,e);<br>    insert(i<em>2,b,mid,l,r);insert(i</em>2+1,mid+1,e,l,r);<br>    sgt[i]:=sgt[i<em>2]+sgt[i</em>2+1];<br>end;</b)></p>
<p>begin<br>    assign(input,’lites.in’);reset(input);<br>    assign(output,’lites.out’);rewrite(output);<br>    read(n,m);<br>    for i:=1 to m do begin<br>        read(j,x,y);<br>        if j=0 then insert(1,1,n,x,y)<br>        else writeln(query(1,1,n,x,y));<br>    end;<br>    close(input);close(output);<br>end.<br>```</p>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[Bash对拍和数据生成]]></title>
      <url>https://cothrax.github.io/2016/08/21/Bash%E5%AF%B9%E6%8B%8D%E5%92%8C%E6%95%B0%E6%8D%AE%E7%94%9F%E6%88%90/</url>
      <content type="html"><![CDATA[<p>NOIP2016在即，学习一下Linux下对拍脚本的编写以及数据生成的技巧。</p>
<h2 id="Bash对拍脚本"><a href="#Bash对拍脚本" class="headerlink" title="Bash对拍脚本"></a>Bash对拍脚本</h2><p>先把dash关掉防止脚本报<code>Syntax error: Bad for loop variable</code>的错误</p>
<pre><code class="bash">sudo dpkg-reconfigure dash
</code></pre>
<p>在弹出的选项中选NO即可。<br>然后可以开始写脚本了，name是程序的名字xxx，<code>xxx_gen</code>是数据生成器，<code>xxx_che</code>是暴力程序，对于每一道题改一下name变量值即可。</p>
<dir style="display:none"><a href="/2016/08/21/Bash对拍和数据生成/check.sh" title="复制代码">复制代码</a></dir>

<p>```bash check.sh</p>
<p>#!/bin/bash<br>name=”test”                         #程序名</p>
<p>for ((;1;))                         #死循环<br>do<br>    ./${name}_gen                   #数据生成器<br>    ./${name}_che                   #暴力程序<br>    ./${name}                       #程序<br>    diff ${name}.out ${name}.ans    #比较<br>    if [ $? -ne “0” ]; then         #如果diff的输出$?和”0”不等<br>        echo “fail”<br>        exit                        #退出<br>    else<br>        echo “pass”<br>    fi<br>done</p>
<pre><code>&lt;!--more--&gt;
然后赋予脚本执行权限
```bash
chmod +x check.sh
</code></pre><h3 id="小技巧"><a href="#小技巧" class="headerlink" title="小技巧"></a>小技巧</h3><p>bash下可以用time输出程序运行时间，当然你也可以用pascal的sysutils库。</p>
<pre><code class="bash">time test.exe
</code></pre>
<p>如果你写-v参数的话，还可以输出更多的东西。</p>
<pre><code class="bash">/usr/bin/time -v test.exe
</code></pre>
<p>输出：</p>
<pre><code class="plain">Command being timed: &quot;./plutotree0&quot;
    User time (seconds): 0.33
    System time (seconds): 0.31
    Percent of CPU this job got: 99%
    Elapsed (wall clock) time (h:mm:ss or m:ss): 0:00.64
    Average shared text size (kbytes): 0
    Average unshared data size (kbytes): 0
    Average stack size (kbytes): 0
    Average total size (kbytes): 0
    Maximum resident set size (kbytes): 94816
    Average resident set size (kbytes): 0
    Major (requiring I/O) page faults: 0
    Minor (reclaiming a frame) page faults: 6069
    Voluntary context switches: 1
    Involuntary context switches: 4
    Swaps: 0
    File system inputs: 0
    File system outputs: 1760
    Socket messages sent: 0
    Socket messages received: 0
    Signals delivered: 0
    Page size (bytes): 4096
    Exit status: 0
</code></pre>
<h3 id="本地数据check"><a href="#本地数据check" class="headerlink" title="本地数据check"></a>本地数据check</h3><p>因为大多数据给的check脚本都是bat，要改造成sh，以transport 50组数据为例。</p>
<dir style="display:none"><a href="/2016/08/21/Bash对拍和数据生成/check0.sh" title="复制代码">复制代码</a></dir>

<p>```bash check0.sh<br>for ((i=1;i&lt;51;i++))<br>do<br>    cp ./transport${i}.in ./transport.in<br>    ./transport<br>    diff -w ./transport.out ./transport${i}.out<br>    if [ $? -ne “0” ];then<br>        echo “fail: “${i}<br>    else<br>        echo “pass: “${i}<br>    fi<br>    rm ./transport.in<br>    rm ./transport.out<br>done</p>
<pre><code>
## 更通用的对拍程序
直接用pascal写

&lt;dir style=&quot;display:none&quot;&gt;<a href="/2016/08/21/Bash对拍和数据生成/compare.pas" title="复制代码">复制代码</a>&lt;/dir&gt;

```delphi compare.pas
uses crt,dos;
const name=&#39;test&#39;; //程序名
var a,b:ansistring; 

procedure readin(f:string;var a:ansistring); 
begin  
    assign(input,f);reset(input);  
    read(a);
    close(input);  
end;  
begin
    repeat
        exec(name+&#39;_gen&#39;,&#39;&#39;);  
        exec(name+&#39;_che&#39;,&#39;&#39;);  
        exec(name,&#39;&#39;);  
        readin(name+&#39;.out&#39;,a);  
        readin(name+&#39;.ans&#39;,b);  
        writeln(a=b);
    until a&lt;&gt;b;
end.
</code></pre><h2 id="数据生成"><a href="#数据生成" class="headerlink" title="数据生成"></a>数据生成</h2><h3 id="生成一棵树"><a href="#生成一棵树" class="headerlink" title="生成一棵树"></a>生成一棵树</h3><p>枚举节点i，从i向前（1..i）随便连一条边</p>
<pre><code class="delphi">type int=longint;
var 
    n,i,j:int;
    opt:array[0..10010,0..2] of int;
begin
    assign(output,&#39;tree.in&#39;);rewrite(output);
    randomize;
    n:=random(10000);
    for i:=1 to n-1 do begin
        opt[i,0]:=random(i);
        opt[i,1]:=i;
        opt[i,2]:=random(10000);
    end;
    writeln(n);
    for i:=1 to n-1 do begin
        for j:=0 to 2 do
            write(opt[i,j],&#39; &#39;);
        writeln
    end;
    close(output);
end.
</code></pre>
<h3 id="生成联通图"><a href="#生成联通图" class="headerlink" title="生成联通图"></a>生成联通图</h3><p>先生成一棵树，剩余的边随便连</p>
<pre><code class="delphi">type int=longint;
var 
    n,m,i,j:int;
    opt:array[0..50010,0..2] of int;

begin
    assign(output,&#39;graph.in&#39;);rewrite(output);
    randomize;
    n:=random(10000);
    for i:=1 to n-1 do begin
        opt[i,0]:=random(i);
        opt[i,1]:=i;
        opt[i,2]:=random(10000);
    end;
    m:=random(50000-n+1)+n-1;
    for i:=n to m do begin
        opt[i,0]:=random(n);
        opt[i,1]:=random(n);
        opt[i,2]:=random(10000);
    end;
    writeln(n,&#39; &#39;,m);
    for i:=1 to m do begin
        for j:=0 to 2 do
            write(opt[i,j],&#39; &#39;);
        writeln
    end;
    close(output);
end.
</code></pre>
<h3 id="生成全排列"><a href="#生成全排列" class="headerlink" title="生成全排列"></a>生成全排列</h3><p>先令a[i]=i，然后随便交换几次就好了。</p>
<pre><code class="delphi">type int=longint;
var
    i,n:int; 
    a:array[0..1000] of int;

procedure swap(var a,b:int);
var tmp:int;
begin tmp:=a;a:=b;b:=tmp end;    

begin
    assign(output,&#39;test.in&#39;);rewrite(output);
    randomize;
    n:=random(1000);
    for i:=1 to n do a[i]:=i;
    for i:=1 to n shr 1 do 
        swap(a[random(n-1)+1],a[random(n-1)+1]);
    writeln(n);
    for i:=1 to n do write(a[i],&#39; &#39;); 
    close(output);
end.
</code></pre>
<p>全排列有什么用呢，比如说你生成有根树的时候不希望1是根，可以用一个全排列来做映射。</p>
<blockquote>
<p>坑慢慢填</p>
</blockquote>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[[JSOI2016] 提高1班 Day5]]></title>
      <url>https://cothrax.github.io/2016/08/21/JSOI2016-%E6%8F%90%E9%AB%981%E7%8F%AD-Day5/</url>
      <content type="html"><![CDATA[<p>第1题一如既往地水，第3题的数据BT，但用dfs栈并没有爆。</p>
<h1 id="P1-Video"><a href="#P1-Video" class="headerlink" title="P1 Video"></a>P1 Video</h1><p>pluto 喜欢看片，现在他的硬盘里有n 部片，但是由于他还要把妹，所以看片时间有限，他只能挑出其中的k 部片来看，他想知道有多少种不同的选片方案。方案数可能很大，答案mod 1000000007 输出。</p>
<h2 id="格式"><a href="#格式" class="headerlink" title="格式"></a>格式</h2><h3 id="输入格式"><a href="#输入格式" class="headerlink" title="输入格式"></a>输入格式</h3><p>一行两个整数，n和m</p>
<h3 id="输出格式"><a href="#输出格式" class="headerlink" title="输出格式"></a>输出格式</h3><p>一行一个整数，即所求答案<br><a id="more"></a></p>
<h2 id="样例"><a href="#样例" class="headerlink" title="样例"></a>样例</h2><h3 id="样例输入"><a href="#样例输入" class="headerlink" title="样例输入"></a>样例输入</h3><blockquote>
<p>6 2</p>
</blockquote>
<h3 id="样例输出"><a href="#样例输出" class="headerlink" title="样例输出"></a>样例输出</h3><blockquote>
<p>15</p>
</blockquote>
<h2 id="提示"><a href="#提示" class="headerlink" title="提示"></a>提示</h2><ul>
<li>对于30% 的数据，n &lt; 10</li>
<li>对于60% 的数据，n &lt; 3000</li>
<li>对于100% 的数据，n &lt; 2x10e5</li>
</ul>
<h2 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h2><p>难得碰到这么水的题，暴力算一下阶乘，拿扩展欧几里得求一下逆元就好了。</p>
<dir style="display:none"><a href="/2016/08/21/JSOI2016-提高1班-Day5/video.pas" title="复制代码">复制代码</a></dir>

<p>```delphi video.pas<br>const z=1000000007;<br>var<br>    n,m,a,rev,tmp,ans:int64;<br>    i:longint;</p>
<p>procedure extgcd(a,b:int64;var x,y:int64);<br>begin<br>    if b=0 then begin<br>        x:=1;y:=0;exit;<br>    end;<br>    extgcd(b,a mod b,y,x);<br>    dec(y,(a div b)*x);<br>end;</p>
<p>begin<br>    assign(input,’video.in’);reset(input);<br>    assign(output,’video.out’);rewrite(output);</p>
<pre><code>read(n,m);
a:=1;
for i:=1 to m do a:=a*i mod z;
extgcd(a,z,rev,tmp);
rev:=(rev+z) mod z;
ans:=1;
for i:=n-m+1 to n do ans:=ans*i mod z;
write(ans*rev mod z);

close(input);close(output);
</code></pre><p>end.</p>
<pre><code>
# P2 Chance
pluto 去找妹子xxx 约会，然而xxx 要求和pluto 玩一个游戏，pluto 赢了才能获得和xxx约会的机会。游戏内容为：现在有N 个袋子(你可以认为它是哆啦A 梦的口袋，每个袋子里放着一些球)，所以容量十分大，第i 个袋子里放着编号为Li 到Ri 的球(除编号外完全相同)，pluto 需要从每个袋子里摸出一个球，第i 个袋子里任何一个球被摸到的概率是1/(Ri - Li + 1)，如果pluto 摸出的球中有K% 或以上的球的编号的第一位是1(比如11,121,199 的第一位是1, 而21,233 第一位就不是1)，那么pluto 就将赢得与xxx 约会的机会。现在pluto 想知道他能人生中第一次与妹子约会的概率有多大。

## 格式
### 输入格式
第一行两个整数N,K
接下来N 行，每行两个整数，Li 和Ri
### 输出格式
一行一个实数（保留7位小数）表示答案
绝对误差不超过10e-6 即视为正确
&lt;!--more--&gt;

## 样例
### 样例输入
&gt;2 50
1 2
9 11

### 样例输出
&gt;0.833333333333333

## 提示
- 对于100% 的数据，0 &lt; k &lt; 100，0 &lt; Li &lt; Ri
- 对于30% 的数据，n &lt; 10，Li &lt; Ri &lt; 100
- 对于60% 的数据，n &lt; 500，Li &lt; Ri &lt; 2000
- 对于100% 的数据，n &lt; 2000，Li &lt; Ri &lt; 10e18

## 题解
先乱搞就能够求出第i个袋子中摸出第一位是1的球的概率p[i]（然而因为乱搞WA N次）
然后DP，f[i,j]在前i个袋子中摸出j个符合要求的球的概率
<span>$f[i,j]=f[i-1,j-1]*p[i]+f[i-1,j]*(1-p[i])$</span><!-- Has MathJax -->
注意：
1. 乱搞需谨慎
2. f[0,i]也要算
3. 答案是<span>$\sum\{ f[n,j]\ |\ j\geq \left\lceil n*k\% \right\rceil\}$</span><!-- Has MathJax -->

&lt;dir style=&quot;display:none&quot;&gt;<a href="/2016/08/21/JSOI2016-提高1班-Day5/chance.pas" title="复制代码">复制代码</a>&lt;/dir&gt;

```delphi chance.pas
uses math;
var 
    n,k,i,j:longint;l,r:int64;
    p:array[0..2010] of double;
    f:array[0..2010,-1..2010] of double;
    ans:double;

function cal():double;
var x,y,tot:int64;i:longint;
begin
    read(l,r);
    x:=1;tot:=0;
    for i:=1 to 18 do begin
        if x&gt;r then break;
        y:=2*x-1;
        if y&gt;=l then
            inc(tot,min(y,r)-max(l,x)+1);
        x:=x*10;
    end;
    cal:=tot/(r-l+1);
end;

begin
    assign(input,&#39;chance.in&#39;);reset(input);
    assign(output,&#39;chance.out&#39;);rewrite(output);
    read(n,k);
    ans:=0;
    for i:=1 to n do p[i]:=cal();
    f[0,0]:=1;
    for i:=1 to n do
        for j:=0 to n do
            f[i,j]:=f[i-1,j-1]*p[i]+f[i-1,j]*(1-p[i]); 
    ans:=0;
    for i:=ceil(n*k/100) to n do
        ans:=ans+f[n,i];
    write(ans:0:7);
    close(input);close(output);
end.
</code></pre><h1 id="P3-Plutotree"><a href="#P3-Plutotree" class="headerlink" title="P3 Plutotree"></a>P3 Plutotree</h1><p>有一棵n 个节点的树，节点编号为1 到n，i 号节点的权值为Wi。这棵树有些奇怪，它的每一个叶子节点都是根节点的父亲(表示每个叶子节点与根节点之间有一条边权为0 的边)。我们称这样的树为pluto 树，根节点编号为1。我们需要最小化从u 到v 的路径(每条边只能经过一次) 上的节点权值之和，并且在最小化节点权值之和的同时求这个路径上可能的最大权值。</p>
<h2 id="格式-1"><a href="#格式-1" class="headerlink" title="格式"></a>格式</h2><h3 id="输入格式-1"><a href="#输入格式-1" class="headerlink" title="输入格式"></a>输入格式</h3><p>第一行两个整数n 和q，n 表示节点个数，q 表示询问个数。<br>第二行n-1 个整数Ai，表示i + 1 号节点的父亲为Ai<br>第三行n 个整数Wi 表示i 号节点的权值为Wi<br>接下来q 行，每行两个整数u，v，表示一组询问</p>
<h3 id="输出格式-1"><a href="#输出格式-1" class="headerlink" title="输出格式"></a>输出格式</h3><p>对于每组询问输出两个整数x; y<br>x 表示u 到v 的权值和最小的路径的权值和，y 表示这条路径上点权最大值。如果有多个相同权值和的路径，输出那个点权最大值最大的。<br><!--more--></p>
<h2 id="样例-1"><a href="#样例-1" class="headerlink" title="样例"></a>样例</h2><h3 id="样例输入-1"><a href="#样例输入-1" class="headerlink" title="样例输入"></a>样例输入</h3><blockquote>
<p>5 1<br>1 2 3 4<br>413 127 263 869 960<br>1 5</p>
</blockquote>
<h3 id="样例输出-1"><a href="#样例输出-1" class="headerlink" title="样例输出"></a>样例输出</h3><blockquote>
<p>1373 960</p>
</blockquote>
<h2 id="提示-1"><a href="#提示-1" class="headerlink" title="提示"></a>提示</h2><p>• 对于30% 的数据，n ≤ 300，q ≤ 1000<br>• 对于50% 的数据，n ≤ 2000，q ≤ 10000<br>• 对于100% 的数据，n ≤ 100000，q ≤ 100000</p>
<h2 id="题解-1"><a href="#题解-1" class="headerlink" title="题解"></a>题解</h2><p><strong>倍增LCA+树形DP</strong><br>对于查询(u,v)，分类讨论</p>
<ol>
<li>直接走树上的简单路径，这种情况倍增一下就可以了</li>
<li>一个点通过叶子走回根，再从根走到另一个点</li>
<li>两个点都通过叶子，在根相遇</li>
</ol>
<p>后两种情况，要处理出离每个点最近的叶子节点，对于点i，有两种情况：</p>
<ol>
<li>走到i的子树上叶子，这个dfs顺手就算出来了</li>
<li>先向上（父节点）走，然后向下到达一个叶子，这个在情况1算出来后再dp一下。</li>
</ol>
<p>注意点：</p>
<ol>
<li>算最近的叶子不要忘了情况2（数据比较BT，忘了就爆0了）</li>
<li>倍增数组要开大，我开到15然后爆了。</li>
<li>还有就是关于每条边只能经过一次的问题，但由于是<strong>最小化权值和</strong>，重复经过的情况不可能是最优解，所以没有必要多做考虑。</li>
<li>分类2有两种走法都要考虑</li>
<li>由于是点权，和边权类似，但注意边界问题</li>
</ol>
<dir style="display:none"><a href="/2016/08/21/JSOI2016-提高1班-Day5/plutotree0.pas" title="复制代码">复制代码</a></dir>

<p>```delphi plutotree0.pas<br>uses math;<br>const inf=1000000000;<br>type<br>    int=longint;<br>    edge=record t,next:int end;<br>var<br>    g:array[0..100010] of edge;<br>    head,dep,w,dist:array[0..100010] of int;<br>    d:array[0..100010,0..1] of int;<br>    par,mxw:array[0..100010,0..25] of int;<br>    n,logn,q,i,j:int;</p>
<p>procedure add(f,t:int);<br>var m:int;<br>begin<br>    inc(head[0]);m:=head[0];<br>    g[m].t:=t;<br>    g[m].next:=head[f];head[f]:=m;<br>end;<br>//为了省事，更新答案用<br>procedure update(var x,y:int;nx,ny:int);<br>begin<br>    if (nx<x) or="" ((nx="x)" and="" (ny="">y)) then<br>        begin x:=nx;y:=ny end;<br>end;</x)></p>
<p>procedure dfs(v,p:int);<br>var i,u:int;<br>begin<br>    dep[v]:=dep[p]+1; //深度<br>    dist[v]:=dist[p]+w[v]; //到根的路径上的点权和<br>    par[v,0]:=p; //父节点<br>    mxw[v,0]:=max(w[p],w[v]); //倍增路径上的最大点权<br>    i:=head[v];<br>    //d是dp数组，d[v,0]是离最近叶子的路径上的点权和，d[v,1]是这个路径上的最大点权<br>    if i=0 then d[v,0]:=w[v] else d[v,0]:=inf;<br>    d[v,1]:=w[v];<br>    while i&lt;&gt;0 do begin<br>        u:=g[i].t;<br>        dfs(u,v);<br>        update(d[v,0],d[v,1],d[u,0]+w[v],max(d[u,1],w[v]));<br>        i:=g[i].next;<br>    end;<br>end;</p>
<p>procedure dp(v,p:int);<br>var i:int;<br>begin<br>    update(d[v,0],d[v,1],d[p,0]+w[v],max(d[p,1],w[v]));<br>    i:=head[v];<br>    while i&lt;&gt;0 do begin<br>        dp(g[i].t,v);<br>        i:=g[i].next;<br>    end;<br>end;</p>
<p>procedure swap(var a,b:int);<br>var tmp:int;<br>begin tmp:=a;a:=b;b:=tmp end;</p>
<p>procedure lca(u,v:int;var c,mx:int);<br>var i:int;<br>begin<br>    if dep[u]<dep[v] 0="" then="" swap(u,v);="" mx:="max(w[u],w[v]);" for="" i:="logn" downto="" do="" if="" dep[par[u,i]]="">=dep[v] then begin<br>            mx:=max(mx,mxw[u,i]);<br>            u:=par[u,i];<br>        end;<br>    if u=v then begin c:=u;exit end;<br>    for i:=logn downto 0 do<br>        if par[u,i]&lt;&gt;par[v,i] then begin<br>            mx:=max(mx,max(mxw[u,i],mxw[v,i]));<br>            u:=par[u,i];v:=par[v,i];<br>        end;<br>    mx:=max(mx,max(mxw[u,0],mxw[v,0]));<br>    c:=par[u,0];<br>end;</dep[v]></p>
<p>procedure solve();<br>var t1,t2,c,mx,mx1,md,md1:int;<br>begin<br>    read(t1,t2);<br>    if t1=t2 then begin writeln(w[t1],’ ‘,w[t1]);exit end;<br>    //Case 1<br>    lca(t1,t2,c,mx);<br>    md:=dist[t1]+dist[t2]-2*dist[c]+w[c];<br>    //Case 2.1<br>    mx1:=max(mxw[t1,logn],d[t2,1]);<br>    md1:=dist[t1]+d[t2,0];<br>    update(md,mx,md1,mx1);<br>    //Case 2.2<br>    mx1:=max(mxw[t2,logn],d[t1,1]);<br>    md1:=dist[t2]+d[t1,0];<br>    update(md,mx,md1,mx1);<br>    //Case 3<br>    mx1:=max(w[1],max(d[t1,1],d[t2,1]));<br>    md1:=d[t1,0]+d[t2,0]+w[1];<br>    update(md,mx,md1,mx1);</p>
<pre><code>writeln(md,&#39; &#39;,mx);
</code></pre><p>end;</p>
<p>begin<br>    assign(input,’plutotree.in’);reset(input);<br>    assign(output,’plutotree.out’);rewrite(output);<br>    read(n,q);<br>    for i:=2 to n do begin<br>        read(j);add(j,i);<br>    end;<br>    for i:=1 to n do read(w[i]);<br>    dfs(1,0);<br>    dp(1,1);<br>    //倍增数组<br>    logn:=floor(ln(n)/ln(2));<br>    for i:=1 to logn do<br>        for j:=1 to n do begin<br>            par[j,i]:=par[par[j,i-1],i-1];<br>            mxw[j,i]:=max(mxw[j,i-1],mxw[par[j,i-1],i-1]);<br>        end;<br>    for i:=1 to q do solve();<br>    close(input);close(output);<br>end.<br>```</p>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[[JSOI2016] 提高2班 单调队列及动规优化]]></title>
      <url>https://cothrax.github.io/2016/08/20/JSOI2016-%E6%8F%90%E9%AB%982%E7%8F%AD-%E5%8D%95%E8%B0%83%E9%98%9F%E5%88%97%E5%8F%8A%E5%8A%A8%E8%A7%84%E4%BC%98%E5%8C%96/</url>
      <content type="html"><![CDATA[<h1 id="P1-轰炸机"><a href="#P1-轰炸机" class="headerlink" title="P1 轰炸机"></a>P1 轰炸机</h1><p>大山两侧的X国与Y国爆发了一场战争，由于山势险峻，只有一条山路可以通行，所以双方的军营都设置在这一条路上（直线）。X国科学家正在研制一种高威力轰炸机，其炮弹可以大规模精准摧毁目标。由于在前线连连失利，X国高层决定提前将其投入使用。但由于研发尚未完成，仅有一枚导弹可供使用。这枚导弹至多可以摧毁M个目标（包括敌方军营和己方军营），但这些目标必须是连续的。<br>在一个月黑风高的夜晚，X国高层决定用这架轰炸机发起突袭。他们预先侦查到了山路上双方军营共有N个军营，并探清了每个军营的情况，他们请你帮他们设计出这次突袭战果最大的方案。<br>X国战国的计算公式为：战果=敌方损失的战斗力-己方损失的战斗力。</p>
<h2 id="格式"><a href="#格式" class="headerlink" title="格式"></a>格式</h2><h3 id="输入格式"><a href="#输入格式" class="headerlink" title="输入格式"></a>输入格式</h3><p>第一行两个整数 N,M;<br>第2~N+1行，每行一个整数Ai，表示第i个军营的属性值。<br>abs(Ai)表示第i个军营的战斗力。<br>Ai>0，表明该军营是Y国的军营；<br>Ai&lt;0，表明该军营是X国的军营；<br>Ai=0，表明该军营是空的。</p>
<h3 id="输出格式"><a href="#输出格式" class="headerlink" title="输出格式"></a>输出格式</h3><p>仅一行，输出使突袭战果最大的方案（按照输入顺序输出所有轰炸目标的属性值），每两个属性值之间用一个空格隔开。</p>
<a id="more"></a>
<h2 id="样例"><a href="#样例" class="headerlink" title="样例"></a>样例</h2><h3 id="样例输入"><a href="#样例输入" class="headerlink" title="样例输入"></a>样例输入</h3><blockquote>
<p>4 2<br>-1<br>3<br>–10<br>20</p>
</blockquote>
<h3 id="样例输出"><a href="#样例输出" class="headerlink" title="样例输出"></a>样例输出</h3><blockquote>
<p>20</p>
</blockquote>
<h2 id="提示"><a href="#提示" class="headerlink" title="提示"></a>提示</h2><p>30%的数据：N&lt;=3000,M&lt;=100<br>100%的数据N,M&lt;=1000000 -maxlongint&lt;=Ai&lt;=maxlongint</p>
<h2 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h2><p>最大子段和的升级版，要求长度不超过m。<br>先求前缀和sum[i]<br>然后，记f[i]是以i结尾的最大子段和，<span>$f[i]=sum[i]-min\{sum[j]\ |\ i-j&lt;=m\}$</span><!-- Has MathJax --><br>然后可以用一个严格递增的单调队列维护sum[j]</p>
<dir style="display:none"><a href="/2016/08/20/JSOI2016-提高2班-单调队列及动规优化/sum.pas" title="复制代码">复制代码</a></dir>

<p>```delphi sum.pas<br>uses math;<br>type int=longint;<br>var<br>    n,m,i,j,k,d,h,t,ans:int;<br>    c,w,a:array[0..110] of int; //费用,价值,数量<br>    f:array[0..10010] of int;<br>    q:array[0..10010,0..1] of int;</p>
<p>begin<br>    read(n,m);<br>    for i:=1 to n do read(c[i],w[i],a[i]);<br>    d:=0;<br>    for i:=1 to n do begin<br>        d:=min(m,d+c[i]<em>a[i]);<br>        for j:=0 to c[i]-1 do begin<br>            h:=1;t:=0;k:=0;<br>            while j+c[i]</em>k&lt;=d do begin<br>                while (h&lt;=t) and (q[t,0]&lt;=f[j+c[i]<em>k]-w[i]</em>k) do dec(t);<br>                inc(t);q[t,1]:=k;q[t,0]:=f[j+c[i]<em>k]-w[i]</em>k;<br>                while (h&lt;=t) and (k-q[h,1]&gt;a[i]) do inc(h);<br>                f[j+c[i]<em>k]:=max(f[j+c[i]</em>k],q[h,0]+k*w[i]);<br>                inc(k);<br>            end;<br>        end;<br>    end;<br>    ans:=0;<br>    for i:=1 to m do ans:=max(ans,f[i]);<br>    write(ans);<br>end.</p>
<pre><code>
# P2 武器调度
为了取得胜利，X国高层决定调动武器库中的装备支援前线，以增强前线的战斗力。X国武器库中共有N种武器，每种武器都有固定的质量，且数量有限，能给前线增加的战斗力也是已知的。拟定将用飞机运送，为了使飞机具有能摆脱Y国防空导弹的速度，其最大装载质量不得超过M。现在他们需要你求出这一次装备运输最多能给前线增加多少战斗力。

## 格式
### 输入格式
第一行两个整数 N，M；
第2~N+1行，每行三个整数Pi、Wi、Ci， 
Pi表示每件第i种武器的质量；
Wi表示每件第i种武器能给前线增加的战斗力；
Ci表示第i种武器的数量。

### 输出格式
仅一行，输出这一次装备运输能给前线增加的最大战斗力。

## 样例
### 样例输入
&gt;5 20
3 8 5
12 16 2
1 4 1
5 9 2
4 11 1

### 样例输出
&gt;55

## 提示
30%的数据中，n&lt;=10
50%的数据中，n&lt;=50,m&lt;=5000
100%的数据中，n&lt;=100,m&lt;=10000,ci&lt;=100
保证输出结果在maxlongint范围内。

## 题解
单调队列优化多重背包，代码优美到不可思议。
详解见此：http://www.cppblog.com/flyinghearts/archive/2010/09/01/125555.html

&lt;dir style=&quot;display:none&quot;&gt;<a href="/2016/08/20/JSOI2016-提高2班-单调队列及动规优化/war.pas" title="复制代码">复制代码</a>&lt;/dir&gt;

```delphi war.pas
uses math;
type int=longint;
var 
    n,m,i,j,k,d,h,t,ans:int;
    c,w,a:array[0..110] of int; //费用,价值,数量
    f:array[0..10010] of int;
    q:array[0..10010,0..1] of int;

begin
    assign(input,&#39;war.in&#39;);reset(input);
    assign(output,&#39;war.out&#39;);rewrite(output);
    read(n,m);
    for i:=1 to n do read(c[i],w[i],a[i]);
    d:=0;
    for i:=1 to n do begin
        d:=min(m,d+c[i]*a[i]);
        for j:=0 to c[i]-1 do begin
            h:=1;t:=0;k:=0;
            while j+c[i]*k&lt;=d do begin
                while (h&lt;=t) and (q[t,0]&lt;=f[j+c[i]*k]-w[i]*k) do dec(t);
                inc(t);q[t,1]:=k;q[t,0]:=f[j+c[i]*k]-w[i]*k;
                while (h&lt;=t) and (k-q[h,1]&gt;a[i]) do inc(h);
                f[j+c[i]*k]:=max(f[j+c[i]*k],q[h,0]+k*w[i]);
                inc(k);
            end;
        end;
    end;
    ans:=0;
    for i:=1 to m do ans:=max(ans,f[i]);
    write(ans);
    close(input);close(output);
end.
</code></pre><h1 id="P3-瑰丽华尔兹"><a href="#P3-瑰丽华尔兹" class="headerlink" title="P3 瑰丽华尔兹"></a>P3 瑰丽华尔兹</h1><blockquote>
<p>前面的废话被我删了</p>
</blockquote>
<p>晚上在金色的地板上快乐地跳着华尔兹是不是很惬意呢？也许，我们忘记了一个人，那就是艾米丽，她可没闲着：她必须在适当的时候施魔法帮助1900，不让钢琴碰上舞厅里的家具。而艾米丽还小，她无法施展魔法改变钢琴的运动方向或速度，而只能让钢琴停一下。<br>不妨认为舞厅是一个N行M列的矩阵，矩阵中的某些方格上堆放了一些家具，其他的则是空地。钢琴可以在空地上滑动，但不能撞上家具或滑出舞厅，否则会损坏钢琴和家具，引来难缠的船长。<br>每个时刻，钢琴都会随着船体倾斜的方向向相邻的方格滑动一格，其中相邻的方格可以是向东、向西、向南或向北的。而艾米丽可以选择施魔法或不施魔法，如果不施魔法，则钢琴会滑动，而如果施魔法，则钢琴会原地不动。 艾米丽是个天使，她知道每段时间的船体的倾斜情况。她想使钢琴尽量长时间在舞厅里滑行，这样1900会非常高兴，同时也有利于治疗托尼的晕船。但艾米丽还太小，不会算，所以希望你能帮助她。</p>
<h2 id="格式-1"><a href="#格式-1" class="headerlink" title="格式"></a>格式</h2><h3 id="输入格式-1"><a href="#输入格式-1" class="headerlink" title="输入格式"></a>输入格式</h3><p>输入文件的第一行包含5个数N, M, x, y和K。N和M描述舞厅的大小，x和y为在第1时刻初钢琴的位置（x行y列）；我们对船体倾斜情况是按时间的区间来描述的，比如“在[1, 3]时间里向东倾斜，[4, 5]时间里向北倾斜”，因此这里的K表示区间的数目。<br>以下N行，每行M个字符，描述舞厅里的家具。第i行第j列的字符若为‘ . ‘，则表示该位置是空地；若为‘ x ‘，则表示有家具。<br>以下K行，顺序描述K个时间区间，格式为：si ti di(1 ≤ i ≤ K)。表示在时间区间[si, ti]内，船体都是向di方向倾斜的。di为1, 2, 3, 4中的一个，依次表示北、南、西、东（分别对应矩阵中的上、下、左、右）。输入保证区间是连续的，即<br>s1 = 1<br>ti = si-1 + 1 (1 &lt; i ≤ K)<br>tK = T</p>
<h3 id="输出格式-1"><a href="#输出格式-1" class="headerlink" title="输出格式"></a>输出格式</h3><p>输出文件仅有1行，包含一个整数，表示钢琴滑行的最长距离(即格子数)。</p>
<h2 id="样例-1"><a href="#样例-1" class="headerlink" title="样例"></a>样例</h2><h3 id="样例输入-1"><a href="#样例输入-1" class="headerlink" title="样例输入"></a>样例输入</h3><blockquote>
<p>4 5 4 1 3<br>..xx.<br>…..<br>…x.<br>…..<br>1 3 4<br>4 5 1<br>6 7 3</p>
</blockquote>
<h3 id="样例输出-1"><a href="#样例输出-1" class="headerlink" title="样例输出"></a>样例输出</h3><blockquote>
<p>6</p>
</blockquote>
<h2 id="提示-1"><a href="#提示-1" class="headerlink" title="提示"></a>提示</h2><img src="/2016/08/20/JSOI2016-提高2班-单调队列及动规优化/adv.png" alt="adv.png" title="">
<p>钢琴在“×位置上时天使使用一次魔法，因此滑动总长度为6。<br>【数据范围】<br>50%的数据中，1≤N, M≤200，T≤200；<br>100%的数据中，1≤N, M≤200，K≤200，T≤40000。</p>
<h2 id="题解-1"><a href="#题解-1" class="headerlink" title="题解"></a>题解</h2><p>NOI2005的题目，帮助理解单调队列的好题。<br>黄学长的题解已经很清楚了：<a href="http://hzwer.com/7397.html" target="_blank" rel="external">http://hzwer.com/7397.html</a><br>其实可以发现，这一题和多重背包有异曲同工之妙，把k个区间看成k种物品，把滑1步看成添加1个物品，每个物品的价值为1，区间长度就是物品的总数，而可以施魔法停止就意味着可以取任意数量的物品，多重背包是通过对c[i]取模分组，而这一题是通过行列分组，所以 可以看出，这就是一个二维的多重背包。<br>和P2的代码一样，可以把k个区间（物品种类）这一维压掉。</p>
<dir style="display:none"><a href="/2016/08/20/JSOI2016-提高2班-单调队列及动规优化/adv1900.pas" title="复制代码">复制代码</a></dir>

<p>```delphi adv1900<br>uses math;<br>type int=longint;<br>const<br>    inf=1000000000;<br>    dir:array[1..4,0..1] of int=((-1,0),(1,0),(0,-1),(0,1));<br>var<br>    map:array[0..210,0..210] of char;<br>    f:array[0..210,0..210] of int;<br>    q:array[0..100010,0..1] of int;<br>    n,m,k,i,j,sx,sy,l,r,d,ans:int;</p>
<p>procedure dp(x,y,d,l:int);<br>var h,t,cnt:int;<br>begin<br>    h:=1;t:=0;cnt:=1;<br>    while (x&gt;0) and (y&gt;0) and (x&lt;=n) and (y&lt;=m) do begin<br>        if map[x,y]=’x’ then begin h:=1;t:=0 end;<br>        while (h&lt;=t) and (q[t,0]<f[x,y]-cnt) do="" dec(t);="" inc(t);q[t,0]:="f[x,y]-cnt;q[t,1]:=cnt;" while="" (h<="t)" and="" (cnt-q[h,1]="">l) do inc(h);<br>        f[x,y]:=q[h,0]+cnt;<br>        ans:=max(ans,f[x,y]);<br>        inc(x,dir[d,0]);inc(y,dir[d,1]);inc(cnt);<br>    end;<br>end;</f[x,y]-cnt)></p>
<p>begin<br>    assign(input,’adv1900.in’);reset(input);<br>    assign(output,’adv1900.out’);rewrite(output);<br>    readln(n,m,sx,sy,k);<br>    for i:=1 to n do begin<br>        for j:=1 to m do read(map[i,j]);<br>        readln;<br>    end;<br>    filldword(f,sizeof(f) div 4,-inf);<br>    f[sx,sy]:=0;ans:=0;<br>    for i:=1 to k do begin<br>        read(l,r,d);<br>        if d=1 then for j:=1 to m do dp(n,j,d,r-l+1);<br>        if d=2 then for j:=1 to m do dp(1,j,d,r-l+1);<br>        if d=3 then for j:=1 to n do dp(j,m,d,r-l+1);<br>        if d=4 then for j:=1 to n do dp(j,1,d,r-l+1);<br>    end;<br>    write(ans);<br>    close(input);close(output);<br>end.</p>
<pre><code>
# P4 Dividing
Marsha and Bill own a collection of marbles. They want to split the collection among themselves so that both receive an equal share of the marbles. This would be easy if all the marbles had the same value, because then they could just split the collection in half. But unfortunately, some of the marbles are larger, or more beautiful than others. So, Marsha and Bill start by assigning a value, a natural number between one and six, to each marble. Now they want to divide the marbles so that each of them gets the same total value. Unfortunately, they realize that it might be impossible to divide the marbles in this way (even if the total value of all marbles is even). For example, if there are one marble of value 1, one of value 3 and two of value 4, then they cannot be split into sets of equal value. So, they ask you to write a program that checks whether there is a fair partition of the marbles.

## 格式
### 输入格式
Each line in the input file describes one collection of marbles to be divided. The lines contain six non-negative integers n1 , . . . , n6 , where ni is the number of marbles of value i. So, the example from above would be described by the input-line &quot;1 0 1 2 0 0&quot;. The maximum total number of marbles will be 20000. 
The last line of the input file will be &quot;0 0 0 0 0 0&quot;; do not process this line.

#### 输出格式
For each collection, output &quot;Collection #k:&quot;, where k is the number of the test case, and then either &quot;Can be divided.&quot; or &quot;Can&#39;t be divided.&quot;. 
Output a blank line after each test case.

## 样例
### 样例输入
&gt;1 0 1 2 0 0 
1 0 0 0 1 1 
0 0 0 0 0 0 

### 样例输出
&gt;Collection #1:
Can&#39;t be divided.

&gt;Collection #2:
Can be divided.

## 题解
这是[OJ上的一道题](http://noi.openjudge.cn/ch0405/16/)
题目大意是：求给定数量的数字1~6能否分成和相等的两组。
体积为1..6的物品做多重背包，问达到体积sum div 2是否可行。
同样用单调队列优化即可，只不过这里不计价值，dp数组可以存boolean。
对于给定体积v=i+k\*c，如果f[i-1,v]=true则入队，接下来无效元素出队，之后如果队列不为空则f[i,v]:=true
如果f[6,sum div 2]=true就可以被划分。

&lt;dir style=&quot;display:none&quot;&gt;<a href="/2016/08/20/JSOI2016-提高2班-单调队列及动规优化/dividing.pas" title="复制代码">复制代码</a>&lt;/dir&gt;

```delphi dividing.pas
uses math;
type int=longint;
var 
    f:array[0..500010] of boolean;
    q:array[0..1000010] of int;
    a:array[0..6] of int;
    i,sum,cnt,d:int;

procedure print(i:int;b:boolean);
begin
    writeln(&#39;Collection #&#39;,cnt,&#39;:&#39;);
    if b then writeln(&#39;Can be divided.&#39;) 
    else writeln(&#39;Can&#39;,chr(39),&#39;t be divided.&#39;);
    writeln;
end;

procedure dp(c,a:int);
var h,t,k,i:int;
begin
    if a=0 then exit;
    d:=min(sum,d+c*a);
    for i:=0 to c-1 do begin
        h:=1;t:=0;k:=0;
        while i+k*c&lt;=d do begin
            if f[i+k*c] then begin inc(t);q[t]:=k end;
            while (h&lt;=t) and (k-q[h]&gt;a) do inc(h);
            if (h&lt;=t) then f[i+k*c]:=true;
            inc(k);
        end;
    end;
end;

begin
    cnt:=0;
    while true do begin
        sum:=0;
        for i:=1 to 6 do begin
            read(a[i]);
            inc(sum,a[i]*i);
        end;
        if sum=0 then break;
        inc(cnt);
        if odd(sum) then begin print(cnt,false);continue end;
        fillchar(f,sizeof(f),false);
        f[0]:=true;d:=0;
        for i:=1 to 6 do dp(i,a[i]);
        print(cnt,f[sum div 2]);
    end;
end.
</code></pre>]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[[JSOI2016] 提高2班 二分答案]]></title>
      <url>https://cothrax.github.io/2016/08/20/JSOI2016-%E6%8F%90%E9%AB%982%E7%8F%AD-%E4%BA%8C%E5%88%86%E7%AD%94%E6%A1%88/</url>
      <content type="html"><![CDATA[<p>二分的坑点在于解的检验。</p>
<table>
<thead>
<tr>
<th>题号</th>
<th>检验方法</th>
</tr>
</thead>
<tbody>
<tr>
<td>P1 P2</td>
<td>贪心</td>
</tr>
<tr>
<td>P3 P5</td>
<td>DP</td>
</tr>
<tr>
<td>P4</td>
<td>DFS</td>
</tr>
</tbody>
</table>
<h1 id="P1-晒衣服"><a href="#P1-晒衣服" class="headerlink" title="P1 晒衣服"></a>P1 晒衣服</h1><p>洗完衣服后，你要弄干衣服。衣服在自然条件下用1个单位时间可以晒干A点湿度，现在买了1台烘衣机，使用烘衣机可以让你用1个单位的时间使1件衣服除开自然晒干的A点湿度外，还可烘干B点湿度，但在1个单位的时间内只能对1件衣服使用。<br>N件衣服因为种种原因而不一样湿，现在告诉你每件衣服的湿度，要你求出弄干所有衣服的最少时间（湿度为0为干）。</p>
<h2 id="格式"><a href="#格式" class="headerlink" title="格式"></a>格式</h2><h3 id="输入格式"><a href="#输入格式" class="headerlink" title="输入格式"></a>输入格式</h3><p>输入文件第一行N，A，B;<br>接下来1^行，每行一个数，表示衣服的湿度$a_i$（<span>$1\leq a_i\leq500000，1\leq N\leq 500000$</span><!-- Has MathJax -->）。</p>
<h3 id="输出格式"><a href="#输出格式" class="headerlink" title="输出格式"></a>输出格式</h3><p>输出一行一个整数，表示最少时间。<br><a id="more"></a></p>
<h2 id="样例"><a href="#样例" class="headerlink" title="样例"></a>样例</h2><h3 id="样例输入"><a href="#样例输入" class="headerlink" title="样例输入"></a>样例输入</h3><blockquote>
<p>3 2 1 1 2<br>3</p>
</blockquote>
<h3 id="样例输出"><a href="#样例输出" class="headerlink" title="样例输出"></a>样例输出</h3><blockquote>
<p>1</p>
</blockquote>
<h2 id="提示"><a href="#提示" class="headerlink" title="提示"></a>提示</h2><p>样例解析：<br>第1个单位时间内，用机器处理第3件衣服，此外，所有衣服自然晒干2。</p>
<h2 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h2><dir style="display:none"><a href="/2016/08/20/JSOI2016-提高2班-二分答案/dry.pas" title="复制代码">复制代码</a></dir>

<p>```delphi dry.pas<br>uses math;<br>type int=longint;<br>var<br>    n,a,b,l,r,mid,ans,i:int;<br>    f:array[0..500010] of int;</p>
<p>function check(x:int):boolean;<br>var i,cnt:int;<br>begin<br>    cnt:=0;<br>    for i:=1 to n do<br>        if x<em>a&lt;f[i] then<br>            inc(cnt,ceil((f[i]-x</em>a)/b));<br>    check:=cnt&lt;=x;<br>end;</p>
<p>begin<br>    assign(input,’dry.in’);reset(input);<br>    assign(output,’dry.out’);rewrite(output);<br>    read(n,a,b);<br>    l:=0;r:=0;<br>    for i:=1 to n do begin<br>        read(f[i]);<br>        r:=max(f[i],r);<br>    end;<br>    while l&lt;=r do begin<br>        mid:=(l+r) shr 1;<br>        if check(mid) then begin ans:=mid;r:=mid-1 end<br>        else l:=mid+1;<br>    end;<br>    write(ans);<br>    close(input);close(output);<br>end.</p>
<pre><code>
# P2 收入计划
高考结束后，同学们大都找到了一份临时工作，渴望挣得一些零用钱。从今天起，Matrix67将 连续工作N天(1≤N≤00000)。每一天末他可以领取当天及前面若干天里没有领取的工资，但他总共 只有M(l^M^N)次领取工资的机会。Matrix67已经知道了在接下来的这N天里每一天他可以赚多少钱。为了避免自己滥用零花钱，他希望知道如何安排领取工资的时间才能使得领到工资最多的那一 次工资数额最小。
注意:Matrix67必须恰好领工资M次，且需要将所有的工资全部领走（即最后一天末需要领一次 工资）。

## 格式
### 输入格式
输入文件第一行包括2个正整数N和M。
以下N行，每行一个不超过10000正整数，依次表示每一天的薪水。

### 输出格式
输出文件仅一行一个整数，表示领取到的工资的最大值最小是多少。
&lt;!--more--&gt;

## 样例
### 样例输入
&gt;75
100
400
300
100
500
101
400

### 样例输出
&gt;500

## 题解

&lt;dir style=&quot;display:none&quot;&gt;<a href="/2016/08/20/JSOI2016-提高2班-二分答案/income.pas" title="复制代码">复制代码</a>&lt;/dir&gt;

```delphi income.pas
type int=longint;
var 
    n,m,i,l,r,mid,ans:int;
    a:array[0..100010] of int;

function check(x:int):boolean;
var i,sum,cnt:int;
begin
    sum:=0;cnt:=0;
    for i:=1 to n do
        if a[i]&gt;x then exit(false) //不要忘了这个
        else if sum+a[i]&gt;x then begin
            inc(cnt);sum:=a[i]
        end else
            inc(sum,a[i]);
    check:=(cnt+1)&lt;=m;
end;

begin
    assign(input,&#39;income.in&#39;);reset(input);
    assign(output,&#39;income.out&#39;);rewrite(output);
    read(n,m);
    l:=0;r:=0;
    for i:=1 to n do begin
        read(a[i]);
        inc(r,a[i]);
    end;
    while l&lt;=r do begin
        mid:=(l+r) shr 1;
        if check(mid) then begin ans:=mid;r:=mid-1 end
        else l:=mid+1;
    end;
    write(ans);
    close(input);close(output);
end.
</code></pre><h1 id="P3-软件开发"><a href="#P3-软件开发" class="headerlink" title="P3 软件开发"></a>P3 软件开发</h1><p>一个软件开发公司同时要开发两个软件，并且要同时交付给用户，现在公司为了尽快完成这一 任务，将每个软件划分成m个模块，由公司里的技术人员分工完成，每个技术人员完成同一软件的 不同模块的所用的天数是相同的，并且是已知的，但完成不同软件的一个模块的时间是不同的，每 个技术人员在同一时刻只能做一个模块，一个模块只能由一个人独立完成而不能由多人协同完成。 一个技术人员在整个开发期内完成一个模块以后可以接着做任一软件的任一模块。写一个程序，求 出公司最早能在什么时候交付软件。</p>
<h2 id="格式-1"><a href="#格式-1" class="headerlink" title="格式"></a>格式</h2><h3 id="输入格式-1"><a href="#输入格式-1" class="headerlink" title="输入格式"></a>输入格式</h3><p>输入数据共若干行。第一行包含两个由空格隔开的整数n和m，其中1≤n,m≤100。接下 来的n行每行包含两个用空格隔开的整数d1和d2, d1表示该技术人员完成第一个软件中的一个模块所需的天数，d2表示该技术人员完成第二个软件中的一个模块所需的天数，其中1≤d1,d2≤100 输出格式：<br>输出数据仅有一行包含一个整数d，表示公司最早能于d天后交付软件。</p>
<h3 id="输出格式-1"><a href="#输出格式-1" class="headerlink" title="输出格式"></a>输出格式</h3><p>输出文件仅一行一个整数，表示领取到的工资的最大值最小是多少。<br><!--more--></p>
<h2 id="样例-1"><a href="#样例-1" class="headerlink" title="样例"></a>样例</h2><h3 id="样例输入-1"><a href="#样例输入-1" class="headerlink" title="样例输入"></a>样例输入</h3><blockquote>
<p>3 20<br>1 1<br>2 4<br>1 6</p>
</blockquote>
<h3 id="样例输出-1"><a href="#样例输出-1" class="headerlink" title="样例输出"></a>样例输出</h3><blockquote>
<p>18</p>
</blockquote>
<h2 id="提示-1"><a href="#提示-1" class="headerlink" title="提示"></a>提示</h2><p>最快的方案是第一个技术人员完成第二个软件的18个模块，用时18天，第三个技术人员完成 第一个软件的18个模块，用时18天，其余的模块由第二个技术人员完成，用时12天，做完所有模 块需要18天。如果第一个技术人员完成第二个软件的17个模块，第三个技术人员完成第一个软件 的17个模块，其余的模块由第二个技术人员完成，需要用时18天，做完所有模块仍然需要18天， 所以少于18天不可能做完所有模块。</p>
<h2 id="题解-1"><a href="#题解-1" class="headerlink" title="题解"></a>题解</h2><p>给定时间x，记f[i,j]为前i个人完成了软件1的j个模块后，能完成软件2的模块的最大数量，然后DP。</p>
<dir style="display:none"><a href="/2016/08/20/JSOI2016-提高2班-二分答案/software.pas" title="复制代码">复制代码</a></dir>

<p>```delphi software.pas<br>uses math;<br>const inf=100000000;<br>type int=longint;<br>var<br>    n,m,i,l,r,mid,ans:int;<br>    f:array[0..101] of int;<br>    d:array[0..101,0..1] of int;</p>
<p>function check(x:int):boolean;<br>var i,j,k,maxs:int;<br>begin<br>    filldword(f,sizeof(f) div 4,-inf);<br>    f[0]:=0;<br>    for i:=1 to n do begin<br>        maxs:=x div d[i,0];<br>        for j:=m downto 0 do<br>            for k:=0 to min(maxs,j) do<br>                f[j]:=max(f[j],f[j-k]+(x-k*d[i,0]) div d[i,1]);<br>    end;<br>    check:=f[m]&gt;=m;<br>end;</p>
<p>begin<br>    assign(input,’software.in’);reset(input);<br>    assign(output,’software.out’);rewrite(output);<br>    read(n,m);<br>    for i:=1 to n do read(d[i,0],d[i,1]);<br>    l:=1;r:=inf;<br>    while l&lt;=r do begin<br>        mid:=(l+r) shr 1;<br>        if check(mid) then begin ans:=mid;r:=mid-1 end<br>        else l:=mid+1;<br>    end;<br>    write(ans);<br>    close(input);close(output);<br>end.</p>
<pre><code>
# P4 架设电话线
FJ打算将电话线引到自己的农场，但电信公司并不打算为他提供免费服务。于是，H必须为此 向电信公司支付一定的费用。
FJ的农场周围分布着N(1≤N≤1000)根按1..N顺次编号的废弃的电话线杆，任意两根电话线杆间 都没有电话线相连。一共P(1≤P≤1OOOO)对电话线杆间可以拉电话线，其余的那些由于隔得太远而无 法被连接。第i对电话线杆的两个端点分别为Ai、Bi，它们间的距离为Li(1≤Li≤1,000,000)。数据中 保证每对(Ai，Bi)最多只出现1次。编号为1的电话线杆已经接入了全国的电话网络，整个农场的 电话线全都连到了编号为N的电话线杆上。也就是说，FJ的任务仅仅是找一条将1号和N号电话线 杆连起来的路径，其余的电话线杆并不一定要连入电话网络。
经过谈判，电信公司最终同意免费为FJ连结K((0≤K\&lt;N)对由H指定的电话线杆。对于此外的那 些电话线，n需要为它们付的费用，等于其中最长的电话线的长度（每根电话线仅连结一对电话线 杆）。如果需要连结的电话线杆不超过K对，那么FJ的总支出为0。
请你计算一下，FJ最少需要在电话线上花多少钱。

## 格式
### 输入格式
输入文件第1行:3个用空格隔开的整数：N, P，以及K。
第2..P+1行：第i+1行为3个用空格隔开的整数：Ai，Bi，Li。

### 输出格式
输出文件一行一个整数，为FJ这项工程上的最小支出。如果任务不可能完成，输出-1。
&lt;!--more--&gt;

## 样例
### 样例输入
&gt;5 7 1
1 2 5
3 1 4 
2 4 8
3 2 3
5 2 9
3 4 7
4 5 6

### 样例输出
&gt;4

## 提示
一共有5根废弃的电话线杆。电话线杆1不能直接与电话线杆4、5相连。电话线杆5不能直接 与电话线杆1、3相连。其余所有电话线杆间均可拉电话线。电信公司可以免费为FJ连结一对电话 线杆。
FJ选择如下的连结方案：1-&gt;3; 3-&gt;2; 2-&gt;5,这3对电话线杆间需要的电话线的长度分别为4、 3、9。FJ让电信公司提供那条长度为9的电话线，于是，他所需要购买的电话线的最大长度为4。


## 题解
最小化最大值，二分答案，不能再裸了。
给定费用x，从1开始dfs，距离小于x的边直接走过去，大于的话递归统计数量j，当j&gt;k时exit。
注意判重数组为used[n,k]而不是used[n]
可以用flag记录一下有没有走到n，如果有直接exit就好。

&lt;dir style=&quot;display:none&quot;&gt;<a href="/2016/08/20/JSOI2016-提高2班-二分答案/phoneline.pas" title="复制代码">复制代码</a>&lt;/dir&gt;

```delphi phoneline.pas
uses math;
type
    int=longint;
    edge=record t,next,w:int end;
var 
    g:array[0..20010] of edge;
    head:array[0..1010] of int;
    used:array[0..1010,0..1010] of boolean;
    n,p,k,i,l,r,mid,ans,f0,t0,w0:int;
    flag:boolean;

procedure add(f,t,w:int);
var m:int;
begin
    inc(head[0]);m:=head[0];
    g[m].t:=t;g[m].w:=w;
    g[m].next:=head[f];head[f]:=m;
end;

procedure dfs(v,j:int);
var i,u:int;
begin
    if j&gt;k then exit;
    if v=n then begin flag:=true;exit end;
    used[v,j]:=true;
    i:=head[v];
    while i&lt;&gt;0 do begin
        u:=g[i].t;
        if (g[i].w&lt;=mid) and not used[u,j] then dfs(u,j);
        if (g[i].w&gt;mid) and not used[u,j+1] then dfs(u,j+1);
        if flag then exit;
        i:=g[i].next;
    end;
end;

function check():boolean;
begin
    fillchar(used,sizeof(used),false);
    flag:=false;
    dfs(1,0);
    check:=flag;
end;

begin
    assign(input,&#39;phoneline.in&#39;);reset(input);
    assign(output,&#39;phoneline.out&#39;);rewrite(output);
    read(n,p,k);
    l:=0;r:=0;
    fillchar(head,sizeof(head),0);
    for i:=1 to p do begin
        read(f0,t0,w0);
        add(f0,t0,w0);add(t0,f0,w0);
        r:=max(r,w0);
    end;
    ans:=-1;
    while l&lt;=r do begin
        mid:=(l+r) shr 1;
        if check() then begin ans:=mid;r:=mid-1 end
        else l:=mid+1;
    end;
    write(ans);
    close(input);close(output);
end.
</code></pre><h1 id="P5-圣诞节的花环"><a href="#P5-圣诞节的花环" class="headerlink" title="P5 圣诞节的花环"></a>P5 圣诞节的花环</h1><p>圣诞节就要到了。现在有个困难的任务摆在你眼前——装饰房间。你手头上有n朵大小相同的 花，第i朵花的重量为Wi。现在打算用一根绳将这n朵花按顺序穿起来，挂在天花板上。绳子被m 个点固定，也就是绳子的一头被固定在1号点，另外一头固定在m号点，中间部分需要固定在剩余 的点。当然，装饰还有一些规则要注意：<br>1、每一段需要包含非0的偶数个花朵。正因如此，我们可以将每一段划分为两个半段。<br>2、为了减小你的客人撞到花环的可能，花环不能挂的太低：也就是说，每个半段不能超过d朵花。<br>3、最后，你需要让所有半段的重量的最大值最小。<br>下图是一个不错的安排方案，圈中的数字代表花朵的重量。<br><img src="/2016/08/20/JSOI2016-提高2班-二分答案/t.jpg" alt="t.jpg" title=""></p>
<h2 id="格式-2"><a href="#格式-2" class="headerlink" title="格式"></a>格式</h2><h3 id="输入格式-2"><a href="#输入格式-2" class="headerlink" title="输入格式"></a>输入格式</h3><p>输入文件第一行包含三个正整数n, m和d( 1≤1≤15000,2≤m≤10000,1≤d≤2000,且n*d≤5000000)。<br>接下来一行包含n个正整数w1，w2, …，wn (l≤w≤1OOOO)，代表对应花的重量。</p>
<h3 id="输出格式-2"><a href="#输出格式-2" class="headerlink" title="输出格式"></a>输出格式</h3><p>输出一行一个整数，代表最小的所有半段重量的最大值。如果没有方案满足条件，那么你只要 输出“BAD”（不包括引号）。</p>
<h2 id="样例-2"><a href="#样例-2" class="headerlink" title="样例"></a>样例</h2><h3 id="样例输入-2"><a href="#样例输入-2" class="headerlink" title="样例输入"></a>样例输入</h3><blockquote>
<p>4 3 10 10 10<br>20 20</p>
<p>6 4 10<br>1 1 100 100 1 1</p>
<p>6 3 10<br>1 1 100 100 1 1</p>
<p>1 2 2<br>333</p>
</blockquote>
<h3 id="样例输出-2"><a href="#样例输出-2" class="headerlink" title="样例输出"></a>样例输出</h3><blockquote>
<p>20</p>
<p>100</p>
<p>200</p>
<p>BAD</p>
</blockquote>
<h2 id="题解-2"><a href="#题解-2" class="headerlink" title="题解"></a>题解</h2><p>又见最小化最大值。<br>首先，n为奇数显然是无解的。因为题中要求固定点<strong>恰好</strong>m个，且环不能为0，那么如果<span>$n&lt;2*(m-1)$</span><!-- Has MathJax -->，也是无解的。<br>然后二分最大重量。<br>可以DP做，f[i]表示前i<strong>对</strong>花最少需要分成几段，于是<span>$f[i]=max\{f[j]+1\}$</span><!-- Has MathJax -->。然后<span>$f[n]&lt;m$</span><!-- Has MathJax -->的话就返回true<br>但这样写样例3是过不了的，因为将整段划分成1个区间符合答案102，但1个区间是不能被截成m-1=2个区间的。<br>实际上，如果k个区间可行，那么k+2个区间是可行的。<br>所以分奇偶讨论，f[n,0..1]，0为偶数段，1为奇数段<br><span>$f[i,0]=max\{f[j,1]+1\}$</span><!-- Has MathJax --><br><span>$f[i,1]=max\{f[j,0]+1\}$</span><!-- Has MathJax --></p>
<dir style="display:none"><a href="/2016/08/20/JSOI2016-提高2班-二分答案/flow.pas" title="复制代码">复制代码</a></dir>

<p>```delphi flow.pas<br>uses math;<br>type int=longint;<br>const inf=1000000000;<br>var<br>    n,m,d,i,l,r,mid,ans:int;<br>    w,s:array[0..15010] of int;<br>    f:array[0..15010,0..1] of int;</p>
<p>function check(x:int):boolean;<br>var i,j:int;<br>begin<br>    filldword(f,sizeof(f) div 4,inf);<br>    f[0,0]:=0;<br>    for i:=1 to n div 2 do<br>        for j:=i-1 downto max(i-d,0) do<br>            if max(s[2<em>j+i-j]-s[2</em>j],s[2<em>i]-s[2</em>j+i-j])&lt;=x then begin<br>                f[i,0]:=min(f[i,0],f[j,1]+1);<br>                f[i,1]:=min(f[i,1],f[j,0]+1);<br>            end;<br>    check:=f[n div 2,(m-1) and 1]&lt;m;<br>end;</p>
<p>begin<br>    assign(input,’flow.in’);reset(input);<br>    assign(output,’flow.out’);rewrite(output);<br>    read(n,m,d);<br>    if odd(n) or (n&lt;2*m-2) then begin write(‘BAD’);halt end;<br>    l:=0;r:=0;s[0]:=0;<br>    for i:=1 to n do begin<br>        read(w[i]);<br>        inc(r,w[i]);<br>        s[i]:=s[i-1]+w[i];<br>    end;</p>
<pre><code>ans:=-1;
while l&lt;=r do begin
    mid:=(l+r) shr 1;
    if check(mid) then begin ans:=mid;r:=mid-1 end
    else l:=mid+1;
end;
if ans=-1 then write(&#39;BAD&#39;) else write(ans);
close(input);close(output);
</code></pre><p>end.<br>```</p>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[[JSOI2016] 提高2班 树形DP（二）]]></title>
      <url>https://cothrax.github.io/2016/08/19/JSOI2016-%E6%8F%90%E9%AB%982%E7%8F%AD-%E6%A0%91%E5%BD%A2DP%EF%BC%88%E4%BA%8C%EF%BC%89/</url>
      <content type="html"><![CDATA[<h1 id="P5-The-more-The-better"><a href="#P5-The-more-The-better" class="headerlink" title="P5 The more, The better"></a>P5 The more, The better</h1><p>ACboy很喜欢玩一种战略游戏，在一个地图上，有N座城堡，每座城堡都有一定的宝物，在每次游戏中ACboy允许攻克M个城堡并获得里面的宝物。但由于地理位置原因，有些城堡不能直接攻克，要攻克这些城堡必须先攻克其他某一个特定的城堡。你能帮ACboy算出要获得尽量多的宝物应该攻克哪M个城堡吗？</p>
<h2 id="格式"><a href="#格式" class="headerlink" title="格式"></a>格式</h2><h3 id="输入格式"><a href="#输入格式" class="headerlink" title="输入格式"></a>输入格式</h3><p>每个测试实例首先包括2个整数，N,M.(1 &lt;= M &lt;= N &lt;= 200);在接下来的N行里，每行包括2个整数，a,b. 在第 i 行，a 代表要攻克第 i 个城堡必须先攻克第 a 个城堡，如果 a = 0 则代表可以直接攻克第 i 个城堡。b 代表第 i 个城堡的宝物数量, b &gt;= 0。当N = 0, M = 0输入结束。</p>
<h3 id="输出格式"><a href="#输出格式" class="headerlink" title="输出格式"></a>输出格式</h3><p>对于每个测试实例，输出一个整数，代表ACboy攻克M个城堡所获得的最多宝物的数量。<br><a id="more"></a></p>
<h2 id="样例"><a href="#样例" class="headerlink" title="样例"></a>样例</h2><h3 id="样例输入"><a href="#样例输入" class="headerlink" title="样例输入"></a>样例输入</h3><blockquote>
<p>3 2<br>0 1<br>0 2<br>0 3<br>7 4<br>2 2<br>0 1<br>0 4<br>2 1<br>7 1<br>7 6<br>2 2<br>0 0</p>
</blockquote>
<h3 id="样例输出"><a href="#样例输出" class="headerlink" title="样例输出"></a>样例输出</h3><blockquote>
<p>5<br>13</p>
</blockquote>
<h2 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h2><p>裸的树形背包，多叉转二叉后做就可以了。<br>杭电OJ不知怎么爆掉了，以下代码没测，仅供参考思路。交上去应该会ce，因为uses math</p>
<dir style="display:none"><a href="/2016/08/19/JSOI2016-提高2班-树形DP（二）/test.pas" title="复制代码">复制代码</a></dir>

<p>```delphi test.pas<br>uses math;<br>type<br>    int=longint;<br>var<br>    br,ch,w:array[0..210] of int;<br>    f:array[0..210,0..210] of int;<br>    n,m,i,a:int;</p>
<p>procedure add(p,c:int);<br>begin<br>    br[c]:=ch[p];<br>    ch[p]:=c;<br>end;</p>
<p>function dp(v,j:int):int;<br>var i:int;<br>begin<br>    if (v=0) or (v=0) then exit(0);<br>    if f[v,j]&lt;&gt;-1 then exit(f[v,j]);<br>    f[v,j]:=0;<br>    for i:=0 to j-1 do<br>        f[v,j]:=max(f[v,j],dp(ch[v],i)+w[v]+dp(br[v],j-i-1));<br>    f[v,j]:=max(f[v,j],dp(br[v],j));<br>    dp:=f[v,j];<br>end;</p>
<p>begin<br>    read(n,m);<br>    while (n&lt;&gt;0) and (m&lt;&gt;0) do begin<br>        fillchar(br,sizeof(br),0);<br>        fillchar(ch,sizeof(ch),0);<br>        for i:=1 to n do begin<br>            read(a,w[i]);<br>            add(a,i);<br>        end;<br>        filldword(f,sizeof(f) div 4,-1);<br>        writeln(dp(ch[0],m));<br>        read(n,m);<br>    end;<br>end.</p>
<pre><code>
# P6 作业大会
可爱的凯文在高一时就统计了所有人的联系方式，完成了教一的通讯录。每年的寒暑假开作业大会的时候这张通讯录就充分发挥了作用。同志们根据这张通讯录制定了通讯网络，可以抽象成一棵树。
每个节点（除叶子节点）首先接受他的所有孩子节点完成的卷子。接着他选择可以完成任意一张未完成的卷子，也可以选择不做。最后所有完成的卷子被汇总到树根节点。
很显然做卷子是要消耗时间的，卷子从孩子传到父亲也是要耗时间的。你的任务就是安排一个计划使得消耗最少时间完成所有卷子并汇总到树根。

## 格式
### 输入格式
第一行两个整数n，m。表示人数和卷子总数。
接下来n-1行每行三个整数x，y，c。表示x和y连通，在x和y之间传递时间为c。
最后n行，每行m个整数。第i行第j列的整数是编号i的节点完成第j张卷子消耗的时间。
n&lt;=55，m&lt;=11，保证n&gt;=m。根节点的编号为1。

### 输出格式
一个整数t。表示消耗的最小总时间。保证答案在longint范围内。

## 样例
### 样例输入
&gt;6 3
1 2 1
1 3 1
2 4 1
2 5 1
3 6 1
3 4 3
3 2 5
6 1 2
1 8 9
8 8 1
4 7 6

### 样例输出
&gt;7

## 题解
**树形DP+状压**，又是一个下午==
我的想法是多叉转二叉后做。
f[v,s]表示v的子树，完成状态s的卷子所需的时间，对应的记忆化函数为dp(v,s)
a[v,i]指v做卷子i的时间，w[v]指v向父节点传输的时间
1. 枚举v做的卷子i，在剩余的卷子$s1=s-1\ shl\ (i-1)$中，枚举子节点做的卷子状态s2，于是答案<span>$=w[v]+a[v,i]+dp(ch[v],s2)+dp(br[v],s1\ xor\ s2)$</span><!-- Has MathJax -->
2. v不做卷子，直接枚举子节点做的卷子状态s1，答案<span>$=w[v]+dp(ch[v],s1)+dp(br[v],s1\ xor\ s)$</span><!-- Has MathJax -->，注意$s1\not=0$
3. 卷子全部给兄弟节点做，答案$=dp(br[v],s)$

但转二叉后的问题在于冗余的情况非常的多，然后就TLE了，于是考虑优化：
cnt[x]记录x的二进制中1的个数
siz[v]以v为根的子树节点个数
当cnt[s]&gt;siz[v]时，直接返回inf。这个剪枝是非常厉害的。

标程是直接的多叉上做的，启发式合并什么的然而我并不会。

&lt;dir style=&quot;display:none&quot;&gt;<a href="/2016/08/19/JSOI2016-提高2班-树形DP（二）/network.pas" title="复制代码">复制代码</a>&lt;/dir&gt;

```delphi network.pas
uses math;
const inf=1000000000;
type 
    int=longint;
    edge=record t,w,next:int end;
var 
    g:array[0..120] of edge; //存多叉
    head,br,ch,w,siz:array[0..60] of int;
    a:array[0..60,0..15] of int;
    f:array[0..60,0..1 shl 11-1] of int;
    cnt:array[0..1 shl 11-1] of int;
    n,m,k,i,j,f0,t0,w0:int;

procedure add(f,t,w:int);
var m:int;
begin
    inc(head[0]);m:=head[0];
    g[m].t:=t;g[m].w:=w;
    g[m].next:=head[f];head[f]:=m;
end;
//多叉转二叉
procedure dfs(v,p,w0:int);inline;
var i,u:int;
begin
    br[v]:=ch[p];ch[p]:=v;w[v]:=w0;
    i:=head[v];
    while i&lt;&gt;0 do begin
        u:=g[i].t;
        if u&lt;&gt;p then dfs(u,v,g[i].w);
        i:=g[i].next;
    end;
end;
//计算x的二进制表示中1的个数
function count(x:int):int;
begin
    count:=0;
    while x&lt;&gt;0 do begin
        inc(count);
        dec(x,x and (-x));
    end;
end;
//计算以v为根的子树的节点数
function cal(v:int):int;
begin
    if v=0 then exit(0);
    siz[v]:=cal(ch[v])+cal(br[v])+1;
    cal:=siz[v];
end;

function dp(v,s:int):int;
var x,i,j,s1,s2,tmp:int;
begin
    if cnt[s]&gt;siz[v] then exit(inf); //剪枝
    if f[v,s]&lt;&gt;-1 then exit(f[v,s]);
    if s=0 then exit(0);
    if v=0 then exit(inf);

    x:=s;
    f[v,s]:=inf;
    while x&lt;&gt;0 do begin //枚举v做的卷子
        i:=x and (-x);
        j:=round(ln(i)/ln(2))+1;
        s1:=s and not i;
        f[v,s]:=min(f[v,s],w[v]+a[v,j]+min(dp(br[v],s1),dp(ch[v],s1)));

        s2:=s1;
        while s2&lt;&gt;0 do begin //枚举子节点做的卷子
            tmp:=w[v]+a[v,j]+dp(ch[v],s2)+dp(br[v],s1 xor s2);
            f[v,s]:=min(f[v,s],tmp);
            s2:=(s2-1) and s1;
        end;
        x:=x and not i;
    end;
    s1:=s; //v不做卷子
    while s1&lt;&gt;0 do begin //枚举子节点做的卷子
        f[v,s]:=min(f[v,s],w[v]+dp(ch[v],s1)+dp(br[v],s xor s1));
        s1:=(s1-1) and s;
    end;
    f[v,s]:=min(f[v,s],dp(br[v],s)); //全给兄弟做
    dp:=f[v,s];
end;

begin
    assign(input,&#39;network.in&#39;);reset(input);
    assign(output,&#39;network.out&#39;);rewrite(output);

    read(n,m);
    k:=1 shl m-1;
    for i:=1 to k do cnt[i]:=count(i);
    for i:=1 to n-1 do begin
        read(f0,t0,w0);
        add(f0,t0,w0);add(t0,f0,w0);
    end;
    dfs(1,0,0);cal(1);
    for i:=1 to n do
        for j:=1 to m do read(a[i,j]);

    filldword(f,sizeof(f) div 4,-1);
    write(dp(1,k));

    close(input);close(output);
end.
</code></pre><p>如果想用多叉，可以欣赏一下标程：<a href="/2016/08/19/JSOI2016-提高2班-树形DP（二）/network2.pas" title="戳这里">戳这里</a></p>
<h1 id="P7-消防站"><a href="#P7-消防站" class="headerlink" title="P7 消防站"></a>P7 消防站</h1><p>Z国有N个城市，编号为1~N。城市之间用高速公路连接，任意两个城市之间有且仅有一条路径。<br>最近，Z国火灾频发，于是政府决定在一些城市建立一些消防站，在城市K建立消防站需要花费W（K），每个城市的W可能不同。如果不在城市K建立消防站，那么需要保证离K最近的消防站与K的距离不超过D（K）。每个城市的D可能不同。<br>为了节省开支，政府希望你计算满足要求的最小花费。</p>
<h2 id="格式-1"><a href="#格式-1" class="headerlink" title="格式"></a>格式</h2><h3 id="输入格式-1"><a href="#输入格式-1" class="headerlink" title="输入格式"></a>输入格式</h3><p>第一行一个整数T，表示测试数据组数。<br>接下来一共T部分，每部分格式如下：<br>第一行包含一个整数N(1≤n≤1000)。<br>第二行包含N个整数，第i个整数表示W（i）(0 &lt; W(i) &lt;= 10000)。<br>第三行包含N个整数，第i个整数表示D（i）（0 &lt;= D(i) &lt;= 10000）。<br>接下来n-1行，每行三个数u，v，L(1 &lt;= u, v &lt;= N，0 &lt; L &lt;= 1000)，表示城市u和城市v之间有一条长度为l的高速公路。</p>
<h4 id="输出格式-1"><a href="#输出格式-1" class="headerlink" title="输出格式"></a>输出格式</h4><p>每组测试数据输出一个整数，表示最小费用。</p>
<h2 id="样例-1"><a href="#样例-1" class="headerlink" title="样例"></a>样例</h2><h3 id="输入样例"><a href="#输入样例" class="headerlink" title="输入样例"></a>输入样例</h3><blockquote>
<p>1<br>5<br>1 1 1 1 1<br>2 1 1 1 2<br>1 2 1<br>2 3 1<br>3 4 1<br>4 5 1</p>
</blockquote>
<h3 id="输出样例"><a href="#输出样例" class="headerlink" title="输出样例"></a>输出样例</h3><blockquote>
<p>1</p>
</blockquote>
<h2 id="题解-1"><a href="#题解-1" class="headerlink" title="题解"></a>题解</h2><p>好像很厉害的树形DP，完整分析可以看<a href="/2016/08/19/JSOI2016-提高2班-树形DP（二）/消防站解题报告.doc" title="陈启峰的解题报告">陈启峰的解题报告</a>。<br>这里简单说一下思路：<br>ans[i]记录以i为根的子树全部被覆盖的最优值<br>f[i,j]记录以i为根的子树，在i依赖j的情况下的最优值<br>树形DP的方程都不好表示，直接看代码好了。<br>可以用dfs预处理两点距离，当然也可以倍增做。</p>
<dir style="display:none"><a href="/2016/08/19/JSOI2016-提高2班-树形DP（二）/fire.pas" title="复制代码">复制代码</a></dir>

<p>```delphi fire.pas<br>uses math;<br>const inf=1000000000;<br>type<br>    int=longint;<br>    edge=record t,w,next:int end;<br>var<br>    n,t,i,f0,t0,w0:int;<br>    g:array[0..2010] of edge;<br>    dist,f:array[0..1010,0..1010] of int;<br>    w,lim,ans,head:array[0..1010] of int;</p>
<p>procedure add(f,t,w:int);<br>var m:int;<br>begin<br>    inc(head[0]);m:=head[0];<br>    g[m].t:=t;g[m].w:=w;<br>    g[m].next:=head[f];head[f]:=m;<br>end;</p>
<p>procedure cal(v,p,d:int);<br>var j:int;<br>begin<br>    dist[i,v]:=d;<br>    j:=head[v];<br>    while j&lt;&gt;0 do begin<br>        if g[j].t&lt;&gt;p then cal(g[j].t,v,d+g[j].w);<br>        j:=g[j].next;<br>    end;<br>end;</p>
<p>procedure dp(v,p:int);<br>var i,j:int;<br>begin<br>    i:=head[v];<br>    while i&lt;&gt;0 do begin<br>        if g[i].t&lt;&gt;p then dp(g[i].t,v);<br>        i:=g[i].next;<br>    end;<br>    for i:=1 to n do<br>        if dist[v,i]&lt;=lim[v] then begin<br>            f[v,i]:=w[i];<br>            j:=head[v];<br>            while j&lt;&gt;0 do begin<br>                if g[j].t&lt;&gt;p then<br>                    inc(f[v,i],min(ans[g[j].t],f[g[j].t,i]-w[i]));<br>                j:=g[j].next;<br>            end;<br>            ans[v]:=min(ans[v],f[v,i]);<br>        end;<br>end;</p>
<p>begin<br>    assign(input,’fire.in’);reset(input);<br>    assign(output,’fire.out’);rewrite(output);<br>    read(t);<br>    while t&gt;0 do begin<br>        fillchar(head,sizeof(head),0);<br>        filldword(ans,sizeof(ans) shr 2,inf);<br>        filldword(f,sizeof(f) shr 2,inf);<br>        filldword(dist,sizeof(dist) shr 2,inf);</p>
<pre><code>    read(n);
    for i:=1 to n do read(w[i]);
    for i:=1 to n do read(lim[i]);
    for i:=1 to n-1 do begin
        read(f0,t0,w0);
        add(f0,t0,w0);add(t0,f0,w0);
    end;
    for i:=1 to n do cal(i,0,0);

    dp(1,0);
    writeln(ans[1]);
    dec(t);
end;
close(input);close(output);
</code></pre><p>end.<br>```</p>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[[JSOI2016] 提高1班 Day4]]></title>
      <url>https://cothrax.github.io/2016/08/19/JSOI2016-%E6%8F%90%E9%AB%981%E7%8F%AD-Day4/</url>
      <content type="html"><![CDATA[<h1 id="P1-公约数"><a href="#P1-公约数" class="headerlink" title="P1 公约数"></a>P1 公约数</h1><p>小w 最近仔细研究了公约数，他想到了以下问题：<br>现有n 个正整数，从中选k（2&lt;=k&lt;=n）个，设这k 个数的最大公约数为g，则这k 个数<br>的价值为k*g。求这个价值的最大值。<br>小w 当然知道答案了。现在他想考考你，你能很快回答出来吗？</p>
<h2 id="格式"><a href="#格式" class="headerlink" title="格式"></a>格式</h2><h3 id="输入格式"><a href="#输入格式" class="headerlink" title="输入格式"></a>输入格式</h3><p>第一行，一个整数n。<br>第二行，n 个正整数。</p>
<h3 id="输出格式"><a href="#输出格式" class="headerlink" title="输出格式"></a>输出格式</h3><p>一行一个正整数，表示答案。<br><a id="more"></a></p>
<h2 id="样例"><a href="#样例" class="headerlink" title="样例"></a>样例</h2><h3 id="样例输入"><a href="#样例输入" class="headerlink" title="样例输入"></a>样例输入</h3><blockquote>
<p>5<br>4 6 3 8 9</p>
</blockquote>
<h3 id="样例输出"><a href="#样例输出" class="headerlink" title="样例输出"></a>样例输出</h3><blockquote>
<p>9</p>
</blockquote>
<h2 id="提示"><a href="#提示" class="headerlink" title="提示"></a>提示</h2><p>对于30%数据，N&lt;=100<br>对于100%数据，N&lt;=200000，输入第二行每个数字不超过2000000</p>
<h2 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h2><p>开始莫名其妙想到了背包，结果是枚举。<br>枚举公约数就好了。</p>
<dir style="display:none"><a href="/2016/08/19/JSOI2016-提高1班-Day4/gcd.pas" title="复制代码">复制代码</a></dir>

<p>```delphi gcd.pas<br>uses math;<br>type int=longint;<br>var<br>    n,m,i,j,cur:int;ans:int64;<br>    cnt:array[0..2000010] of int;</p>
<p>begin<br>    assign(input,’gcd.in’);reset(input);<br>    assign(output,’gcd.out’);rewrite(output);</p>
<pre><code>read(n);m:=0;
for i:=1 to n do begin
    read(j);
    inc(cnt[j]);
    m:=max(m,j);
end;
ans:=0;
for i:=1 to m do begin
    j:=i;cur:=0;
    while j&lt;=m do begin
        inc(cur,cnt[j]);
        inc(j,i);
    end;
    if cur&lt;2 then continue;
    ans:=max(ans,cur*i);
end;
write(ans);

close(input);close(output);
</code></pre><p>end.</p>
<pre><code>
# P2 友好城市
小w 生活在美丽的Z 国。Z 国是一个有n 个城市的大国，城市之间有m 条单向公路（连
接城市i、j 的公路只能从i 连到j）。城市i、j 是友好城市当且仅当从城市i 能到达城市j 并
且从城市j 能到达城市i。如果k 个城市两两互为友好城市，那么我们称这k 个城市是友好
城市群，k 为友好城市群的大小。现在小w 想知道友好城市群的大小最大为多少，你能告诉
他吗？

## 格式
### 输入格式
第一行包含两个整数n 和m。
接下来m 行，每行两个整数i 和j，表示有从城市i 到城市j 的一条单向公路。

### 输出格式
共一行一个整数表示答案。
&lt;!--more--&gt;

## 样例
### 样例输入
&gt;10 12
3 7
1 2
4 5
7 10
10 8
6 8
2 1
3 8
10 3
6 8
7 3
4 1

### 样例输出
&gt;3

## 提示
对于30%的数据，n,m&lt;=100
对于80%的数据，n&lt;=1000,m&lt;=100000
对于100%的数据，n,m&lt;=100000

## 题解
咦这不是裸的强连通分量吗，上tarjan吧。
最后一个点好像由于分量大小BT，然后递归栈爆了。。。

&lt;dir style=&quot;display:none&quot;&gt;<a href="/2016/08/19/JSOI2016-提高1班-Day4/friend.pas" title="复制代码">复制代码</a>&lt;/dir&gt;

```delphi friend.pas
uses math;
type 
    int=longint;
    edge=record t,next:int end;
var 
    g:array[0..100010] of edge;
    head,dfn,low,s:array[0..100010] of int;
    ins:array[0..100010] of boolean;
    n,m,i,j,t,tim,ans:int;

procedure add(f,t:int);
var m:int;
begin
    inc(head[0]);m:=head[0];
    g[m].t:=t;
    g[m].next:=head[f];head[f]:=m;
end;

procedure tarjan(v:int);
var i,u,cnt:int;
begin
    inc(tim);dfn[v]:=tim;low[v]:=tim;
    inc(t);s[t]:=v;ins[v]:=true;
    i:=head[v];
    while i&lt;&gt;0 do begin
        u:=g[i].t;
        if dfn[u]=0 then begin
            tarjan(u);
            low[v]:=min(low[v],low[u]);
        end else if ins[u] then
            low[v]:=min(low[v],dfn[u]);
        i:=g[i].next;
    end;
    if low[v]=dfn[v] then begin
        cnt:=0;
        while s[t+1]&lt;&gt;v do begin
            inc(cnt);
            ins[s[t]]:=false;
            dec(t);
        end;
        ans:=max(ans,cnt);
    end;
end;

begin
    assign(input,&#39;friend.in&#39;);reset(input);
    assign(output,&#39;friend.out&#39;);rewrite(output);

    read(n,m);
    fillchar(head,sizeof(head),0);
    for i:=1 to m do begin
        read(j,t);add(j,t);
    end;
    t:=0;tim:=0;ans:=0;
    fillchar(dfn,sizeof(dfn),0);
    fillchar(ins,sizeof(ins),false);
    for i:=1 to n do if dfn[i]=0 then tarjan(i);
    write(ans);

    close(input);close(output);
end.
</code></pre><h1 id="P3-运货"><a href="#P3-运货" class="headerlink" title="P3 运货"></a>P3 运货</h1><p>小w 开了一家快递公司，在n 个城市之间进行货物运输工作，一共雇了m 个快递员。<br>每个快递员性格很奇特，第i 号快递员只愿意将货物从城市si 运送到ti（甚至不愿意将货物从ti 运送到si），并且如果他运送的货物量x&lt;=di，那么他要求获得的报酬为x<em>ai，否则为di</em>ai+(x-di)*bi。<br>现在小w 接到一个大订单，需要将f 单位货物从s 运送到t，请求出小w 的最小开支。<br>你可以假定每个快递员的运货量没有限制。</p>
<h2 id="格式-1"><a href="#格式-1" class="headerlink" title="格式"></a>格式</h2><h3 id="输入格式-1"><a href="#输入格式-1" class="headerlink" title="输入格式"></a>输入格式</h3><p>第一行五个整数n，m，s，t，f<br>接下来m 行每行五个数si,ti,ai,bi,di，描述一个快递员的信息。</p>
<h3 id="输出格式-1"><a href="#输出格式-1" class="headerlink" title="输出格式"></a>输出格式</h3><p>如有解请输出最小小开支，否则请输出“Impossible”。（不含引号）<br><!--more--></p>
<h2 id="样例-1"><a href="#样例-1" class="headerlink" title="样例"></a>样例</h2><h3 id="样例输入-1"><a href="#样例输入-1" class="headerlink" title="样例输入"></a>样例输入</h3><blockquote>
<p>4 4 0 3 5<br>0 1 3 0 3<br>1 3 3 0 3<br>0 2 2 1 6<br>2 3 2 1 6</p>
</blockquote>
<h3 id="样例输出-1"><a href="#样例输出-1" class="headerlink" title="样例输出"></a>样例输出</h3><blockquote>
<p>18</p>
</blockquote>
<h2 id="提示-1"><a href="#提示-1" class="headerlink" title="提示"></a>提示</h2><p>$n&lt;=100,m&lt;=1000,si,ti,s,t&lt;=n-1,f,di&lt;=200,ai,bi&lt;=1000$<br>保证至多只有一名邮递员<span>$ai&lt;bi$</span><!-- Has MathJax -->,其余均是<span>$ai&gt;bi$</span><!-- Has MathJax --><br>共50 组数据，保证数据有梯度。</p>
<h2 id="题解-1"><a href="#题解-1" class="headerlink" title="题解"></a>题解</h2><p>想到网络流，但模型不一样</p>
<ol>
<li>没有流量限制</li>
<li>有两种费用</li>
</ol>
<p>考虑到只有<strong>一名</strong>邮递员<span>$ai&lt;bi$</span><!-- Has MathJax -->，于是可以<strong>贪心</strong>。<br>如果没有这样的邮递员的话，显然对于一个邮递员要运<strong>尽量多的货物</strong>，才能使费用最少，这种情况下，直接用满流f，计算每条边的费用，然后跑floyd即可。<br>这个贪心可以反证，假设有一条路径上有两个邮递员i和j，它们的流都<span>$&lt;f$</span><!-- Has MathJax -->，不妨设<span>$ai&lt;aj$</span><!-- Has MathJax -->，把aj的流加到ai上显然更优。<br>如果有一个<span>$ai&gt;bi$</span><!-- Has MathJax -->的邮递员的话，对于经过这个邮递员x的路径s-&gt;t的最优解存可能存在另一种情况：</p>
<ol>
<li>s-&gt;t上经过x跑一个流为d[x]</li>
<li>s-&gt;t上不经过x跑一个流f-d[x]</li>
</ol>
<p>这样我们可以对这两种情况都跑一次floyd，然后枚举两点i,j根据三次floyd的结果得到最小值。</p>
<p>坑点</p>
<ol>
<li>f-d[x]的流不能经过x</li>
<li>存在大量重边QAQ</li>
<li>极大值inf不能太大，要加四倍可能会爆longint</li>
</ol>
<dir style="display:none"><a href="/2016/08/19/JSOI2016-提高1班-Day4/transport.pas" title="复制代码">复制代码</a></dir>

<p>```delphi transport.pas<br>uses math;<br>const inf=100000000;<br>type<br>    int=longint;<br>    arr=array[0..110,0..110] of int;<br>var<br>    ds0,ds1,ds2:arr;<br>    a,b,d,s,t:array[0..1010] of int;<br>    n,m,s0,t0,f,i,j,x,ans:int;</p>
<p>//flag标记能否经过邮递员x<br>procedure floyd(var ds:arr;f:int;flag:boolean);<br>var i,j,k:int;<br>begin<br>    filldword(ds,sizeof(ds) div 4,inf);<br>    for i:=1 to m do begin<br>        if flag and (i=x) then continue;<br>        k:=a[i]<em>min(f,d[i])+b[i]</em>max(0,f-d[i]);<br>        ds[s[i],t[i]]:=min(k,ds[s[i],t[i]]);<br>    end;<br>    for i:=1 to n do ds[i,i]:=0;<br>    for k:=1 to n do<br>        for i:=1 to n do<br>            for j:=1 to n do<br>                ds[i,j]:=min(ds[i,k]+ds[k,j],ds[i,j]);<br>end;</p>
<p>begin<br>    assign(input,’transport.in’);reset(input);<br>    assign(output,’transport.out’);rewrite(output);<br>    read(n,m,s0,t0,f);<br>    inc(s0);inc(t0);<br>    x:=-1;<br>    for i:=1 to m do begin<br>        read(s[i],t[i],a[i],b[i],d[i]);<br>        inc(s[i]);inc(t[i]);<br>        if a[i]&lt;b[i] then x:=i;<br>    end;</p>
<pre><code>floyd(ds0,f,false);
if (x=-1) or (f&lt;=d[x]) then begin
    if ds0[s0,t0]=inf then write(&#39;Impossible&#39;) 
    else write(ds0[s0,t0]);
    close(input);close(output);halt;
end;

floyd(ds1,d[x],false);
floyd(ds2,f-d[x],true);
ans:=inf;
for i:=1 to n do
    for j:=1 to n do
        ans:=min(ans,ds0[s0,i]+ds1[i,j]+ds2[i,j]+ds0[j,t0]);
if ans=inf then write(&#39;Impossible&#39;) else write(ans);
close(input);close(output);
</code></pre><p>end.<br>```</p>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[[JSOI2016] 提高2班 树形DP（一）]]></title>
      <url>https://cothrax.github.io/2016/08/18/JSOI2016-%E6%8F%90%E9%AB%982%E7%8F%AD-%E6%A0%91%E5%BD%A2DP/</url>
      <content type="html"><![CDATA[<h1 id="P1-学校网络"><a href="#P1-学校网络" class="headerlink" title="P1 学校网络"></a>P1 学校网络</h1><p>一所学校在几年前购进了第一台电脑（这台电脑的编号为1）。最近几年，学校又购买了N-1台电脑，每台新电脑和之前的某一台电脑连接。学校的管理员想知道对于每一台电脑i，到与它距离最远的电脑的距离Si。你需要提供这个信息。<br><img src="/2016/08/18/JSOI2016-提高2班-树形DP/T.jpg" alt="T.jpg" title=""><br>Hint: 样例输入如上图所示，从图中你可以知道，4号电脑到1号电脑的距离最远，所以S1=3。4号电脑和5号电脑到2号电脑的距离最远，所以S2=2。5号电脑到3号电脑距离最远，所以S3=3。由此类推S4=4，S5=4。</p>
<h2 id="格式"><a href="#格式" class="headerlink" title="格式"></a>格式</h2><h3 id="输入格式"><a href="#输入格式" class="headerlink" title="输入格式"></a>输入格式</h3><p>输入文件包含多组测试数据，对于每组测试数据：<br>第一行包含一个整数N (N&lt;=10000) ；<br>接下来N-1行描述每一台电脑。第i行包含两个用空格隔开的整数y、l，表示i号电脑与之前的y号电脑连接，距离为l。<br>所有l之和不超过10^9。</p>
<h3 id="输出格式"><a href="#输出格式" class="headerlink" title="输出格式"></a>输出格式</h3><p>对于每组测试数据输出N行，第i行表示离i号电脑的最远距离Si。<br><a id="more"></a></p>
<h2 id="样例"><a href="#样例" class="headerlink" title="样例"></a>样例</h2><h3 id="样例输入"><a href="#样例输入" class="headerlink" title="样例输入"></a>样例输入</h3><blockquote>
<p>5<br>1 1<br>2 1<br>3 1<br>1 1</p>
</blockquote>
<h3 id="样例输出"><a href="#样例输出" class="headerlink" title="样例输出"></a>样例输出</h3><blockquote>
<p>3 2 3 4 4</p>
</blockquote>
<h2 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h2><dir style="display:none"><a href="/2016/08/18/JSOI2016-提高2班-树形DP/computer.pas" title="复制代码">复制代码</a></dir>

<p>```delphi computer.pas<br>uses math;<br>const inf=100000000;<br>type<br>    int=longint;<br>    edge=record f,t,w,next:int end;<br>var<br>    g:array[0..10010] of edge;<br>    head,par:array[0..10010] of int;<br>    f,p:array[0..10010,0..2] of int;<br>    n,i,j,k:int;</p>
<p>procedure add(f,t,w:int);<br>var m:int;<br>begin<br>    inc(head[0]);m:=head[0];<br>    g[m].f:=f;g[m].t:=t;g[m].w:=w;<br>    g[m].next:=head[f];head[f]:=m;<br>end;</p>
<p>procedure dp(v:int);<br>var i,u,tmp:int;<br>begin<br>    fillchar(f[v],sizeof(f[v]),0);<br>    i:=head[v];<br>    while i&lt;&gt;0 do begin<br>        u:=g[i].t;dp(u);<br>        tmp:=f[u,0]+g[i].w;<br>        if tmp&gt;f[v,0] then begin<br>            f[v,1]:=f[v,0];<br>            f[v,0]:=tmp;<br>            f[v,2]:=u;<br>        end else if tmp&gt;f[v,1] then<br>            f[v,1]:=tmp;<br>        i:=g[i].next;<br>    end;<br>end;</p>
<p>procedure dfs(v,w:int);<br>var i,tmp:int;<br>begin<br>    p[v]:=f[v];<br>    if p[par[v],2]&lt;&gt;v then begin<br>        tmp:=p[par[v],0]+w;<br>        if tmp&gt;p[v,0] then begin<br>            p[v,1]:=p[v,0];<br>            p[v,0]:=tmp;<br>            p[v,2]:=par[v];<br>        end else if tmp&gt;p[v,1] then<br>            p[v,1]:=tmp;<br>    end else begin<br>        tmp:=p[par[v],1]+w;<br>        if tmp&gt;p[v,0] then begin<br>            p[v,1]:=p[v,0];<br>            p[v,0]:=tmp;<br>            p[v,2]:=par[v];<br>        end else if tmp&gt;p[v,1] then<br>            p[v,1]:=tmp;<br>    end;<br>    i:=head[v];<br>    while i&lt;&gt;0 do begin<br>        dfs(g[i].t,g[i].w);<br>        i:=g[i].next;<br>    end;<br>end;</p>
<p>begin<br>    assign(input,’computer.in’);reset(input);<br>    assign(output,’computer.out’);rewrite(output);</p>
<pre><code>read(n);
for i:=2 to n do begin
    read(j,k);
    add(j,i,k);par[i]:=j;
end;
dp(1);
dfs(1,-inf);
for i:=1 to n do writeln(p[i,0]);

close(input);close(output);
</code></pre><p>end.</p>
<pre><code>
# P2 黑手党
去年的芝加哥充满了黑帮争斗和奇怪的谋杀。警察局长真的厌倦了所有这些罪行，决定逮捕黑手党领袖。
不幸的是，芝加哥黑手党相当复杂的结构。没有人知道黑手党的信息。警方已经追踪他们一段时间的活动，并且知道他们中的一些人互相通信。根据收集到的资料，警察局长表明黑手党的层次结构可以表示为一棵树。黑手党首脑是树的根，每个节点表示一个人，一个节点的孩子即为这个节点表示的人的直接下属。
更不幸的是，虽然警方知道了匪徒的通讯，他们不知道谁是黑手党首脑。因此他们只有通信关系的无向树。
基于这样的思想，警察局长猜测可能表示黑手党首脑的节点必须满足：在删除它后，包含最多节点的剩余连通块的节点数最小。帮助警察找到所有可能成为黑手党首脑的节点。

## 格式
### 输入格式
第一行包含一个整数n(2≤n≤50000)，表示有n个人，编号为1~n。
接下来n-1行，每行两个数x，y，表示编号为x的人和编号为y的人之间有通信。

### 输出格式
输出所有可能成为黑手党首脑的人的编号，按升序排列，两个编号之间用空格隔开。
&lt;!--more--&gt;

## 样例
### 样例输入
&gt;6
1 2
2 3
2 5
3 4
3 6

### 样例输出
&gt;2 3

## 题解

&lt;dir style=&quot;display:none&quot;&gt;<a href="/2016/08/18/JSOI2016-提高2班-树形DP/godfather.pas" title="复制代码">复制代码</a>&lt;/dir&gt;

```delphi godfather.pas
uses math;
type 
    int=longint;
    edge=record t,next:int end;
var 
    n,i,j,k,mins:int;
    g:array[0..100010] of edge;
    head,siz,f:array[0..50010] of int;

procedure add(f,t:int);
var m:int;
begin
    inc(head[0]);m:=head[0];
    g[m].t:=t;
    g[m].next:=head[f];head[f]:=m;
end;

procedure dp(v,p:int);
var i,u:int;
begin
    i:=head[v];
    siz[v]:=1;
    while i&lt;&gt;0 do begin
        u:=g[i].t;
        if u&lt;&gt;p then begin
            dp(u,v);
            inc(siz[v],siz[u]);
            f[v]:=max(f[v],siz[u]);
        end;
        i:=g[i].next;
    end;    
    f[v]:=max(f[v],n-siz[v]);
    mins:=min(mins,f[v]);
end;

begin
    assign(input,&#39;godfather.in&#39;);reset(input);
    assign(output,&#39;godfather.out&#39;);rewrite(output);

    read(n);
    for i:=1 to n-1 do begin
        read(j,k);
        add(j,k);add(k,j);
    end;
    mins:=maxlongint;
    dp(1,0);
    for i:=1 to n do
        if f[i]=mins then write(i,&#39; &#39;);

    close(input);close(output);
end.
</code></pre><h1 id="P3-树的合并"><a href="#P3-树的合并" class="headerlink" title="P3 树的合并"></a>P3 树的合并</h1><p>话说moreD经过不懈努力，终于背完了循环整数，也终于完成了他的蛋糕大餐。 但是不幸的是， moreD得到了诅咒，受到诅咒的原因至今无人知晓。<br>moreD在发觉自己得到诅咒之后，决定去寻找闻名遐迩的术士CD帮忙。 话说CD最近在搞OI，遇到了一道有趣的题目： 给定两棵树， 则总共有N*M种方案把这两棵树通过加一条边连成一棵树， 那这N*M棵 树的直径之和是多少呢？<br>CD为了考验moreD是否值得自己费心力为他除去诅咒，于是要他编程回答这个问题， 但是这moreD早就被诅咒搞晕了头脑，就只好请你帮助他了。 </p>
<h2 id="格式-1"><a href="#格式-1" class="headerlink" title="格式"></a>格式</h2><h3 id="输入格式-1"><a href="#输入格式-1" class="headerlink" title="输入格式"></a>输入格式</h3><p>第一行两个正整数N,M，分别表示两棵树的大小。 接下来N-1行，每行两个正整数ai,bi,表示第一棵树上的边。 接下来M-1行，每行两个正整数ci,di,表示第二棵树上的边。</p>
<h3 id="输出格式-1"><a href="#输出格式-1" class="headerlink" title="输出格式"></a>输出格式</h3><p>一个整数，答案<br><!--more--></p>
<h2 id="样例-1"><a href="#样例-1" class="headerlink" title="样例"></a>样例</h2><h3 id="样例输入-1"><a href="#样例输入-1" class="headerlink" title="样例输入"></a>样例输入</h3><blockquote>
<p>4 3<br>1 2<br>2 3<br>2 4<br>1 3<br>2 3</p>
</blockquote>
<h3 id="样例输出-1"><a href="#样例输出-1" class="headerlink" title="样例输出"></a>样例输出</h3><blockquote>
<p>53</p>
</blockquote>
<h2 id="题解-1"><a href="#题解-1" class="headerlink" title="题解"></a>题解</h2><p>首先，类似于P1，求两棵树上，每一个点的最长路g[i]。$O(N+M)$<br>然后，如果枚举的话$O(NM)$肯定会TLE的，于是<strong>乱搞</strong>：<br>cnt[l]统计g[i]小于l的节点个数，做前缀和即可，$O(N+M)$<br>顺便可以算出两棵树原来的直径d[0]和d[1]，我们记dl=max(d[0],d[1])</p>
<p>先想第一棵树：从节点i连一条边到另一棵树的节点x上，当$g[i]+g[x]+1&gt;=dl$时，g[i]会被统计进答案，将式子变形一下$g[x]&gt;=dl-g[i]-1$，也就是说g[i]被统计进答案的次数=另一棵树上最长路$&gt;=dl-g[i]-1$的节点个数，这个值我们用cnt算过了。<br>同理考虑第二棵树就可以了。</p>
<p>为了防止 新连的边1 和 不能形成新的直径（新直径小于dl）的树 被重复计算，我们统计n*m棵树中，能连成新直径的树的个数是$k$，答案加上$k+(n*m-k)*dl$就可以了。</p>
<p>这样总的复杂度是$O(N+M)$<br>但是有三个点数据量太大导致递归过深，然后202了。。。这不怪我，因为我试了一下标程也202了233。</p>
<dir style="display:none"><a href="/2016/08/18/JSOI2016-提高2班-树形DP/connect.pas" title="复制代码">复制代码</a></dir>

<p>```delphi connect.pas<br>uses math;<br>type<br>    int=longint;<br>    edge=record t,next:int end;<br>    tree=array[0..200010] of edge;<br>    arr=array[0..100010] of int;<br>var<br>    t:array[0..1] of tree;<br>    h:array[0..1] of arr;<br>    f,g:array[0..1,0..100010,0..2] of int;<br>    cnt:array[0..1,0..100010] of int;<br>    d,n:array[0..1] of int;<br>    i,j,f0,t0,dl,k,tmp:int;ans:int64;</p>
<p>procedure add(var g:tree;var head:arr;f,t:int);<br>var m:int;<br>begin<br>    inc(head[0]);m:=head[0];<br>    g[m].t:=t;<br>    g[m].next:=head[f];head[f]:=m;<br>end;</p>
<p>procedure dp(x,v,p:int);<br>var i,u,tmp:int;<br>begin<br>    fillchar(f[x,v],sizeof(f[x,v]),0);<br>    i:=h[x][v];<br>    while i&lt;&gt;0 do begin<br>        u:=t[x][i].t;<br>        if u&lt;&gt;p then begin<br>            dp(x,u,v);<br>            tmp:=f[x,u,0]+1;<br>            if tmp&gt;f[x,v,0] then begin<br>                f[x,v,1]:=f[x,v,0];<br>                f[x,v,0]:=tmp;<br>                f[x,v,2]:=u;<br>            end else if tmp&gt;f[x,v,1] then<br>                f[x,v,1]:=tmp;<br>        end;<br>        i:=t[x][i].next;<br>    end;<br>end;</p>
<p>procedure dfs(x,v,p:int);<br>var i,tmp:int;<br>begin<br>    g[x,v]:=f[x,v];<br>    if p&lt;&gt;0 then<br>        if g[x,p,2]&lt;&gt;v then begin<br>            tmp:=g[x,p,0]+1;<br>            if tmp&gt;g[x,v,0] then begin<br>                g[x,v,1]:=g[x,v,0];<br>                g[x,v,0]:=tmp;<br>                g[x,v,2]:=p;<br>            end else if tmp&gt;g[x,v,1] then<br>                g[x,v,1]:=tmp;<br>        end else begin<br>            tmp:=g[x,p,1]+1;<br>            if tmp&gt;g[x,v,0] then begin<br>                g[x,v,1]:=g[x,v,0];<br>                g[x,v,0]:=tmp;<br>                g[x,v,2]:=p;<br>            end else if tmp&gt;g[x,v,1] then<br>                g[x,v,1]:=tmp;<br>        end;<br>    i:=h[x][v];<br>    while i&lt;&gt;0 do begin<br>        if t[x][i].t&lt;&gt;p then dfs(x,t[x][i].t,v);<br>        i:=t[x][i].next;<br>    end;<br>end;</p>
<p>begin<br>    assign(input,’connect.in’);reset(input);<br>    assign(output,’connect.out’);rewrite(output);</p>
<pre><code>read(n[0],n[1]);
for i:=0 to 1 do
    for j:=1 to n[i]-1 do begin
        read(f0,t0);
        add(t[i],h[i],f0,t0);add(t[i],h[i],t0,f0);
    end;
for i:=0 to 1 do begin 
    dp(i,1,0);
    dfs(i,1,0) 
end;

for i:=0 to 1 do begin
    d[i]:=0;
    for j:=1 to n[i] do begin
        inc(cnt[i,g[i,j,0]]);
        d[i]:=max(d[i],g[i,j,0]);
    end;
    for j:=1 to d[i] do
        inc(cnt[i,j],cnt[i,j-1]);
end;
dl:=max(d[0],d[1]);
ans:=0;k:=0;
for i:=0 to 1 do
    for j:=1 to n[i] do begin
        tmp:=n[1-i]-cnt[1-i,dl-g[i,j,0]-1];
        inc(ans,tmp*g[i,j,0]);
        if i=0 then inc(k,tmp);
    end;
inc(ans,k+(n[0]*n[1]-k)*dl);
write(ans);

close(input);close(output);
</code></pre><p>end.</p>
<pre><code>
# P4 Contestants Division
有一棵N个点N-1条边的树，每个点有一个权值。需要删去一条边使这棵树分成的两部分权值差最小，求出最小的权值。

## 格式
### 输入格式
含有多组测试数据，最后以0 0 结尾。
第一行：N和M，表示点数和边数（M=N-1）。
第二行：N个整数，表示N个点的权值。
接下来M行：每行两个数a，b，表示a和b有连边。

### 输出格式
最小的权值差。格式见样例
&lt;!--more--&gt;

## 样例
### 样例输入
&gt;7 6
1 1 1 1 1 1 1
1 2
2 7
3 7
4 6
6 2
5 7
0 0

### 样例输出
&gt;Case 1: 1

## 题解
这是[POJ 3140](http://poj.org/problem?id=3140)，题目被老师简化了于是直接做就好了，数据范围到POJ看吧。
ACM OJ对pascal总是异常的不友好，math库不能用，abs(int64)都没有重载。
关于这一题，统计子树权值和就可以了。

&lt;dir style=&quot;display:none&quot;&gt;<a href="/2016/08/18/JSOI2016-提高2班-树形DP/3140.pas" title="复制代码">复制代码</a>&lt;/dir&gt;
```delphi 3140.pas
type 
    int=longint;
    edge=record t,next:int end;
var 
    n,m,i,f0,t0,cnt:int;sum,ans:int64;
    g:array[0..2000010] of edge;
    head:array[0..100010] of int;
    w,f:array[0..100010] of int64;

function min(a,b:int64):int64;
begin if a&gt;b then min:=b else min:=a end;

function qabs(a:int64):int64;
begin if a&lt;0 then qabs:=-a else qabs:=a end;

procedure add(f,t:int);
var m:int;
begin
    inc(head[0]);m:=head[0];
    g[m].t:=t;
    g[m].next:=head[f];head[f]:=m;
end;

procedure dp(v,p:int);
var i,u:int;
begin
    f[v]:=w[v];
    i:=head[v];
    while i&lt;&gt;0 do begin
        u:=g[i].t;
        if p&lt;&gt;u then begin
            dp(u,v);
            inc(f[v],f[u]);
        end;
        i:=g[i].next;
    end;
    ans:=min(ans,qabs(sum-f[v]*2));
end;

begin
    read(n,m);cnt:=0;
    while (n&lt;&gt;0) and (m&lt;&gt;0) do begin
        fillchar(head,sizeof(head),0);
        sum:=0;
        for i:=1 to n do begin
            read(w[i]);
            inc(sum,w[i]);
        end;
        for i:=1 to m do begin
            read(f0,t0);
            add(f0,t0);add(t0,f0);
        end;
        ans:=sum;
        dp(1,0);
        inc(cnt);
        writeln(&#39;Case &#39;,cnt,&#39;: &#39;,ans);
        read(n,m);
    end;
end.
</code></pre>]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[[JSOI2016] 提高1班 Day2]]></title>
      <url>https://cothrax.github.io/2016/08/17/JSOI2016-%E6%8F%90%E9%AB%981%E7%8F%AD-Day2/</url>
      <content type="html"><![CDATA[<h1 id="P1-超市"><a href="#P1-超市" class="headerlink" title="P1 超市"></a>P1 超市</h1><p>超市正在举行一个活动，该活动的规则如下：<br>想要参与的顾客会将他购物的账单放入纸箱中，账单上写有顾客的联系方式和购物的金额。每天超市关门前纸箱中金额最大、最小的两张帐单被取出，付款金额最大的顾客将获得一笔奖金，价值为取出的两张帐单的金额之差；为了不重复计算，取出的两张帐单不再放回箱子，而剩下的帐单仍保留在箱中，进行第二天的活动。<br>顾客很多，因此可假定：每天活动结束时，箱中至少有两张帐单以供取出。<br>小h也参加了这次活动，他想知道整个活动期间超市付出的奖金总额是多少？</p>
<h2 id="格式"><a href="#格式" class="headerlink" title="格式"></a>格式</h2><h3 id="输入格式"><a href="#输入格式" class="headerlink" title="输入格式"></a>输入格式</h3><p>第一行是一个整数n，表示活动历时的天数。<br>以下的n行，每行包含若干由空格分隔的非负整数。第i+1行的数表示在第i天投入箱子的账单金额。每行的第一个数是一个整数k，表示当日账单的数目。后面的k个正整数代表这k笔账单的金额。</p>
<h3 id="输出格式"><a href="#输出格式" class="headerlink" title="输出格式"></a>输出格式</h3><p>输出一个数，表示活动期间超市付出的奖金总额。<br><a id="more"></a></p>
<h2 id="样例"><a href="#样例" class="headerlink" title="样例"></a>样例</h2><h3 id="样例输入"><a href="#样例输入" class="headerlink" title="样例输入"></a>样例输入</h3><blockquote>
<p>5<br>3 1 2 3<br>2 1 1<br>4 10 5 5 1<br>0<br>1 2</p>
</blockquote>
<h3 id="样例输出"><a href="#样例输出" class="headerlink" title="样例输出"></a>样例输出</h3><blockquote>
<p>19</p>
</blockquote>
<h2 id="提示​"><a href="#提示​" class="headerlink" title="提示​"></a>提示​</h2><p>设s为整个活动中涉及到的账单笔数。<br>30%的数据满足n≤100,s≤10000。<br>70%的数据满足s≤10^5。<br>100%的数据满足1≤n≤5000,0≤k≤10^5,s≤10^6,每笔账单的金额不超过10^6。</p>
<h2 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h2><p>用一个大根堆和一个小根堆，维护值对{金额,编号}，用del[i]记录编号i的账单是否已经被取出，然后模拟即可。</p>
<dir style="display:none"><a href="/2016/08/17/JSOI2016-提高1班-Day2/market.pas" title="复制代码">复制代码</a></dir>

<p>```delphi market.pas<br>const big=1;small=-1;<br>type<br>    int=longint;<br>    heap=array[0..1000010,0..1] of int;</p>
<p>procedure swap(var a,b:int);<br>var tmp:int;<br>begin<br>    tmp:=a;a:=b;b:=tmp;<br>end;</p>
<p>function com(p,c,s:int):boolean;<br>begin<br>    if s=big then com:=p&gt;c else com:=p&lt;c;<br>end;</p>
<p>procedure heapify(var h:heap;x:int);<br>var l,r,s:int;<br>begin<br>    l:=2<em>x;r:=2</em>x+1;<br>    if (l&lt;=h[0,0]) and com(h[l,0],h[x,0],h[0,1]) then s:=l else s:=x;<br>    if (r&lt;=h[0,0]) and com(h[r,0],h[s,0],h[0,1]) then s:=r;<br>    if s&lt;&gt;x then begin<br>        swap(h[s,0],h[x,0]);<br>        swap(h[s,1],h[x,1]);<br>        heapify(h,s);<br>    end;<br>end;</p>
<p>procedure extract(var h:heap);<br>begin<br>    h[1]:=h[h[0,0]];<br>    dec(h[0,0]);<br>    heapify(h,1);<br>end;</p>
<p>procedure insert(var h:heap;k,v:int);<br>var i:int;<br>begin<br>    inc(h[0,0]);i:=h[0,0];<br>    h[i,0]:=v;h[i,1]:=k;<br>    while (i&gt;1) and com(h[i,0],h[i div 2,0],h[0,1]) do begin<br>        swap(h[i,0],h[i div 2,0]);<br>        swap(h[i,1],h[i div 2,1]);<br>        i:=i div 2;<br>    end;<br>end;</p>
<p>var<br>    hb,hs:heap;<br>    i,j,n,m,cnt,each,b,s:int;<br>    ans:int64;<br>    del:array[0..1000010] of boolean;</p>
<p>begin<br>    assign(input,’market.in’);reset(input);<br>    assign(output,’market.out’);rewrite(output);</p>
<pre><code>read(n);
fillchar(del,sizeof(del),false);
hb[0,0]:=0;hb[0,1]:=big;
hs[0,0]:=0;hs[0,1]:=small;
cnt:=0;ans:=0;
for i:=1 to n do begin
    read(m);
    for j:=1 to m do begin
        inc(cnt);
        read(each);
        insert(hs,cnt,each);
        insert(hb,cnt,each);
    end;
    //writeln(hb[0,0],&#39; &#39;,hs[0,0],&#39; &#39;,ans);
    while del[hb[1,1]] do extract(hb);
    b:=hb[1,0];del[hb[1,1]]:=true;extract(hb);
    while del[hs[1,1]] do extract(hs);
    s:=hs[1,0];del[hs[1,1]]:=true;extract(hs);
    inc(ans,b-s);
end;
write(ans);

close(input);close(output);
</code></pre><p>end.</p>
<pre><code>
# P2 醉酒
小X 家住在一条东西向的大街上。在他们家的东面，自东向西依次分布着n 幢相似的房
屋，编号为1 到n,可以用一个长度为n 的字符串表示这n 幢房屋的颜色。
小X 的父亲经常喝醉酒，每次醉酒后他都会稀里糊涂地走到第Ai 幢房屋前，然后坚信
他现在第Bi 幢房屋前。虽然他喝醉了，但是他依然能分清每幢房屋的颜色，并且掏出地图
进行比较，只有房屋颜色和地图上一致时，他才会继续向西走。当他发现自己的错误或者不
能前进时，就会停下来。现在，小X 记录下了每次的数据Ai 和Bi，他希望知道父亲最多走
过多少幢相同颜色的房屋。

## 格式
### 输入格式
第一行两个数n 和m，表示n 幢房屋和m 次询问。
第二行一个长度为n 的字符串，仅包含大写字母。
接下来m 行，每行两个数Ai 和Bi。

#### 输出格式
m 行，每个一个数，表示小X 的父亲父亲最多走过多少幢相同颜色的房屋。

## 样例
### 输入样例
&gt;10 6
AABBCCAABB
1 7
7 1
3 4
4 9
2 5
5 5

### 输出样例
&gt;4
4
1
1
0
6

## 提示
对于60%的数据，n,m≤100。
对于80%的数据，n≤1000。
对于100%的数据，n,m≤100000,Ai,Bi≤n。

## 题解
双字符串Hash+二分答案
预处理前缀Hash：$O(N)$
对于每个查询二分：$O(MlogN)$
hash函数要写好，注意端点。

&lt;dir style=&quot;display:none&quot;&gt;<a href="/2016/08/17/JSOI2016-提高1班-Day2/drunk.pas" title="复制代码">复制代码</a>&lt;/dir&gt;

```delphi drunk.pas
uses math;

type int=longint;
const 
    q:array[0..1] of int=(1000019,100000007);
    p:array[0..1] of int=(1009,133);

var
    n,m,i,j,k:int;
    s:ansistring;
    pn,f:array[0..1,0..100010] of int64;

function hash(l,r,j:int):int64;
begin
    hash:=(f[j,r]-f[j,l-1]*pn[j,r-l+1] mod q[j]+q[j]) mod q[j];
end;

function query(i,j:int):int;
var l,r,mid:int;
begin
    if i&gt;j then begin l:=i;i:=j;j:=l end;
    l:=1;r:=n-j+1;query:=0;
    while l&lt;=r do begin
        mid:=(l+r) shr 1;
        if (hash(i,i+mid-1,0)=hash(j,j+mid-1,0)) and
           (hash(i,i+mid-1,1)=hash(j,j+mid-1,1)) then begin
            query:=mid;l:=mid+1;
        end else r:=mid-1;
    end;
end;

begin
    assign(input,&#39;drunk.in&#39;);reset(input);
    assign(output,&#39;drunk.out&#39;);rewrite(output);

    readln(n,m);readln(s);
    for i:=0 to 1 do begin f[i,0]:=0;pn[i,0]:=1 end;
    for i:=1 to n do 
        for j:=0 to 1 do begin
            pn[j,i]:=pn[j,i-1]*p[j] mod q[j];
            f[j,i]:=(f[j,i-1]*p[j]+ord(s[i])) mod q[j];
        end;

    for i:=1 to m do begin
        read(j,k);
        writeln(query(j,k));
    end;

    close(input);close(output);
end.
</code></pre><h1 id="P3-方块游戏"><a href="#P3-方块游戏" class="headerlink" title="P3 方块游戏"></a>P3 方块游戏</h1><p>小A 和小B 在玩一个方块游戏。编号为1 到n(1&lt;=n&lt;=30000)的n 个方块正放在地上。<br>每个构成一个立方柱。<br>游戏开始后，小A 会给小B 发出p(1&lt;=p&lt;=100000)个指令。</p>
<ol>
<li>移动(M)：将包含X 的立方柱移动到包含Y 的立方柱上。</li>
<li>统计(C)：统计含X 的立方柱中，在X 下方的方块数目。</li>
</ol>
<p>写个程序帮小B 完成游戏。</p>
<h2 id="格式-1"><a href="#格式-1" class="headerlink" title="格式"></a>格式</h2><h3 id="输入格式-1"><a href="#输入格式-1" class="headerlink" title="输入格式"></a>输入格式</h3><p>第1 行输入P，之后P 行每行输入一条指令。形式为“M X Y”或者“C X”。<br>输入保证不会有将立方柱放在自己头上的指令。</p>
<h4 id="输出格式-1"><a href="#输出格式-1" class="headerlink" title="输出格式"></a>输出格式</h4><p>每一行，对于每个统计指令，输出其结果。</p>
<h2 id="样例-1"><a href="#样例-1" class="headerlink" title="样例"></a>样例</h2><h3 id="输入样例"><a href="#输入样例" class="headerlink" title="输入样例"></a>输入样例</h3><blockquote>
<p>6<br>M 1 6<br>C 1<br>M 2 4<br>M 2 6<br>C 3<br>C 4</p>
</blockquote>
<h3 id="输出样例"><a href="#输出样例" class="headerlink" title="输出样例"></a>输出样例</h3><blockquote>
<p>1<br>0<br>2</p>
</blockquote>
<h2 id="提示"><a href="#提示" class="headerlink" title="提示"></a>提示</h2><p>对于40%的数据，n,P≤200。<br>对于60%的数据，n,P≤2000。<br>对于100%的数据，n,P≤100000。</p>
<h2 id="题解-1"><a href="#题解-1" class="headerlink" title="题解"></a>题解</h2><p>并查集。</p>
<ol>
<li>记dist[i]是i到par[i]的距离，即i与par[i]之间 包含par[i] 不包含i 的方块格数</li>
<li>记len[i]是根i所在立方体的方块个数，当i不是根时=0</li>
</ol>
<p>然后在查询和合并时维护即可。</p>
<dir style="display:none"><a href="/2016/08/17/JSOI2016-提高1班-Day2/cubes.pas" title="复制代码">复制代码</a></dir>

<p>```delphi drunk.pas<br>type int=longint;<br>const n=100000;<br>var<br>    par,dist,len:array[0..100010] of int;<br>    p,i,x,y:int;c:char;</p>
<p>function find(x:int):int;<br>begin<br>    if par[x]=x then find:=x<br>    else begin<br>        find:=find(par[x]);<br>        inc(dist[x],dist[par[x]]);<br>        par[x]:=find;<br>    end;<br>end;</p>
<p>procedure union(x,y:int);<br>begin<br>    x:=find(x);y:=find(y);<br>    par[x]:=y;<br>    dist[x]:=len[y];<br>    inc(len[y],len[x]);<br>    len[x]:=0;<br>end;</p>
<p>function query(x:int):int;<br>begin<br>    if par[x]=x then query:=1<br>    else query:=dist[x]+query(par[x]);<br>end;</p>
<p>begin<br>    assign(input,’cubes.in’);reset(input);<br>    assign(output,’cubes.out’);rewrite(output);</p>
<pre><code>for i:=1 to n do begin
    par[i]:=i;
    dist[i]:=0;
    len[i]:=1;
end;
readln(p);
for i:=1 to p do begin
    read(c);
    if c=&#39;M&#39; then begin
        readln(x,y);
        union(x,y);
    end else begin
        readln(x);
        writeln(query(x)-1);
    end;
end;

close(input);close(output);
</code></pre><p>end.</p>
<pre><code>
# P4 道路网
C国的道路网络由若干条双向线路组成。每条线路途经一些城市(可能会经过多次同一
城市)，位于线路上的两个城市a，b通过i号线路互相抵达的费用为 w[i]\[a\] + w[i]\[b\]。现在有若干个询问，询问两城市互相到达的最小费用。

## 格式
### 输入格式
第一行为城市数n与线路数m。
以下m行每行描述一条线路：
第一个正整数l\[i\]为i号线路途经的城市数，接下来2*l\[i\]个正整数，每两个数描述一个城市，依次表示途经的城市j，费用w\[i\]\[j\]；接下来若干行每行两个正整数a，b表示询问a，b之间的最小费用，最后以0 0结束。


#### 输出格式
每一行，对于每个统计指令，输出其结果。

## 样例
### 输入样例
&gt;4 2
3 1 1 2 1 3 3
3 1 2 2 1 4 2
1 2
3 4
2 4
0 0

### 输出样例
&gt;2
7
3

## 提示
令T为询问数
10%的数据满足n≤10,m≤3,T≤3。
30%的数据满足n,T≤100,m,l[i]≤15。
50%的数据满足n≤1000,T≤100,m,l[i]≤50。
100%的数据满足n≤100000,m≤300,T,l[i],w\[i\]\[j\]≤2000。

## 水解
$w[i]\[a\] + w[i]\[b\]$，把线路当成点，然后n+m个点跑Floyd，
30分到手。

&lt;dir style=&quot;display:none&quot;&gt;<a href="/2016/08/17/JSOI2016-提高1班-Day2/map.pas" title="复制代码">复制代码</a>&lt;/dir&gt;

```delphi map.pas
uses math;
const inf=100000000;
type int=longint;
var 
    f:array[0..1110,0..1110] of int;
    n,m,l,k,i,j,tmp:int;

begin
    assign(input,&#39;map.in&#39;);reset(input);
    assign(output,&#39;map.out&#39;);rewrite(output);

    read(n,m);
    filldword(f,sizeof(f) div 4,inf);
    for i:=1 to m do begin
        read(l);
        for j:=1 to l do begin
            read(k);read(tmp);
            f[k,i+n]:=min(f[k,i+n],tmp);
            f[i+n,k]:=f[k,i+n];
        end;
    end;
    for i:=1 to m+n do f[i,i]:=0;
    for k:=1 to m+n do
        for i:=1 to m+n do
            for j:=1 to m+n do
                f[i,j]:=min(f[i,j],f[i,k]+f[k,j]);
    read(i,j);
    while (i&lt;&gt;0) and (j&lt;&gt;0) do begin
        if f[i,j]=inf then writeln(-1) else writeln(f[i,j]);
        read(i,j);
    end;
end.
</code></pre><h2 id="正解"><a href="#正解" class="headerlink" title="正解"></a>正解</h2><p>线路数非常小，我们从线路入手，依然把线路看成点，每两个城市的路径必然要经过代表线路的点，先考虑线路间的切换。<br>贪心地考虑两条线路i和j：记它们的公用城市为a，i和j的连边为<span>$min\{w[i,a]+w[j,a]\}$</span><!-- Has MathJax -->，<br>然后在线路设点组成的图上跑Floyd。<br>对于每个查询，枚举经过两点的线路算最小值就可以了。</p>
<p>处理线路间的连边可以用类似 前向星计数排序 的思想，在$O(l[i]*m)$的时间内将w[i,j]压缩进一个数组，也可以用规模为n的指针数组实现。<br>手残敲错了一次floyd。</p>
<dir style="display:none"><a href="/2016/08/17/JSOI2016-提高1班-Day2/0map.pas" title="复制代码">复制代码</a></dir>

<p>```delphi 0map.pas<br>uses math;<br>type int=longint;<br>const inf=100000000;<br>var<br>    n,m,k,i,j,t1,t2,ans,last:int;<br>    f:array[0..310,0..310] of int; //floyd<br>    e:array[0..310,0..2010,0..1] of int; //原始数据<br>    g:array[0..600010,0..1] of int; //压缩后数据<br>    cnt,l,r,p:array[0..100010] of int; //计数,左端点,右端点,当前指针<br>    s:array[0..310] of int; //题中的l</p>
<p>begin<br>    assign(input,’map.in’);reset(input);<br>    assign(output,’map.out’);rewrite(output);<br>    //input<br>    read(n,m);<br>    fillchar(cnt,sizeof(cnt),0);<br>    for i:=1 to m do begin<br>        read(s[i]);<br>        for j:=1 to s[i] do begin<br>            read(e[i,j,0],e[i,j,1]);<br>            inc(cnt[e[i,j,0]]);<br>        end;<br>    end;<br>    //指针<br>    last:=0;<br>    for i:=1 to n do begin<br>        l[i]:=last+1;<br>        r[i]:=last+cnt[i];<br>        p[i]:=l[i];<br>        last:=r[i];<br>    end;<br>    //e压进g（类似计数排序）<br>    for i:=1 to m do<br>        for j:=1 to s[i] do begin<br>            g[p[e[i,j,0]],0]:=i;<br>            g[p[e[i,j,0]],1]:=e[i,j,1];<br>            inc(p[e[i,j,0]]);<br>        end;<br>    //init f<br>    filldword(f,sizeof(f) div 4,inf);<br>    for i:=1 to n do<br>        for j:=l[i] to r[i] do<br>            for k:=l[i] to r[i] do<br>                f[g[j,0],g[k,0]]:=min(f[g[j,0],g[k,0]],g[j,1]+g[k,1]);<br>    for i:=1 to m do f[i,i]:=0;<br>    //floyd<br>    for k:=1 to m do<br>        for i:=1 to m do<br>            for j:=1 to m do<br>                f[i,j]:=min(f[i,j],f[i,k]+f[k,j]);<br>    //query<br>    read(t1,t2);<br>    while (t1&lt;&gt;0) and (t2&lt;&gt;0) do begin<br>        ans:=inf;<br>        for i:=l[t1] to r[t1] do<br>            for j:=l[t2] to r[t2] do<br>                ans:=min(ans,g[i,1]+f[g[i,0],g[j,0]]+g[j,1]);<br>        if ans=inf then writeln(-1) else writeln(ans);<br>        read(t1,t2);<br>    end;</p>
<pre><code>close(input);close(output);
</code></pre><p>end.<br>```</p>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[[JSOI2016] 提高2班 位运算]]></title>
      <url>https://cothrax.github.io/2016/08/17/JSOI2016-%E6%8F%90%E9%AB%982%E7%8F%AD-%E4%BD%8D%E8%BF%90%E7%AE%97/</url>
      <content type="html"><![CDATA[<h1 id="P1-拔河比赛"><a href="#P1-拔河比赛" class="headerlink" title="P1 拔河比赛"></a>P1 拔河比赛</h1><p>一个学校举行拔河比赛，所有的人被分成了两组，每个人必须（且只能够）在其中的一组，且两个组内的所有人体重加起来尽可能地接近。</p>
<h2 id="格式"><a href="#格式" class="headerlink" title="格式"></a>格式</h2><h3 id="输入格式"><a href="#输入格式" class="headerlink" title="输入格式"></a>输入格式</h3><p>数据的第1行是一个n，表示参加拔河比赛的总人数，接下来的n行表示第1到第n个人的体重，每个人的体重weight都是整数。</p>
<h3 id="输出格式"><a href="#输出格式" class="headerlink" title="输出格式"></a>输出格式</h3><p>包含两个整数：分别是两个组的所有人的体重和，用一个空格隔开。注意如果这两个数不相等，则请把小的放在前面输出。<br><a id="more"></a></p>
<h2 id="样例"><a href="#样例" class="headerlink" title="样例"></a>样例</h2><h3 id="样例输入"><a href="#样例输入" class="headerlink" title="样例输入"></a>样例输入</h3><blockquote>
<p>3<br>100<br>90<br>200</p>
</blockquote>
<h3 id="样例输出"><a href="#样例输出" class="headerlink" title="样例输出"></a>样例输出</h3><blockquote>
<p>190 200</p>
</blockquote>
<h2 id="提示"><a href="#提示" class="headerlink" title="提示"></a>提示</h2><p>60%的数据保证 n&lt;=100，1&lt;=weight&lt;=500。<br>100%的数据保证 n&lt;=500，1&lt;=weight&lt;=1000。</p>
<h2 id="水解"><a href="#水解" class="headerlink" title="水解"></a>水解</h2><p>变形背包，很显然。<br>记f[i,j]前i个人差值为j的情况是否可能，a[i]放到第一组认为是-a[i]，放到第二组认为是+a[i]，那么：$f[i,j]=f[i,j-a[i]]\ or\ f[i,j+a[i]]$<br>但复杂度是$O(N^2W)$，60分。</p>
<dir style="display:none"><a href="/2016/08/17/JSOI2016-提高2班-位运算/competition.pas" title="复制代码">复制代码</a></dir>

<p>```delphi competition.pas<br>type int=longint;<br>var<br>    n,m,i,j,i0,i1:int;<br>    a:array[0..501] of int;<br>    f:array[0..1,-501000..501000] of boolean;</p>
<p>begin<br>    assign(input,’competition.in’);reset(input);<br>    assign(output,’competition.out’);rewrite(output);</p>
<pre><code>read(n);
m:=0;
for i:=1 to n do begin
    read(a[i]);
    inc(m,a[i]);
end;
fillchar(f,sizeof(f),false);
f[0,0]:=true;
for i:=1 to n do begin
    i0:=i mod 2;i1:=1-i0;
    for j:=-m to m do
        f[i0,j]:=f[i1,j-a[i]] or f[i1,j+a[i]];
end;
i0:=n mod 2;
for j:=0 to m do
    if f[i0,j] or f[i0,-j] then begin
        write((m-j) div 2,&#39; &#39;,(m+j) div 2);
        halt
    end;

close(input);close(output);
</code></pre><p>end.</p>
<pre><code>
## 正解
C++有一个stl叫bitset，然而p没有。
思路是H[w]表示组合出体重w是否可行，那么每次读入x，w=可行解+x 都是可行的，于是`H|=H&lt;&lt;x`
```cpp
bitset&lt;501000&gt; H;
int  main(){
    cin&gt;&gt;n;
    H[0]=true;
    for(int i=1;i&lt;=n;i++){
         cin&gt;&gt;x;s+=x;H=H|(H&lt;&lt;x);
    }
    int x=0;
    for(int i=1;i&lt;=s;i++)if(H[i]&amp;&amp;i&lt;=s-i)x=i;
    cout&lt;&lt;x&lt;&lt;&quot; &quot;&lt;&lt;s-x&lt;&lt;endl;
}
</code></pre><h1 id="P2-起床困难综合症"><a href="#P2-起床困难综合症" class="headerlink" title="P2 起床困难综合症"></a>P2 起床困难综合症</h1><p>21世纪，许多人得了一种奇怪的病：起床困难综合症，其临床表现为：起床难，起床后精神不佳。作为一名青春阳光好少年，atm一直坚持与起床困难综合症作斗争。通过研究相关文献，他找到了该病的发病原因：在深邃的太平洋海底中，出现了一条名为drd的巨龙，它掌握着睡眠之精髓，能随意延长大家的睡眠时间。正是由于drd的活动，起床困难综合症愈演愈烈，以惊人的速度在世界上传播。为了彻底消灭这种病，atm决定前往海底，消灭这条恶龙。<br>历经千辛万苦，atm终于来到了drd所在的地方，准备与其展开艰苦卓绝的战斗。drd有着十分特殊的技能，他的防御战线能够使用一定的运算来改变他受到的伤害。具体说来，drd的防御战线由n扇防御门组成。每扇防御门包括一个运算op和一个参数t，其中运算一定是OR,XOR,AND中的一种，参数则一定为非负整数。如果还未通过防御门时攻击力为x，则其通过这扇防御门后攻击力将变为xopt。最终drd受到的伤害为对方初始攻击力x依次经过所有n扇防御门后转变得到的攻击力。<br>由于atm水平有限，他的初始攻击力只能为0到m之间的一个整数（即他的初始攻击力只能在0,1,…,m中任选，但在通过防御门之后的攻击力不受m的限制）。为了节省体力，他希望通过选择合适的初始攻击力使得他的攻击能让drd受到最大的伤害，请你帮他计算一下，他的一次攻击最多能使drd受到多少伤害。</p>
<h2 id="格式-1"><a href="#格式-1" class="headerlink" title="格式"></a>格式</h2><h3 id="输入格式-1"><a href="#输入格式-1" class="headerlink" title="输入格式"></a>输入格式</h3><p>第1行包含2个整数，依次为n,m，表示drd有n扇防御门，atm的初始攻击力为0到m之间的整数。接下来n行，依次表示每一扇防御门。每行包括一个字符串op和一个非负整数t，两者由一个空格隔开，且op在前，t在后，op表示该防御门所对应的操作， t表示对应的参数。</p>
<h3 id="输出格式-1"><a href="#输出格式-1" class="headerlink" title="输出格式"></a>输出格式</h3><p>一行一个整数，表示atm的一次攻击最多使 drd 受到多少伤害。</p>
<h2 id="样例-1"><a href="#样例-1" class="headerlink" title="样例"></a>样例</h2><h3 id="样例输入-1"><a href="#样例输入-1" class="headerlink" title="样例输入"></a>样例输入</h3><blockquote>
<p>3 10<br>AND 5<br>OR 6<br>XOR 7</p>
</blockquote>
<h3 id="样例输出-1"><a href="#样例输出-1" class="headerlink" title="样例输出"></a>样例输出</h3><blockquote>
<p>3</p>
</blockquote>
<h2 id="提示-1"><a href="#提示-1" class="headerlink" title="提示"></a>提示</h2><p><strong>补充说明</strong><br>atm可以选择的初始攻击力为0,1,…,10。<br>假设初始攻击力为4，最终攻击力经过了如下计算<br>4 AND 5 = 4<br>4 OR  6 = 6<br>6 XOR 7 = 1<br>类似的，我们可以计算出初始攻击力为1,3,5,7,9时最终攻击力为0，初始攻击力为0,2,4,6,8,10时最终攻击力为1，因此atm的一次攻击最多使 drd 受到的伤害值为1。<br><strong>数据范围</strong><br>0&lt;=m&lt;=10^9<br>0&lt;=t&lt;=10^9<br>运算一定为OR,XOR,AND 中的一种</p>
<h2 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h2><p>位运算每一位都是独立的，于是从高到低枚举选择数字的每一位，分几种情况讨论：</p>
<ol>
<li>该位取0时经过n次操作结果取1，该位选择0一定最优。</li>
<li>若情况1不满足，该位取1时经过n次操作结果取1 且取1后值不超过m 这样我们也选择1。</li>
<li>上两种情况不满足，则该位取0一定比取1小且更不容易超过m。<br>可以直接用<span>$(0...0)_2$</span><!-- Has MathJax -->和<span>$(1...1)_2$</span><!-- Has MathJax -->，这样优化为$O(N)$。<br>代码丑的可以。</li>
</ol>
<dir style="display:none"><a href="/2016/08/17/JSOI2016-提高2班-位运算/sleep.pas" title="复制代码">复制代码</a></dir>

<p>```delphi sleep.pas<br>type int=longint;<br>var<br>    a1,a0,ans,orig,p,t,c,i,n,m:int;<br>    s,op:string;</p>
<p>begin<br>    assign(input,’sleep.in’);reset(input);<br>    assign(output,’sleep.out’);rewrite(output);</p>
<pre><code>readln(n,m);
a0:=0;a1:=not 0;
for i:=1 to n do begin
    readln(s);
    p:=pos(&#39; &#39;,s);
    op:=copy(s,1,p-1);
    val(copy(s,p+1,length(s)-p),t,c);

    if op=&#39;XOR&#39; then begin a0:=a0 xor t;a1:=a1 xor t end
    else if op=&#39;OR&#39; then begin a0:=a0 or t;a1:=a1 or t end
    else begin a0:=a0 and t;a1:=a1 and t end;
end;

ans:=0; //最终伤害
orig:=0; //原始伤害
for i:=30 downto 0 do 
    if ((a0 shr i) and 1)=1 then
        ans:=ans or (1 shl i)
    else if (((a1 shr i) and 1)=1) and 
            ((orig or (1 shl i))&lt;=m) then begin
        ans:=ans or (1 shl i);
        orig:=orig or (1 shl i);
    end;
write(ans);

close(input);close(output);
</code></pre><p>end.</p>
<pre><code>

# P3 乒乓游戏
一条大街上住着n个乒乓球爱好者，经常组织比赛切磋技术。每个人都有一个不同的技能值ai。每场比赛需要3个人：两名选手，一名裁判。他们有一个奇怪的规定，即裁判必须住在两名选手的中间，并且技能值也在两名选手之间。问一共能组织多少种比赛。

## 格式
### 输入格式
第一行是整数n，然后是n个不同的整数，即a1,a2,...,an，按照住处从左到右的顺序给每个乒乓球爱好者的技能值。

### 输出格式
输出比赛总数的值。
&lt;!--more--&gt;

## 样例
### 样例输入
&gt;5
6 1 8 10 1

### 样例输出
&gt;3

## 提示
30%的数据 n&lt;=3000。
100%的数据 n&lt;=100000,ai&lt;=100000。 

## 题解
对于裁判i，记1..i-1中技能值小于a[i]的人数为ls，i+1..n中小于a[i]的人数rs，那么这个裁判能组织的比赛数$=sl\*(n-i-sr)+(i-1-sl)\*sr$
扫一遍i，可以用两个树状数组维护。

&lt;dir style=&quot;display:none&quot;&gt;<a href="/2016/08/17/JSOI2016-提高2班-位运算/pingpong.pas" title="复制代码">复制代码</a>&lt;/dir&gt;

```delphi pingpong.pas
const maxn=100000;
type 
    int=longint;
    arr=array[0..100010] of int;
var 
    l,r,a:arr;
    n,i,sl,sr:int;ans:int64;

function lowbit(x:int):int;
begin lowbit:=x and (-x) end;

procedure add(var a:arr;x,k:int);
begin
    if x=0 then exit;
    while x&lt;=maxn do begin
        inc(a[x],k);
        inc(x,lowbit(x));
    end;
end;

function sum(var a:arr;x:int):int;
begin
    sum:=0;
    while x&gt;0 do begin
        inc(sum,a[x]);
        dec(x,lowbit(x));
    end;    
end;

begin
    assign(input,&#39;pingpong.in&#39;);reset(input);
    assign(output,&#39;pingpong.out&#39;);rewrite(output);

    read(n);
    for i:=1 to n do begin
        read(a[i]);
        if i&lt;&gt;1 then add(r,a[i],1);
    end;
    ans:=0;
    for i:=1 to n do begin
        sl:=sum(l,a[i]);sr:=sum(r,a[i]);
        inc(ans,sl*(n-i-sr)+(i-1-sl)*sr);
        add(r,a[i+1],-1);add(l,a[i],1);
    end;
    write(ans);

    close(input);close(output);
end.
</code></pre><h1 id="P4-黑客的攻击"><a href="#P4-黑客的攻击" class="headerlink" title="P4 黑客的攻击"></a>P4 黑客的攻击</h1><p>假设你是一个黑客，入侵了一个有着n台计算机(编号为0,1,…,n-1)的网络。一共有n种服务，每台计算机都运行着所有的服务。对于每台计算机，你都可以选择一项服务，终止这台计算机和所有和它相邻计算机的该项服务（如果其中的一些服务已经停止，则这些服务继续处于停止状态）。你的目标是让尽量多的服务完全瘫痪（即：没有任何计算机运行该项服务)</p>
<h2 id="格式-2"><a href="#格式-2" class="headerlink" title="格式"></a>格式</h2><h3 id="输入格式-2"><a href="#输入格式-2" class="headerlink" title="输入格式"></a>输入格式</h3><p>第一行为整数n；以下n行每行描述一台计算机的相邻计算机，其中第一个数m为相邻的计算机个数，接下来m个数为这些计算机的编号。</p>
<h3 id="输出格式-2"><a href="#输出格式-2" class="headerlink" title="输出格式"></a>输出格式</h3><p>输出完全瘫痪的服务器的最大数量<br><!--more--></p>
<h2 id="样例-2"><a href="#样例-2" class="headerlink" title="样例"></a>样例</h2><h3 id="样例输入-2"><a href="#样例输入-2" class="headerlink" title="样例输入"></a>样例输入</h3><blockquote>
<p>4<br>1 1<br>1 0<br>1 3<br>1 2</p>
</blockquote>
<h3 id="样例输出-2"><a href="#样例输出-2" class="headerlink" title="样例输出"></a>样例输出</h3><blockquote>
<p>2</p>
</blockquote>
<h2 id="提示-2"><a href="#提示-2" class="headerlink" title="提示"></a>提示</h2><p>n≤16。</p>
<h2 id="题解-1"><a href="#题解-1" class="headerlink" title="题解"></a>题解</h2><p>看数据范围，状压DP，用二进制表示集合<br>a[i]预处理出点i相邻的节点，二进制表示<br>p[S]预处理出集合S所能够覆盖的点的集合<br>然后dp，<span>$f[S]=max\{f[S\ xor\ j]+1\ |\ j\in S\ and\ p[j]=(1\ shl\ n)-1\}$</span><!-- Has MathJax --></p>
<dir style="display:none"><a href="/2016/08/17/JSOI2016-提高2班-位运算/hacker.pas" title="复制代码">复制代码</a></dir>

<p>```delphi hacker.pas<br>uses math;<br>type int=longint;<br>var<br>    n,m,k,i,j,t,lowbit:int;<br>    f,p:array[0..(1 shl 16)-1] of int;<br>    a:array[0..17] of int;</p>
<p>begin<br>    assign(input,’hacker.in’);reset(input);<br>    assign(output,’hacker.out’);rewrite(output);</p>
<pre><code>read(n);
k:=(1 shl n)-1;
for i:=0 to n-1 do begin
    read(m);
    a[i]:=1 shl i;
    for j:=1 to m do begin
        read(t);
        a[i]:=a[i] or (1 shl t);
    end;
end;
for i:=0 to k do begin
    t:=i;
    p[i]:=0;
    while t&gt;0 do begin
        lowbit:=t and (-t);
        p[i]:=p[i] or a[round(ln(lowbit)/ln(2))];
        t:=t-lowbit;
    end;
end;
for i:=1 to k do begin
    f[i]:=0;j:=i;
    while j&lt;&gt;0 do begin
        if p[j]=k then f[i]:=max(f[i xor j]+1,f[i]);
        j:=(j-1) and i;
    end;
end;
write(f[k]);

close(input);close(output);
</code></pre><p>end.<br>```</p>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[[JSOI2016] 提高1班-Day1]]></title>
      <url>https://cothrax.github.io/2016/08/16/JSOI2016-%E6%8F%90%E9%AB%981%E7%8F%AD-Day1/</url>
      <content type="html"><![CDATA[<h1 id="P1-选数"><a href="#P1-选数" class="headerlink" title="P1 选数"></a>P1 选数</h1><p>现在有一排共N个数，你需要从中选出恰好K个。选出K个数后，计算它们两两差值的绝对值的最小值S。你需要确定选出哪K个，才能最大化这个S。</p>
<h2 id="格式"><a href="#格式" class="headerlink" title="格式"></a>格式</h2><h3 id="输入格式"><a href="#输入格式" class="headerlink" title="输入格式"></a>输入格式</h3><p>输入第一行两个正整数N、K，含义如上。<br>输入第二行N个正整数，依次表示这N个数A1~An。0＜Ai≤10^9。</p>
<h3 id="输出格式"><a href="#输出格式" class="headerlink" title="输出格式"></a>输出格式</h3><p>一行一个正整数，S的最大值。<br><a id="more"></a></p>
<h2 id="样例"><a href="#样例" class="headerlink" title="样例"></a>样例</h2><h3 id="样例输入"><a href="#样例输入" class="headerlink" title="样例输入"></a>样例输入</h3><blockquote>
<p>11 5<br>19 585 29 1111 5868 3331 272 4441 2251 868 581</p>
</blockquote>
<h3 id="样例输出"><a href="#样例输出" class="headerlink" title="样例输出"></a>样例输出</h3><blockquote>
<p>1092</p>
</blockquote>
<h2 id="提示​"><a href="#提示​" class="headerlink" title="提示​"></a>提示​</h2><p>对于30%的数据，N≤18。<br>对于60%的数据，N≤20。<br>对于80%的数据，N≤100。<br>对于100%的数据，N≤100000，K&lt;=N</p>
<h2 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h2><p>最大化最小值，典型的二分答案。<br>然而不知道怎么在O(N)内判定一个解的正确性。。。<br>我们贪心的想：<br>先qsort升序<br>最小的数一定要选，可以反正：如果选了次小的数没有选最小，那么把次小换成最小的答案一定更优。<br>于是先选a[last=1]，O(N)扫一遍，如果a[i]-a[last]&gt;=mid那么就选i，更新last，统计个数。</p>
<dir style="display:none"><a href="/2016/08/16/JSOI2016-提高1班-Day1/choose.pas" title="复制代码">复制代码</a></dir>

<p>```delphi choose.pas<br>type int=longint;<br>var<br>    a:array[0..100010] of int;<br>    n,k,i,l,r,mid,ans:int;</p>
<p>procedure swap(var a,b:int);<br>var tmp:int;<br>begin tmp:=a;a:=b;b:=tmp end;</p>
<p>procedure qsort(b,e:int);<br>var i,j,x:int;<br>begin<br>    i:=b;j:=e;x:=a[random(e-b)+b];<br>    repeat<br>        while a[i]<x do="" inc(i);="" while="" a[j]="">x do dec(j);<br>        if i&lt;=j then begin<br>            swap(a[i],a[j]);<br>            inc(i);dec(j);<br>        end;<br>    until i&gt;j;<br>    if i&lt;e then qsort(i,e);<br>    if b&lt;j then qsort(b,j);<br>end;</x></p>
<p>function check(x:int):boolean;<br>var i,last,cnt:int;<br>begin<br>    cnt:=1;last:=a[1];<br>    for i:=2 to n do<br>        if a[i]-last&gt;=x then begin<br>            last:=a[i];<br>            inc(cnt);<br>        end;<br>    check:=cnt&gt;=k;<br>end;</p>
<p>begin<br>    assign(input,’choose.in’);reset(input);<br>    assign(output,’choose.out’);rewrite(output);</p>
<pre><code>read(n,k);
for i:=1 to n do read(a[i]);
qsort(1,n);
l:=0;r:=a[n]-a[1];
while l&lt;=r do begin
    mid:=(l+r) shr 1;
    if check(mid) then begin ans:=mid;l:=mid+1 end
    else r:=mid-1;
end;
write(ans);

close(input);close(output);
</code></pre><p>end.</p>
<pre><code>
# P2 划区灌溉
约翰的奶牛们发现山脊上的草特别美味。为了维持草的生长，约翰打算安装若干喷灌器。
为简化问题，山脊可以看成一维的数轴，长为L(1≤L≤1,000,000)，而且L一定是一个偶数。每个喷灌器可以双向喷灌，并有确定的射程，该射程是一个整数，且不短于A，不长于B。A,B(1≤A≤B≤1000)都是给出的正整数。它所在位置的两边射程内，都属它的灌溉区域。现要求山脊的每一个区域都被灌溉到，而且喷灌器的灌溉区域不允许重叠。
约翰有N(1≤N≤1000)只奶牛，每一只都有特别喜爱的草区，第i只奶牛的草区是[Si，Ei]，不同奶牛的草区可以重叠。现要求，每只奶牛的草区仅被一个喷灌器灌溉。
寻找最少需要的喷灌器数目。

## 格式
### 输入格式
第1行：N,L.
第2行：A,B.
第3到N十2行：每行2个整数Si，Ei,(0≤S\&lt;E≤L).

### 输出格式
最小的喷灌器数目。如果无法设计出满足条件的喷灌器数目，请输出-1.

## 样例
### 样例输入
&gt;2 8 
1 2 
6 7 
3 6 


### 样例输出
&gt;3

## 提示
【样例说明】
如下图，只需安装三个喷灌器。c1,c2为奶牛们的草区。
```plain
                 |-----c2----|-c1|       
     |---1---|-------2-------|---3---|   
     +---+---+---+---+---+---+---+---+
     0   1   2   3   4   5   6   7   8
</code></pre><p>【数据范围】<br>对于30%的数据，L≤100。<br>对于60%的数据，L≤10000。<br>对于100%的数据，1≤L≤1,000,000，1≤A≤B≤1000，1≤N≤1000。</p>
<h2 id="水解"><a href="#水解" class="headerlink" title="水解"></a>水解</h2><p>首先，看起来像线段覆盖DP，于是又$O(L^2)$的算法<br>左右都覆盖比较麻烦，可以看成只向左覆盖，范围[2*a,2*b]<br>80分，一个点TLE，还有一个不知道为什么WA。。。</p>
<dir style="display:none"><a href="/2016/08/16/JSOI2016-提高1班-Day1/divide.pas" title="复制代码">复制代码</a></dir>

<p>```delphi divide.pas<br>uses math;<br>const inf=1000000000;<br>type int=longint;<br>var<br>    n,l,a,b,i,j,k:int;<br>    seg:array[0..1010,0..1] of int;<br>    f:array[-1010..1000010] of int;</p>
<p>function com(x,y:int):boolean;<br>begin<br>    if (seg[x,0]&lt;seg[y,0]) or<br>       ((seg[x,0]=seg[y,0]) and (seg[x,1]&lt;seg[y,1])) then com:=true<br>    else com:=false;<br>end;</p>
<p>procedure swap(var a,b:int);<br>var tmp:int;<br>begin tmp:=a;a:=b;b:=tmp end;</p>
<p>procedure qsort(b,e:int);<br>var i,j:int;<br>begin<br>    i:=b;j:=e;seg[0]:=seg[random(e-b)+b];<br>    repeat<br>        while com(i,0) do inc(i);<br>        while com(0,j) do dec(j);<br>        if i&lt;=j then begin<br>            swap(seg[i,0],seg[j,0]);swap(seg[i,1],seg[j,1]);<br>            inc(i);dec(j);<br>        end;<br>    until i&gt;j;<br>    if i&lt;e then qsort(i,e);<br>    if b&lt;j then qsort(b,j);<br>end;</p>
<p>begin<br>    assign(input,’divide.in’);reset(input);<br>    assign(output,’divide.out’);rewrite(output);</p>
<pre><code>read(n,l,a,b);
for i:=1 to n do read(seg[i,0],seg[i,1]);
qsort(1,n);
filldword(f,sizeof(f) div 4,inf);
seg[0,1]:=0;seg[0,0]:=0;seg[n+1,0]:=l;

f[0]:=0;
for i:=1 to n+1 do
    for j:=seg[i-1,1] to seg[i,0] do
        for k:=a to b do
            f[j]:=min(f[j],f[j-k*2]+1);
if f[l]=inf then write(-1) else write(f[l]);
close(input);close(output);
</code></pre><p>end.</p>
<pre><code>
## 正解
然后发现对于第i个位置，决策在[i-2*b,i-2*a]，于是想到了 定窗长最大值 的模型，而且决策单调，于是用单调队列优化成O(N)。
注意：
1. 同理看成向左覆盖，只能在偶数点处理
2. 注意端点和队列指针的细节
3. 被奶牛的草区覆盖的点不做处理，这可以用差分序列c预处理O(N)

&lt;dir style=&quot;display:none&quot;&gt;<a href="/2016/08/16/JSOI2016-提高1班-Day1/0divide.pas" title="复制代码">复制代码</a>&lt;/dir&gt;

```delphi 0divide.pas
uses math;
const inf=1000000000;
type int=longint;
var 
    n,l,a,b,h,t,i,x:int;
    q:array[0..10010,0..1] of int;
    c,f:array[0..1000010] of int;

begin
    assign(input,&#39;divide.in&#39;);reset(input);
    assign(output,&#39;divide.out&#39;);rewrite(output);

    read(n,l,a,b);
    for i:=1 to n do begin
        read(h,t);
        inc(c[h+1]);dec(c[t]);
    end;
    for i:=1 to l do inc(c[i],c[i-1]);

    filldword(f,sizeof(f) div 4,inf);
    f[0]:=0;
    h:=0;t:=0;i:=2;
    while i&lt;=l do begin
        x:=i-2*a;
        if x&gt;=0 then begin
            while (h&lt;&gt;t) and (q[t-1,0]&gt;=f[x]) do dec(t);
            q[t,0]:=f[x];q[t,1]:=x;
            inc(t);if t&gt;10010 then t:=0;
        end;
        if c[i]=0 then begin
            x:=i-2*b;
            while (h&lt;&gt;t) and (q[h,1]&lt;x) do begin
                inc(h);if h&gt;10010 then h:=0;
            end;
            if (h=t) or (q[h,0]=inf) then f[i]:=inf else f[i]:=q[h,0]+1;
        end;
        inc(i,2);
    end;
    if f[l]=inf then write(-1) else write(f[l]);

    close(input);close(output);
end.
</code></pre><h1 id="P3-树林"><a href="#P3-树林" class="headerlink" title="P3 树林"></a>P3 树林</h1><p>现在有一片树林，小B很想知道，最少需要多少步能围绕树林走一圈，最后回到起点．他能上下左右走，也能走对角线格子。<br>土地被分成R行C列（1≤R≤50,1≤C≤50)，下面是一张样例的地图，其中“.”表示小B可以走的空地，”X”表示树林，”*”表示起点。而小B走的最近的路己经特别地用“+”表示出来。</p>
<pre><code class="plain">. . . + . . .
. . + X + . .
. + X X X + .
. . + X X X +
. . + X . . +
. . . + + + *
</code></pre>
<p>题目保证，一定有合法解并且有且只有一片树林，树林一定是上下左右联通的。</p>
<h2 id="格式-1"><a href="#格式-1" class="headerlink" title="格式"></a>格式</h2><h3 id="输入格式-1"><a href="#输入格式-1" class="headerlink" title="输入格式"></a>输入格式</h3><p> 第1行输入R和C，接下来R行C列表示一张地图。地图中的符号如题干所述。</p>
<h3 id="输出格式-1"><a href="#输出格式-1" class="headerlink" title="输出格式"></a>输出格式</h3><p>输出最少的步数。</p>
<h2 id="样例-1"><a href="#样例-1" class="headerlink" title="样例"></a>样例</h2><h3 id="样例输入-1"><a href="#样例输入-1" class="headerlink" title="样例输入"></a>样例输入</h3><blockquote>
<p>6 7<br>…….<br>…X…<br>..XXX..<br>…XXX.<br>…X…<br>……*</p>
</blockquote>
<h3 id="样例输出-1"><a href="#样例输出-1" class="headerlink" title="样例输出"></a>样例输出</h3><blockquote>
<p>13</p>
</blockquote>
<h2 id="提示"><a href="#提示" class="headerlink" title="提示"></a>提示</h2><p>对于40%的数据，R,C≤12<br>对于60%的数据，R,C≤30<br>对于100%的数据，R,C≤50</p>
<h2 id="题解-1"><a href="#题解-1" class="headerlink" title="题解"></a>题解</h2><p>神奇的题目，我们取一棵树（如取横坐标最小的），水平向左引一条射线（图中“-”）</p>
<pre><code class="plain">. . . + . . .
. . a X + . .
- - X X X + .
. . b X X X +
. . + X . . +
. . . + + + *
</code></pre>
<p>然后在<strong>不穿过这条线</strong>的情况下从起点BFS，那么一条合法路径必然是：</p>
<ol>
<li>从起点，不穿过线到达射线下一点b</li>
<li>从b穿过线到达射线上一点a</li>
<li>从a不穿过射线回到起点</li>
</ol>
<p>1和3的最短路在bfs里算过了；2的话，记b(i-1,j) a(i+1,k)，那么路径2的值就是$max(|k-j|,2)$<br>两个循环枚举a,b就好了。</p>
<dir style="display:none"><a href="/2016/08/16/JSOI2016-提高1班-Day1/grove.pas" title="复制代码">复制代码</a></dir>

<p>```delphi grove.pas<br>uses math;<br>type int=integer;<br>const<br>    dir:array[0..7,0..1] of int=<br>    ((0,1),(0,-1),(1,0),(-1,0),(1,1),(-1,-1),(-1,1),(1,-1));<br>    inf=5000;<br>var<br>    n,m,i,j,sx,sy,x,y,nx,ny,h,t,ans:int;<br>    map:array[0..51,0..51] of char;<br>    f:array[0..51,0..51] of int;<br>    q:array[0..2510,0..1] of int;</p>
<p>begin<br>    assign(input,’grove.in’);reset(input);<br>    assign(output,’grove.out’);rewrite(output);</p>
<pre><code>readln(n,m);
y:=51;
for i:=1 to n do begin
    for j:=1 to m do begin
        read(map[i,j]);
        if (map[i,j]=&#39;X&#39;) and (j&lt;y) then begin x:=i;y:=j end;
        if map[i,j]=&#39;*&#39; then begin sx:=i;sy:=j end;
    end;
    readln;
end;
for j:=1 to y-1 do map[x,j]:=&#39;-&#39;; //画一条水平线
//bfs
fillword(f,sizeof(f) div 2,inf);
h:=1;t:=2;
q[h,0]:=sx;q[h,1]:=sy;
f[sx,sy]:=0;
while h&lt;&gt;t do begin
    for i:=0 to 7 do begin
        nx:=q[h,0]+dir[i,0];ny:=q[h,1]+dir[i,1];
        if (nx&lt;1) or (ny&lt;1) or (nx&gt;n) or (ny&gt;m) then continue;
        if f[nx,ny]&lt;&gt;inf then continue;
        if (map[nx,ny]=&#39;X&#39;) or (map[nx,ny]=&#39;-&#39;) then continue;

        q[t,0]:=nx;q[t,1]:=ny;f[nx,ny]:=f[q[h,0],q[h,1]]+1;
        inc(t);if t&gt;2510 then t:=0;
    end;
    inc(h);if h&gt;2510 then h:=0;
end;

ans:=maxint;
for i:=1 to y do
    for j:=1 to y do
        ans:=min(ans,f[x-1,i]+f[x+1,j]+max(abs(j-i),2));
write(ans);

close(input);close(output);
</code></pre><p>end.</p>
<pre><code>
# P4 迷宫花坛
圣玛格丽特学园的一角有一个巨大、如迷宫般的花坛。大约有一个人这么高的大型花坛，做成迷宫的形状，深受中世纪贵族的喜爱。维多利加的小屋就坐落在这迷宫花坛的深处。某一天早晨，久城同学要穿过这巨大的迷宫花坛，去探望感冒的维多利加。
整个迷宫可以用N个路口与M条连接两个不同路口的无向通道来描述。路口被标号为1到N，每条通道有各自的长度。整个迷宫一定是连通的，迷宫中可能存在若干个环路，但是，出于美观考虑，每个路口最多只会属于一个简单环路。例如，图1所示的迷宫是非常美观的，但图2则不符合我们的描述，因为3号路口同属于两个简单环。
<img src="/2016/08/16/JSOI2016-提高1班-Day1/1.png" alt="1.png" title=""><img src="/2016/08/16/JSOI2016-提高1班-Day1/2.png" alt="2.png" title="">
你需要回答多个这样的询问：假如久城处在路口x，维多利加的小屋处在路口y，久城最短需要走多少距离才能到达小屋？

## 格式
### 输入格式
第一行2个整数N,M，表示迷宫花坛的路口数和通道数；
接下来M行，每行3个整数x,y,z，描述一条连接路口x与路口y，长度为z的通道；
再接下来1行包含一个整数Q，表示询问数量；
之后Q行，每行2个整数x,y，描述一个询问。


### 输出格式
对于每个询问输出一行一个整数，表示最短距离。

## 样例
### 样例输入
&gt;4 4
1 2 1
2 3 2
1 3 2
3 4 1
2
2 4
1 3

### 样例输出
&gt;3
2

## 提示
对于30%的数据，N≤100；
另有30%的数据，保证N=M；
对于100%的数据，1≤N≤100,000，Q≤200,000，1≤x,y≤N，1≤z≤1000。

## 题解
仙人掌上的倍增LCA。。。
我还是觉得暴力Floyd骗30分比较适合我。
那么来欣赏一下标程吧

&lt;dir style=&quot;display:none&quot;&gt;&lt;/dir&gt;

```cpp garden.cpp
#include&lt;cstdio&gt;
#include&lt;cstring&gt;
#include&lt;iostream&gt;
#include&lt;algorithm&gt;

#define maxn 100010
#define INF  0x3f3f3f3f
using namespace std;
int  n,m,K;
int  F[maxn][20];
int  H[maxn];       //深度 
int  D[maxn];       //距离 

int  List[maxn*3];  //SCC距离 
int  Front[maxn];   //SCC第一距离 
int  Back[maxn];    //SCC第二距离
int  SCC[maxn];     //联通分量 
int  Ls=0,SCCs=0;
struct Edge{int v,w;Edge *next;};
Edge *E[maxn],Er[maxn*3];int Es=0;

struct Data1{
    void addEdge(int u,int v,int w){
        Edge *P=&amp;Er[++Es];P-&gt;v=v;P-&gt;w=w;P-&gt;next=E[u];E[u]=P;
              P=&amp;Er[++Es];P-&gt;v=u;P-&gt;w=w;P-&gt;next=E[v];E[v]=P;
    }
    void init(){
        memset(E,0,sizeof(E));
        int u,v,w;
        scanf(&quot;%d%d&quot;,&amp;n,&amp;m);
        for(int i=1;i&lt;=m;i++)scanf(&quot;%d%d%d&quot;,&amp;u,&amp;v,&amp;w),addEdge(u,v,w);
    }
}data1;

int  calc(int u,int v){
    int x1=Front[u],x2=Back[u],y1=Front[v],y2=Back[v],dis=INF;
    dis=min(dis,abs(List[x1]-List[y1]));
    dis=min(dis,abs(List[x1]-List[y2]));
    dis=min(dis,abs(List[x2]-List[y1]));
    dis=min(dis,abs(List[x2]-List[y2]));
    return dis;
}
int  LCA(int u,int v){
    int fu=u,fv=v;
    if(D[fu]&gt;D[fv])swap(fu,fv);
    for(int j=19;j&gt;=0;j--)
        if(F[fv][j]&amp;&amp;D[F[fv][j]]&gt;=D[fu])fv=F[fv][j];
    if(fv==fu)return H[u]+H[v]-H[fu]-H[fu];
    for(int j=19;j&gt;=0;j--)
        if(F[fv][j]&amp;&amp;F[fu][j]&amp;&amp;F[fu][j]!=F[fv][j])fu=F[fu][j],fv=F[fv][j];
    if(SCC[fu]!=SCC[fv]||SCC[fu]==0||SCC[fv]==0)return H[u]+H[v]-H[F[fu][0]]-H[F[fu][0]];
    return H[u]+H[v]-H[fu]-H[fv]+calc(fu,fv);
}

int  Q[maxn],bot;
struct Data2{
    int  Path[maxn],Length[maxn],u;
    bool V[maxn];
    int  P1[maxn*2][2],P2[maxn][2],bot1,bot2;

    void getPath(int u,int v,int f,int w){
        bot1=bot2=0;
        //cout&lt;&lt;&quot;getPath &quot;&lt;&lt;u&lt;&lt;&quot; &quot;&lt;&lt;v&lt;&lt;&quot; &quot;&lt;&lt;f&lt;&lt;&quot; &quot;&lt;&lt;w&lt;&lt;endl;
        for(int P=u;H[P]&gt;=H[f];P=Path[P]){bot1++;P1[bot1][0]=P;P1[bot1+1][1]=Length[P];}
        //cout&lt;&lt;&quot;P1&quot;&lt;&lt;endl;
        //for(int i=1;i&lt;=bot1;i++)cout&lt;&lt;i&lt;&lt;&quot; &quot;&lt;&lt;P1[i][0]&lt;&lt;&quot; &quot;&lt;&lt;P1[i][1]&lt;&lt;endl;
        for(int P=v;H[P]&gt;H[f];P=Path[P]){bot2++;P2[bot2][0]=P;P2[bot2][1]=Length[P];}
        //cout&lt;&lt;&quot;P2&quot;&lt;&lt;endl;
        //for(int i=1;i&lt;=bot2;i++)cout&lt;&lt;i&lt;&lt;&quot; &quot;&lt;&lt;P2[i][0]&lt;&lt;&quot; &quot;&lt;&lt;P2[i][1]&lt;&lt;endl;
        while(bot2){
            bot1++;P1[bot1][0]=P2[bot2][0];P1[bot1][1]=P2[bot2][1];bot2--;
        }
        for(int i=bot1+1;i&lt;=bot1*2;i++)P1[i][0]=P1[i-bot1][0],P1[i][1]=P1[i-bot1][1];
        P1[bot1+1][1]+=w;

        Ls++;
        for(int i=1;i&lt;=bot1*2;i++)List[Ls+i]=List[Ls+i-1]+P1[i][1];
        for(int i=1;i&lt;=bot1;i++)Front[P1[i][0]]=Ls+i,Back[P1[i][0]]=Ls+i+bot1;
        Ls+=bot1*2;
    }
    void findSCC(int u,int v,int w){
        int fu=u,fv=v;
        while(fu!=fv)if(H[fu]&gt;H[fv])fu=Path[fu];else fv=Path[fv];
        getPath(u,v,fu,w);

        SCCs++;
        for(int i=1;i&lt;=bot1;i++)SCC[P1[i][0]]=SCCs;
        for(int i=1;i&lt;=bot1;i++)if(P1[i][0]!=fu)F[P1[i][0]][0]=fu;
        //cout&lt;&lt;&quot;SCC &quot;&lt;&lt;SCCs&lt;&lt;endl;
        //for(int i=1;i&lt;=2*bot1;i++)cout&lt;&lt;i&lt;&lt;&quot; &quot;&lt;&lt;P1[i][0]&lt;&lt;&quot; &quot;&lt;&lt;P1[i][1]&lt;&lt;endl;
    }
    void BFS(){
        memset(H,0,sizeof(H));
        memset(V,true,sizeof(V));
        memset(List,0,sizeof(List));
        memset(SCC,0,sizeof(SCC));
        memset(F,0,sizeof(F));
        Q[bot=1]=1;V[1]=false;Path[1]=Length[1]=0;H[1]=1;
        for(int top=1;top&lt;=bot;top++){
            u=Q[top];
            //cout&lt;&lt;&quot;BFS &quot;&lt;&lt;u&lt;&lt;endl;
            for(Edge *P=E[u];P;P=P-&gt;next){
                if(P-&gt;v==Path[u])continue;
                if(V[P-&gt;v]){
                    Q[++bot]=P-&gt;v;
                    H[P-&gt;v]=H[u]+1;V[P-&gt;v]=false;
                    F[P-&gt;v][0]=Path[P-&gt;v]=u;
                    Length[P-&gt;v]=P-&gt;w;
                }
                else if(SCC[u]==0)findSCC(P-&gt;v,u,P-&gt;w);
            }
        }
        //for(int i=1;i&lt;=bot;i++)cout&lt;&lt;Q[i]&lt;&lt;&quot; &quot;&lt;&lt;F[Q[i]][0]&lt;&lt;&quot; &quot;&lt;&lt;SCC[Q[i]]&lt;&lt;&quot; &quot;&lt;&lt;Length[Q[i]]&lt;&lt;endl;
    }
    void work(){
        memset(H,0,sizeof(H));
        memset(D,0,sizeof(D));
        for(int top=1;top&lt;=bot;top++){
            u=Q[top];
            D[u]=D[F[u][0]]+1;
            if(SCC[F[u][0]]!=SCC[u]||SCC[u]==0)H[u]=H[F[u][0]]+Length[u];
                                          else H[u]=H[F[u][0]]+calc(F[u][0],u);
            for(int j=1;j&lt;20&amp;&amp;F[u][j-1];j++)F[u][j]=F[F[u][j-1]][j-1];
        }
        /*
        for(int i=1;i&lt;=bot;i++){
            u=Q[i];
            printf(&quot;Qi=%d SCC=%d H=%d D=%d\n&quot;,u,SCC[u],H[u],D[u]);
            for(int j=0;j&lt;20;j++)printf(&quot;%5d&quot;,F[u][j]);cout&lt;&lt;endl;
        }
        */
    }
}data2;

struct Data3{
    void query(){
        int  u,v;
        scanf(&quot;%d&quot;,&amp;K);
        for(int i=1;i&lt;=K;i++){
            scanf(&quot;%d%d&quot;,&amp;u,&amp;v);
            printf(&quot;%d\n&quot;,LCA(u,v));
        }
    }
}data3;
int  main(){
    freopen(&quot;garden.in&quot;,&quot;r&quot;,stdin);
    freopen(&quot;garden.out&quot;,&quot;w&quot;,stdout);
    data1.init();
    data2.BFS();
    data2.work();
    data3.query();
    return 0;
}
</code></pre>]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[[POJ] P2942 Knights of the Round Table]]></title>
      <url>https://cothrax.github.io/2016/08/16/POJ-P2942/</url>
      <content type="html"><![CDATA[<h2 id="描述"><a href="#描述" class="headerlink" title="描述"></a>描述</h2><p>Being a knight is a very attractive career: searching for the Holy Grail, saving damsels in distress, and drinking with the other knights are fun things to do. Therefore, it is not very surprising that in recent years the kingdom of King Arthur has experienced an unprecedented increase in the number of knights. There are so many knights now, that it is very rare that every Knight of the Round Table can come at the same time to Camelot and sit around the round table; usually only a small group of the knights isthere, while the rest are busy doing heroic deeds around the country.</p>
<p>Knights can easily get over-excited during discussions-especially after a couple of drinks. After some unfortunate accidents, King Arthur asked the famous wizard Merlin to make sure that in the future no fights break out between the knights. After studying the problem carefully, Merlin realized that the fights can only be prevented if the knights are seated according to the following two rules:</p>
<ol>
<li>The knights should be seated such that two knights who hate each other should not be neighbors at the table. (Merlin has a list that says who hates whom.) The knights are sitting around a roundtable, thus every knight has exactly two neighbors.</li>
<li>An odd number of knights should sit around the table. This ensures that if the knights cannot agree on something, then they can settle the issue by voting. (If the number of knights is even, then itcan happen that “yes” and “no” have the same number of votes, and the argument goes on.)<a id="more"></a>
</li>
</ol>
<p>Merlin will let the knights sit down only if these two rules are satisfied, otherwise he cancels the meeting. (If only one knight shows up, then the meeting is canceled as well, as one person cannot sit around a table.) Merlin realized that this means that there can be knights who cannot be part of any seating arrangements that respect these rules, and these knights will never be able to sit at the Round Table (one such case is if a knight hates every other knight, but there are many other possible reasons). If a knight cannot sit at the Round Table, then he cannot be a member of the Knights of the Round Table and must be expelled from the order. These knights have to be transferred to a less-prestigious order, such as the Knights of the Square Table, the Knights of the Octagonal Table, or the Knights of the Banana-Shaped Table. To help Merlin, you have to write a program that will determine the number of knights that must be expelled. </p>
<h2 id="格式"><a href="#格式" class="headerlink" title="格式"></a>格式</h2><h3 id="输入格式"><a href="#输入格式" class="headerlink" title="输入格式"></a>输入格式</h3><p>The input contains several blocks of test cases. Each case begins with a line containing two integers 1 ≤ n ≤ 1000 and 1 ≤ m ≤ 1000000 . The number n is the number of knights. The next m lines describe which knight hates which knight. Each of these m lines contains two integers k1 and k2 , which means that knight number k1 and knight number k2 hate each other (the numbers k1 and k2 are between 1 and n ). </p>
<p>The input is terminated by a block with n = m = 0 . </p>
<h3 id="输出格式"><a href="#输出格式" class="headerlink" title="输出格式"></a>输出格式</h3><p>For each test case you have to output a single integer on a separate line: the number of knights that have to be expelled. </p>
<h2 id="样例"><a href="#样例" class="headerlink" title="样例"></a>样例</h2><h3 id="样例输入"><a href="#样例输入" class="headerlink" title="样例输入"></a>样例输入</h3><blockquote>
<p>5 5<br>1 4<br>1 5<br>2 5<br>3 4<br>4 5<br>0 0</p>
</blockquote>
<h3 id="样例输出"><a href="#样例输出" class="headerlink" title="样例输出"></a>样例输出</h3><blockquote>
<p>2</p>
</blockquote>
<h2 id="提示"><a href="#提示" class="headerlink" title="提示"></a>提示</h2><p>Huge input file, ‘scanf’ recommended to avoid TLE. </p>
<h2 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h2><p>WA了N次后发现原来一个输入里有多组数据，又WA了N次后发现忘记初始化连通分量的数组了。果然外语不好不能刷POJ的题。<br>题意是：</p>
<blockquote>
<p>有N个骑士围坐在一个圆桌旁开会，给出某些骑士之间的仇恨关系。一次会议能够顺利举行，要满足两个条件：<br>1：任意相互憎恨的两个骑士不能相邻<br>2：开会人数为大于2的奇数<br>若某个骑士<strong>任何会议</strong>都不能参加，那么就必须将他踢出，问最少需要踢出多少个骑士？</p>
</blockquote>
<p>先求仇恨关系的补图，补图中边的含义就是两个骑士能相邻，<br>那么要开圆桌会就是找图中的n&gt;=3的奇圈，<br>奇圈一定形成了双连通分量，于是tarjan找出所有分量，<br>对于每一个分量，如果n&gt;=3且不能二分染色，就标记这个分量内的所有点。<br>最后统计没有被标记的点数。</p>
<p>注意：</p>
<ol>
<li>一个点可能处在多个分量中，找到立即处理。</li>
<li>割点处理后不要退栈。</li>
<li>初始化！</li>
</ol>
<dir style="display:none"><a href="/2016/08/16/POJ-P2942/test.pas" title="复制代码">复制代码</a></dir>

<p>```delphi test.pas<br>//uses math;<br>type int=longint;<br>var<br>    n,m,cc,i,f,t,tim,ans:int;<br>    g:array[0..1010,0..1010] of boolean;<br>    ins,kick:array[0..1010] of boolean;<br>    dfn,low,scc,s,col:array[0..1010] of int;</p>
<p>function min(a,b:int):int;<br>begin if a&lt;b then min:=a else min:=b end;</p>
<p>function paint(v,c:int):boolean;<br>var i:int;<br>begin<br>    col[v]:=c;<br>    for i:=1 to n do<br>        if g[v,i] and (scc[i]=cc) then begin<br>            if (col[i]=c) then exit(false);<br>            if (col[i]=0) and not paint(i,-c) then exit(false);<br>        end;<br>    paint:=true;<br>end;</p>
<p>procedure solve(v,i:int);<br>var<br>    tmp:array[0..1010] of int;<br>    cnt,j:int;<br>begin<br>    inc(cc);cnt:=0;<br>    while s[t+1]&lt;&gt;i do begin<br>        ins[s[t]]:=false;<br>        inc(cnt);tmp[cnt]:=s[t];<br>        scc[s[t]]:=cc;<br>        dec(t);<br>    end;<br>    inc(cnt);tmp[cnt]:=v;<br>    fillchar(col,sizeof(col),0);<br>    if (cnt&gt;=3) and not paint(v,1) then<br>        for j:=1 to cnt do kick[tmp[j]]:=false;<br>end;</p>
<p>procedure tarjan(v,p:int);<br>var i:int;<br>begin<br>    inc(tim);dfn[v]:=tim;low[v]:=tim;<br>    ins[v]:=true;inc(t);s[t]:=v;<br>    for i:=1 to n do<br>        if g[v,i] then begin<br>            if i=p then continue;<br>            if dfn[i]=0 then begin<br>                tarjan(i,v);<br>                low[v]:=min(low[v],low[i]);<br>                if low[i]&gt;=dfn[v] then solve(v,i);<br>            end else if ins[i] then<br>                low[v]:=min(low[v],dfn[i]);<br>        end;<br>end;</p>
<p>begin<br>    while true do begin<br>        read(n,m);<br>        if (n=0) and (m=0) then break;</p>
<pre><code>    fillchar(g,sizeof(g),true);
    for i:=1 to m do begin
        read(f,t);
        g[f,t]:=false;g[t,f]:=false;
    end;
    for i:=1 to n do g[i,i]:=false;

    fillchar(kick,sizeof(kick),true);
    fillchar(dfn,sizeof(dfn),0);
    fillchar(scc,sizeof(scc),0);
    fillchar(ins,sizeof(ins),false);
    cc:=0;tim:=0;t:=0;
    for i:=1 to n do if dfn[i]=0 then tarjan(i,0);

    ans:=0;
    for i:=1 to n do if kick[i] then inc(ans);
    writeln(ans);
end;
</code></pre><p>end.</p>
<p>```</p>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[[Vijos] P1124 字串变换]]></title>
      <url>https://cothrax.github.io/2016/08/15/Vijos-P1124/</url>
      <content type="html"><![CDATA[<h2 id="描述"><a href="#描述" class="headerlink" title="描述"></a>描述</h2><p>已知有两个字串 A\$, B\$ 及一组字串变换的规则（至多6个规则）:<br>A1\$ -&gt; B1\$<br>A2\$ -&gt; B2\$<br>规则的含义为：在 A＄中的子串 A1\$ 可以变换为 B1\$、A2\$ 可以变换为 B2\$ …。<br>例如：A\$＝’abcd’　B\$＝’xyz’<br>变换规则为：<br>‘abc’-&gt;‘xu’　‘ud’-&gt;‘y’　‘y’-&gt;‘yz’<br>则此时，A\$ 可以经过一系列的变换变为 B\$，其变换的过程为：<br>‘abcd’-&gt;‘xud’-&gt;‘xy’-&gt;‘xyz’<br>共进行了三次变换，使得 A\$ 变换为B\$。</p>
<h2 id="格式"><a href="#格式" class="headerlink" title="格式"></a>格式</h2><h3 id="输入格式"><a href="#输入格式" class="headerlink" title="输入格式"></a>输入格式</h3><p>第一行为两个字符串，第二行至文件尾为变换规则<br>A\$ B\$<br>A1\$ B1\$ \<br>A2\$ B2\$ |-&gt; 变换规则<br>… … /<br>所有字符串长度的上限为 20。</p>
<h3 id="输出格式"><a href="#输出格式" class="headerlink" title="输出格式"></a>输出格式</h3><p>若在 10 步（包含 10步）以内能将 A\$ 变换为 B\$ ，则输出最少的变换步数；否则输出”NO ANSWER!”<br><a id="more"></a></p>
<h2 id="样例"><a href="#样例" class="headerlink" title="样例"></a>样例</h2><h3 id="样例输入"><a href="#样例输入" class="headerlink" title="样例输入"></a>样例输入</h3><blockquote>
<p>abcd xyz<br>abc xu<br>ud y<br>y yz</p>
</blockquote>
<h3 id="样例输出"><a href="#样例输出" class="headerlink" title="样例输出"></a>样例输出</h3><blockquote>
<p>3</p>
</blockquote>
<h2 id="提示​"><a href="#提示​" class="headerlink" title="提示​"></a>提示​</h2><p>每个测试点1s<br>noip2002提高组第二题</p>
<h2 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h2><p>暴力BFS+Hash<br>注意：一个字串中可能存在对一个变化的多个匹配，如”aaa”和规则”a-&gt;p”就有三种情况<br>还有hash表比较大，fill耗时，于是省掉就好。</p>
<h3 id="方法一：单向BFS-Hash"><a href="#方法一：单向BFS-Hash" class="headerlink" title="方法一：单向BFS+Hash"></a>方法一：单向BFS+Hash</h3><dir style="display:none"><a href="/2016/08/15/Vijos-P1124/pp1124.pas" title="复制代码">复制代码</a></dir>

<p>```delphi pp1124.pas<br>uses math;<br>const seed=131;p=100000007;<br>type state=record s:string;i:integer end;<br>var<br>    ht:array[0..p] of boolean;<br>    q:array[0..10010] of state;<br>    a:array[0..1,0..7] of string;<br>    n,p0,h,t:integer;s:string;</p>
<p>function hash(s:string):dword;<br>var i:integer;<br>begin<br>    hash:=0;<br>    for i:=1 to length(s) do<br>        hash:=(hash*seed+ord(s[i])) and $FFFFFFF;<br>    hash:=hash mod p;<br>end;</p>
<p>//start开始，t在p中第一次出现的位置<br>function getpos(t,p:string;start:integer):integer;<br>begin<br>    getpos:=pos(t,copy(p,start,length(p)-start+1));<br>    if getpos&lt;&gt;0 then inc(getpos,start-1);<br>end;</p>
<p>procedure bfs();<br>var i,p0:integer;cstr,nstr:string;ha:dword;<br>begin<br>    if a[0,0]=a[1,0] then begin write(0);halt end;<br>    h:=1;t:=2;<br>    q[h].s:=a[0,0];q[h].i:=0;<br>    while h&lt;&gt;t do begin<br>        cstr:=q[h].s;<br>        if q[h].i=10 then exit;<br>        for i:=1 to n do begin<br>            p0:=getpos(a[0,i],cstr,1);<br>            while p0&lt;&gt;0 do begin<br>                nstr:=cstr;<br>                delete(nstr,p0,length(a[0,i]));<br>                insert(a[1,i],nstr,p0);</p>
<pre><code>            ha:=hash(nstr);
            if not ht[ha] then begin
                ht[ha]:=true;
                if nstr=a[1,0] then begin
                    write(q[h].i+1);
                    halt;
                end;
                q[t].s:=nstr;q[t].i:=q[h].i+1;
                inc(t);if t&gt;10010 then t:=0;
            end;
            p0:=getpos(a[0,i],cstr,p0+1);
        end;
    end;
    inc(h);if h&gt;10010 then h:=0;
end;
</code></pre><p>end;</p>
<p>begin {Main}<br>    n:=-1;<br>    while not eof do begin<br>        inc(n);<br>        readln(s);<br>        p0:=pos(‘ ‘,s);<br>        a[0,n]:=copy(s,1,p0-1);<br>        a[1,n]:=copy(s,p0+1,length(s)-p0);<br>    end;</p>
<pre><code>//fillchar(ht,sizeof(ht),false);
bfs();
write(&#39;NO ANSWER!&#39;);
</code></pre><p>end.</p>
<pre><code>
### 方法二：双向BFS+Hash
直接用hash表存得到该字串的最小步骤，然后发现匹配可以直接输出

&lt;dir style=&quot;display:none&quot;&gt;<a href="/2016/08/15/Vijos-P1124/p1124.pas" title="复制代码">复制代码</a>&lt;/dir&gt;

```delphi p1124.pas
uses math;
const seed=131;p=10000019;
type state=record s:ansistring;i:integer end;
var
    //0：正向；1：逆向
    ht:array[0..1,0..p] of integer;
    q:array[0..1,0..10010] of state;
    a:array[0..1,0..7] of ansistring;
    n,p0:integer;s:ansistring;
    h,t:array[0..1] of integer;

function hash(s:ansistring):dword;
var i:integer;
begin
    hash:=0;
    for i:=1 to length(s) do
        hash:=(hash*seed+ord(s[i])) and $FFFFFFF;
    hash:=hash mod p;
end;

function getpos(t,p:string;start:integer):integer;
begin
    getpos:=pos(t,copy(p,start,length(p)-start+1));
    if getpos&lt;&gt;0 then inc(getpos,start-1);
end;

procedure expand(x:integer);
var i,p0:integer;cstr,nstr:ansistring;ha:dword;
begin
    cstr:=q[x,h[x]].s;
    for i:=1 to n do begin
        p0:=getpos(a[x,i],cstr,1);
        while p0&lt;&gt;0 do begin
            nstr:=cstr;
            delete(nstr,p0,length(a[x,i]));
            insert(a[1-x,i],nstr,p0);

            ha:=hash(nstr);
            if ht[1-x,ha]&lt;&gt;0 then begin
                write(ht[1-x,ha]+q[x,h[x]].i+1);
                halt;
            end;
            if ht[x,ha]=0 then begin
                q[x,t[x]].s:=nstr;q[x,t[x]].i:=q[x,h[x]].i+1;
                ht[x,ha]:=q[x,t[x]].i;
                inc(t[x]);if t[x]&gt;10010 then t[x]:=0;
            end;
            p0:=getpos(a[x,i],cstr,p0+1);
        end;
    end;
    inc(h[x]);if h[x]&gt;10010 then h[x]:=0;
end;

procedure bfs();
var i:integer;
begin
    for i:=0 to 1 do begin
        h[i]:=1;t[i]:=2;
        q[i,1].s:=a[i,0];q[i,1].i:=0;
    end;
    repeat
        for i:=0 to 1 do
            if (h[i]&lt;&gt;t[i]) and (q[i,t[i]].i&lt;=10) then expand(i);
    until ((h[0]=t[0]) and (h[1]=t[1])) or 
          (q[0,h[0]].i+q[1,h[1]].i&gt;10);
end;

begin {Main}
    n:=-1;
    while not eof do begin
        inc(n);
        readln(s);
        p0:=pos(&#39; &#39;,s);
        a[0,n]:=copy(s,1,p0-1);
        a[1,n]:=copy(s,p0+1,length(s)-p0);
    end;
    //fillchar(ht,sizeof(ht),0);
    bfs();
    write(&#39;NO ANSWER!&#39;);
end.
</code></pre>]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[[Vijos] p1023 Victoria的舞会3]]></title>
      <url>https://cothrax.github.io/2016/08/15/Vijos-p1023/</url>
      <content type="html"><![CDATA[<h2 id="描述"><a href="#描述" class="headerlink" title="描述"></a>描述</h2><p>Victoria是一位颇有成就的艺术家，他因油画作品《我爱北京天安门》闻名于世界。现在，他为了报答帮助他的同行们，准备开一个舞会。<br>Victoria准备邀请n个已经确定的人，可是问题来了：<br>这n个人每一个人都有一个小花名册，名册里面写着他能够通知到的人的名字。比如说在A的人名单里写了B，那么表示A能够通知到B；但是B的名单里不见的有A，也就是说B不见得通知到A。<br>Victoria觉得需要确定自己需要通知多少个人m，能够实际将所有人n都通知到。并求出一种方案以确定m的最小值是多少。<br>注意：自己的名单里面不会有自己的名字。Victoria可以自身通知到所有n个人。</p>
<h2 id="格式"><a href="#格式" class="headerlink" title="格式"></a>格式</h2><h3 id="输入格式"><a href="#输入格式" class="headerlink" title="输入格式"></a>输入格式</h3><p>第一行一个数n。接下来n行，每i+1行表示编号为i的人的小花名册名单，名单以0结束。\<br>1&lt;=n&lt;=200。</p>
<h3 id="输出格式"><a href="#输出格式" class="headerlink" title="输出格式"></a>输出格式</h3><p>一个数，m。<br><a id="more"></a></p>
<h2 id="样例"><a href="#样例" class="headerlink" title="样例"></a>样例</h2><h3 id="样例输入"><a href="#样例输入" class="headerlink" title="样例输入"></a>样例输入</h3><blockquote>
<p>18<br>0<br>11 0<br>0<br>0<br>0<br>16 0<br>14 0<br>0<br>0<br>0<br>2 13 0<br>0<br>11 0<br>7 0<br>0<br>6 0<br>0<br>0</p>
<h3 id="样例输出"><a href="#样例输出" class="headerlink" title="样例输出"></a>样例输出</h3><p>14</p>
</blockquote>
<h2 id="提示​"><a href="#提示​" class="headerlink" title="提示​"></a>提示​</h2><p>各个测试点1s</p>
<h2 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h2><p>又见强连通分量，tarjan缩点，答案是入度为0的分量数</p>
<dir style="display:none"><a href="/2016/08/15/Vijos-p1023/p1023.pas" title="复制代码">复制代码</a></dir>

<p>```delphi p1023.pas<br>uses math;<br>var<br>    g:array[0..201,0..201] of boolean;<br>    dfn,low,scc,ind,s:array[0..201] of integer;<br>    ins,used:array[0..201] of boolean;<br>    n,i,j,t,cc,tim,ans:integer;</p>
<p>procedure tarjan(v:integer);<br>var i:integer;<br>begin<br>    inc(tim);dfn[v]:=tim;low[v]:=tim;<br>    used[v]:=true;ins[v]:=true;<br>    inc(t);s[t]:=v;<br>    for i:=1 to n do<br>        if g[v,i] then begin<br>            if not used[i] then begin<br>                tarjan(i);<br>                low[v]:=min(low[v],low[i]);<br>            end else if ins[i] then<br>                low[v]:=min(low[v],dfn[i]);<br>        end;<br>    if dfn[v]=low[v] then begin<br>        inc(cc);<br>        while s[t+1]&lt;&gt;v do begin<br>            scc[s[t]]:=cc;<br>            ins[s[t]]:=false;<br>            dec(t);<br>        end;<br>    end;<br>end;</p>
<p>begin<br>    read(n);<br>    fillchar(g,sizeof(g),false);<br>    for i:=1 to n do begin<br>        read(j);<br>        while j&lt;&gt;0 do begin<br>            g[i,j]:=true;<br>            read(j);<br>        end;<br>    end;<br>    fillchar(ins,sizeof(ins),false);<br>    fillchar(used,sizeof(used),false);<br>    fillchar(ind,sizeof(ind),0);<br>    tim:=0;cc:=0;t:=0;<br>    for i:=1 to n do<br>        if not used[i] then tarjan(i);<br>    for i:=1 to n do<br>        for j:=1 to n do<br>            if g[i,j] and (scc[i]&lt;&gt;scc[j]) then<br>                inc(ind[scc[j]]);<br>    ans:=0;<br>    for i:=1 to cc do<br>        if ind[i]=0 then inc(ans);<br>    write(ans);<br>end.<br>```</p>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[[Vijos] p1595 学校网络]]></title>
      <url>https://cothrax.github.io/2016/08/15/Vijos-p1595/</url>
      <content type="html"><![CDATA[<h2 id="描述"><a href="#描述" class="headerlink" title="描述"></a>描述</h2><p>一些学校的校园网连接在一个计算机网络上。学校之间存在软件支援协议。每个学校都有它应支援的学校名单（学校a支援学校b，并不表示学校b一定支援学校a）。当某校获得一个新软件时，无论是直接得到的还是从网络得到的，该校都应立即将这个软件通过网络传送给它应支援的学校。因此，若需要让所有连接在网络上的学校都能使用一个新软件，只需要将其提供给其中一些学校即可。<br>子任务a：根据学校间软件支援协议（各个学校的支援名单），计算最少需要将一个软件直接提供给多少个学校，才能使该软件通过网络传送到所有学校。<br>子任务b：如果允许在原有支援协议上添加新的支援关系，则总可以形成一个新的协议，使得此时只需要将一个新软件提供给任何一个学校，其他所有学校就都可以通过网络获得该软件。请计算出最少需要添加几条新的支援关系。</p>
<h2 id="格式"><a href="#格式" class="headerlink" title="格式"></a>格式</h2><h3 id="输入格式"><a href="#输入格式" class="headerlink" title="输入格式"></a>输入格式</h3><p>第一行是一个整数 n(2≤n≤100)，表示与网络连接的学校总数。接下来 n行描述了每个学校要支援的学校。第i+1行表示第i 号学校要支援的所有学校的编号，编号之间用空格隔开，每行以数字0 结束。如果某个学校不支援任何学校，则相应的行会有一个0。</p>
<h3 id="输出格式"><a href="#输出格式" class="headerlink" title="输出格式"></a>输出格式</h3><p>包含两行，第一行是一个正整数，表示子任务a的解。第二行也是一个正整数，表示子任务b的解。<br><a id="more"></a></p>
<h2 id="样例"><a href="#样例" class="headerlink" title="样例"></a>样例</h2><h3 id="样例输入"><a href="#样例输入" class="headerlink" title="样例输入"></a>样例输入</h3><blockquote>
<p>5<br>2 4 3 0<br>4 5 0<br>0<br>0<br>1 0</p>
</blockquote>
<h3 id="样例输出"><a href="#样例输出" class="headerlink" title="样例输出"></a>样例输出</h3><blockquote>
<p>1<br>2</p>
</blockquote>
<h2 id="提示​"><a href="#提示​" class="headerlink" title="提示​"></a>提示​</h2><p>图结构</p>
<h2 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h2><p>裸的强连通分量。<br>tarjan缩点<br>统计每个强连通分量的入度和出度<br>第一问答案是入度为0的分量数<br>第二问的答案是max(入度为0的分量数，出度为0的分量数)<br>可以通过从入度0的点向出度为0的点连有向边来构造<br><strong>注意只有一个分量时，答案为1 0，不特判的话输出的是1 1</strong></p>
<dir style="display:none"><a href="/2016/08/15/Vijos-p1595/p1595.pas" title="复制代码">复制代码</a></dir>

<p>```delphi p1595.pas<br>uses math;<br>var<br>    g:array[0..101,0..101] of boolean;<br>    dfn,low,scc,s,ind,outd:array[0..101] of integer;<br>    used,ins:array[0..101] of boolean;<br>    n,i,j,t,cc,tim:integer;</p>
<p>procedure tarjan(v:integer);<br>var i:integer;<br>begin<br>    inc(tim);dfn[v]:=tim;low[v]:=tim;<br>    ins[v]:=true;used[v]:=true;<br>    inc(t);s[t]:=v;<br>    for i:=1 to n do<br>        if g[v,i] then begin<br>            if not used[i] then begin<br>                tarjan(i);<br>                low[v]:=min(low[v],low[i]);<br>            end else if ins[i] then<br>                low[v]:=min(low[v],dfn[i]);<br>        end;<br>    if low[v]=dfn[v] then begin<br>        inc(cc);<br>        while s[t+1]&lt;&gt;v do begin<br>            ins[s[t]]:=false;<br>            scc[s[t]]:=cc;<br>            dec(t);<br>        end;<br>    end;<br>end;</p>
<p>begin<br>    read(n);<br>    fillchar(g,sizeof(g),false);<br>    for i:=1 to n do begin<br>        read(j);<br>        while j&lt;&gt;0 do begin<br>            g[i,j]:=true;<br>            read(j);<br>        end;<br>    end;</p>
<pre><code>fillchar(used,sizeof(used),false);
fillchar(ins,sizeof(ins),false);
cc:=0;tim:=0;t:=0;
for i:=1 to n do if not used[i] then tarjan(i);

if cc=1 then begin writeln(1);write(0);halt end;
fillchar(ind,sizeof(ind),0);
fillchar(outd,sizeof(outd),0);
for i:=1 to n do 
    for j:=1 to n do
        if (g[i,j]) and (scc[i]&lt;&gt;scc[j]) then begin
            inc(outd[scc[i]]);
            inc(ind[scc[j]]);
        end;
for i:=1 to cc do begin
    if ind[i]=0 then inc(ind[0]);
    if outd[i]=0 then inc(outd[0]);
end;
writeln(ind[0]);
write(max(ind[0],outd[0]));
</code></pre><p>end.</p>
<p>```</p>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[[Vijos] P1845 花匠]]></title>
      <url>https://cothrax.github.io/2016/08/14/Vijos-P1845/</url>
      <content type="html"><![CDATA[<h2 id="描述"><a href="#描述" class="headerlink" title="描述"></a>描述</h2><p>花匠栋栋种了一排花，每株花都有自己的高度。花儿越长越大，也越来越挤。栋栋决定把这排中的一部分花移走，将剩下的留在原地，使得剩下的花能有空间长大，同时，栋栋希望剩下的花排列得比较别致。<br>具体而言，栋栋的花的高度可以看成一列整数h1, h2, … , hn。设当一部分花被移走后，剩下的花的高度依次为g1, g2, … , gm，则栋栋希望下面两个条件中至少有一个满足：</p>
<p>条件 A：对于所有的<span>$1&lt;i&lt;m/2$</span><!-- Has MathJax -->，<span>$g_{2i}&gt;g_{2i-1}$</span><!-- Has MathJax -->，且<span>$g_{2i}&gt;g_{2i+1}$</span><!-- Has MathJax -->；<br>条件 B：对于所有的<span>$1&lt;i&lt;m/2$</span><!-- Has MathJax -->，<span>$g_{2i}&lt;g_{2i-1}$</span><!-- Has MathJax -->，且<span>$g_{2i}&lt;g_{2i+1}$</span><!-- Has MathJax -->。</p>
<p>注意上面两个条件在m=1时同时满足，当m&gt;1时最多有一个能满足。<br>请问，栋栋最多能将多少株花留在原地。</p>
<h2 id="格式"><a href="#格式" class="headerlink" title="格式"></a>格式</h2><h3 id="输入格式"><a href="#输入格式" class="headerlink" title="输入格式"></a>输入格式</h3><p>输入的第一行包含一个整数 n，表示开始时花的株数。<br>第二行包含 n 个整数，依次为h1, h2,… , hn，表示每株花的高度。</p>
<h3 id="输出格式"><a href="#输出格式" class="headerlink" title="输出格式"></a>输出格式</h3><p>输出一行，包含一个整数 m，表示最多能留在原地的花的株数。<br><a id="more"></a></p>
<h2 id="样例"><a href="#样例" class="headerlink" title="样例"></a>样例</h2><h3 id="样例输入"><a href="#样例输入" class="headerlink" title="样例输入"></a>样例输入</h3><blockquote>
<p>5<br>5 3 2 1 2</p>
</blockquote>
<h3 id="样例输出"><a href="#样例输出" class="headerlink" title="样例输出"></a>样例输出</h3><blockquote>
<p>3</p>
</blockquote>
<h2 id="提示​"><a href="#提示​" class="headerlink" title="提示​"></a>提示​</h2><p>对于 20%的数据，n ≤ 10；<br>对于 30%的数据，n ≤ 25；<br>对于 70%的数据，n ≤ 1000，0 ≤ hi ≤ 1000；<br>对于 100%的数据，1 ≤ n ≤ 100,000，0 ≤ hi ≤ 1,000,000，所有的h_i随机生成，所有随机数服从某区间内的均匀分布。</p>
<p>NOIP 2013 提高组 day 2</p>
<h2 id="水解"><a href="#水解" class="headerlink" title="水解"></a>水解</h2><p>首先想到LIS，然后5分钟DP就写好啦，80分然后TLE</p>
<blockquote>
<p>f[i,j] 以h[i]结尾的合法序列的最长长度<br>j=0时h[i]小于前一个数，j=1时h[i]大于前一个数<br>于是<br><span>$f[i,0]=max\{f[k,1]+1\ |\ h[k]&gt;h[i]\ and\ 1\leq k\leq i\}$</span><!-- Has MathJax --><br><span>$f[i,1]=max\{f[k,0]+1\ |\ h[k]&lt;h[i]\ and\ 1\leq k\leq i\}$</span><!-- Has MathJax --></p>
</blockquote>
<dir style="display:none"><a href="/2016/08/14/Vijos-P1845/p1845.pas" title="复制代码">复制代码</a></dir>

<p>```delphi p1845.pas<br>uses math;<br>type int=longint;<br>var<br>    h:array[0..100010] of int;<br>    f:array[0..100010,0..1] of int;<br>    i,j,n,len:int;</p>
<p>begin<br>    read(n);<br>    for i:=1 to n do read(h[i]);<br>    fillchar(f,sizeof(f),0);<br>    f[1,0]:=1;f[1,1]:=1;len:=1;<br>    for i:=2 to n do begin<br>        for j:=1 to i-1 do begin<br>            if h[i]&gt;h[j] then f[i,1]:=max(f[i,1],f[j,0]+1);<br>            if h[i]&lt;h[j] then f[i,0]:=max(f[i,0],f[j,1]+1);<br>        end;<br>        len:=max(len,max(f[i,0],f[i,1]));<br>    end;<br>    write(len);<br>end.</p>
<pre><code>
## 正解
其实LIS是可以用单调栈做的，于是这一题有了一个类似单调栈的做法，然后乱搞就A了。

&lt;dir style=&quot;display:none&quot;&gt;<a href="/2016/08/14/Vijos-P1845/pp1845.pas" title="复制代码">复制代码</a>&lt;/dir&gt;

```delphi pp1845.pas
uses math;
type int=longint;
var 
    h,s:array[0..100010] of int;
    i,n,t:int;

function cal(sym:int):int;
var i:int;
begin
    //sym=1 下一个数大
    //sym=-1 下一个数小
    t:=1;s[t]:=h[1];
    for i:=2 to n do begin
        if ((sym&gt;0) and (h[i]&gt;s[t])) or
           ((sym&lt;0) and (h[i]&lt;s[t])) then begin
            inc(t);
            sym:=-sym;
        end;
        s[t]:=h[i];
    end;
    cal:=t;
end;

begin
    read(n);
    for i:=1 to n do read(h[i]);
    write(max(cal(1),cal(-1)));
end.
</code></pre>]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[[Vijos] p1906 联合权值]]></title>
      <url>https://cothrax.github.io/2016/08/14/Vijos-p1906/</url>
      <content type="html"><![CDATA[<h2 id="描述"><a href="#描述" class="headerlink" title="描述"></a>描述</h2><p>无向连通图 G 有 n 个点，n-1 条边。点从 1 到 n 依次编号，编号为 i 的点的权值为 Wi， 每条边的长度均为 1。图上两点(u, v)的距离定义为 u 点到 v 点的最短距离。对于图 G 上的点对(u, v)，若它们的距离为 2，则它们之间会产生Wu×Wv的联合权值。<br>请问图 G 上所有可产生联合权值的有序点对中，联合权值最大的是多少？所有联合权值之和是多少？</p>
<h2 id="格式"><a href="#格式" class="headerlink" title="格式"></a>格式</h2><h3 id="输入格式"><a href="#输入格式" class="headerlink" title="输入格式"></a>输入格式</h3><p>第一行包含 1 个整数 n。<br>接下来 n-1 行，每行包含 2 个用空格隔开的正整数 u、v，表示编号为 u 和编号为 v 的点 之间有边相连。<br>最后 1 行，包含 n 个正整数，每两个正整数之间用一个空格隔开，其中第 i 个整数表示 图 G 上编号为 i 的点的权值为Wi。</p>
<h3 id="输出格式"><a href="#输出格式" class="headerlink" title="输出格式"></a>输出格式</h3><p>输出共 1 行，包含 2 个整数，之间用一个空格隔开，依次为图 G 上联合权值的最大值 和所有联合权值之和。由于所有联合权值之和可能很大，输出它时要对10007取余。</p>
<a id="more"></a>
<h2 id="样例"><a href="#样例" class="headerlink" title="样例"></a>样例</h2><h3 id="样例输入"><a href="#样例输入" class="headerlink" title="样例输入"></a>样例输入</h3><blockquote>
<p>5<br>1 2<br>2 3<br>3 4<br>4 5<br>1 5 2 3 10</p>
</blockquote>
<h3 id="样例输出"><a href="#样例输出" class="headerlink" title="样例输出"></a>样例输出</h3><blockquote>
<p>20 74</p>
</blockquote>
<h2 id="提示"><a href="#提示" class="headerlink" title="提示"></a>提示</h2><p>对于 30%的数据，1 &lt; n ≤ 100；<br>对于 60%的数据，1 &lt; n ≤ 2000；<br>对于 100%的数据，1 &lt; n ≤ 200,000，0 &lt; WiWi ≤ 10,000。</p>
<p>NOIP2014 提高组 Day1<br>​</p>
<h2 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h2><p>14年的题目怎么都很水。。。</p>
<p>对于点v，记与有v连边的所有点为$u_i$，两两配对所能得到的联合权值之和=$(\sum W_{u_i})^2-\sum W_{u_{i}}^2$<br>比如有与v连的有三个点，权值分别为a,b,c，那么这三个点能够成的联合权值之和=$2ab+2bc+2ca=(a+b+c)^2-a^2-b^2-c^2$<br>至于最大的权值，取$W_{u_i}$中的最大值和次大值，乘起来就是最大的联合权值。<br>于是扫一遍节点得到答案。<br>注意当v的度为1时不能构成联合权值</p>
<dir style="display:none"><a href="/2016/08/14/Vijos-p1906/p1906.pas" title="复制代码">复制代码</a></dir>

<p>```delphi p1906.pas<br>uses math;<br>const z=10007;<br>type<br>    int=longint;<br>    edge=record t,next:int end;<br>var<br>    n,i,f,t,ans,maxw:int;<br>    w,head:array[0..200010] of int;<br>    g:array[0..400010] of edge;</p>
<p>procedure add(f,t:int);<br>var m:int;<br>begin<br>    inc(head[0]);m:=head[0];<br>    g[m].t:=t;<br>    g[m].next:=head[f];head[f]:=m;<br>end;</p>
<p>procedure solve(v:int);<br>var i,u,fir,sec,sqrsum,sum:int;<br>begin<br>    fir:=0;sec:=0;sqrsum:=0;sum:=0;<br>    i:=head[v];<br>    while i&lt;&gt;0 do begin<br>        u:=g[i].t;<br>        if w[u]&gt;fir then begin sec:=fir;fir:=w[u] end<br>        else if w[u]&gt;sec then sec:=w[u];<br>        sum:=(sum+w[u]) mod z;<br>        sqrsum:=(sqrsum+sqr(w[u])) mod z;<br>        i:=g[i].next;<br>    end;<br>    if sec&lt;&gt;0 then begin<br>        maxw:=max(maxw,fir*sec);<br>        ans:=(ans+sqr(sum)-sqrsum) mod z;<br>    end;<br>end;</p>
<p>begin<br>    read(n);<br>    for i:=1 to n-1 do begin<br>        read(f,t);<br>        add(f,t);add(t,f);<br>    end;<br>    for i:=1 to n do read(w[i]);<br>    ans:=0;maxw:=0;<br>    for i:=1 to n do solve(i);<br>    write(maxw,’ ‘,ans);<br>end.<br>```</p>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[[Vijos] p1908 无线网路发射器选址]]></title>
      <url>https://cothrax.github.io/2016/08/14/Vijos-p1908/</url>
      <content type="html"><![CDATA[<h2 id="描述"><a href="#描述" class="headerlink" title="描述"></a>描述</h2><p>随着智能手机的日益普及，人们对无线网的需求日益增大。某城市决定对城市内的公共场所覆盖无线网。<br>假设该城市的布局为由严格平行的 129 条东西向街道和 129 条南北向街道所形成的网格状，并且相邻的平行街道之间的距离都是恒定值 1 。东西向街道从北到南依次编号为0,1,2…128,南北向街道从西到东依次编号为 0,1,2…128。<br>东西向街道和南北向街道相交形成路口，规定编号为 x 的南北向街道和编号为 y 的东西向街道形成的路口的坐标是（x, y）。在某些路口存在一定数量的公共场所。<br>由于政府财政问题，只能安装一个大型无线网络发射器。该无线网络发射器的传播范围是一个以该点为中心，边长为 2*d 的正方形。传播范围包括正方形边界。<br>例如下图是一个 d = 1 的无线网络发射器的覆盖范围示意图。<br><img src="/2016/08/14/Vijos-p1908/noip2014tgday2p1.jpg" alt="noip2014tgday2p1.jpg" title=""><br>现在政府有关部门准备安装一个传播参数为 d 的无线网络发射器，希望你帮助他们在城 市内找出合适的安装地点，使得覆盖的公共场所最多。</p>
<h2 id="格式"><a href="#格式" class="headerlink" title="格式"></a>格式</h2><h3 id="输入格式"><a href="#输入格式" class="headerlink" title="输入格式"></a>输入格式</h3><p>第一行包含一个整数 d，表示无线网络发射器的传播距离。<br>第二行包含一个整数 n，表示有公共场所的路口数目。<br>接下来 n 行，每行给出三个整数 x, y, k, 中间用一个空格隔开，分别代表路口的坐标(x, y)以及该路口公共场所的数量。同一坐标只会给出一次。</p>
<h3 id="输出格式"><a href="#输出格式" class="headerlink" title="输出格式"></a>输出格式</h3><p>输出一行，包含两个整数，用一个空格隔开，分别表示能覆盖最多公共场所的安装地点方案数，以及能覆盖的最多公共场所的数量。</p>
<a id="more"></a>
<h2 id="样例"><a href="#样例" class="headerlink" title="样例"></a>样例</h2><h3 id="样例输入"><a href="#样例输入" class="headerlink" title="样例输入"></a>样例输入</h3><blockquote>
<p>1<br>2<br>4 4 10<br>6 6 20</p>
<h3 id="样例输出"><a href="#样例输出" class="headerlink" title="样例输出"></a>样例输出</h3><p>1 30</p>
</blockquote>
<h2 id="提示​"><a href="#提示​" class="headerlink" title="提示​"></a>提示​</h2><p>对于 100%的数据，1 ≤ d ≤ 20，1 ≤ n ≤ 20， 0 ≤ x ≤ 128, 0 ≤ y ≤ 128, 0 &lt; k ≤ 1,000,000。</p>
<p>NOIP2014 提高组 Day2</p>
<h2 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h2><p>水一发，直接枚举就好啦。</p>
<dir style="display:none"><a href="/2016/08/14/Vijos-p1908/p1908.pas" title="复制代码">复制代码</a></dir>

<p>```delphi p1908.pas<br>uses math;<br>type int=longint;<br>var<br>    n,d,x,y,mx,my,i,j,tmp,ans,cnt:int;<br>    a:array[-21..200,-21..200] of int;</p>
<p>function solve(x,y:int):int;<br>var i,j:int;<br>begin<br>    solve:=0;<br>    for i:=x-d to x+d do<br>        for j:=y-d to y+d do<br>            inc(solve,a[i,j]);<br>end;</p>
<p>begin<br>    read(d,n);<br>    mx:=0;my:=0;<br>    fillchar(a,sizeof(a),0);<br>    for i:=1 to n do begin<br>        read(x,y);read(a[x,y]);<br>        mx:=max(x,mx);my:=max(y,my);<br>    end;<br>    inc(mx,d);inc(my,d);<br>    ans:=0;cnt:=0;<br>    for i:=0 to min(mx,128) do<br>        for j:=0 to min(my,128) do begin<br>            tmp:=solve(i,j);<br>            if tmp&gt;ans then begin ans:=tmp;cnt:=1 end<br>            else if ans=tmp then inc(cnt);<br>        end;<br>    write(cnt,’ ‘,ans);<br>end.<br>```</p>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[[Vijos] P1983 运输计划]]></title>
      <url>https://cothrax.github.io/2016/08/13/Vijos-P1983/</url>
      <content type="html"><![CDATA[<h2 id="描述"><a href="#描述" class="headerlink" title="描述"></a>描述</h2><p>公元 2044 年，人类进入了宇宙纪元。L 国有 n 个星球，还有 n−1 条双向航道，每条航道建立在两个星球之间，这 n−1 条 航道连通了 L 国的所有星球。<br>小 P 掌管一家物流公司，该公司有很多个运输计划，每个运输计划形如：有一艘物 流飞船需要从 ui 号星球沿最快的宇航路径飞行到 vi 号星球去。显然，飞船驶过一条航道是需要时间的，对于航道 j，任意飞船驶过它所花费的时间为 tj，并且任意两艘飞船之间不会产生任何干扰。<br>为了鼓励科技创新，L 国国王同意小 P 的物流公司参与 L 国的航道建设，即允许小 P 把某一条航道改造成虫洞，飞船驶过虫洞不消耗时间。<br>在虫洞的建设完成前小 P 的物流公司就预接了 m 个运输计划。在虫洞建设完成后， 这 m 个运输计划会同时开始，所有飞船一起出发。当这 m 个运输计划都完成时，小 P 的 物流公司的阶段性工作就完成了。<br>如果小 P 可以自由选择将哪一条航道改造成虫洞，试求出小 P 的物流公司完成阶段性工作所需要的最短时间是多少？</p>
<h2 id="格式"><a href="#格式" class="headerlink" title="格式"></a>格式</h2><h3 id="输入格式"><a href="#输入格式" class="headerlink" title="输入格式"></a>输入格式</h3><p>第一行包括两个正整数 n、m,表示 L 国中星球的数量及小 P 公司预接的运输计划的数量,星球从 1 到 n 编号。接下来 n-1 行描述航道的建设情况,其中第 i 行包含三个整数 ai, bi 和 ti,表示第 i 条双向航道修建在 ai 与 bi 两个星球之间,任意飞船驶过它所花费的时间为 ti。 接下来 m 行描述运输计划的情况,其中第 j 行包含两个正整数 uj 和 vj,表示第 j 个运输计划是从 uj 号星球飞往 vj 号星球。</p>
<h3 id="输出格式"><a href="#输出格式" class="headerlink" title="输出格式"></a>输出格式</h3><p>共 1 行,包含 1 个整数,表示小 P 的物流公司完成阶段性工作所需要的最短时间。<br><a id="more"></a></p>
<h2 id="样例"><a href="#样例" class="headerlink" title="样例"></a>样例</h2><h3 id="样例输入1"><a href="#样例输入1" class="headerlink" title="样例输入1"></a>样例输入1</h3><blockquote>
<p>6 3<br>1 2 3<br>1 6 4<br>3 1 7<br>4 3 6<br>3 5 5<br>3 6<br>2 5<br>4 5</p>
</blockquote>
<h3 id="样例输出1"><a href="#样例输出1" class="headerlink" title="样例输出1"></a>样例输出1</h3><blockquote>
<p>11</p>
</blockquote>
<h2 id="限制​"><a href="#限制​" class="headerlink" title="限制​"></a>限制​</h2><p>一共有20组数据。<br>其中n的取值依次为：100，100，100，2000，1000，2000，3000，1000，2000，3000，80000，100000，70000，80000，90000，100000，80000，90000，100000，300000。<br>其中m的取值依次为：1，100，100，1，1000，2000，3000，1000，2000，3000，1，1，70000，80000，90000，100000，80000，90000，100000，300000。<br>其中第2，5，6，7，13，14，15，16组数据满足：第 i 条航道连接 i 号星球与 i+1 号星球。</p>
<h2 id="提示"><a href="#提示" class="headerlink" title="提示"></a>提示</h2><p>输入输出样例 1<br>将第 1 条航道改造成虫洞：则三个计划耗时分别为：11、12、11，故需要花费的时 间为 12。<br>将第 2 条航道改造成虫洞：则三个计划耗时分别为：7、15、11，故需要花费的时 间为 15。<br>将第 3 条航道改造成虫洞：则三个计划耗时分别为：4、8、11，故需要花费的时间 为 11。<br>将第 4 条航道改造成虫洞：则三个计划耗时分别为：11、15、5，故需要花费的时 间为 15。<br>将第 5 条航道改造成虫洞：则三个计划耗时分别为：11、10、6，故需要花费的时 间为 11。<br>故将第 3 条或第 5 条航道改造成虫洞均可使得完成阶段性工作的耗时最短，需要花 费的时间为 11。</p>
<h2 id="来源"><a href="#来源" class="headerlink" title="来源"></a>来源</h2><p>NOIP 2015 提高组 Day 2 第三题<br>数据由AHdoc生成</p>
<h2 id="水解"><a href="#水解" class="headerlink" title="水解"></a>水解</h2><p>正解貌似是<strong>树链剖分</strong>，可是我不会==<br>于是写了LCA，然后$O(MlogN+logW(M+N))$，然后卡常，<del>还是只有95分</del>，然后A掉啦</p>
<p>大概是先倍增+LCA，然后二分时间，求大于给定时间x的所有路径的交，然后扫一遍交上的边j，如果有 最长路径-j的权&lt;=x 那么返回true<br><strong>路径求交</strong>：dfs维护一个<strong>树上前缀和</strong><br>用count[i]记录记录经过边i（该边是节点i和其父节点的连边）的路径条数<br>对于一条边</p>
<ol>
<li>count[起点]+=1</li>
<li>count[终点]+=1</li>
<li>count[lca]-=2</li>
</ol>
<p>然后从根开始dfs，对一节点v，$count[v]+=\sum count[u]\ |\ u=child(v)$<br>count[1]不考虑，若count[i]=路径总数tot，那么i在路径的交上。</p>
<dir style="display:none"><a href="/2016/08/13/Vijos-P1983/P1983.pas" title="复制代码">复制代码</a></dir>

<p>```delphi P1983.pas<br>uses math;<br>const inf=1000000000;<br>type<br>    int=longint;<br>    edge=record f,t,w,next:int end;<br>    ask=record f,t,w,lca:int end;<br>var<br>    g:array[0..600010] of edge;<br>    head,dep,count:array[0..300010] of int;<br>    par,dist:array[0..300010,0..20] of int;<br>    a:array[0..300010] of ask;<br>    n,m,logn,i,j,f0,t0,w0,l,r,mid,ans:int;</p>
<p>procedure add(f,t,w:int);<br>var m:int;<br>begin<br>    inc(head[0]);m:=head[0];<br>    g[m].f:=f;g[m].t:=t;g[m].w:=w;<br>    g[m].next:=head[f];head[f]:=m;<br>end;</p>
<p>procedure dfs(v,p,d,w:int);<br>var i,u:int;<br>begin<br>    dep[v]:=d;par[v,0]:=p;dist[v,0]:=w;<br>    i:=head[v];<br>    while i&lt;&gt;0 do begin<br>        u:=g[i].t;<br>        if dep[u]=0 then dfs(u,v,d+1,g[i].w);<br>        i:=g[i].next;<br>    end;<br>end;</p>
<p>procedure lca(u,v,id:int);<br>var i:int;<br>begin<br>    if dep[u]<dep[v] 0="" then="" begin="" i:="u;u:=v;v:=i" end;="" for="" downto="" do="" if="" dep[par[u,i]]="">=dep[v] then begin<br>            inc(a[id].w,dist[u,i]);<br>            u:=par[u,i];<br>        end;<br>    if u=v then begin a[id].lca:=u;exit end;<br>    for i:=logn downto 0 do<br>        if par[u,i]&lt;&gt;par[v,i] then begin<br>            inc(a[id].w,dist[u,i]+dist[v,i]);<br>            u:=par[u,i];v:=par[v,i];<br>        end;<br>    a[id].w:=a[id].w+dist[u,0]+dist[v,0];<br>    a[id].lca:=par[u,0];<br>end;</dep[v]></p>
<p>procedure dfs2(v:int);<br>var i,u:int;<br>begin<br>    i:=head[v];<br>    while i&lt;&gt;0 do begin<br>        u:=g[i].t;<br>        if u&lt;&gt;par[v,0] then begin<br>            dfs2(u);<br>            inc(count[v],count[u]);<br>        end;<br>        i:=g[i].next;<br>    end;<br>end;</p>
<p>function check(x:int):boolean;<br>var i,j,w,tot:int;<br>begin<br>    fillchar(count,sizeof(count),0);<br>    w:=0;tot:=0;<br>    for i:=1 to m do<br>        if a[i].w&gt;x then begin<br>            inc(count[a[i].f]);<br>            inc(count[a[i].t]);<br>            dec(count[a[i].lca],2);<br>            w:=max(w,a[i].w-x);inc(tot);<br>        end;<br>    if tot=0 then exit(true);</p>
<pre><code>dfs2(1);
for i:=2 to n do
    if (count[i]=tot) and (dist[i,0]&gt;=w) then exit(true);
check:=false;
</code></pre><p>end;</p>
<p>begin<br>    read(n,m);<br>    logn:=floor(ln(n)/ln(2));<br>    for i:=1 to n-1 do begin<br>        read(f0,t0,w0);<br>        add(f0,t0,w0);add(t0,f0,w0);<br>    end;<br>    for i:=1 to m do read(a[i].f,a[i].t);</p>
<pre><code>//倍增数组和LCA
filldword(dist,sizeof(dist) div 4,inf);
fillchar(par,sizeof(par),0);
dfs(1,0,1,inf);
for i:=1 to logn do
    for j:=1 to n do begin
        par[j,i]:=par[par[j,i-1],i-1];
        if par[j,i]&lt;&gt;0 then
            dist[j,i]:=dist[j,i-1]+dist[par[j,i-1],i-1];
    end;
for i:=1 to m do lca(a[i].f,a[i].t,i);

//二分
l:=0;r:=inf;
while l&lt;=r do begin
    mid:=(l+r) shr 1;
    if check(mid) then begin ans:=mid;r:=mid-1 end
    else l:=mid+1;
end;
write(ans);
</code></pre><p>end.</p>
<pre><code>
## 正解
**二分+树链剖分+差分序列**，不就是用树链剖分代替了倍增吗，因为直接维护序列就不用dfs了，于是速度会快很多。
**差分序列**就是把**区间修改**变成对应的**单点修改**，然后可以通过求**前缀和**来计算需要的信息。
典型的例子是黄学长做的 noip2012-借教室 那一题：[去围观](http://hzwer.com/2959.html)
关于树链剖分可以看神犇的讲解：http://blog.sina.com.cn/s/blog_7a1746820100wp67.html

关于本题：
先树链剖分，顺便求LCA，算出所有运输计划的路径长
然后二分时间
和水解类似的，把所有大于给定时间的路径求交，然后扫一遍，找可行的边建虫洞。
只不过求交直接在剖分得到的树链上做差分序列。

说明一下我用的**变量**
- 以节点编号为下标
&gt; par 直接父节点
chd 同一重链上的儿子
dep 深度
siz 子树上的节点数
w 与父节点的连边在树链序列中的编号
top 所在重链的顶端节点
**dist 到根1的距离**

- 以树链序列中编号为下标的
&gt; ev 树链序列，大小为k（最终等于n-1）
count 统计次数的差分序列

注意编号不要弄混，以及差分时注意**端点**的问题

&lt;dir style=&quot;display:none&quot;&gt;<a href="/2016/08/13/Vijos-P1983/pp1983.pas" title="复制代码">复制代码</a>&lt;/dir&gt;

```delphi pp1983.pas
uses math;
const inf=1000000000;
type
    int=longint; 
    edge=record f,t,w,next:int end;
    ask=record f,t,w:int end;
var 
    n,m,i,j,f0,t0,w0,l,r,mid,ans:int;
    g:array[0..600010] of edge;
    head:array[0..300010] of int;
    a:array[0..300010] of ask;
    //剖分变量
    k:int;
    par,chd,dep,w,siz,top,dist,
    ev,cnt:array[0..300010] of int;

procedure add(f,t,w:int);
var m:int;
begin
    inc(head[0]);m:=head[0];
    g[m].f:=f;g[m].t:=t;g[m].w:=w;
    g[m].next:=head[f];head[f]:=m;
end;
//算出dep,siz,chd,par,dist
procedure dfs1(v,p:int);
var i,u:int;
begin
    dep[v]:=dep[p]+1;par[v]:=p;siz[v]:=1;chd[v]:=0;
    i:=head[v];
    while i&lt;&gt;0 do begin
        u:=g[i].t;
        if u&lt;&gt;p then begin
            dist[u]:=dist[v]+g[i].w;
            dfs1(u,v);
            inc(siz[v],siz[u]);
            if siz[u]&gt;siz[chd[v]] then chd[v]:=u;
        end;
        i:=g[i].next;
    end;
end;

//算出w,top,ev
procedure dfs2(v,tp:int);
var i,u:int;
begin
    inc(k);ev[k]:=dist[v]-dist[par[v]];w[v]:=k;top[v]:=tp;
    if chd[v]&lt;&gt;0 then dfs2(chd[v],tp);
    i:=head[v];
    while i&lt;&gt;0 do begin
        u:=g[i].t;
        if (u&lt;&gt;par[v]) and (u&lt;&gt;chd[v]) then begin
            dfs2(u,u);
        end;
        i:=g[i].next;
    end;
end;

procedure swap(var a,b:int);
var tmp:int;
begin tmp:=a;a:=b;b:=tmp end;

function lca(u,v:int):int;
var tu,tv:int;
begin
    while true do begin
        if dep[u]&gt;dep[v] then swap(u,v);
        tu:=top[u];tv:=top[v];
        if tu=tv then break;
        if dep[tu]&lt;dep[tv] then v:=par[tv] else u:=par[tu];
    end;
    lca:=u;
end;

//修改路径的cnt
procedure modify(u,v:int);
var tu,tv:int;
begin
    while true do begin
        if dep[u]&gt;dep[v] then swap(u,v);
        tu:=top[u];tv:=top[v];
        if tu=tv then begin
            inc(cnt[w[u]+1]);
            dec(cnt[w[v]+1]);
            break;
        end;
        if dep[tu]&lt;dep[tv] then begin
            inc(cnt[w[tv]+1]);
            dec(cnt[w[v]+1]);
            v:=par[tv];
        end else begin
            inc(cnt[w[tu]+1]);
            dec(cnt[w[u]+1]);
            u:=par[tu];
        end;
    end;
end;

function check(x:int):boolean;
var i,tot,maxw,cur:int;
begin
    fillchar(cnt,sizeof(cnt),0);
    tot:=0;maxw:=0;
    for i:=1 to m do
        if a[i].w&gt;x then begin
            modify(a[i].f,a[i].t);
            inc(tot);
            maxw:=max(maxw,a[i].w-x);
        end;
    cur:=0;
    for i:=1 to k do begin
        inc(cur,cnt[i]);
        if (cur=tot) and (ev[i]&gt;=maxw) then exit(true);
    end;
    check:=false;
end;

begin
    read(n,m);
    for i:=1 to n-1 do begin
        read(f0,t0,w0);
        add(f0,t0,w0);add(t0,f0,w0);
    end;
    for i:=1 to m do read(a[i].f,a[i].t);
    //树链剖分
    k:=0;dfs1(1,1);dfs2(1,1);

    //LCA
    for i:=1 to m do begin
        j:=lca(a[i].f,a[i].t);
        a[i].w:=dist[a[i].f]+dist[a[i].t]-2*dist[j]; //路径长
    end;

    //二分
    l:=0;r:=inf;
    while l&lt;=r do begin
        mid:=(l+r) shr 1;
        if check(mid) then begin ans:=mid;r:=mid-1 end
        else l:=mid+1;
    end;
    write(ans);
end.
</code></pre><p>树链修改还可以用<strong>指针</strong>写，好像短一些</p>
<pre><code class="delphi">procedure modify(u,v:int);
var p:^int;
begin
    while top[u]&lt;&gt;top[v] do begin
        if dep[top[u]]&lt;dep[top[v]] then p:=@v else p:=@u;
        inc(cnt[w[par[p^]]]);
        dec(cnt[w[p^]]);
        p^:=par[top[p^]];
    end;
    if dep[u]&gt;dep[v] then swap(u,v);
    inc(cnt[w[u]+1]);
    dec(cnt[w[v]+1]);
end;
</code></pre>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[[Vijos] P1982 子串]]></title>
      <url>https://cothrax.github.io/2016/08/13/Vijos-P1982/</url>
      <content type="html"><![CDATA[<h2 id="描述"><a href="#描述" class="headerlink" title="描述"></a>描述</h2><p>有两个仅包含小写英文字母的字符串 A 和 B。现在要从字符串 A 中取出 k 个<strong>互不重叠</strong>的非空子串，然后把这 k 个子串按照其在字符串 A 中出现的顺序依次连接起来得到一 个新的字符串，请问有多少种方案可以使得这个新串与字符串 B 相等？注意：子串取出的位置不同也认为是不同的方案。</p>
<h2 id="格式"><a href="#格式" class="headerlink" title="格式"></a>格式</h2><h3 id="输入格式"><a href="#输入格式" class="headerlink" title="输入格式"></a>输入格式</h3><p>第一行是三个正整数 n，m，k，分别表示字符串 A 的长度，字符串 B 的长度，以及问 题描述中所提到的 k，每两个整数之间用一个空格隔开。第二行包含一个长度为 n 的字符串，表示字符串 A。 第三行包含一个长度为 m 的字符串，表示字符串 B。</p>
<h3 id="输出格式"><a href="#输出格式" class="headerlink" title="输出格式"></a>输出格式</h3><p>输出共一行，包含一个整数，表示所求方案数。由于答案可能很大，<strong>所以这里要求输出答案对 1,000,000,007 取模的结果。</strong><br><a id="more"></a></p>
<h2 id="样例"><a href="#样例" class="headerlink" title="样例"></a>样例</h2><h3 id="样例输入1"><a href="#样例输入1" class="headerlink" title="样例输入1"></a>样例输入1</h3><blockquote>
<p>6 3 1<br>aabaab<br>aab</p>
</blockquote>
<h3 id="样例输出1"><a href="#样例输出1" class="headerlink" title="样例输出1"></a>样例输出1</h3><blockquote>
<p>2</p>
</blockquote>
<h3 id="样例输入2"><a href="#样例输入2" class="headerlink" title="样例输入2"></a>样例输入2</h3><blockquote>
<p>6 3 2<br>aabaab<br>aab</p>
</blockquote>
<h3 id="样例输出2"><a href="#样例输出2" class="headerlink" title="样例输出2"></a>样例输出2</h3><blockquote>
<p>7</p>
</blockquote>
<h2 id="提示​"><a href="#提示​" class="headerlink" title="提示​"></a>提示​</h2><p>对于第 1 组数据：1≤n≤500，1≤m≤50，k=1；<br>对于第 2 组至第 3 组数据：1≤n≤500，1≤m≤50，k=2；<br>对于第 4 组至第 5 组数据：1≤n≤500，1≤m≤50，k=m；<br>对于第 1 组至第 7 组数据：1≤n≤500，1≤m≤50，1≤k≤m；<br>对于第 1 组至第 9 组数据：1≤n≤1000，1≤m≤100，1≤k≤m；<br>对于所有 10 组数据：1≤n≤1000，1≤m≤200，1≤k≤m。</p>
<p>NOIP 2015 提高组 Day 2 第二题</p>
<h2 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h2><p><strong>划分DP+滚动数组</strong><br>f[t,i,j] 在a[1..i]中取t份，与b[1..j]匹配的方法数。<br>注意初始化f[0,i,0]=1</p>
<dir style="display:none"><a href="/2016/08/13/Vijos-P1982/p1982.pas" title="复制代码">复制代码</a></dir>

<p><code>delphi p1982.pas
uses math;
type int=longint;
const z=1000000007;
var 
    n,m,k,i,i0,i1,j,t,l:int;
    f:array[0..1,0..1010,0..210] of int;
    a,b:ansistring;
begin {Main}
    readln(n,m,k);
    readln(a);readln(b);
    for i:=0 to n do f[0,i,0]:=1;
    for i:=1 to k do begin
        i0:=i mod 2;i1:=(i+1) mod 2;
        fillchar(f[i0],sizeof(f[i0]),0);
        for j:=1 to n do
            for t:=1 to m do begin
                f[i0,j,t]:=f[i0,j-1,t];
                l:=0;
                while a[j-l]=b[t-l] do begin
                    if l&gt;=min(j,t) then break;
                    f[i0,j,t]:=(f[i0,j,t]+f[i1,j-l-1,t-l-1]) mod z;
                    inc(l);
                end;
            end;
    end;
    write(f[k mod 2,n,m]);
end.</code></p>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[[Vijos] P1981 跳石头]]></title>
      <url>https://cothrax.github.io/2016/08/13/Vijos-P1981/</url>
      <content type="html"><![CDATA[<h2 id="描述"><a href="#描述" class="headerlink" title="描述"></a>描述</h2><p>一年一度的“跳石头”比赛又要开始了！<br>这项比赛将在一条笔直的河道中进行，河道中分布着一些巨大岩石。组委会已经选择好了两块岩石作为比赛起点和终点。在起点和终点之间，有 N 块岩石（不含起点和终 点的岩石）。在比赛过程中，选手们将从起点出发，每一步跳向相邻的岩石，直至到达终点。<br>为了提高比赛难度，组委会计划移走一些岩石，使得选手们在比赛过程中的最短跳 跃距离尽可能长。由于预算限制，组委会至多从起点和终点之间移走 M 块岩石（不能 移走起点和终点的岩石）。</p>
<h2 id="格式"><a href="#格式" class="headerlink" title="格式"></a>格式</h2><h3 id="输入格式"><a href="#输入格式" class="headerlink" title="输入格式"></a>输入格式</h3><p>输入第一行包含三个整数 L，N，M，分别表示起点到终点的距离，起点和终 点之间的岩石数，以及组委会至多移走的岩石数。<br>接下来 N 行，每行一个整数，第 i 行的整数 Di（0&lt;Di&lt;L0&lt;Di&lt;L）表示第 i 块岩石与起点的距离。这些岩石按与起点距离从小到大的顺序给出，且不会有两个岩石出现在同 一个位置。</p>
<h3 id="输出格式"><a href="#输出格式" class="headerlink" title="输出格式"></a>输出格式</h3><p>输出只包含一个整数，即最短跳跃距离的最大值。<br><a id="more"></a></p>
<h2 id="样例"><a href="#样例" class="headerlink" title="样例"></a>样例</h2><h3 id="样例输入"><a href="#样例输入" class="headerlink" title="样例输入"></a>样例输入</h3><blockquote>
<p>25 5 2<br>2<br>11<br>14<br>17<br>21</p>
</blockquote>
<h3 id="样例输出"><a href="#样例输出" class="headerlink" title="样例输出"></a>样例输出</h3><blockquote>
<p>4</p>
</blockquote>
<h2 id="提示​"><a href="#提示​" class="headerlink" title="提示​"></a>提示​</h2><p>对于20%的数据，0≤M≤N≤10。<br>对于50%的数据，0≤M≤N≤100。<br>对于100%的数据，0≤M≤N≤50000，1≤L≤1000000000。</p>
<p>对于样例。将与起点距离为 2 和 14 的两个岩石移走后，最短的跳跃距离为 4（从与起点距离17 的岩石跳到距离 21 的岩石，或者从距离 21 的岩石跳到终点）。</p>
<h2 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h2><p><strong>二分</strong>最大距离，不要忘记起终点的石头。</p>
<dir style="display:none"><a href="/2016/08/13/Vijos-P1981/p1981.pas" title="复制代码">复制代码</a></dir>

<p>```delphi p1981.pas<br>type int=longint;<br>var </p>
<pre><code>l0,m,n,i,l,r,mid,ans:int;
d:array[0..50010] of int;
</code></pre><p>function c(x:int):boolean;<br>var i,last,count:int;<br>begin<br>    count:=0;last:=0;i:=1;<br>    while i&lt;=n do begin<br>        while (d[i]-d[last]<x) and="" (i<="n)" do="" begin="" inc(i);inc(count);="" end;="" if="" count="">m then exit(false);<br>        last:=i;inc(i);<br>    end;<br>    c:=true;<br>end;</x)></p>
<p>begin<br>    read(l0,n,m);<br>    for i:=1 to n do read(d[i]);<br>    d[0]:=0;<br>    inc(n);d[n]:=l0;</p>
<pre><code>l:=0;r:=l0;ans:=-1;
while l&lt;=r do begin
    mid:=(l+r) shr 1;
    if c(mid) then begin ans:=mid;l:=mid+1 end
    else r:=mid-1;
end;
write(ans);
</code></pre><p>end.<br>```</p>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[[Vijos] P1979 信息传递]]></title>
      <url>https://cothrax.github.io/2016/08/13/Vijos-P1979/</url>
      <content type="html"><![CDATA[<h2 id="描述"><a href="#描述" class="headerlink" title="描述"></a>描述</h2><p>有 n 个同学（编号为 1 到 n）正在玩一个信息传递的游戏。在游戏里每人都有一个固定的信息传递对象，其中，编号为i的同学的信息传递对象是编号为Ti的同学。<br>游戏开始时，每人都只知道自己的生日。之后每一轮中，所有人会同时将自己当前所知的生日信息告诉各自的信息传递对象（注意：可能有人可以从若干人那里获取信息， 但是每人只会把信息告诉一个人，即自己的信息传递对象）。当有人从别人口中得知自己的生日时，游戏结束。请问该游戏一共可以进行几轮？</p>
<h2 id="格式"><a href="#格式" class="headerlink" title="格式"></a>格式</h2><h3 id="输入格式"><a href="#输入格式" class="headerlink" title="输入格式"></a>输入格式</h3><p>输入共 2 行。<br>第 1 行包含 1 个正整数 n，表示 n 个人。<br>第 2 行包含 n 个用空格隔开的正整数 T1,T2,… …,Tn，其中第 i 个整数Ti表示编号为i的同学的信息传递对象是编号为Ti的同学， Ti≤n且 Ti≠i。<br>数据保证游戏一定会结束。</p>
<h3 id="输出格式"><a href="#输出格式" class="headerlink" title="输出格式"></a>输出格式</h3><p>输出共 1 行，包含 1 个整数，表示游戏一共可以进行多少轮。<br><a id="more"></a></p>
<h2 id="样例"><a href="#样例" class="headerlink" title="样例"></a>样例</h2><h3 id="样例输入"><a href="#样例输入" class="headerlink" title="样例输入"></a>样例输入</h3><blockquote>
<p>5<br>2 4 2 3 1</p>
</blockquote>
<h3 id="样例输出"><a href="#样例输出" class="headerlink" title="样例输出"></a>样例输出</h3><blockquote>
<p>3</p>
</blockquote>
<h2 id="提示"><a href="#提示" class="headerlink" title="提示"></a>提示</h2><p>对于 30%的数据， n ≤ 200；<br>对于 60%的数据，n ≤ 2500；<br>对于 100%的数据，n ≤ 200000。</p>
<p>【输入输出样例 1 说明】<br><img src="/2016/08/13/Vijos-P1979/noip2015tgd1t2.jpg" alt="noip2015tgd1t2.jpg" title="">​</p>
<h2 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h2><p>本题的解法很多，比如说用并查集找最小环，Tarjan等。但发现，构成的有向图非常特殊：<strong>每个点的出度都是1</strong>，所以可以用简单的dfs解决问题。<br>用flag[v]记录v节点是否访问过，由于点的出度为1，从一个点出发构成的链是唯一确定的，一旦发现flag[t[v]]=true就可以回溯，标记t[v]这个点，用全局变量d储存回溯的链的长度，当回溯到t[v]时用d+1更新答案。</p>
<dir style="display:none"><a href="/2016/08/13/Vijos-P1979/p1979.pas" title="复制代码">复制代码</a></dir>

<p>```delphi p1979.pas<br>uses math;<br>type int=longint;<br>var<br>    n,i,p,d,ans:int;<br>    t:array[0..200010] of int;<br>    flag:array[0..200010] of boolean;</p>
<p>procedure dfs(v:int);<br>begin<br>    flag[v]:=true;<br>    if flag[t[v]] then p:=t[v]<br>    else dfs(t[v]);<br>    if p=v then ans:=min(ans,d+1);<br>    inc(d);<br>end;</p>
<p>begin<br>    read(n);<br>    for i:=1 to n do read(t[i]);<br>    ans:=maxlongint;<br>    fillchar(flag,sizeof(flag),false);<br>    for i:=1 to n do begin<br>        d:=0;p:=0;<br>        if not flag[i] then dfs(i);<br>    end;<br>    write(ans);<br>end.<br>```</p>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[Hexo初体验]]></title>
      <url>https://cothrax.github.io/2016/08/12/Hexo%E5%88%9D%E4%BD%93%E9%AA%8C/</url>
      <content type="html"><![CDATA[<p>作为JS的一只OIer，一直用Evernote写（tie）题（dai）解（ma），今天想试试<a href="https://pages.github.com/" target="_blank" rel="external">GitHub Pages</a>，于是就有了这个页面。<br>折腾了一个晚上带一个上午，自己的Blog已经有了雏形，记录一下中途遇到的各种<strong>BUG</strong>。</p>
<h2 id="参考教程"><a href="#参考教程" class="headerlink" title="参考教程"></a>参考教程</h2><p>这是用<a href="https://hexo.io" target="_blank" rel="external">Hexo</a>建的站，阅读了多位大牛的文章，才有了我这个简陋的Blog。</p>
<ol>
<li><a href="http://blog.csdn.net/poem_of_sunshine/article/details/29369785/" target="_blank" rel="external">如何搭建一个独立博客——简明Github Pages与Hexo教程 by cnfeat</a></li>
<li><a href="https://ijiaober.github.io/categories/hexo/" target="_blank" rel="external">Hexo使用攻略 by ijiaober</a></li>
</ol>
<h2 id="安装和部署"><a href="#安装和部署" class="headerlink" title="安装和部署"></a>安装和部署</h2><h3 id="npm卡住不动"><a href="#npm卡住不动" class="headerlink" title="npm卡住不动"></a>npm卡住不动</h3><p>hexo是基于node.js，于是运行npm安装：</p>
<pre><code class="plain">npm install -g hexo
</code></pre>
<p>由于gfw的存在，就动不了了。还好可以换<strong>国内的镜像</strong></p>
<pre><code class="plain">nano ~/.npmrc
registry =https://registry.npm.taobao.org
</code></pre>
<p>或者用<a href="https://github.com/cnpm/cnpm" target="_blank" rel="external">cnpm</a>替换npm</p>
<pre><code class="plain">npm install -g cnpm --registry=https://registry.npm.taobao.org
</code></pre>
<h3 id="Hexo-command-not-found"><a href="#Hexo-command-not-found" class="headerlink" title="Hexo command not found"></a>Hexo command not found</h3><p>修改Windows的<strong>环境变量</strong>，把<code>hexo安装目录\node_modules\.bin</code>加到Path里去就好了。</p>
<h3 id="ERROR-Deployer-not-found-github"><a href="#ERROR-Deployer-not-found-github" class="headerlink" title="ERROR Deployer not found: github"></a>ERROR Deployer not found: github</h3><p>Hexo3.0把github改成了git<br>于是在bash中执行：</p>
<pre><code class="plain">npm install hexo-deployer-git --save
</code></pre>
<p>然后把<code>type</code>从<code>github</code>改成<code>git</code><br><a id="more"></a></p>
<h3 id="deploy时repository各种报错"><a href="#deploy时repository各种报错" class="headerlink" title="deploy时repository各种报错"></a>deploy时repository各种报错</h3><p>肯定是yml哪里写错了，这玩意连冒号后面的空格都不能少，如我的username是Cothrax，于是deploy这样写：</p>
<pre><code class="plain">deploy:
  type: git
  repository: git@github.com:cothrax/cothrax.github.io.git
  branch: master
</code></pre>
<h3 id="nothing-to-commit-working-tree-clean后卡住"><a href="#nothing-to-commit-working-tree-clean后卡住" class="headerlink" title="nothing to commit, working tree clean后卡住"></a>nothing to commit, working tree clean后卡住</h3><p>耐心等吧，实在不行使用科学上网工具，也可以用这个很棒的<strong>hosts</strong>优化网络：<a href="https://serve.netsh.org/pub/ipv4-hosts/" target="_blank" rel="external">https://serve.netsh.org/pub/ipv4-hosts/</a></p>
<h3 id="每次部署都要输入passphrase"><a href="#每次部署都要输入passphrase" class="headerlink" title="每次部署都要输入passphrase"></a>每次部署都要输入passphrase</h3><p>谁叫你生成ssh时设了密钥呢，passphrase是防止别人向你的项目中提交文件，重新生成一下ssh，passphrase那两个输入直接敲回车就可以了。</p>
<h2 id="配置和体验"><a href="#配置和体验" class="headerlink" title="配置和体验"></a>配置和体验</h2><p>我用了<a href="https://github.com/wuchong/jacman" target="_blank" rel="external">jacman</a>的主题，下面一些feature基于jacman，其他主题的设置应该大同小异，在此感谢这个<a href="http://wuchong.me/" target="_blank" rel="external">主题的作者</a></p>
<h3 id="Markdown相关"><a href="#Markdown相关" class="headerlink" title="Markdown相关"></a>Markdown相关</h3><p>Hexo 3提供了<strong>标签插件</strong>，可以方便地插入图片和文件。</p>
<ol>
<li>官方文档<ol>
<li>标签插件：<a href="https://hexo.io/zh-cn/docs/tag-plugins.html" target="_blank" rel="external">https://hexo.io/zh-cn/docs/tag-plugins.html</a></li>
<li>资源文件夹：<a href="https://hexo.io/zh-cn/docs/asset-folders.html" target="_blank" rel="external">https://hexo.io/zh-cn/docs/asset-folders.html</a></li>
</ol>
</li>
<li>我的一些例子和测试：<a href="/2016/08/12/Test-Hexo/" title="Test Hexo">Test Hexo</a></li>
</ol>
<h4 id="代码复制到剪切板"><a href="#代码复制到剪切板" class="headerlink" title="代码复制到剪切板"></a>代码复制到剪切板</h4><p>直接复制会碰到行号，但js什么的早就忘干净了，于是替代方案是在<strong>给出asset链接指向源码文件</strong><br>可以在markdown里写html+css来处理右对齐</p>
<pre><code>&lt;dir style=&quot;display:none&quot;&gt;&lt;/dir&gt;
下面是代码块
</code></pre><p>就成了这样：<br><img src="/2016/08/12/Hexo初体验/codeblock.jpg" alt="用了css的效果" title="用了css的效果"></p>
<h3 id="多说评论系统"><a href="#多说评论系统" class="headerlink" title="多说评论系统"></a>多说评论系统</h3><ol>
<li>登录多说，然后获取站点<strong>通用代码</strong>：<a href="http://duoshuo.com/create-site" target="_blank" rel="external">http://duoshuo.com/create-site</a></li>
<li>找到<code>\themes\jacman\layout\_partial\post\comment.ejs</code></li>
<li>把得到的通用代码复制到<code>&lt;section id=&quot;comments&quot; class=&quot;comment&quot;&gt;</code>和<code>&lt;/section&gt;</code>之间，原来的东西覆盖掉。</li>
<li>然后主题的<code>_config.yml</code>中把<code>duoshuo_shortname</code>填成你的多说用户名就好了</li>
<li>还有，如果想在一个页面（如404）<strong>禁用评论</strong>，可以在front-master中加<code>comments: false</code></li>
</ol>
<h3 id="站内搜索的实现"><a href="#站内搜索的实现" class="headerlink" title="站内搜索的实现"></a>站内搜索的实现</h3><p>百度的站内搜索要验证，结果不是是不支持https，就是是连不上github服务器，还会报301错误，无奈还是用google好啦。</p>
<p>goole的<strong>自定义搜索引擎</strong>：<a href="https://cse.google.com/cse/all" target="_blank" rel="external">https://cse.google.com/cse/all</a><br>用jacman主题，只要更改jacman下的<code>_config.yml</code>，把cx码和enable设好，还有的注释上说得很清楚：</p>
<blockquote>
<p>To enable the custom search You must create a “search” folder in ‘/source’ and a “index.md” file<br>set the ‘front-matter’ as<br>layout: search<br>title: search</p>
</blockquote>
<h4 id="一直显示“正在加载搜索结果，请稍等”"><a href="#一直显示“正在加载搜索结果，请稍等”" class="headerlink" title="一直显示“正在加载搜索结果，请稍等”"></a>一直显示“正在加载搜索结果，请稍等”</h4><p>检查了Chrome的Console：<br><img src="/2016/08/12/Hexo初体验/screenshot.jpg" alt="Console" title="Console"><br>发现是<strong>http和https混用</strong>，然后Chrome把不安全的http给block掉了，找到<code>\themes\jacman\layout\_partial\search.ejs</code>，将</p>
<pre><code class="html">&lt;script src=&quot;http://www.google.com.hk/jsapi&quot; type=&quot;text/javascript&quot;&gt;&lt;/script&gt;
</code></pre>
<p>中的http改成https就好了</p>
<pre><code class="html">&lt;script src=&quot;https://www.google.com.hk/jsapi&quot; type=&quot;text/javascript&quot;&gt;&lt;/script&gt;
</code></pre>
<h4 id="搜索显示无结果"><a href="#搜索显示无结果" class="headerlink" title="搜索显示无结果"></a>搜索显示无结果</h4><p>没有向google提交你的blog，当然什么也找不到了。<br>把blog加到google的索引中：<br><a href="https://www.google.cn/intl/zh-CN/submit_content.html" target="_blank" rel="external">https://www.google.cn/intl/zh-CN/submit_content.html</a></p>
<h3 id="RSS功能"><a href="#RSS功能" class="headerlink" title="RSS功能"></a>RSS功能</h3><p>执行命令</p>
<pre><code>npm install hexo-generator-feed --save
</code></pre><p>然后在根下的配置文件里写入：<br>```yml _config.yml</p>
<p>#RSS订阅<br>plugin:</p>
<ul>
<li>hexo-generator-feed<br>#Feed Atom<br>feed:<br>type: atom<br>path: atom.xml<br>limit: 20<br>```</li>
</ul>
<h4 id="RSS报UTF-8错误"><a href="#RSS报UTF-8错误" class="headerlink" title="RSS报UTF-8错误"></a>RSS报UTF-8错误</h4><p>Windows下会用BOM标记utf-8文件，hexo不识别这种标记，可以在目录下查找atom.xml文件，然后用utf-8的文本编辑器（如notepad++,gedit）打开，重新保存一下就好了</p>
<h3 id="Chrome下分享图标显示不全"><a href="#Chrome下分享图标显示不全" class="headerlink" title="Chrome下分享图标显示不全"></a>Chrome下分享图标显示不全</h3><p>这是因为用了广告屏蔽的插件，如AdBlock可以设置屏蔽社交按钮。<br>然后有趣的事情发生了，ABP把页面下方的GitHub和Twitter的链接干掉了，它认不得知乎，于是一排图标只剩下知乎和Email了。</p>
<blockquote>
<p>end.</p>
</blockquote>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[Test Hexo]]></title>
      <url>https://cothrax.github.io/2016/08/12/Test-Hexo/</url>
      <content type="html"><![CDATA[<p><del>localhost下测试，asset、404都没有用，deploy后就</del>能用啦。</p>
<p>要用资源文件夹的话：<br>```yml _config.yml<br>post_asset_folder: true</p>
<pre><code>
## 一张图片
</code></pre><img src="/2016/08/12/Test-Hexo/example.gif" alt="TestImage" title="TestImage">
<pre><code>
<img src="/2016/08/12/Test-Hexo/example.gif" alt="TestImage" title="TestImage">

## 一份源码
</code></pre>/2016/08/12/Test-Hexo/p1523.pas
<pre><code>/2016/08/12/Test-Hexo/p1523.pas
</code></pre><a href="/2016/08/12/Test-Hexo/p1523.pas" title="p1523.pas">p1523.pas</a>
<pre><code><a href="/2016/08/12/Test-Hexo/p1523.pas" title="p1523.pas">p1523.pas</a>
</code></pre><a href="/2016/08/12/Test-Hexo/p1523.pas" title="标题">标题</a>
<pre><code><a href="/2016/08/12/Test-Hexo/p1523.pas" title="标题">标题</a>
&lt;!--more--&gt;

## 404
</code></pre><p>hexo new page “404”</p>
<pre><code>
```yml 404.md
---
title: 404 Page not Found
comments: false
toc: false
permalink: /404
---
</code></pre><p><a href="https://cothrax.github.io/这就404了">https://cothrax.github.io/这就404了</a><br>还有根下<code>_config.yml</code>中<code>relative_link: false</code>，不然在子目录下404就找不到css了，然后layout就没有了</p>
<h2 id="Raw标签"><a href="#Raw标签" class="headerlink" title="Raw标签"></a>Raw标签</h2><p>用来避免<strong>解析异常</strong>，如可以用Raw来避免markdown和mathjax的解析冲突。<br>如果直接这样写的话</p>
<pre><code class="markdown">点为$u_i$，能得到的联合权值之和=$(\sum W_{u_i})^2-\sum W_{u_{i}}^2$
</code></pre>
<p>由于下划线被markdown当做斜体，就成了这样：</p>
<blockquote>
<p>点为$u<em>i$，能得到的联合权值之和=$(\sum W</em>{u<em>i})^2-\sum W</em>{u_{i}}^2$</p>
</blockquote>
<p>当然你可以用<strong>转义符</strong>来解决问题：</p>
<pre><code class="markdown">点为$u\_i$，能得到的联合权值之和=$(\sum W\_{u\_i})^2-\sum W\_{u\_{i}}^2$
</code></pre>
<blockquote>
<p>点为$u_i$，能得到的联合权值之和=$(\sum W_{u_i})^2-\sum W_{u_{i}}^2$</p>
</blockquote>
<p>当公式特别长时，转义符就不方便了，于是这样写：</p>
<pre><code class="markdown"> 
点为$u_i$，能得到的联合权值之和=$(\sum W_{u_i})^2-\sum W_{u_{i}}^2$

</code></pre>
<p>就好啦：</p>
<blockquote>
点为$u_i$，能得到的联合权值之和=$(\sum W_{u_i})^2-\sum W_{u_{i}}^2$
</blockquote>
<h2 id="其他的"><a href="#其他的" class="headerlink" title="其他的"></a>其他的</h2><h3 id="引用"><a href="#引用" class="headerlink" title="引用"></a>引用</h3><pre><code class="plain"><a href="/2016/08/12/Test-Hexo/" title="标题">标题</a>
<a href="/2016/08/12/Hello-the-Wicked-World/" title="Hello the Wicked World">Hello the Wicked World</a>
</code></pre>
<a href="/2016/08/12/Test-Hexo/" title="标题">标题</a><br><br><a href="/2016/08/12/Hello-the-Wicked-World/" title="Hello the Wicked World">Hello the Wicked World</a>
<h3 id="Gist"><a href="#Gist" class="headerlink" title="Gist"></a>Gist</h3><pre><code class="plain"><script src="//gist.github.com/0781305b79f54aaeac06b49444529d1c.js?file=p1144.pas"></script>
</code></pre>
<p>好棒<br><script src="//gist.github.com/0781305b79f54aaeac06b49444529d1c.js?file=p1144.pas"></script></p>
<h3 id="视频"><a href="#视频" class="headerlink" title="视频"></a>视频</h3><p>Youtube和Vimeo</p>
<pre><code class="plain"><div class="video-container"><iframe src="//www.youtube.com/embed/dc-nyGo0aC8" frameborder="0" allowfullscreen></iframe></div>
</code></pre>
<div class="video-container"><iframe src="//www.youtube.com/embed/dc-nyGo0aC8" frameborder="0" allowfullscreen></iframe></div>
<pre><code class="plain"><div class="video-container"><iframe src="//player.vimeo.com/video/video_id" frameborder="0" allowfullscreen></iframe></div>
</code></pre>
<p>这个没试过</p>
<blockquote>
<p>Done.</p>
</blockquote>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[[Vijos] P1523 贪吃的九头龙]]></title>
      <url>https://cothrax.github.io/2016/08/12/Vijos-P1523/</url>
      <content type="html"><![CDATA[<h2 id="描述"><a href="#描述" class="headerlink" title="描述"></a>描述</h2><p>传说中的九头龙是一种特别贪吃的动物。虽然名字叫“九头龙”，但这只是说它出生的时候有九个头，而在成长的过程中，它有时会长出很多的新头，头的总数会远大于九，当然也会有旧头因衰老而自己脱落。</p>
<p>有一天，有M个脑袋的九头龙看到一棵长有N个果子的果树，喜出望外，恨不得一口把它全部吃掉。可是必须照顾到每个头，因此它需要把N个果子分成M组，每组至少有一个果子，让每个头吃一组。</p>
<p>这M个脑袋中有一个最大，称为“大头”，是众头之首，它要吃掉恰好K个果子，而且K个果子中理所当然地应该包括唯一的一个最大的果子。果子由N-1根树枝连接起来，由于果树是一个整体，因此可以从任意一个果子出发沿着树枝“走到”任何一个其他的果子。</p>
<p>对于每段树枝，如果它所连接的两个果子需要由不同的头来吃掉，那么两个头会共同把树枝弄断而把果子分开；如果这两个果子是由同一个头来吃掉，那么这个头会懒得把它弄断而直接把果子连同树枝一起吃掉。当然，吃树枝并不是很舒服的，因此每段树枝都有一个吃下去的“难受值”，而九头龙的难受值就是所有头吃掉的树枝的“难受值”之和。</p>
<p>九头龙希望它的“难受值”尽量小，你能帮它算算吗？</p>
<h2 id="格式"><a href="#格式" class="headerlink" title="格式"></a>格式</h2><h3 id="输入格式"><a href="#输入格式" class="headerlink" title="输入格式"></a>输入格式</h3><p>输入的第1行包含三个整数N(1&lt;=N&lt;=300)，M(2&lt;=M&lt;=N)，K(1&lt;=K&lt;=N)。N个果子依次编号1,2,…,N，且最大的果子的编号总是1。第2行到第N行描述了果树的形态，每行包含三个整数a(1&lt;=a&lt;=N)，b(1&lt;=b&lt;=N)，c(0&lt;=c&lt;=105)，表示存在一段难受值为c的树枝连接果子a和果子b。</p>
<h3 id="输出格式"><a href="#输出格式" class="headerlink" title="输出格式"></a>输出格式</h3><p>输出仅有一行，包含一个整数，表示在满足“大头”的要求的前提下，九头龙的难受值的最小值。如果无法满足要求，输出-1。<br><a id="more"></a></p>
<h2 id="样例"><a href="#样例" class="headerlink" title="样例"></a>样例</h2><h3 id="样例输入"><a href="#样例输入" class="headerlink" title="样例输入"></a>样例输入</h3><blockquote>
<p>8 2 4<br> 1 2 20<br> 1 3 4<br> 1 4 13<br> 2 5 10<br> 2 6 12<br> 3 7 15<br> 3 8 5</p>
</blockquote>
<h3 id="样例输出"><a href="#样例输出" class="headerlink" title="样例输出"></a>样例输出</h3><blockquote>
<p>4</p>
</blockquote>
<h2 id="提示"><a href="#提示" class="headerlink" title="提示"></a>提示</h2><p>树形动态规划</p>
<h2 id="来源"><a href="#来源" class="headerlink" title="来源"></a>来源</h2><p>安徽省芜湖市第二十七中学测试题<br>NOI 2002 贪吃的九头龙(dragon)<br>Description:Official<br>Data:Official<br>Program:Converted by JackDavid127<br>​</p>
<h2 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h2><p>发现树形DP根本不会==<br>首先状态无比复杂，考虑一个神一样的简化：<strong>树一定可以被k分染色。</strong><br>因为一张无向图能被二分染色的充要条件是至少两个节点且不存在偶数边的环，显然树时满足要求的，能被二分染色的图自然可以被k分染色。<br><br>于是题目变成了：</p>
<ol>
<li>用两种颜色染一棵树</li>
<li>根节点颜色是1</li>
<li>颜色是1的节点恰好是k个</li>
</ol>
<p>也就是说把所有小头看成一个头，如果m=2的话小头的难受度要算进答案，如果m&gt;2，我们可以通过<strong>分配小头来保证不存在难受度</strong>，此时对答案有贡献的只有大头的难受度。</p>
<p>然后某神犇说方程好简单。。。OTZ<br><strong>f[i,j,k]表示以i为根的子树，j个被大头吃了，i的父节点是k吃的（0表示大头，1表示小头）</strong><br>方程见代码。</p>
<p>注意这里的树是<strong>多叉转二叉</strong>的树，转的时候边的难受度可以放到子节点里，n-1条边与n个点配对，根节点1忽略不计。<br>然后答案是<strong>dp(tr[i].ch,k-1,1)</strong>，当然直接搜根然后特判一下也可以。</p>
<p>还有注意初始化为负数方便记忆化，如果无法完成要赋成inf，codevs经常因为一个warning就大惊小怪地报CE，因为我用filldword赋-1，但其实不会出问题因为我给的是longint数组，今天知道了只要fillchar(a,sizeof(a),255)就完事了。<br>开始手残k=0和1写反了。。。居然还有10分真是不可思议</p>
<dir style="display:none"><a href="/2016/08/12/Vijos-P1523/p1523.pas" title="复制代码">复制代码</a></dir>

<p>```delphi p1523.pas<br>uses math;<br>const inf=10000000;<br>type<br>    edge=record t,w,next:longint end;<br>    node=record br,ch,w:longint end;<br>var<br>    n,m,k,i,f0,t0,w0:longint;<br>    g:array[0..610] of edge;<br>    tr:array[0..310] of node;<br>    f:array[0..310,0..310,0..1] of longint;<br>    head:array[0..310] of longint;    </p>
<p>procedure add(f0,t0,w0:longint);<br>var m:longint;<br>begin<br>    inc(head[0]);m:=head[0];<br>    g[m].t:=t0;g[m].w:=w0;<br>    g[m].next:=head[f0];head[f0]:=m;<br>end; </p>
<p>procedure dfs(v,p:longint);<br>var i,u:longint;<br>begin<br>    i:=head[v];<br>    while i&lt;&gt;0 do begin<br>        u:=g[i].t;<br>        if p&lt;&gt;u then begin<br>            tr[u].br:=tr[v].ch;<br>            tr[v].ch:=u;<br>            tr[u].w:=g[i].w;<br>            dfs(u,v);<br>        end;<br>        i:=g[i].next;<br>    end;<br>end;    </p>
<p>//v的子树，大头吃j棵，父节点是k吃的（0大头，1小头）<br>function dp(v,j,k:longint):longint;<br>var t,tmp:longint;<br>begin<br>    if v=0 then begin<br>        if j=0 then exit(0) else exit(inf)<br>    end;<br>    if f[v,j,k]&gt;=0 then exit(f[v,j,k]);<br>    f[v,j,k]:=inf;<br>    //大头吃i<br>    for t:=1 to j do begin<br>        tmp:=dp(tr[v].ch,t-1,0)+dp(tr[v].br,j-t,k);<br>        if k=0 then inc(tmp,tr[v].w);<br>        f[v,j,k]:=min(f[v,j,k],tmp);<br>    end;<br>    //小头吃i<br>    for t:=0 to j do begin<br>        tmp:=dp(tr[v].ch,t,1)+dp(tr[v].br,j-t,k);<br>        if (k=1) and (m=2) then inc(tmp,tr[v].w);<br>        f[v,j,k]:=min(f[v,j,k],tmp);<br>    end;<br>    dp:=f[v,j,k];<br>end; </p>
<p>begin<br>    read(n,m,k);<br>    if m+k&gt;n then begin write(-1);halt end;<br>    //先用邻接表存多叉<br>    for i:=1 to n-1 do begin<br>        read(f0,t0,w0);<br>        add(f0,t0,w0);add(t0,f0,w0);<br>    end;<br>    //深搜一遍，多叉转二叉<br>    tr[1].w:=0;dfs(1,0);<br>    //记忆化<br>    fillchar(f,sizeof(f),255);<br>    write(dp(tr[1].ch,k-1,0));<br>end.<br>```</p>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[Hello the Wicked World]]></title>
      <url>https://cothrax.github.io/2016/08/12/Hello-the-Wicked-World/</url>
      <content type="html"><![CDATA[<h1 id="Cothrax"><a href="#Cothrax" class="headerlink" title="Cothrax"></a>Cothrax</h1><blockquote>
<p>这是测试页 </p>
</blockquote>
<p>注意：标题的#后面要有<strong>空格</strong></p>
<pre><code class="delphi">program noip2016;
var rp:qword;
begin
    writeln(&#39;JS的一只蒟蒻&#39;);
    writeln(&#39;Evernote用腻了，想试试GitHub&#39;);
    while true do
        inc(rp);
end;
</code></pre>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[[Luogu] P1993 小K的农场]]></title>
      <url>https://cothrax.github.io/2016/07/25/Luogu-P1993-%E5%B0%8FK%E7%9A%84%E5%86%9C%E5%9C%BA/</url>
      <content type="html"><![CDATA[<h2 id="描述"><a href="#描述" class="headerlink" title="描述"></a>描述</h2><p>小K在MC里面建立很多很多的农场，总共n个，以至于他自己都忘记了每个农场中种植作物的具体数量了，他只记得一些含糊的信息（共m个），以下列三种形式描述：农场a比农场b至少多种植了c个单位的作物，农场a比农场b至多多种植了c个单位的作物，农场a与农场b种植的作物数一样多。但是，由于小K的记忆有些偏差，所以他想要知道存不存在一种情况，使得农场的种植作物数量与他记忆中的所有信息吻合。</p>
<h2 id="格式"><a href="#格式" class="headerlink" title="格式"></a>格式</h2><h3 id="输入格式"><a href="#输入格式" class="headerlink" title="输入格式"></a>输入格式</h3><p>第一行包括两个整数n和m，分别表示农场数目和小K记忆中的信息数目。<br>接下来m行：<br>如果每行的第一个数是1，接下来有3个整数a,b,c，表示农场a比农场b至少多种植了c个单位的作物。<br>如果每行的第一个数是2，接下来有3个整数a,b,c，表示农场a比农场b至多多种植了c个单位的作物。<br>如果每行第一个数是3，家下来有2个整数a,b，表示农场a终止的数量和b一样多。 </p>
<h3 id="输出格式"><a href="#输出格式" class="headerlink" title="输出格式"></a>输出格式</h3><p>如果存在某种情况与小K的记忆吻合，输出“Yes”，否则输出“No”。<br><a id="more"></a></p>
<h2 id="样例"><a href="#样例" class="headerlink" title="样例"></a>样例</h2><h3 id="样例输入"><a href="#样例输入" class="headerlink" title="样例输入"></a>样例输入</h3><blockquote>
<p>3 3<br>3 1 2<br>1 1 3 1<br>2 2 3 2</p>
</blockquote>
<h3 id="样例输出"><a href="#样例输出" class="headerlink" title="样例输出"></a>样例输出</h3><blockquote>
<p>Yes</p>
</blockquote>
<h2 id="提示​"><a href="#提示​" class="headerlink" title="提示​"></a>提示​</h2><p>样例解释：三个农场种植数量可以为(2,2,1)。<br>对于100%的数据  1&lt;=n,m,a,b,c&lt;=10000.</p>
<h2 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h2><p>考差分约束。<br>建图</p>
<ol>
<li>情况1：a-b&gt;=c -&gt; b-a&lt;=-c 由a向b连权为-c的有向弧</li>
<li>情况2：a-b&lt;=c 由b向a连权为c的有向弧</li>
<li>情况3：a=b -&gt; a-b&gt;=0 and b-a&gt;=0 由a向b、由b向a 连两条权为0的有向弧</li>
</ol>
<p>然后spfa判负环。<br>bfs版本：记录同一顶点的入队次数，如果次数大于顶点数，存在负环。<br>由于复杂度最坏O(N^2)，4个点超时。<br>dfs版本，如果同一路径上，某一顶点可松弛多次，存在负环。<br>注意由于图不一定联通，加一个<strong>超级源点</strong><br>最坏O(N)，秒杀</p>
<dir style="display:none"><a href="/2016/07/25/Luogu-P1993-小K的农场/p1993.pas" title="复制代码">复制代码</a></dir>

<p>```delphi p1993.pas<br>const inf=10000000;<br>type<br>    edge=record<br>        f,t,next,w:longint;<br>    end;<br>var<br>    n,m,i,tmp,k,a,b,c:longint;<br>    g:array[0..40010] of edge;<br>    head,d:array[0..10010] of longint;<br>    flag:array[0..10010] of boolean;</p>
<p>procedure add(f0,t0,w0:longint);<br>begin<br>    inc(m);<br>    g[m].f:=f0;g[m].t:=t0;g[m].w:=w0;<br>    g[m].next:=head[f0];<br>    head[f0]:=m;<br>end;</p>
<p>procedure spfa(x:longint);<br>var i,v:longint;<br>begin<br>    i:=head[x];<br>    while i&lt;&gt;0 do begin<br>        v:=g[i].t;<br>        if d[x]+g[i].w&lt;d[v] then<br>            if flag[v] then begin<br>                write(‘No’);<br>                halt;<br>            end else begin<br>                d[v]:=d[x]+g[i].w;<br>                flag[v]:=true;<br>                spfa(v);<br>            end;<br>        i:=g[i].next;<br>    end;<br>    flag[x]:=false;<br>end;</p>
<p>begin<br>    fillchar(head,sizeof(head),0);<br>    read(n,tmp);<br>    m:=0;<br>    for i:=1 to tmp do begin<br>        read(k,a,b);<br>        case k of<br>            1:begin read(c);add(a,b,-c) end;<br>            2:begin read(c);add(b,a,c) end;<br>            3:begin add(a,b,0);add(b,a,0) end;<br>        end;<br>    end;<br>    for i:=1 to n do add(0,i,0);<br>    fillchar(flag,sizeof(flag),false);<br>    filldword(d,sizeof(d) div 4,inf);<br>    d[0]:=0;flag[0]:=true;<br>    spfa(0);<br>    write(‘Yes’);<br>end.<br>```</p>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[[Luogu] P1991 无线通讯网]]></title>
      <url>https://cothrax.github.io/2016/07/25/Luogu-P1991/</url>
      <content type="html"><![CDATA[<h2 id="描述"><a href="#描述" class="headerlink" title="描述"></a>描述</h2><p>国防部计划用无线网络连接若干个边防哨所。2种不同的通讯技术用来搭建无线网络；每个边防哨所都要配备无线电收发器；有一些哨所还可以增配卫星电话。<br>任意两个配备了一条卫星电话线路的哨所（两边都拥有卫星电话）均可以通话，无论他们相距多远。而只通过无线电收发器通话的哨所之间的距离不能超过D，这是受收发器的功率限制。收发器的功率越高，通话距离D会更远，但同时价格也会更贵。<br>收发器需要统一购买和安装，所以全部哨所只能选择安装一种型号的收发器。换句话说，每一对哨所之间的通话距离都是同一个D。<br>你的任务是确定收发器必须的最小通话距离D，使得每一对哨所之间至少有一条通话路径（直接的或者间接的）。</p>
<h2 id="格式"><a href="#格式" class="headerlink" title="格式"></a>格式</h2><h3 id="输入格式"><a href="#输入格式" class="headerlink" title="输入格式"></a>输入格式</h3><p>第1行：2个整数S（1&lt;=S&lt;=100）和P（S&lt;P&lt;=500），S表示可安装的卫星电话的哨所数，P表示边防哨所的数量。<br>接下里P行，每行描述一个哨所的平面坐标（x,y），以km为单位，整数，0&lt;=x,y&lt;=10000。</p>
<h3 id="输出格式"><a href="#输出格式" class="headerlink" title="输出格式"></a>输出格式</h3><p>第1行：1个实数D，表示无线电收发器的最小传输距离。精确到小数点后两位。<br><a id="more"></a></p>
<h2 id="样例"><a href="#样例" class="headerlink" title="样例"></a>样例</h2><h3 id="样例输入"><a href="#样例输入" class="headerlink" title="样例输入"></a>样例输入</h3><blockquote>
<p>2 4<br> 0 100<br> 0 300<br> 0 600<br> 150 750</p>
</blockquote>
<h3 id="样例输出"><a href="#样例输出" class="headerlink" title="样例输出"></a>样例输出</h3><blockquote>
<p>212.13</p>
</blockquote>
<h2 id="提示​"><a href="#提示​" class="headerlink" title="提示​"></a>提示​</h2><p>数据范围<br>对于20%的数据  P=2，S=1<br>对于另外20%的数据  P=4，S=2<br>对于100%的数据  1&lt;=S&lt;=100，S&lt;P&lt;=500 </p>
<h2 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h2><p><strong>最小生成树</strong></p>
<ol>
<li>用kruskal会很简单，只要生成s-p条边就终kruskal，其余的顶点可以用卫星电话连接，答案是生成过程中最大的树边。</li>
<li>用prim可以做，但因为prim生成树时，子树是连通的，因此要完整生成一棵树，然后给树边排序，贪心给树中距离最远的两点装卫星电话，注意点的判重。</li>
</ol>
<dir style="display:none"><a href="/2016/07/25/Luogu-P1991/p1991.pas" title="复制代码">复制代码</a></dir>

<p>```delphi p1991.pas<br>uses math;<br>const inf=200000;<br>type<br>    edge=record<br>        f,t:longint;<br>        d:real;<br>    end;<br>var<br>    n,p,m,i,j,count:longint;<br>    x,y,par,rank:array[0..510] of longint;<br>    g:array[0..250010] of edge;<br>    ans:real;</p>
<p>procedure qsort(b,e:longint);<br>var i,j:longint;x:real;tmp:edge;<br>begin<br>    i:=b;j:=e;x:=g[random(e-b)+b].d;<br>    repeat<br>        while g[i].d<x do="" inc(i);="" while="" g[j].d="">x do dec(j);<br>        if i&lt;=j then begin<br>            tmp:=g[i];g[i]:=g[j];g[j]:=tmp;<br>            inc(i);dec(j);<br>        end;<br>    until i&gt;j;<br>    if i&lt;e then qsort(i,e);<br>    if b&lt;j then qsort(b,j);<br>end;</x></p>
<p>function find(x:longint):longint;<br>begin<br>    if par[x]=x then find:=x<br>    else begin<br>        par[x]:=find(par[x]);<br>        find:=par[x];<br>    end;<br>end;</p>
<p>procedure union(x,y:longint);<br>begin<br>    x:=find(x);y:=find(y);<br>    if rank[x]&lt;rank[y] then par[x]:=y<br>    else begin<br>        par[y]:=x;<br>        if rank[y]=rank[x] then inc(rank[x]);<br>    end;<br>end;</p>
<p>function same(x,y:longint):boolean;<br>begin same:=(find(x)=find(y)) end;</p>
<p>begin<br>    read(p,n);<br>    for i:=1 to n do read(x[i],y[i]);<br>    m:=0;<br>    for i:=1 to n do<br>        for j:=i+1 to n do begin<br>            inc(m);<br>            g[m].f:=i;g[m].t:=j;<br>            g[m].d:=sqrt(sqr(x[i]-x[j])+sqr(y[i]-y[j]));<br>        end;<br>    for i:=1 to n do par[i]:=i;<br>    fillchar(rank,sizeof(rank),0);<br>    qsort(1,m);<br>    count:=0;ans:=0;<br>    for i:=1 to m do<br>        if not same(g[i].f,g[i].t) then begin<br>            union(g[i].f,g[i].t);<br>            ans:=max(ans,g[i].d);<br>            inc(count);<br>            if count=n-p then break;<br>        end;<br>    write(ans:0:2);<br>end.<br>```</p>
]]></content>
    </entry>
    
  
  
</search>
